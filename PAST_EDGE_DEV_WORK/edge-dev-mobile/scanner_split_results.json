{"success":true,"message":"AI successfully split scanner into 3 individual patterns","extracted_scanners":[{"scanner_name":"Parabolic Score Filter_AI_Generated","description":"A scoring system that evaluates stocks based on ATR expansion, EMA distance, multi-day burst, volume, and gap behavior to identify parabolic moves.","formatted_code":"import pandas as pd\nimport requests\nimport time\nimport numpy as np\nimport pandas_market_calendars as mcal\nimport aiohttp\nimport asyncio\nimport pandas as pd\nfrom multiprocessing import Pool, cpu_count\nfrom concurrent.futures import ProcessPoolExecutor\nfrom tabulate import tabulate\nimport webbrowser\nimport plotly.graph_objects as go\nimport sys\nfrom concurrent.futures import ThreadPoolExecutor\nimport dask\nfrom dask.distributed import Client, as_completed\nimport dask.dataframe as dd\nimport datetime\nimport logging\nimport backoff\n\nnyse = mcal.get_calendar('NYSE')\nexecutor = ThreadPoolExecutor() \n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nif sys.platform == 'win32':\n    asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())\n\nDATE = datetime.date.today().strftime('%Y-%m-%d')\nAPI_KEY = '4r6MZNWLy2ucmhVI7fY8MrvXfXTSmxpy'\nBASE_URL = \"https://api.polygon.io\"\n\ndef check_high_lvl_filter_lc(df):\n    df['filter'] = False\n    df.loc[(df['c'] > 5) & (df['c'] < 200) & (df['v'] > 100000), 'filter'] = True\n    return df\n\ndef adjust_daily(df):\n    df['date'] = pd.to_datetime(df['t'], unit='ms')\n    df['date'] = df['date'].dt.date          \n    df['pdc'] = df['c'].shift(1)\n    df['high_low'] = df['h'] - df['l']\n    df['high_pdc'] = abs(df['h'] - df['pdc'])\n    df['low_pdc'] = abs(df['l'] - df['pdc'])\n    df['true_range'] = df[['high_low', 'high_pdc', 'low_pdc']].max(axis=1)\n    df['atr'] = df['true_range'].rolling(window=14).mean()\n    df.drop(['high_low', 'high_pdc', 'low_pdc'], axis=1, inplace=True)\n         \n    df['h1'] = df['h'].shift(1)\n    df['h2'] = df['h'].shift(2)\n    df['h3'] = df['h'].shift(3)\n\n    df['c1'] = df['c'].shift(1)\n    df['c2'] = df['c'].shift(2)\n    df['c3'] = df['c'].shift(3)\n\n    df['o1'] = df['o'].shift(1)\n    df['o2'] = df['o'].shift(2)\n    \n    df['l1'] = df['l'].shift(1)\n    df['l2'] = df['l'].shift(2)\n\n    df['v_ua1'] = df['v_ua'].shift(1)\n    df['v1'] = df['v'].shift(1)\n    df['v2'] = df['v'].shift(2)\n    \n    df['dol_v'] = (df['c'] * df['v'])\n    df['dol_v1'] = df['dol_v'].shift(1)\n    df['dol_v2'] = df['dol_v'].shift(2)\n\n    df['close_range'] = (df['c'] - df['l'])/(df['h'] - df['l'])\n    df['close_range1'] = df['close_range'].shift(1)\n    df['close_range2'] = df['close_range'].shift(2)\n\n    df['gap_atr'] = ((df['o'] - df['pdc'])/df['atr'])\n    df['gap_atr1'] = ((df['o1'] - df['c2'])/df['atr'])\n\n    df['gap_pdh_atr'] = ((df['o'] - df['h1'])/df['atr'])\n    \n    df['high_chg'] = (df['h'] - df['o'])\n    df['high_chg_atr'] = ((df['h'] - df['o'])/df['atr'])\n    df['high_chg_atr1'] = ((df['h1'] - df['o1'])/df['atr'])\n    df['high_chg_atr2'] = ((df['h2'] - df['o2'])/df['atr'])\n\n    df['high_chg_from_pdc_atr'] = ((df['h'] - df['c1'])/df['atr'])\n    df['high_chg_from_pdc_atr1'] = ((df['h1'] - df['c2'])/df['atr'])\n\n    df['pct_change'] = round(((df['c'] / df['c1']) - 1)*100, 2)\n    \n    df['ema9'] = df['c'].ewm(span=9, adjust=False).mean().fillna(0)\n    df['ema20'] = df['c'].ewm(span=20, adjust=False).mean().fillna(0)\n    df['ema50'] = df['c'].ewm(span=50, adjust=False).mean().fillna(0)\n    df['ema200'] = df['c'].ewm(span=200, adjust=False).mean().fillna(0)\n\n    df['ema20_2'] = df['ema20'].shift(2)\n    \n    df['ema9_1'] = df['ema9'].shift(1)\n    df['ema20_1'] = df['ema20'].shift(1)\n    df['ema50_1'] = df['ema50'].shift(1)\n    \n    df['dist_h_9ema'] = (df['h'] - df['ema9'])\n    df['dist_h_20ema'] = (df['h'] - df['ema20'])\n    df['dist_h_50ema'] = (df['h'] - df['ema50'])\n    df['dist_h_200ema'] = (df['h'] - df['ema200'])\n\n    df['dist_h_9ema1'] = df['dist_h_9ema'].shift(1)\n    df['dist_h_20ema1'] = df['dist_h_20ema'].shift(1)\n    df['dist_h_50ema1'] = df['dist_h_50ema'].shift(1)\n    df['dist_h_200ema1'] = df['dist_h_200ema'].shift(1)\n\n    df['dist_h_9ema_atr'] = df['dist_h_9ema'] / df['atr']\n    df['dist_h_20ema_atr'] = df['dist_h_20ema'] / df['atr']\n    df['dist_h_50ema_atr'] = df['dist_h_50ema'] / df['atr']\n    df['dist_h_200ema_atr'] = df['dist_h_200ema'] / df['atr']\n\n    df['dist_h_9ema_atr1'] = df['dist_h_9ema1'] / df['atr']\n    df['dist_h_20ema_atr1'] = df['dist_h_20ema1'] / df['atr']\n    df['dist_h_50ema_atr1'] = df['dist_h_50ema1'] / df['atr']\n    df['dist_h_200ema_atr1'] = df['dist_h_200ema1'] / df['atr']\n\n    df['dist_h_9ema2'] = df['dist_h_9ema'].shift(2)\n    df['dist_h_9ema3'] = df['dist_h_9ema'].shift(3)\n    df['dist_h_9ema4'] = df['dist_h_9ema'].shift(4)\n\n    df['dist_h_20ema2'] = df['dist_h_20ema'].shift(2)\n    df['dist_h_20ema3'] = df['dist_h_20ema'].shift(3)\n    df['dist_h_20ema4'] = df['dist_h_20ema'].shift(4)\n    df['dist_h_20ema5'] = df['dist_h_20ema'].shift(5)\n\n    df['dist_h_9ema_atr2'] = df['dist_h_9ema2'] / df['atr']\n    df['dist_h_9ema_atr3'] = df['dist_h_9ema3'] / df['atr']\n    df['dist_h_9ema_atr4'] = df['dist_h_9ema4'] / df['atr']\n    \n    df['dist_h_20ema_atr2'] = df['dist_h_20ema2'] / df['atr']\n    df['dist_h_20ema_atr3'] = df['dist_h_20ema3'] / df['atr']\n    df['dist_h_20ema_atr4'] = df['dist_h_20ema4'] / df['atr']\n    df['dist_h_20ema_atr5'] = df['dist_h_20ema5'] / df['atr']\n\n    df['score_atr'] = df['high_chg_atr'] * 2\n    df['score_ema'] = df['dist_h_9ema_atr'] * 1.5\n    df['score_burst'] = (df['high_chg_atr'] + df['high_chg_atr1'] + df['high_chg_atr2']) * 1.2\n    df['score_vol'] = (df['v'] / df['v1']) * 0.8\n    df['score_gap'] = df['gap_atr'] * 1.0\n\n    df['parabolic_score_raw'] = (df['score_atr'] + df['score_ema'] + df['score_burst'] + df['score_vol'] + df['score_gap'])\n    df['parabolic_score'] = df['parabolic_score_raw'].round(2)\n\n    return df\n\nasync def fetch_ticker_data(session, ticker):\n    url = f\"{BASE_URL}/v2/aggs/ticker/{ticker}/range/1/day/{DATE}/{DATE}?adjusted=true&sort=asc&limit=120&apiKey={API_KEY}\"\n    try:\n        async with session.get(url) as response:\n            if response.status == 200:\n                data = await response.json()\n                if data.get('resultsCount', 0) > 0:\n                    df = pd.DataFrame(data['results'])\n                    df['ticker'] = ticker\n                    return df\n    except Exception as e:\n        logging.error(f\"Error fetching data for {ticker}: {e}\")\n    return None\n\nasync def fetch_all_tickers(tickers):\n    async with aiohttp.ClientSession() as session:\n        tasks = [fetch_ticker_data(session, ticker) for ticker in tickers]\n        results = await asyncio.gather(*tasks)\n        return [result for result in results if result is not None]\n\ndef get_tickers():\n    url = f\"{BASE_URL}/v3/reference/tickers?market=stocks&active=true&sort=ticker&order=asc&limit=1000&apiKey={API_KEY}\"\n    response = requests.get(url)\n    if response.status_code == 200:\n        data = response.json()\n        return [ticker['ticker'] for ticker in data['results']]\n    return []\n\ndef process_ticker_data(df):\n    df = adjust_daily(df)\n    df = check_high_lvl_filter_lc(df)\n    df = df[df['filter'] == True]\n    if len(df) > 0:\n        df = df.sort_values('parabolic_score', ascending=False)\n        return df[['ticker', 'parabolic_score', 'c', 'v', 'high_chg_atr', 'dist_h_9ema_atr', 'gap_atr']].head(1)\n    return None\n\nasync def main():\n    logging.basicConfig(level=logging.INFO)\n    tickers = get_tickers()\n    logging.info(f\"Found {len(tickers)} tickers to process\")\n    \n    all_data = await fetch_all_tickers(tickers)\n    if not all_data:\n        logging.error(\"No data fetched\")\n        return\n    \n    combined_df = pd.concat(all_data)\n    processed_data = []\n    \n    with ProcessPoolExecutor() as executor:\n        futures = [executor.submit(process_ticker_data, group) for _, group in combined_df.groupby('ticker')]\n        for future in futures:\n            result = future.result()\n            if result is not None:\n                processed_data.append(result)\n    \n    if processed_data:\n        final_df = pd.concat(processed_data)\n        final_df = final_df.sort_values('parabolic_score', ascending=False)\n        print(tabulate(final_df.head(20), headers='keys', tablefmt='psql'))\n    else:\n        print(\"No stocks met the criteria\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())","parameters":[{"name":"atr_mult","default_value":0.0,"description":"ATR expansion multiplier for scoring","category":"technical","importance":"critical"},{"name":"ema_dev","default_value":0.0,"description":"EMA distance normalized by ATR","category":"technical","importance":"high"},{"name":"rvol","default_value":0.0,"description":"Relative volume for volume scoring","category":"volume","importance":"medium"},{"name":"gap","default_value":0.0,"description":"Gap percentage for gap behavior scoring","category":"price","importance":"medium"}],"complexity":7,"dependencies":["check_high_lvl_filter_lc"]},{"scanner_name":"LC Frontside D3 Extended_AI_Generated","description":"Identifies stocks with a strong uptrend over three days, considering price changes, volume, and EMA distances.","formatted_code":"import pandas as pd\nimport requests\nimport time\nimport numpy as np\nimport pandas_market_calendars as mcal\nimport aiohttp\nimport asyncio\nfrom multiprocessing import Pool, cpu_count\nfrom concurrent.futures import ProcessPoolExecutor\nfrom tabulate import tabulate\nimport webbrowser\nimport plotly.graph_objects as go\nimport sys\nfrom concurrent.futures import ThreadPoolExecutor\nimport dask\nfrom dask.distributed import Client, as_completed\nimport dask.dataframe as dd\nimport datetime\nimport logging\nimport backoff\n\nnyse = mcal.get_calendar('NYSE')\nexecutor = ThreadPoolExecutor()\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nif sys.platform == 'win32':\n    asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())\n\nDATE = \"2025-01-17\"\nAPI_KEY = '4r6MZNWLy2ucmhVI7fY8MrvXfXTSmxpy'\nBASE_URL = \"https://api.polygon.io\"\n\ndef adjust_daily(df):\n    df['date'] = pd.to_datetime(df['t'], unit='ms')\n    df['date'] = df['date'].dt.date\n    df['pdc'] = df['c'].shift(1)\n    df['high_low'] = df['h'] - df['l']\n    df['high_pdc'] = abs(df['h'] - df['pdc'])\n    df['low_pdc'] = abs(df['l'] - df['pdc'])\n    df['true_range'] = df[['high_low', 'high_pdc', 'low_pdc']].max(axis=1)\n    df['atr'] = df['true_range'].rolling(window=14).mean()\n    df.drop(['high_low', 'high_pdc', 'low_pdc'], axis=1, inplace=True)\n\n    df['h1'] = df['h'].shift(1)\n    df['h2'] = df['h'].shift(2)\n    df['h3'] = df['h'].shift(3)\n\n    df['c1'] = df['c'].shift(1)\n    df['c2'] = df['c'].shift(2)\n    df['c3'] = df['c'].shift(3)\n\n    df['o1'] = df['o'].shift(1)\n    df['o2'] = df['o'].shift(2)\n\n    df['l1'] = df['l'].shift(1)\n    df['l2'] = df['l'].shift(2)\n\n    df['v_ua1'] = df['v_ua'].shift(1)\n    df['v1'] = df['v'].shift(1)\n    df['v2'] = df['v'].shift(2)\n\n    df['dol_v'] = (df['c'] * df['v'])\n    df['dol_v1'] = df['dol_v'].shift(1)\n    df['dol_v2'] = df['dol_v'].shift(2)\n\n    df['close_range'] = (df['c'] - df['l'])/(df['h'] - df['l'])\n    df['close_range1'] = df['close_range'].shift(1)\n    df['close_range2'] = df['close_range'].shift(2)\n\n    df['gap_atr'] = ((df['o'] - df['pdc'])/df['atr'])\n    df['gap_atr1'] = ((df['o1'] - df['c2'])/df['atr'])\n\n    df['gap_pdh_atr'] = ((df['o'] - df['h1'])/df['atr'])\n\n    df['high_chg'] = (df['h'] - df['o'])\n    df['high_chg_atr'] = ((df['h'] - df['o'])/df['atr'])\n    df['high_chg_atr1'] = ((df['h1'] - df['o1'])/df['atr'])\n    df['high_chg_atr2'] = ((df['h2'] - df['o2'])/df['atr'])\n\n    df['high_chg_from_pdc_atr'] = ((df['h'] - df['c1'])/df['atr'])\n    df['high_chg_from_pdc_atr1'] = ((df['h1'] - df['c2'])/df['atr'])\n\n    df['pct_change'] = round(((df['c'] / df['c1']) - 1)*100, 2)\n\n    df['ema9'] = df['c'].ewm(span=9, adjust=False).mean().fillna(0)\n    df['ema20'] = df['c'].ewm(span=20, adjust=False).mean().fillna(0)\n    df['ema50'] = df['c'].ewm(span=50, adjust=False).mean().fillna(0)\n    df['ema200'] = df['c'].ewm(span=200, adjust=False).mean().fillna(0)\n\n    df['ema20_2'] = df['ema20'].shift(2)\n\n    df['ema9_1'] = df['ema9'].shift(1)\n    df['ema20_1'] = df['ema20'].shift(1)\n    df['ema50_1'] = df['ema50'].shift(1)\n\n    df['dist_h_9ema'] = (df['h'] - df['ema9'])\n    df['dist_h_20ema'] = (df['h'] - df['ema20'])\n    df['dist_h_50ema'] = (df['h'] - df['ema50'])\n    df['dist_h_200ema'] = (df['h'] - df['ema200'])\n\n    df['dist_h_9ema1'] = df['dist_h_9ema'].shift(1)\n    df['dist_h_20ema1'] = df['dist_h_20ema'].shift(1)\n    df['dist_h_50ema1'] = df['dist_h_50ema'].shift(1)\n    df['dist_h_200ema1'] = df['dist_h_200ema'].shift(1)\n\n    df['dist_h_9ema_atr'] = df['dist_h_9ema'] /df['atr']\n    df['dist_h_20ema_atr'] = df['dist_h_20ema'] /df['atr']\n    df['dist_h_50ema_atr'] = df['dist_h_50ema'] /df['atr']\n    df['dist_h_200ema_atr'] = df['dist_h_200ema'] /df['atr']\n\n    df['dist_h_9ema_atr1'] = df['dist_h_9ema1'] /df['atr']\n    df['dist_h_20ema_atr1'] = df['dist_h_20ema1'] /df['atr']\n    df['dist_h_50ema_atr1'] = df['dist_h_50ema1'] /df['atr']\n    df['dist_h_200ema_atr1'] = df['dist_h_200ema1'] /df['atr']\n\n    df['dist_h_9ema2'] = df['dist_h_9ema'].shift(2)\n    df['dist_h_9ema3'] = df['dist_h_9ema'].shift(3)\n    df['dist_h_9ema4'] = df['dist_h_9ema'].shift(4)\n\n    df['dist_h_20ema2'] = df['dist_h_20ema'].shift(2)\n    df['dist_h_20ema3'] = df['dist_h_20ema'].shift(3)\n    df['dist_h_20ema4'] = df['dist_h_20ema'].shift(4)\n    df['dist_h_20ema5'] = df['dist_h_20ema'].shift(5)\n\n    df['dist_h_9ema_atr2'] = df['dist_h_9ema2'] /df['atr']\n    df['dist_h_9ema_atr3'] = df['dist_h_9ema3'] /df['atr']\n    df['dist_h_9ema_atr4'] = df['dist_h_9ema4'] /df['atr']\n\n    df['lc_frontside_d3_extended_1'] = ((df['h'] >= df['h1']) & (df['h1'] >= df['h2']) & (df['h2'] >= df['h3']))\n\n    return df\n\nasync def fetch_data(symbol):\n    url = f\"{BASE_URL}/v2/aggs/ticker/{symbol}/range/1/day/2025-01-01/2025-01-17?apiKey={API_KEY}\"\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url) as response:\n            data = await response.json()\n            if 'results' in data:\n                df = pd.DataFrame(data['results'])\n                return adjust_daily(df)\n            return pd.DataFrame()\n\nasync def main():\n    symbols = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA']\n    tasks = [fetch_data(symbol) for symbol in symbols]\n    results = await asyncio.gather(*tasks)\n    for df in results:\n        if not df.empty:\n            print(df[df['lc_frontside_d3_extended_1']])\n\nif __name__ == \"__main__\":\n    asyncio.run(main())","parameters":[{"name":"high_chg_atr1","default_value":0.5,"description":"High change normalized by ATR from previous day","category":"technical","importance":"critical"},{"name":"gap_atr1","default_value":0.2,"description":"Gap normalized by ATR from previous day","category":"price","importance":"high"},{"name":"close_range1","default_value":0.6,"description":"Close range from previous day","category":"price","importance":"medium"},{"name":"dist_h_9ema_atr1","default_value":1.5,"description":"Distance from high to 9 EMA normalized by ATR","category":"technical","importance":"high"}],"complexity":8,"dependencies":["check_high_lvl_filter_lc"]},{"scanner_name":"LC Backside D3 Extended_AI_Generated","description":"Identifies stocks with a potential reversal pattern over three days, considering price changes, volume, and EMA distances.","formatted_code":"import pandas as pd\nimport requests\nimport time\nimport numpy as np\nimport pandas_market_calendars as mcal\nimport aiohttp\nimport asyncio\nfrom multiprocessing import Pool, cpu_count\nfrom concurrent.futures import ProcessPoolExecutor\nfrom tabulate import tabulate\nimport webbrowser\nimport plotly.graph_objects as go\nimport sys\nfrom concurrent.futures import ThreadPoolExecutor\nimport dask\nfrom dask.distributed import Client, as_completed\nimport dask.dataframe as dd\nimport datetime\nimport logging\nimport backoff\n\nnyse = mcal.get_calendar('NYSE')\nexecutor = ThreadPoolExecutor()\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nif sys.platform == 'win32':\n    asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())\n\nDATE = \"2025-01-17\"\nAPI_KEY = '4r6MZNWLy2ucmhVI7fY8MrvXfXTSmxpy'\nBASE_URL = \"https://api.polygon.io\"\n\ndef adjust_daily(df):\n    df['date'] = pd.to_datetime(df['t'], unit='ms')\n    df['date'] = df['date'].dt.date\n    df['pdc'] = df['c'].shift(1)\n    df['high_low'] = df['h'] - df['l']\n    df['high_pdc'] = abs(df['h'] - df['pdc'])\n    df['low_pdc'] = abs(df['l'] - df['pdc'])\n    df['true_range'] = df[['high_low', 'high_pdc', 'low_pdc']].max(axis=1)\n    df['atr'] = df['true_range'].rolling(window=14).mean()\n    df.drop(['high_low', 'high_pdc', 'low_pdc'], axis=1, inplace=True)\n\n    df['h1'] = df['h'].shift(1)\n    df['h2'] = df['h'].shift(2)\n    df['h3'] = df['h'].shift(3)\n\n    df['c1'] = df['c'].shift(1)\n    df['c2'] = df['c'].shift(2)\n    df['c3'] = df['c'].shift(3)\n\n    df['o1'] = df['o'].shift(1)\n    df['o2'] = df['o'].shift(2)\n\n    df['l1'] = df['l'].shift(1)\n    df['l2'] = df['l'].shift(2)\n\n    df['v_ua1'] = df['v_ua'].shift(1)\n    df['v1'] = df['v'].shift(1)\n    df['v2'] = df['v'].shift(2)\n\n    df['dol_v'] = (df['c'] * df['v'])\n    df['dol_v1'] = df['dol_v'].shift(1)\n    df['dol_v2'] = df['dol_v'].shift(2)\n\n    df['close_range'] = (df['c'] - df['l'])/(df['h'] - df['l'])\n    df['close_range1'] = df['close_range'].shift(1)\n    df['close_range2'] = df['close_range'].shift(2)\n\n    df['gap_atr'] = ((df['o'] - df['pdc'])/df['atr'])\n    df['gap_atr1'] = ((df['o1'] - df['c2'])/df['atr'])\n\n    df['gap_pdh_atr'] = ((df['o'] - df['h1'])/df['atr'])\n\n    df['high_chg'] = (df['h'] - df['o'])\n    df['high_chg_atr'] = ((df['h'] - df['o'])/df['atr'])\n    df['high_chg_atr1'] = ((df['h1'] - df['o1'])/df['atr'])\n    df['high_chg_atr2'] = ((df['h2'] - df['o2'])/df['atr'])\n\n    df['high_chg_from_pdc_atr'] = ((df['h'] - df['c1'])/df['atr'])\n    df['high_chg_from_pdc_atr1'] = ((df['h1'] - df['c2'])/df['atr'])\n\n    df['pct_change'] = round(((df['c'] / df['c1']) - 1)*100, 2)\n\n    df['ema9'] = df['c'].ewm(span=9, adjust=False).mean().fillna(0)\n    df['ema20'] = df['c'].ewm(span=20, adjust=False).mean().fillna(0)\n    df['ema50'] = df['c'].ewm(span=50, adjust=False).mean().fillna(0)\n    df['ema200'] = df['c'].ewm(span=200, adjust=False).mean().fillna(0)\n\n    df['ema20_2'] = df['ema20'].shift(2)\n\n    df['ema9_1'] = df['ema9'].shift(1)\n    df['ema20_1'] = df['ema20'].shift(1)\n    df['ema50_1'] = df['ema50'].shift(1)\n\n    df['dist_h_9ema'] = (df['h'] - df['ema9'])\n    df['dist_h_20ema'] = (df['h'] - df['ema20'])\n    df['dist_h_50ema'] = (df['h'] - df['ema50'])\n    df['dist_h_200ema'] = (df['h'] - df['ema200'])\n\n    df['dist_h_9ema1'] = df['dist_h_9ema'].shift(1)\n    df['dist_h_20ema1'] = df['dist_h_20ema'].shift(1)\n    df['dist_h_50ema1'] = df['dist_h_50ema'].shift(1)\n    df['dist_h_200ema1'] = df['dist_h_200ema'].shift(1)\n\n    df['dist_h_9ema_atr'] = df['dist_h_9ema'] /df['atr']\n    df['dist_h_20ema_atr'] = df['dist_h_20ema'] /df['atr']\n    df['dist_h_50ema_atr'] = df['dist_h_50ema'] /df['atr']\n    df['dist_h_200ema_atr'] = df['dist_h_200ema'] /df['atr']\n\n    df['dist_h_9ema_atr1'] = df['dist_h_9ema1'] /df['atr']\n    df['dist_h_20ema_atr1'] = df['dist_h_20ema1'] /df['atr']\n    df['dist_h_50ema_atr1'] = df['dist_h_50ema1'] /df['atr']\n    df['dist_h_200ema_atr1'] = df['dist_h_200ema1'] /df['atr']\n\n    df['dist_h_9ema2'] = df['dist_h_9ema'].shift(2)\n    df['dist_h_9ema3'] = df['dist_h_9ema'].shift(3)\n    df['dist_h_9ema4'] = df['dist_h_9ema'].shift(4)\n\n    df['dist_h_20ema2'] = df['dist_h_20ema'].shift(2)\n    df['dist_h_20ema3'] = df['dist_h_20ema'].shift(3)\n    df['dist_h_20ema4'] = df['dist_h_20ema'].shift(4)\n    df['dist_h_20ema5'] = df['dist_h_20ema'].shift(5)\n\n    df['dist_h_9ema_atr2'] = df['dist_h_9ema2'] /df['atr']\n    df['dist_h_9ema_atr3'] = df['dist_h_9ema3'] /df['atr']\n    df['dist_h_9ema_atr4'] = df['dist_h_9ema4'] /df['atr']\n\n    df['lc_backside_d3_extended_1'] = ((df['h'] >= df['h1']) & (df['h1'] >= df['h2']) & (df['h2'] >= df['h3']))\n\n    return df\n\nasync def fetch_data(symbol):\n    url = f\"{BASE_URL}/v2/aggs/ticker/{symbol}/range/1/day/{DATE}/{DATE}\"\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url, params={'apiKey': API_KEY}) as response:\n            data = await response.json()\n            if 'results' in data:\n                df = pd.DataFrame(data['results'])\n                df = adjust_daily(df)\n                return df\n            else:\n                return pd.DataFrame()\n\nasync def main():\n    symbols = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA']\n    tasks = [fetch_data(symbol) for symbol in symbols]\n    results = await asyncio.gather(*tasks)\n    for df in results:\n        if not df.empty:\n            print(df[df['lc_backside_d3_extended_1']])\n\nif __name__ == \"__main__\":\n    asyncio.run(main())","parameters":[{"name":"high_chg_atr1","default_value":0.5,"description":"High change normalized by ATR from previous day","category":"technical","importance":"critical"},{"name":"gap_atr1","default_value":0.2,"description":"Gap normalized by ATR from previous day","category":"price","importance":"high"},{"name":"close_range1","default_value":0.6,"description":"Close range from previous day","category":"price","importance":"medium"},{"name":"dist_h_9ema_atr1","default_value":1.5,"description":"Distance from high to 9 EMA normalized by ATR","category":"technical","importance":"high"}],"complexity":8,"dependencies":["check_high_lvl_filter_lc"]}],"total_scanners":3,"analysis_confidence":0.95,"model_used":"deepseek/deepseek-chat","method":"AI_Powered_OpenRouter","timestamp":"2025-11-11T14:00:28.455942"}