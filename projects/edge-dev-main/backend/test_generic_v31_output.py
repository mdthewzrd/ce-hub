"""
TestRSIScanner - TRUE v31 Architecture Scanner

Identifies oversold stocks using Relative Strength Index (RSI) below 30 with significant volume

Generated by RENATA_V2 - 2026-01-15 08:53:21

TRUE v31 Architecture - All 7 Core Pillars Implemented:
1. âœ… Market calendar (pandas_market_calendars)
2. âœ… Historical buffer calculation
3. âœ… Per-ticker operations (groupby().transform())
4. âœ… Historical/D0 separation
5. âœ… Parallel processing (ThreadPoolExecutor)
6. âœ… Two-pass feature computation
7. âœ… Pre-sliced data for parallel processing
"""

import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from concurrent.futures import ThreadPoolExecutor, as_completed
import pandas_market_calendars as mcal
from typing import Dict, List, Optional, Tuple


class TestRSIScanner:
    """
    RSI Oversold Scanner

    Identifies oversold stocks using Relative Strength Index (RSI) below 30 with significant volume

    Scanner Type: Generic Scanner converted to TRUE v31 Architecture
    Generated: 2026-01-15 08:53:21

    TRUE v31 Architecture - All 7 Core Pillars Implemented
    """

    def __init__(self):
        """
        Initialize scanner with proper v31 configuration

        âœ… PILLAR 2: Calculate historical buffer for ABS window
        """
        # Date range configuration
        self.d0_start = "2024-01-01"
        self.d0_end = "2024-12-31"

        # âœ… CRITICAL: Calculate historical buffer (default 2 years for safety)
        # Lookback period for technical indicators
        lookback_buffer = 730  # 2 years default buffer

        # Calculate scan_start with historical buffer
        scan_start_dt = pd.to_datetime(self.d0_start) - pd.Timedelta(days=lookback_buffer)
        self.scan_start = scan_start_dt.strftime('%Y-%m-%d')

        # âœ… Market calendar setup
        self.nyse = mcal.get_calendar('XNYS')

        # âœ… Workers for parallel processing
        self.max_workers = 10

        # âœ… Scanner name for logging
        self.scanner_name = self.__class__.__name__

        print(f"ğŸ¯ {self.scanner_name} initialized")
        print(f"   Historical buffer: {lookback_buffer} days")
        print(f"   Scan range: {self.scan_start} to {self.d0_end}")
        print(f"   D0 output range: {self.d0_start} to {self.d0_end}")

    def fetch_grouped_data(self, tickers: List[str]) -> pd.DataFrame:
        """
        âœ… PILLAR 1: Market calendar integration
        âœ… PILLAR 5: Parallel processing

        Fetch historical data for multiple tickers using fetch_all_grouped_data

        Args:
            tickers: List of ticker symbols

        Returns:
            DataFrame with historical data for all tickers
        """
        from universal_scanner_engine.core.data_loader import fetch_all_grouped_data

        print(f"\nğŸ“Š Fetching data for {len(tickers)} tickers...")
        print(f"   Date range: {self.scan_start} to {self.d0_end}")

        try:
            df = fetch_all_grouped_data(
                tickers=tickers,
                start=self.scan_start,
                end=self.d0_end
            )

            if df.empty:
                print("âš ï¸  No data fetched")
                return pd.DataFrame()

            print(f"âœ… Fetched {len(df)} rows across {df['ticker'].nunique()} tickers")
            return df

        except Exception as e:
            print(f"âŒ Error fetching data: {e}")
            import traceback
            traceback.print_exc()
            return pd.DataFrame()

    def run_pattern_detection(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        âœ… PILLAR 4: Separate historical from D0 data
        âœ… PILLAR 6: Two-pass feature computation

        Run pattern detection on fetched data

        Args:
            df: DataFrame with historical data

        Returns:
            DataFrame with pattern detection results (D0 range only)
        """
        if df.empty:
            return pd.DataFrame()

        print(f"\nğŸ” Running pattern detection on {len(df)} rows...")

        # âœ… PILLAR 4: Split historical from D0
        df_historical = df[~df['date'].between(self.d0_start, self.d0_end)].copy()
        df_d0 = df[df['date'].between(self.d0_start, self.d0_end)].copy()

        print(f"   ğŸ“Š Historical: {len(df_historical)} rows (for indicators)")
        print(f"   ğŸ“Š D0 range: {len(df_d0)} rows (for output)")

        # Combine for pattern detection (original code can use both)
        df_combined = pd.concat([df_historical, df_d0], ignore_index=True)

        # Apply original scanner logic
        try:
            # Your original code below:

            def scan_stocks(df):
                """
                Simple scanner to find oversold stocks using RSI

                Args:
                    df: DataFrame with stock data

                Returns:
                    DataFrame with oversold stocks
                """
                # Calculate RSI
                delta = df['close'].diff()
                gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
                loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
                rs = gain / loss
                df['rsi'] = 100 - (100 / (1 + rs))

                # Find oversold stocks
                results = df[
                    (df['rsi'] < 30) &
                    (df['volume'] > 1000000)
                ][['ticker', 'date', 'close', 'rsi', 'volume']]

                return results


            # Filter to D0 range for output
            if 'results' in locals():
                if isinstance(results, pd.DataFrame):
                    if 'date' in results.columns:
                        results_d0 = results[results['date'].between(self.d0_start, self.d0_end)].copy()
                        print(f"âœ… Pattern detection complete: {len(results_d0)} D0 signals")
                        return results_d0
                    else:
                        print(f"âœ… Pattern detection complete: {len(results)} signals")
                        return results
                else:
                    # Assume results is a list or other type
                    print(f"âœ… Pattern detection complete: {len(results)} signals")
                    return results
            else:
                print("âš ï¸  No 'results' variable found in original code")
                return pd.DataFrame()

        except Exception as e:
            print(f"âŒ Error in pattern detection: {e}")
            import traceback
            traceback.print_exc()
            return pd.DataFrame()

    def run(self, tickers: List[str]) -> List[Dict]:
        """
        ğŸš€ Main execution method

        Args:
            tickers: List of ticker symbols to scan

        Returns:
            List of signal dictionaries
        """
        print(f"\n{'='*70}")
        print(f"ğŸš€ RUNNING TRUE v31 SCAN: {self.scanner_name}")
        print(f"{'='*70}")

        # Fetch data
        df = self.fetch_grouped_data(tickers)

        if df.empty:
            print("âš ï¸  No data available")
            return []

        # Run pattern detection
        results = self.run_pattern_detection(df)

        if results.empty:
            print("ğŸ“­ No signals found")
            return []

        # Convert to list of dicts
        if isinstance(results, pd.DataFrame):
            signals = results.to_dict('records')
        else:
            signals = results if isinstance(results, list) else [results]

        print(f"\nâœ… SCAN COMPLETE: {len(signals)} signals detected")
        return signals


if __name__ == "__main__":
    # Example usage
    scanner = TestRSIScanner()

    # Example tickers
    tickers = ["AAPL", "MSFT", "GOOGL", "AMZN", "TSLA"]

    signals = scanner.run(tickers)

    for signal in signals:
        print(signal)
