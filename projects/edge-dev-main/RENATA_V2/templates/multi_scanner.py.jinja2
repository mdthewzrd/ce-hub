{#
  Multi-Pattern Scanner Template

  This template generates a scanner that can detect multiple patterns.
  Each pattern has its own detect method and smart filters.

  Variables:
  - All base_v31 variables plus:
  - patterns: List of pattern dictionaries with:
    - name: Pattern name (e.g., "D2_Gap")
    - detection_method: Pattern detection code
    - filters: Pattern-specific filters
#}
{% extends 'base_v31.py.jinja2' %}

{# Add pattern detection methods #}
{% block pattern_methods %}
{% for pattern in patterns %}
    def detect_{{ pattern.name | replace('-', '_') | lower }}(
        self,
        stage2_data: pd.DataFrame
    ) -> List[Dict[str, Any]]:
        """
        Detect {{ pattern.name }} patterns

        Entry Conditions:
        {% for condition in pattern.entry_conditions %}
        - {{ condition }}
        {% endfor %}

        Args:
            stage2_data: Pre-filtered data for this pattern

        Returns:
            List of pattern results
        """
        if stage2_data.empty:
            return []

        results = []

        {{ pattern.detection_method | indent(8) }}

        # Add pattern name to results
        for result in results:
            result['pattern'] = '{{ pattern.name }}'

        return results

{% endfor %}
{% endblock %}

{# Override detect_patterns to call all pattern methods #}
{% block detect_patterns %}
    def detect_patterns(self, stage2_data: pd.DataFrame) -> List[Dict[str, Any]]:
        """
        Stage 3: Detect all patterns

        Scanning for {{ patterns | length }} patterns:
        {% for pattern in patterns %}
        - {{ pattern.name }}
        {% endfor %}

        Args:
            stage2_data: Filtered DataFrame from apply_smart_filters

        Returns:
            List of dictionaries with all pattern results
        """
        if stage2_data.empty:
            return []

        all_results = []

        {% for pattern in patterns %}
        # Detect {{ pattern.name }}
        print("  Checking for {{ pattern.name }}...")
        {{ pattern.name | replace('-', '_') | lower }}_data = self._apply_{{ pattern.name | replace('-', '_') | lower }}_filters(stage2_data)
        {{ pattern.name | replace('-', '_') | lower }}_results = self.detect_{{ pattern.name | replace('-', '_') | lower }}({{ pattern.name | replace('-', '_') | lower }}_data)
        all_results.extend({{ pattern.name | replace('-', '_') | lower }}_results)
        print(f"    Found {len({{ pattern.name | replace('-', '_') | lower }}_results)} {{ pattern.name }} signals")

        {% endfor %}
        return all_results
{% endblock %}

{# Add pattern-specific filter methods #}
{% block pattern_filter_methods %}
{% for pattern in patterns %}
    def _apply_{{ pattern.name | replace('-', '_') | lower }}_filters(
        self,
        stage1_data: pd.DataFrame
    ) -> pd.DataFrame:
        """
        Apply smart filters for {{ pattern.name }}

        Filters:
        {% if pattern.filters.min_price %}
        - Min price: ${{ pattern.filters.min_price }}
        {% endif %}
        {% if pattern.filters.max_price %}
        - Max price: ${{ pattern.filters.max_price }}
        {% endif %}
        {% if pattern.filters.min_volume %}
        - Min volume: {{ pattern.filters.min_volume | number_format }} shares
        {% endif %}
        {% if pattern.filters.min_gap_pct %}
        - Min gap: {{ pattern.filters.min_gap_pct }}%
        {% endif %}
        {% if pattern.filters.min_gap_consecutive %}
        - Min consecutive: {{ pattern.filters.min_gap_consecutive }} days
        {% endif %}

        Args:
            stage1_data: Data to filter

        Returns:
            Filtered DataFrame
        """
        df = stage1_data.copy()

        # Apply universal smart filters
        {% if smart_filters.min_prev_close %}
        df = df[df['close'] >= {{ smart_filters.min_prev_close }}]
        {% endif %}

        {% if smart_filters.min_prev_volume %}
        df = df[df['volume'] >= {{ smart_filters.min_prev_volume }}]
        {% endif %}

        # Apply pattern-specific filters
        {% if pattern.filters.min_price %}
        df = df[df['close'] >= {{ pattern.filters.min_price }}]
        {% endif %}

        {% if pattern.filters.max_price %}
        df = df[df['close'] <= {{ pattern.filters.max_price }}]
        {% endif %}

        {% if pattern.filters.min_volume %}
        df = df[df['volume'] >= {{ pattern.filters.min_volume }}]
        {% endif %}

        {% if pattern.filters.max_volume %}
        df = df[df['volume'] <= {{ pattern.filters.max_volume }}]
        {% endif %}

        {% if pattern.filters.min_gap_pct %}
        df = df[df['gap'] >= {{ pattern.filters.min_gap_pct }}]
        {% endif %}

        {% if pattern.filters.max_gap_pct %}
        df = df[df['gap'] <= {{ pattern.filters.max_gap_pct }}]
        {% endif %}

        {% if pattern.filters.min_gap_consecutive %}
        df = df[df['consecutive_gaps'] >= {{ pattern.filters.min_gap_consecutive }}]
        {% endif %}

        return df

{% endfor %}
{% endblock %}

{# Override apply_smart_filters for multi-scanner #}
{% block apply_smart_filters %}
    def apply_smart_filters(
        self,
        stage1_data: pd.DataFrame,
        workers: int = {{ stage3_workers | default(4) }}
    ) -> pd.DataFrame:
        """
        Stage 2: Apply universal smart filters

        Note: In multi-scanners, pattern-specific filters are applied
        in each pattern's detection method for maximum efficiency.

        Args:
            stage1_data: Output from fetch_grouped_data
            workers: Number of parallel workers

        Returns:
            Filtered DataFrame (stage2_data)
        """
        if stage1_data.empty:
            return pd.DataFrame()

        df = stage1_data.copy()

        # Apply only universal filters here
        # Pattern-specific filters are applied in each pattern method

        {% if smart_filters.min_prev_close %}
        df = df[df['close'] >= {{ smart_filters.min_prev_close }}]
        {% endif %}

        {% if smart_filters.max_prev_close %}
        df = df[df['close'] <= {{ smart_filters.max_prev_close }}]
        {% endif %}

        {% if smart_filters.min_prev_volume %}
        df = df[df['volume'] >= {{ smart_filters.min_prev_volume }}]
        {% endif %}

        {% if smart_filters.max_prev_volume %}
        df = df[df['volume'] <= {{ smart_filters.max_prev_volume }}]
        {% endif %}

        return df
{% endblock %}
