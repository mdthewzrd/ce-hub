{
  "message": "Original working backside scanner that produces 8 signals - now with FIXED execution pipeline:\n\n```python\n# daily_para_backside_lite_scan.py\n# Daily-only \\\"A+ para, backside\\\" scan — lite mold.\n# Trigger: D-1 (or D-2) fits; trade day (D0) must gap & open > D-1 high.\n# D-1 must take out D-2 high and close above D-2 close.\n# Adds absolute D-1 volume floor: d1_volume_min.\n\nimport pandas as pd, numpy as np, requests\nfrom datetime import datetime\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\n\n# ───────── config ─────────\nsession  = requests.Session()\nAPI_KEY  = \\\"Fm7brz4s23eSocDErnL68cE7wspz2K1I\\\"\nBASE_URL = \\\"https://api.polygon.io\\\"\nMAX_WORKERS = 6\n\nPRINT_FROM = \\\"2025-01-01\\\"  # set None to keep all\nPRINT_TO   = \\\"2025-11-01\\\"\n\n# ───────── knobs ─────────\nP = {\n    # hard liquidity / price\n    \\\"price_min\\\"        : 8.0,\n    \\\"adv20_min_usd\\\"    : 30_000_000,\n\n    # backside context (absolute window)\n    \\\"abs_lookback_days\\\": 1000,\n    \\\"abs_exclude_days\\\" : 10,\n    \\\"pos_abs_max\\\"      : 0.75,\n    \\\"trigger_mode\\\"     : \\\"D1_or_D2\\\",\n\n    # size & trigger\n    \\\"atr_mult\\\"         : .9,\n    \\\"vol_mult\\\"         : 0.9,\n    \\\"d1_volume_min\\\"     : 15_000_000,\n\n    # trend filter\n    \\\"slope5d_min\\\"      : 3.0,\n    \\\"high_ema9_mult\\\"   : 1.05,\n\n    # gap & open criteria\n    \\\"gap_div_atr_min\\\"  : .75,\n    \\\"open_over_ema9_min\\\": .9,\n    \\\"d1_green_atr_min\\\"  : 0.30,\n\n    # structural\n    \\\"require_open_gt_prev_high\\\": True,\n    \\\"enforce_d1_above_d2\\\"       : True,\n}\n\n# This will be overridden with complete market universe\nSYMBOLS = ['AAPL', 'MSFT', 'GOOGL']  # Temporary list\n\ndef fetch_daily(tkr, start, end):\n    \\\"\\\"\\\"Fetch daily price data from Polygon.\\\"\\\"\\\"\n    url = f\\\"{BASE_URL}/v2/aggs/ticker/{tkr}/range/1/day/{start}/{end}\\\"\n    r = session.get(url, params={\\\"apiKey\\\": API_KEY, \\\"adjusted\\\":\\\"true\\\"})\n    if not r.ok:\n        return pd.DataFrame()\n    \n    rows = r.json().get(\\\"results\\\", [])\n    if not rows:\n        return pd.DataFrame()\n        \n    df = pd.DataFrame(rows)\n    df['Date'] = pd.to_datetime(df['t'], unit='ms', utc=True)\n    df = df.rename(columns={\n        \\\"o\\\": \\\"Open\\\",\n        \\\"h\\\": \\\"High\\\",\n        \\\"l\\\": \\\"Low\\\",\n        \\\"c\\\": \\\"Close\\\",\n        \\\"v\\\": \\\"Volume\\\"\n    })\n    return df.set_index(\\\"Date\\\")[[\\\"Open\\\", \\\"High\\\", \\\"Low\\\", \\\"Close\\\", \\\"Volume\\\"]]\n\ndef add_daily_metrics(df):\n    \\\"\\\"\\\"Add technical indicators to daily data.\\\"\\\"\\\"\n    if df.empty:\n        return df\n    try:\n        df.index = df.index.tz_localize(None)\n    except:\n        pass\n        \n    # EMAs and volatility\n    df[\\\"EMA_9\\\"] = df[\\\"Close\\\"].ewm(span=9, adjust=False).mean()\n    hi_lo = df[\\\"High\\\"] - df[\\\"Low\\\"]\n    hi_prev = (df[\\\"High\\\"] - df[\\\"Close\\\"].shift(1)).abs()\n    lo_prev = (df[\\\"Low\\\"] - df[\\\"Close\\\"].shift(1)).abs()\n    df[\\\"TR\\\"] = pd.concat([hi_lo, hi_prev, lo_prev], axis=1).max(axis=1)\n    df[\\\"ATR_raw\\\"] = df[\\\"TR\\\"].rolling(14, min_periods=14).mean()\n    df[\\\"ATR\\\"] = df[\\\"ATR_raw\\\"].shift(1)\n    df[\\\"VOL_AVG\\\"] = df[\\\"Volume\\\"].rolling(14, min_periods=14).mean().shift(1)\n    \n    # Gap and body calculations\n    df[\\\"Gap_abs\\\"] = (df[\\\"Open\\\"] - df[\\\"Close\\\"].shift(1)).abs()\n    df[\\\"Gap_over_ATR\\\"] = df[\\\"Gap_abs\\\"] / df[\\\"ATR\\\"]\n    df[\\\"Open_over_EMA9\\\"] = df[\\\"Open\\\"] / df[\\\"EMA_9\\\"]\n    df[\\\"Body_over_ATR\\\"] = (df[\\\"Close\\\"] - df[\\\"Open\\\"]) / df[\\\"ATR\\\"]\n    df[\\\"Slope_9_5d\\\"] = (df[\\\"EMA_9\\\"] - df[\\\"EMA_9\\\"].shift(5)) / df[\\\"EMA_9\\\"].shift(5) * 100\n    \n    return df\n\ndef scan_symbol(sym, start_date, end_date):\n    \\\"\\\"\\\"Scan a single symbol for backside setups.\\\"\\\"\\\"  \n    try:\n        # Fetch data\n        df = fetch_daily(sym, start_date, end_date)\n        if df.empty:\n            return pd.DataFrame()\n            \n        # Add metrics\n        df = add_daily_metrics(df)\n        if df.empty:\n            return pd.DataFrame()\n            \n        results = []\n        \n        # Scan each day\n        for i in range(20, len(df)):  # Start at 20 to ensure we have enough history\n            current_date = df.index[i]\n            gap_atr = df.iloc[i]['Gap_over_ATR']\n            \n            # Basic gap filter (this is what should trigger signals)\n            if gap_atr >= P['gap_div_atr_min']:\n                results.append({\n                    'Ticker': sym,\n                    'Date': current_date.strftime('%Y-%m-%d'),\n                    'Gap/ATR': round(gap_atr, 2),\n                    'D1Vol(shares)': int(df.iloc[i]['Volume']),\n                    'D1Vol/Avg': round(df.iloc[i]['Volume'] / df.iloc[i]['VOL_AVG'], 2) if df.iloc[i]['VOL_AVG'] > 0 else 0,\n                    'Open>PrevHigh': df.iloc[i]['Open'] > df.iloc[i-1]['High'],\n                    'Slope9_5d': round(df.iloc[i]['Slope_9_5d'], 2) if not pd.isna(df.iloc[i]['Slope_9_5d']) else 0.0\n                })\n                \n        return pd.DataFrame(results)\n        \n    except Exception as e:\n        print(f\\\"Error scanning {sym}: {e}\\\")\n        return pd.DataFrame()\n\n# The execution wrapper will handle the main execution logic\n```",
  "personality": "formatter",
  "context": {
    "page": "renata-popup",
    "timestamp": "2025-11-26T20:10:00.000Z"
  }
}