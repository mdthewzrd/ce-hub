{
  "message": "Original backside scanner ADAPTED for MARKET-WIDE execution using Polygon grouped API:\n\n```python\n# Market-wide version of the original backside scanner\nimport pandas as pd, numpy as np, requests\nfrom datetime import datetime\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\n\n# ───────── knobs ─────────\nP = {\n    \"price_min\"        : 8.0,\n    \"adv20_min_usd\"    : 30_000_000,\n    \"abs_lookback_days\": 1000,\n    \"abs_exclude_days\" : 10,\n    \"pos_abs_max\"      : 0.75,\n    \"trigger_mode\"     : \"D1_or_D2\",\",\n    \"atr_mult\"         : .9,\n    \"vol_mult\"         : 0.9,\n    \"d1_volume_min\"    : 15_000_000,\n    \"slope5d_min\"      : 3.0,\n    \"high_ema9_mult\"   : 1.05,\n    \"gap_div_atr_min\"   : .75,\n    \"open_over_ema9_min\": .9,\n    \"d1_green_atr_min\"  : 0.30,\n    \"require_open_gt_prev_high\": True,\n    \"enforce_d1_above_d2\": True,\n}\n\n# MARKET-WIDE: Use the global market data instead of hardcoded symbols\n# SYMBOLS list will be replaced with MARKET_WIDE_DATA automatically\n\n# ───────── metrics ─────────\ndef add_daily_metrics(df: pd.DataFrame) -> pd.DataFrame:\n    if df.empty: return df\n    m = df.copy()\n    try: m.index = m.index.tz_localize(None)\n    except Exception: pass\n\n    m[\"EMA_9\"]  = m[\"Close\"].ewm(span=9 , adjust=False).mean()\n    m[\"EMA_20\"] = m[\"Close\"].ewm(span=20, adjust=False).mean()\n\n    hi_lo   = m[\"High\"] - m[\"Low\"]\n    hi_prev = (m[\"High\"] - m[\"Close\"].shift(1)).abs()\n    lo_prev = (m[\"Low\"]  - m[\"Close\"].shift(1)).abs()\n    m[\"TR\"]      = pd.concat([hi_lo, hi_prev, lo_prev], axis=1).max(axis=1)\n    m[\"ATR_raw\"] = m[\"TR\"].rolling(14, min_periods=14).mean()\n    m[\"ATR\"]     = m[\"ATR_raw\"].shift(1)\n\n    m[\"VOL_AVG\"]     = m[\"Volume\"].rolling(14, min_periods=14).mean().shift(1)\n    m[\"Prev_Volume\"] = m[\"Volume\"].shift(1)\n    m[\"ADV20_$\"]     = (m[\"Close\"] * m[\"Volume\"]).rolling(20, min_periods=20).mean().shift(1)\n\n    m[\"Slope_9_5d\"]  = (m[\"EMA_9\"] - m[\"EMA_9\"].shift(5)) / m[\"EMA_9\"].shift(5) * 100\n    m[\"High_over_EMA9_div_ATR\"] = (m[\"High\"] - m[\"EMA_9\"]) / m[\"ATR\"]\n\n    m[\"Gap_abs\"]       = (m[\"Open\"] - m[\"Close\"].shift(1)).abs()\n    m[\"Gap_over_ATR\"]  = m[\"Gap_abs\"] / m[\"ATR\"]\n    m[\"Open_over_EMA9\"] = m[\"Open\"] / m[\"EMA_9\"]\n\n    m[\"Body_over_ATR\"] = (m[\"Close\"] - m[\"Open\"]) / m[\"ATR\"]\n\n    m[\"Prev_Close\"] = m[\"Close\"].shift(1)\n    m[\"Prev_Open\"]  = m[\"Open\"].shift(1)\n    m[\"Prev_High\"]  = m[\"High\"].shift(1)\n    return m\n\n# ───────── helpers ─────────\ndef abs_top_window(df: pd.DataFrame, d0, lookback_days: int, exclude_days: int):\n    if df.empty: return (np.nan, np.nan)\n    cutoff = d0 - pd.Timedelta(days=exclude_days)\n    wstart = cutoff - pd.Timedelta(days=lookback_days)\n    win = df[(df.index > wstart) & (df.index <= cutoff)]\n    if win.empty: return (np.nan, np.nan)\n    return float(win[\"Low\"].min()), float(win[\"High\"].max())\n\ndef pos_between(val, lo, hi):\n    if any(pd.isna(t) for t in (val, lo, hi)) or hi <= lo: return np.nan\n    return max(0.0, min(1.0, float((val - lo) / (hi - lo))))\n\ndef _mold_on_row(rx: pd.Series) -> bool:\n    if pd.isna(rx.get(\"Prev_Close\")) or pd.isna(rx.get(\"ADV20_$\")):\n        return False\n    if rx[\"Prev_Close\"] < P[\"price_min\"] or rx[\"ADV20_$\"] < P[\"adv20_min_usd\"]:\n        return False\n    vol_avg = rx[\"VOL_AVG\"]\n    if pd.isna(vol_avg) or vol_avg <= 0: return False\n    vol_sig = max(rx[\"Volume\"]/vol_avg, rx[\"Prev_Volume\"]/vol_avg)\n    checks = [\n        (rx[\"TR\"] / rx[\"ATR\"]) >= P[\"atr_mult\"],\n        vol_sig                 >= P[\"vol_mult\"],\n        rx[\"Slope_9_5d\"]        >= P[\"slope5d_min\"],\n        rx[\"High_over_EMA9_div_ATR\"] >= P[\"high_ema9_mult\"],\n    ]\n    return all(bool(x) and np.isfinite(x) for x in checks)\n\n# ───────── scan one symbol ─────────\ndef scan_symbol(sym: str, start: str, end: str) -> pd.DataFrame:\n    # MARKET-WIDE: Get data from global MARKET_WIDE_DATA instead of fetching\n    global MARKET_WIDE_DATA\n    \n    if 'MARKET_WIDE_DATA' not in globals():\n        print(\"❌ MARKET_WIDE_DATA not available\")\n        return pd.DataFrame()\n        \n    df_sym = MARKET_WIDE_DATA[MARKET_WIDE_DATA['ticker'] == sym].copy()\n    if df_sym.empty:\n        return pd.DataFrame()\n        \n    # Convert to expected format\n    df_sym['Date'] = pd.to_datetime(df_sym['date'])\n    df_sym = df_sym.set_index('Date')\n    df_sym = df_sym.rename(columns={'o': 'Open', 'h': 'High', 'l': 'Low', 'c': 'Close', 'v': 'Volume'})\n    \n    # Apply filters by date range\n    df_sym = df_sym[(df_sym.index >= pd.to_datetime(start)) & (df_sym.index <= pd.to_datetime(end))]\n    if df_sym.empty:\n        return pd.DataFrame()\n        \n    m = add_daily_metrics(df_sym)\n    rows = []\n    \n    for i in range(2, len(m)):\n        d0 = m.index[i]\n        r0 = m.iloc[i]       # D0\n        r1 = m.iloc[i-1]     # D-1\n        r2 = m.iloc[i-2]     # D-2\n\n        # Backside vs D-1 close\n        lo_abs, hi_abs = abs_top_window(m, d0, P[\"abs_lookback_days\"], P[\"abs_exclude_days\"])\n        pos_abs_prev = pos_between(r1[\"Close\"], lo_abs, hi_abs)\n        if not (pd.notna(pos_abs_prev) and pos_abs_prev <= P[\"pos_abs_max\"]):\n            continue\n\n        # Choose trigger\n        trigger_ok = False; trig_row = None; trig_tag = \"-\"\n        if P[\"trigger_mode\"] == \"D1_only\":\n            if _mold_on_row(r1): trigger_ok, trig_row, trig_tag = True, r1, \"D-1\"\n        else:\n            if _mold_on_row(r1): trigger_ok, trig_row, trig_tag = True, r1, \"D-1\"\n            elif _mold_on_row(r2): trigger_ok, trig_row, trig_tag = True, r2, \"D-2\"\n        if not trigger_ok:\n            continue\n\n        # D-1 must be green\n        if not (pd.notna(r1[\"Body_over_ATR\"]) and r1[\"Body_over_ATR\"] >= P[\"d1_green_atr_min\"]):\n            continue\n\n        # Absolute D-1 volume floor\n        if P[\"d1_volume_min\"] is not None:\n            if not (pd.notna(r1[\"Volume\"]) and r1[\"Volume\"] >= P[\"d1_volume_min\"]):\n                continue\n\n        # D-1 > D-2 highs & close\n        if P[\"enforce_d1_above_d2\"]:\n            if not (pd.notna(r1[\"High\"]) and pd.notna(r2[\"High\"]) and r1[\"High\"] > r2[\"High\"]\n                    and pd.notna(r1[\"Close\"]) and pd.notna(r2[\"Close\"]) and r1[\"Close\"] > r2[\"Close\"]):\n                continue\n\n        # D0 gates\n        if pd.isna(r0[\"Gap_over_ATR\"]) or r0[\"Gap_over_ATR\"] < P[\"gap_div_atr_min\"]:\n            continue\n        if P[\"require_open_gt_prev_high\"] and not (r0[\"Open\"] > r1[\"High\"]):\n            continue\n        if pd.isna(r0[\"Open_over_EMA9\"]) or r0[\"Open_over_EMA9\"] < P[\"open_over_ema9_min\"]:\n            continue\n\n        rows.append({\n            \"Ticker\": sym,\n            \"Date\": d0.strftime(\"%Y-%m-%d\"),\n            \"Trigger\": trig_tag,\n            \"PosAbs_1000d\": round(float(pos_abs_prev), 3),\n            \"Gap/ATR\": round(float(r0[\"Gap_over_ATR\"]), 2),\n            \"D1Vol(shares)\": int(r1[\"Volume\"]) if pd.notna(r1[\"Volume\"]) else np.nan,\n            \"Open>PrevHigh\": bool(r0[\"Open\"] > r1[\"High\"]),\n            \"Slope9_5d\": round(float(r0[\"Slope_9_5d\"]), 2) if pd.notna(r0[\"Slope_9_5d\"]) else np.nan,\n        })\n\n    return pd.DataFrame(rows)\n\nprint(\"✅ Market-wide backside scanner loaded - ready to scan ALL symbols from MARKET_WIDE_DATA\")\n```",
  "personality": "formatter",
  "context": {
    "page": "renata-popup",
    "timestamp": "2025-11-26T21:45:00.000Z"
  }
}