/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@langchain";
exports.ids = ["vendor-chunks/@langchain"];
exports.modules = {

/***/ "(rsc)/./node_modules/@langchain/aws/dist/chat_models.cjs":
/*!**********************************************************!*\
  !*** ./node_modules/@langchain/aws/dist/chat_models.cjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChatBedrockConverse = void 0;\nconst messages_1 = __webpack_require__(/*! @langchain/core/messages */ \"(rsc)/./node_modules/@langchain/core/messages.cjs\");\nconst chat_models_1 = __webpack_require__(/*! @langchain/core/language_models/chat_models */ \"(rsc)/./node_modules/@langchain/core/language_models/chat_models.cjs\");\nconst client_bedrock_runtime_1 = __webpack_require__(/*! @aws-sdk/client-bedrock-runtime */ \"(rsc)/./node_modules/@aws-sdk/client-bedrock-runtime/dist-es/index.js\");\nconst outputs_1 = __webpack_require__(/*! @langchain/core/outputs */ \"(rsc)/./node_modules/@langchain/core/outputs.cjs\");\nconst env_1 = __webpack_require__(/*! @langchain/core/utils/env */ \"(rsc)/./node_modules/@langchain/core/utils/env.cjs\");\nconst credential_provider_node_1 = __webpack_require__(/*! @aws-sdk/credential-provider-node */ \"(rsc)/./node_modules/@aws-sdk/credential-provider-node/dist-es/index.js\");\nconst runnables_1 = __webpack_require__(/*! @langchain/core/runnables */ \"(rsc)/./node_modules/@langchain/core/runnables.cjs\");\nconst types_1 = __webpack_require__(/*! @langchain/core/utils/types */ \"(rsc)/./node_modules/@langchain/core/utils/types.cjs\");\nconst json_schema_1 = __webpack_require__(/*! @langchain/core/utils/json_schema */ \"(rsc)/./node_modules/@langchain/core/utils/json_schema.cjs\");\nconst common_js_1 = __webpack_require__(/*! ./common.cjs */ \"(rsc)/./node_modules/@langchain/aws/dist/common.cjs\");\n/**\n * AWS Bedrock Converse chat model integration.\n *\n * Setup:\n * Install `@langchain/aws` and set the following environment variables:\n *\n * ```bash\n * npm install @langchain/aws\n * export BEDROCK_AWS_REGION=\"your-aws-region\"\n * export BEDROCK_AWS_SECRET_ACCESS_KEY=\"your-aws-secret-access-key\"\n * export BEDROCK_AWS_ACCESS_KEY_ID=\"your-aws-access-key-id\"\n * ```\n *\n * ## [Constructor args](https://api.js.langchain.com/classes/langchain_aws.ChatBedrockConverse.html#constructor)\n *\n * ## [Runtime args](https://api.js.langchain.com/interfaces/langchain_aws.ChatBedrockConverseCallOptions.html)\n *\n * Runtime args can be passed as the second argument to any of the base runnable methods `.invoke`. `.stream`, `.batch`, etc.\n * They can also be passed via `.withConfig`, or the second arg in `.bindTools`, like shown in the examples below:\n *\n * ```typescript\n * // When calling `.withConfig`, call options should be passed via the first argument\n * const llmWithArgsBound = llm.withConfig({\n *   stop: [\"\\n\"],\n *   tools: [...],\n * });\n *\n * // When calling `.bindTools`, call options should be passed via the second argument\n * const llmWithTools = llm.bindTools(\n *   [...],\n *   {\n *     stop: [\"\\n\"],\n *   }\n * );\n * ```\n *\n * ## Examples\n *\n * <details open>\n * <summary><strong>Instantiate</strong></summary>\n *\n * ```typescript\n * import { ChatBedrockConverse } from '@langchain/aws';\n *\n * const llm = new ChatBedrockConverse({\n *   model: \"anthropic.claude-3-5-sonnet-20240620-v1:0\",\n *   temperature: 0,\n *   maxTokens: undefined,\n *   timeout: undefined,\n *   maxRetries: 2,\n *   region: process.env.BEDROCK_AWS_REGION,\n *   credentials: {\n *     secretAccessKey: process.env.BEDROCK_AWS_SECRET_ACCESS_KEY!,\n *     accessKeyId: process.env.BEDROCK_AWS_ACCESS_KEY_ID!,\n *   },\n *   // Configure client options (e.g., custom request handler)\n *   // clientOptions: {\n *   //   requestHandler: myCustomRequestHandler,\n *   // },\n *   // other params...\n * });\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Invoking</strong></summary>\n *\n * ```typescript\n * const input = `Translate \"I love programming\" into French.`;\n *\n * // Models also accept a list of chat messages or a formatted prompt\n * const result = await llm.invoke(input);\n * console.log(result);\n * ```\n *\n * ```txt\n * AIMessage {\n *   \"id\": \"81a27f7a-550c-473d-8307-c2fbb9c74956\",\n *   \"content\": \"Here's the translation to French:\\n\\nJ'adore la programmation.\",\n *   \"response_metadata\": {\n *     \"$metadata\": {\n *       \"httpStatusCode\": 200,\n *       \"requestId\": \"81a27f7a-550c-473d-8307-c2fbb9c74956\",\n *       \"attempts\": 1,\n *       \"totalRetryDelay\": 0\n *     },\n *     \"metrics\": {\n *       \"latencyMs\": 1109\n *     },\n *     \"stopReason\": \"end_turn\",\n *     \"usage\": {\n *       \"inputTokens\": 25,\n *       \"outputTokens\": 19,\n *       \"totalTokens\": 44\n *     }\n *   },\n *   \"usage_metadata\": {\n *     \"input_tokens\": 25,\n *     \"output_tokens\": 19,\n *     \"total_tokens\": 44\n *   }\n * }\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Streaming Chunks</strong></summary>\n *\n * ```typescript\n * for await (const chunk of await llm.stream(input)) {\n *   console.log(chunk);\n * }\n * ```\n *\n * ```txt\n * AIMessageChunk {\n *   \"content\": \"\"\n *   \"response_metadata\": {\n *     \"messageStart\": {\n *       \"p\": \"abcdefghijk\",\n *       \"role\": \"assistant\"\n *     }\n *   }\n * }\n * AIMessageChunk {\n *   \"content\": \"Here\"\n * }\n * AIMessageChunk {\n *   \"content\": \"'s\"\n * }\n * AIMessageChunk {\n *   \"content\": \" the translation\"\n * }\n * AIMessageChunk {\n *   \"content\": \" to\"\n * }\n * AIMessageChunk {\n *   \"content\": \" French:\\n\\nJ\"\n * }\n * AIMessageChunk {\n *   \"content\": \"'adore la\"\n * }\n * AIMessageChunk {\n *   \"content\": \" programmation.\"\n * }\n * AIMessageChunk {\n *   \"content\": \"\"\n *   \"response_metadata\": {\n *     \"contentBlockStop\": {\n *       \"contentBlockIndex\": 0,\n *       \"p\": \"abcdefghijk\"\n *     }\n *   }\n * }\n * AIMessageChunk {\n *   \"content\": \"\"\n *   \"response_metadata\": {\n *     \"messageStop\": {\n *       \"stopReason\": \"end_turn\"\n *     }\n *   }\n * }\n * AIMessageChunk {\n *   \"content\": \"\"\n *   \"response_metadata\": {\n *     \"metadata\": {\n *       \"metrics\": {\n *         \"latencyMs\": 838\n *       },\n *       \"p\": \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123\",\n *       \"usage\": {\n *         \"inputTokens\": 25,\n *         \"outputTokens\": 19,\n *         \"totalTokens\": 44\n *       }\n *     }\n *   }\n *   \"usage_metadata\": {\n *     \"input_tokens\": 25,\n *     \"output_tokens\": 19,\n *     \"total_tokens\": 44\n *   }\n * }\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Aggregate Streamed Chunks</strong></summary>\n *\n * ```typescript\n * import { AIMessageChunk } from '@langchain/core/messages';\n * import { concat } from '@langchain/core/utils/stream';\n *\n * const stream = await llm.stream(input);\n * let full: AIMessageChunk | undefined;\n * for await (const chunk of stream) {\n *   full = !full ? chunk : concat(full, chunk);\n * }\n * console.log(full);\n * ```\n *\n * ```txt\n * AIMessageChunk {\n *   \"content\": \"Here's the translation to French:\\n\\nJ'adore la programmation.\",\n *   \"response_metadata\": {\n *     \"messageStart\": {\n *       \"p\": \"ab\",\n *       \"role\": \"assistant\"\n *     },\n *     \"contentBlockStop\": {\n *       \"contentBlockIndex\": 0,\n *       \"p\": \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJK\"\n *     },\n *     \"messageStop\": {\n *       \"stopReason\": \"end_turn\"\n *     },\n *     \"metadata\": {\n *       \"metrics\": {\n *         \"latencyMs\": 838\n *       },\n *       \"p\": \"abcdefghijklmnopqrstuvwxyz\",\n *       \"usage\": {\n *         \"inputTokens\": 25,\n *         \"outputTokens\": 19,\n *         \"totalTokens\": 44\n *       }\n *     }\n *   },\n *   \"usage_metadata\": {\n *     \"input_tokens\": 25,\n *     \"output_tokens\": 19,\n *     \"total_tokens\": 44\n *   }\n * }\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Bind tools</strong></summary>\n *\n * ```typescript\n * import { z } from 'zod';\n *\n * const GetWeather = {\n *   name: \"GetWeather\",\n *   description: \"Get the current weather in a given location\",\n *   schema: z.object({\n *     location: z.string().describe(\"The city and state, e.g. San Francisco, CA\")\n *   }),\n * }\n *\n * const GetPopulation = {\n *   name: \"GetPopulation\",\n *   description: \"Get the current population in a given location\",\n *   schema: z.object({\n *     location: z.string().describe(\"The city and state, e.g. San Francisco, CA\")\n *   }),\n * }\n *\n * const llmWithTools = llm.bindTools(\n *   [GetWeather, GetPopulation],\n *   {\n *     // strict: true  // enforce tool args schema is respected\n *   }\n * );\n * const aiMsg = await llmWithTools.invoke(\n *   \"Which city is hotter today and which is bigger: LA or NY?\"\n * );\n * console.log(aiMsg.tool_calls);\n * ```\n *\n * ```txt\n * [\n *   {\n *     id: 'tooluse_hIaiqfweRtSiJyi6J4naJA',\n *     name: 'GetWeather',\n *     args: { location: 'Los Angeles, CA' },\n *     type: 'tool_call'\n *   },\n *   {\n *     id: 'tooluse_nOS8B0UlTd2FdpH4MSHw9w',\n *     name: 'GetWeather',\n *     args: { location: 'New York, NY' },\n *     type: 'tool_call'\n *   },\n *   {\n *     id: 'tooluse_XxMpZiETQ5aVS5opVDyIaw',\n *     name: 'GetPopulation',\n *     args: { location: 'Los Angeles, CA' },\n *     type: 'tool_call'\n *   },\n *   {\n *     id: 'tooluse_GpYvAfldT2aR8VQfH-p4PQ',\n *     name: 'GetPopulation',\n *     args: { location: 'New York, NY' },\n *     type: 'tool_call'\n *   }\n * ]\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Structured Output</strong></summary>\n *\n * ```typescript\n * import { z } from 'zod';\n *\n * const Joke = z.object({\n *   setup: z.string().describe(\"The setup of the joke\"),\n *   punchline: z.string().describe(\"The punchline to the joke\"),\n *   rating: z.number().optional().describe(\"How funny the joke is, from 1 to 10\")\n * }).describe('Joke to tell user.');\n *\n * const structuredLlm = llm.withStructuredOutput(Joke, { name: \"Joke\" });\n * const jokeResult = await structuredLlm.invoke(\"Tell me a joke about cats\");\n * console.log(jokeResult);\n * ```\n *\n * ```txt\n * {\n *   setup: \"Why don't cats play poker in the jungle?\",\n *   punchline: 'Too many cheetahs!',\n *   rating: 7\n * }\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Multimodal</strong></summary>\n *\n * ```typescript\n * import { HumanMessage } from '@langchain/core/messages';\n *\n * const imageUrl = \"https://example.com/image.jpg\";\n * const imageData = await fetch(imageUrl).then(res => res.arrayBuffer());\n * const base64Image = Buffer.from(imageData).toString('base64');\n *\n * const message = new HumanMessage({\n *   content: [\n *     { type: \"text\", text: \"describe the weather in this image\" },\n *     {\n *       type: \"image_url\",\n *       image_url: { url: `data:image/jpeg;base64,${base64Image}` },\n *     },\n *   ]\n * });\n *\n * const imageDescriptionAiMsg = await llm.invoke([message]);\n * console.log(imageDescriptionAiMsg.content);\n * ```\n *\n * ```txt\n * The weather in this image appears to be clear and pleasant. The sky is a vibrant blue with scattered white clouds, suggesting a sunny day with good visibility. The clouds are light and wispy, indicating fair weather conditions. There's no sign of rain, storm, or any adverse weather patterns. The lush green grass on the rolling hills looks well-watered and healthy, which could indicate recent rainfall or generally favorable weather conditions. Overall, the image depicts a beautiful, calm day with blue skies and sunshine - perfect weather for enjoying the outdoors.\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Usage Metadata</strong></summary>\n *\n * ```typescript\n * const aiMsgForMetadata = await llm.invoke(input);\n * console.log(aiMsgForMetadata.usage_metadata);\n * ```\n *\n * ```txt\n * { input_tokens: 25, output_tokens: 19, total_tokens: 44 }\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Stream Usage Metadata</strong></summary>\n *\n * ```typescript\n * const streamForMetadata = await llm.stream(input);\n * let fullForMetadata: AIMessageChunk | undefined;\n * for await (const chunk of streamForMetadata) {\n *   fullForMetadata = !fullForMetadata ? chunk : concat(fullForMetadata, chunk);\n * }\n * console.log(fullForMetadata?.usage_metadata);\n * ```\n *\n * ```txt\n * { input_tokens: 25, output_tokens: 19, total_tokens: 44 }\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Response Metadata</strong></summary>\n *\n * ```typescript\n * const aiMsgForResponseMetadata = await llm.invoke(input);\n * console.log(aiMsgForResponseMetadata.response_metadata);\n * ```\n *\n * ```txt\n * {\n *   '$metadata': {\n *     httpStatusCode: 200,\n *     requestId: '5de2a2e5-d1dc-4dff-bb02-31361f4107bc',\n *     extendedRequestId: undefined,\n *     cfId: undefined,\n *     attempts: 1,\n *     totalRetryDelay: 0\n *   },\n *   metrics: { latencyMs: 1163 },\n *   stopReason: 'end_turn',\n *   usage: { inputTokens: 25, outputTokens: 19, totalTokens: 44 }\n * }\n * ```\n * </details>\n *\n * <br />\n */\nclass ChatBedrockConverse extends chat_models_1.BaseChatModel {\n    // Used for tracing, replace with the same name as your class\n    static lc_name() {\n        return \"ChatBedrockConverse\";\n    }\n    /**\n     * Replace with any secrets this class passes to `super`.\n     * See {@link ../../langchain-cohere/src/chat_model.ts} for\n     * an example.\n     */\n    get lc_secrets() {\n        return {\n            apiKey: \"API_KEY_NAME\",\n        };\n    }\n    get lc_aliases() {\n        return {\n            apiKey: \"API_KEY_NAME\",\n        };\n    }\n    constructor(fields) {\n        super(fields ?? {});\n        Object.defineProperty(this, \"model\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"anthropic.claude-3-haiku-20240307-v1:0\"\n        });\n        Object.defineProperty(this, \"streaming\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"region\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"temperature\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: undefined\n        });\n        Object.defineProperty(this, \"maxTokens\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: undefined\n        });\n        Object.defineProperty(this, \"endpointHost\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"topP\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"additionalModelRequestFields\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"streamUsage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"guardrailConfig\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"performanceConfig\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"clientOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Which types of `tool_choice` values the model supports.\n         *\n         * Inferred if not specified. Inferred as ['auto', 'any', 'tool'] if a 'claude-3'\n         * model is used, ['auto', 'any'] if a 'mistral-large' model is used, empty otherwise.\n         */\n        Object.defineProperty(this, \"supportsToolChoiceValues\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const { profile, filepath, configFilepath, ignoreCache, mfaCodeProvider, roleAssumer, roleArn, webIdentityTokenFile, roleAssumerWithWebIdentity, ...rest } = fields ?? {};\n        const credentials = rest?.credentials ??\n            (0, credential_provider_node_1.defaultProvider)({\n                profile,\n                filepath,\n                configFilepath,\n                ignoreCache,\n                mfaCodeProvider,\n                roleAssumer,\n                roleArn,\n                webIdentityTokenFile,\n                roleAssumerWithWebIdentity,\n            });\n        const region = rest?.region ?? (0, env_1.getEnvironmentVariable)(\"AWS_DEFAULT_REGION\");\n        if (!region) {\n            throw new Error(\"Please set the AWS_DEFAULT_REGION environment variable or pass it to the constructor as the region field.\");\n        }\n        this.client =\n            fields?.client ??\n                new client_bedrock_runtime_1.BedrockRuntimeClient({\n                    ...fields?.clientOptions,\n                    region,\n                    credentials,\n                    endpoint: rest.endpointHost\n                        ? `https://${rest.endpointHost}`\n                        : undefined,\n                });\n        this.region = region;\n        this.model = rest?.model ?? this.model;\n        this.streaming = rest?.streaming ?? this.streaming;\n        this.temperature = rest?.temperature;\n        this.maxTokens = rest?.maxTokens;\n        this.endpointHost = rest?.endpointHost;\n        this.topP = rest?.topP;\n        this.additionalModelRequestFields = rest?.additionalModelRequestFields;\n        this.streamUsage = rest?.streamUsage ?? this.streamUsage;\n        this.guardrailConfig = rest?.guardrailConfig;\n        this.performanceConfig = rest?.performanceConfig;\n        this.clientOptions = rest?.clientOptions;\n        if (rest?.supportsToolChoiceValues === undefined) {\n            this.supportsToolChoiceValues = (0, common_js_1.supportedToolChoiceValuesForModel)(this.model);\n        }\n        else {\n            this.supportsToolChoiceValues = rest.supportsToolChoiceValues;\n        }\n    }\n    getLsParams(options) {\n        const params = this.invocationParams(options);\n        return {\n            ls_provider: \"amazon_bedrock\",\n            ls_model_name: this.model,\n            ls_model_type: \"chat\",\n            ls_temperature: params.inferenceConfig?.temperature ?? this.temperature,\n            ls_max_tokens: params.inferenceConfig?.maxTokens ?? undefined,\n            ls_stop: options.stop,\n        };\n    }\n    bindTools(tools, kwargs) {\n        return this.withConfig({\n            tools: (0, common_js_1.convertToConverseTools)(tools),\n            ...kwargs,\n        });\n    }\n    // Replace\n    _llmType() {\n        return \"chat_bedrock_converse\";\n    }\n    invocationParams(options) {\n        let toolConfig;\n        if (options?.tools && options.tools.length) {\n            const tools = (0, common_js_1.convertToConverseTools)(options.tools);\n            toolConfig = {\n                tools,\n                toolChoice: options.tool_choice\n                    ? (0, common_js_1.convertToBedrockToolChoice)(options.tool_choice, tools, {\n                        model: this.model,\n                        supportsToolChoiceValues: this.supportsToolChoiceValues,\n                    })\n                    : undefined,\n            };\n        }\n        return {\n            inferenceConfig: {\n                maxTokens: this.maxTokens,\n                temperature: this.temperature,\n                topP: this.topP,\n                stopSequences: options?.stop,\n            },\n            toolConfig,\n            additionalModelRequestFields: this.additionalModelRequestFields ??\n                options?.additionalModelRequestFields,\n            guardrailConfig: this.guardrailConfig ?? options?.guardrailConfig,\n            performanceConfig: options?.performanceConfig,\n        };\n    }\n    async _generate(messages, options, runManager) {\n        if (this.streaming) {\n            const stream = this._streamResponseChunks(messages, options, runManager);\n            let finalResult;\n            for await (const chunk of stream) {\n                if (finalResult === undefined) {\n                    finalResult = chunk;\n                }\n                else {\n                    finalResult = finalResult.concat(chunk);\n                }\n            }\n            if (finalResult === undefined) {\n                throw new Error(\"Could not parse final output from Bedrock streaming call.\");\n            }\n            return {\n                generations: [finalResult],\n                llmOutput: finalResult.generationInfo,\n            };\n        }\n        return this._generateNonStreaming(messages, options, runManager);\n    }\n    async _generateNonStreaming(messages, options, _runManager) {\n        const { converseMessages, converseSystem } = (0, common_js_1.convertToConverseMessages)(messages);\n        const params = this.invocationParams(options);\n        const command = new client_bedrock_runtime_1.ConverseCommand({\n            modelId: this.model,\n            messages: converseMessages,\n            system: converseSystem,\n            requestMetadata: options.requestMetadata,\n            ...params,\n        });\n        const response = await this.client.send(command, {\n            abortSignal: options.signal,\n        });\n        const { output, ...responseMetadata } = response;\n        if (!output?.message) {\n            throw new Error(\"No message found in Bedrock response.\");\n        }\n        const message = (0, common_js_1.convertConverseMessageToLangChainMessage)(output.message, responseMetadata);\n        return {\n            generations: [\n                {\n                    text: typeof message.content === \"string\" ? message.content : \"\",\n                    message,\n                },\n            ],\n        };\n    }\n    async *_streamResponseChunks(messages, options, runManager) {\n        const { converseMessages, converseSystem } = (0, common_js_1.convertToConverseMessages)(messages);\n        const params = this.invocationParams(options);\n        let { streamUsage } = this;\n        if (options.streamUsage !== undefined) {\n            streamUsage = options.streamUsage;\n        }\n        const command = new client_bedrock_runtime_1.ConverseStreamCommand({\n            modelId: this.model,\n            messages: converseMessages,\n            system: converseSystem,\n            requestMetadata: options.requestMetadata,\n            ...params,\n        });\n        const response = await this.client.send(command, {\n            abortSignal: options.signal,\n        });\n        if (response.stream) {\n            for await (const chunk of response.stream) {\n                if (chunk.contentBlockStart) {\n                    yield (0, common_js_1.handleConverseStreamContentBlockStart)(chunk.contentBlockStart);\n                }\n                else if (chunk.contentBlockDelta) {\n                    const textChatGeneration = (0, common_js_1.handleConverseStreamContentBlockDelta)(chunk.contentBlockDelta);\n                    yield textChatGeneration;\n                    await runManager?.handleLLMNewToken(textChatGeneration.text, undefined, undefined, undefined, undefined, {\n                        chunk: textChatGeneration,\n                    });\n                }\n                else if (chunk.metadata) {\n                    yield (0, common_js_1.handleConverseStreamMetadata)(chunk.metadata, {\n                        streamUsage,\n                    });\n                }\n                else {\n                    yield new outputs_1.ChatGenerationChunk({\n                        text: \"\",\n                        message: new messages_1.AIMessageChunk({\n                            content: \"\",\n                            response_metadata: chunk,\n                        }),\n                    });\n                }\n            }\n        }\n    }\n    withStructuredOutput(outputSchema, config) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const schema = outputSchema;\n        const name = config?.name;\n        const description = (0, types_1.getSchemaDescription)(schema) ?? \"A function available to call.\";\n        const method = config?.method;\n        const includeRaw = config?.includeRaw;\n        if (method === \"jsonMode\") {\n            throw new Error(`ChatBedrockConverse does not support 'jsonMode'.`);\n        }\n        let functionName = name ?? \"extract\";\n        let tools;\n        if ((0, types_1.isInteropZodSchema)(schema)) {\n            tools = [\n                {\n                    type: \"function\",\n                    function: {\n                        name: functionName,\n                        description,\n                        parameters: (0, json_schema_1.toJsonSchema)(schema),\n                    },\n                },\n            ];\n        }\n        else {\n            if (\"name\" in schema) {\n                functionName = schema.name;\n            }\n            tools = [\n                {\n                    type: \"function\",\n                    function: {\n                        name: functionName,\n                        description,\n                        parameters: schema,\n                    },\n                },\n            ];\n        }\n        const supportsToolChoiceValues = this.supportsToolChoiceValues ?? [];\n        let toolChoiceObj;\n        if (supportsToolChoiceValues.includes(\"tool\")) {\n            toolChoiceObj = {\n                tool_choice: tools[0].function.name,\n            };\n        }\n        else if (supportsToolChoiceValues.includes(\"any\")) {\n            toolChoiceObj = {\n                tool_choice: \"any\",\n            };\n        }\n        const llm = this.bindTools(tools, toolChoiceObj);\n        const outputParser = runnables_1.RunnableLambda.from((input) => {\n            if (!input.tool_calls || input.tool_calls.length === 0) {\n                throw new Error(\"No tool calls found in the response.\");\n            }\n            const toolCall = input.tool_calls.find((tc) => tc.name === functionName);\n            if (!toolCall) {\n                throw new Error(`No tool call found with name ${functionName}.`);\n            }\n            return toolCall.args;\n        });\n        if (!includeRaw) {\n            return llm.pipe(outputParser).withConfig({\n                runName: \"StructuredOutput\",\n            });\n        }\n        const parserAssign = runnables_1.RunnablePassthrough.assign({\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            parsed: (input, config) => outputParser.invoke(input.raw, config),\n        });\n        const parserNone = runnables_1.RunnablePassthrough.assign({\n            parsed: () => null,\n        });\n        const parsedWithFallback = parserAssign.withFallbacks({\n            fallbacks: [parserNone],\n        });\n        return runnables_1.RunnableSequence.from([\n            {\n                raw: llm,\n            },\n            parsedWithFallback,\n        ]).withConfig({\n            runName: \"StructuredOutputRunnable\",\n        });\n    }\n}\nexports.ChatBedrockConverse = ChatBedrockConverse;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9hd3MvZGlzdC9jaGF0X21vZGVscy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCO0FBQzNCLG1CQUFtQixtQkFBTyxDQUFDLG1GQUEwQjtBQUNyRCxzQkFBc0IsbUJBQU8sQ0FBQyx5SEFBNkM7QUFDM0UsaUNBQWlDLG1CQUFPLENBQUMsOEdBQWlDO0FBQzFFLGtCQUFrQixtQkFBTyxDQUFDLGlGQUF5QjtBQUNuRCxjQUFjLG1CQUFPLENBQUMscUZBQTJCO0FBQ2pELG1DQUFtQyxtQkFBTyxDQUFDLGtIQUFtQztBQUM5RSxvQkFBb0IsbUJBQU8sQ0FBQyxxRkFBMkI7QUFDdkQsZ0JBQWdCLG1CQUFPLENBQUMseUZBQTZCO0FBQ3JELHNCQUFzQixtQkFBTyxDQUFDLHFHQUFtQztBQUNqRSxvQkFBb0IsbUJBQU8sQ0FBQyx5RUFBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0IsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQUk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2QkFBNkI7QUFDNUM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsZUFBZSw2QkFBNkI7QUFDNUM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFJO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSwwREFBMEQsY0FBYztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMERBQTBEO0FBQ25FO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCLFNBQVMsWUFBWSxHQUFHO0FBQ3BFLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFnRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0JBQWdCLG1KQUFtSjtBQUNuSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1DQUFtQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1DQUFtQztBQUNuRDtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGFBQWE7QUFDN0U7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJCQUEyQiIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vYXdzL2Rpc3QvY2hhdF9tb2RlbHMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaGF0QmVkcm9ja0NvbnZlcnNlID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvbWVzc2FnZXNcIik7XG5jb25zdCBjaGF0X21vZGVsc18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9sYW5ndWFnZV9tb2RlbHMvY2hhdF9tb2RlbHNcIik7XG5jb25zdCBjbGllbnRfYmVkcm9ja19ydW50aW1lXzEgPSByZXF1aXJlKFwiQGF3cy1zZGsvY2xpZW50LWJlZHJvY2stcnVudGltZVwiKTtcbmNvbnN0IG91dHB1dHNfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvb3V0cHV0c1wiKTtcbmNvbnN0IGVudl8xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS91dGlscy9lbnZcIik7XG5jb25zdCBjcmVkZW50aWFsX3Byb3ZpZGVyX25vZGVfMSA9IHJlcXVpcmUoXCJAYXdzLXNkay9jcmVkZW50aWFsLXByb3ZpZGVyLW5vZGVcIik7XG5jb25zdCBydW5uYWJsZXNfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvdXRpbHMvdHlwZXNcIik7XG5jb25zdCBqc29uX3NjaGVtYV8xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS91dGlscy9qc29uX3NjaGVtYVwiKTtcbmNvbnN0IGNvbW1vbl9qc18xID0gcmVxdWlyZShcIi4vY29tbW9uLmNqc1wiKTtcbi8qKlxuICogQVdTIEJlZHJvY2sgQ29udmVyc2UgY2hhdCBtb2RlbCBpbnRlZ3JhdGlvbi5cbiAqXG4gKiBTZXR1cDpcbiAqIEluc3RhbGwgYEBsYW5nY2hhaW4vYXdzYCBhbmQgc2V0IHRoZSBmb2xsb3dpbmcgZW52aXJvbm1lbnQgdmFyaWFibGVzOlxuICpcbiAqIGBgYGJhc2hcbiAqIG5wbSBpbnN0YWxsIEBsYW5nY2hhaW4vYXdzXG4gKiBleHBvcnQgQkVEUk9DS19BV1NfUkVHSU9OPVwieW91ci1hd3MtcmVnaW9uXCJcbiAqIGV4cG9ydCBCRURST0NLX0FXU19TRUNSRVRfQUNDRVNTX0tFWT1cInlvdXItYXdzLXNlY3JldC1hY2Nlc3Mta2V5XCJcbiAqIGV4cG9ydCBCRURST0NLX0FXU19BQ0NFU1NfS0VZX0lEPVwieW91ci1hd3MtYWNjZXNzLWtleS1pZFwiXG4gKiBgYGBcbiAqXG4gKiAjIyBbQ29uc3RydWN0b3IgYXJnc10oaHR0cHM6Ly9hcGkuanMubGFuZ2NoYWluLmNvbS9jbGFzc2VzL2xhbmdjaGFpbl9hd3MuQ2hhdEJlZHJvY2tDb252ZXJzZS5odG1sI2NvbnN0cnVjdG9yKVxuICpcbiAqICMjIFtSdW50aW1lIGFyZ3NdKGh0dHBzOi8vYXBpLmpzLmxhbmdjaGFpbi5jb20vaW50ZXJmYWNlcy9sYW5nY2hhaW5fYXdzLkNoYXRCZWRyb2NrQ29udmVyc2VDYWxsT3B0aW9ucy5odG1sKVxuICpcbiAqIFJ1bnRpbWUgYXJncyBjYW4gYmUgcGFzc2VkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYW55IG9mIHRoZSBiYXNlIHJ1bm5hYmxlIG1ldGhvZHMgYC5pbnZva2VgLiBgLnN0cmVhbWAsIGAuYmF0Y2hgLCBldGMuXG4gKiBUaGV5IGNhbiBhbHNvIGJlIHBhc3NlZCB2aWEgYC53aXRoQ29uZmlnYCwgb3IgdGhlIHNlY29uZCBhcmcgaW4gYC5iaW5kVG9vbHNgLCBsaWtlIHNob3duIGluIHRoZSBleGFtcGxlcyBiZWxvdzpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAvLyBXaGVuIGNhbGxpbmcgYC53aXRoQ29uZmlnYCwgY2FsbCBvcHRpb25zIHNob3VsZCBiZSBwYXNzZWQgdmlhIHRoZSBmaXJzdCBhcmd1bWVudFxuICogY29uc3QgbGxtV2l0aEFyZ3NCb3VuZCA9IGxsbS53aXRoQ29uZmlnKHtcbiAqICAgc3RvcDogW1wiXFxuXCJdLFxuICogICB0b29sczogWy4uLl0sXG4gKiB9KTtcbiAqXG4gKiAvLyBXaGVuIGNhbGxpbmcgYC5iaW5kVG9vbHNgLCBjYWxsIG9wdGlvbnMgc2hvdWxkIGJlIHBhc3NlZCB2aWEgdGhlIHNlY29uZCBhcmd1bWVudFxuICogY29uc3QgbGxtV2l0aFRvb2xzID0gbGxtLmJpbmRUb29scyhcbiAqICAgWy4uLl0sXG4gKiAgIHtcbiAqICAgICBzdG9wOiBbXCJcXG5cIl0sXG4gKiAgIH1cbiAqICk7XG4gKiBgYGBcbiAqXG4gKiAjIyBFeGFtcGxlc1xuICpcbiAqIDxkZXRhaWxzIG9wZW4+XG4gKiA8c3VtbWFyeT48c3Ryb25nPkluc3RhbnRpYXRlPC9zdHJvbmc+PC9zdW1tYXJ5PlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IENoYXRCZWRyb2NrQ29udmVyc2UgfSBmcm9tICdAbGFuZ2NoYWluL2F3cyc7XG4gKlxuICogY29uc3QgbGxtID0gbmV3IENoYXRCZWRyb2NrQ29udmVyc2Uoe1xuICogICBtb2RlbDogXCJhbnRocm9waWMuY2xhdWRlLTMtNS1zb25uZXQtMjAyNDA2MjAtdjE6MFwiLFxuICogICB0ZW1wZXJhdHVyZTogMCxcbiAqICAgbWF4VG9rZW5zOiB1bmRlZmluZWQsXG4gKiAgIHRpbWVvdXQ6IHVuZGVmaW5lZCxcbiAqICAgbWF4UmV0cmllczogMixcbiAqICAgcmVnaW9uOiBwcm9jZXNzLmVudi5CRURST0NLX0FXU19SRUdJT04sXG4gKiAgIGNyZWRlbnRpYWxzOiB7XG4gKiAgICAgc2VjcmV0QWNjZXNzS2V5OiBwcm9jZXNzLmVudi5CRURST0NLX0FXU19TRUNSRVRfQUNDRVNTX0tFWSEsXG4gKiAgICAgYWNjZXNzS2V5SWQ6IHByb2Nlc3MuZW52LkJFRFJPQ0tfQVdTX0FDQ0VTU19LRVlfSUQhLFxuICogICB9LFxuICogICAvLyBDb25maWd1cmUgY2xpZW50IG9wdGlvbnMgKGUuZy4sIGN1c3RvbSByZXF1ZXN0IGhhbmRsZXIpXG4gKiAgIC8vIGNsaWVudE9wdGlvbnM6IHtcbiAqICAgLy8gICByZXF1ZXN0SGFuZGxlcjogbXlDdXN0b21SZXF1ZXN0SGFuZGxlcixcbiAqICAgLy8gfSxcbiAqICAgLy8gb3RoZXIgcGFyYW1zLi4uXG4gKiB9KTtcbiAqIGBgYFxuICogPC9kZXRhaWxzPlxuICpcbiAqIDxiciAvPlxuICpcbiAqIDxkZXRhaWxzPlxuICogPHN1bW1hcnk+PHN0cm9uZz5JbnZva2luZzwvc3Ryb25nPjwvc3VtbWFyeT5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBpbnB1dCA9IGBUcmFuc2xhdGUgXCJJIGxvdmUgcHJvZ3JhbW1pbmdcIiBpbnRvIEZyZW5jaC5gO1xuICpcbiAqIC8vIE1vZGVscyBhbHNvIGFjY2VwdCBhIGxpc3Qgb2YgY2hhdCBtZXNzYWdlcyBvciBhIGZvcm1hdHRlZCBwcm9tcHRcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxsbS5pbnZva2UoaW5wdXQpO1xuICogY29uc29sZS5sb2cocmVzdWx0KTtcbiAqIGBgYFxuICpcbiAqIGBgYHR4dFxuICogQUlNZXNzYWdlIHtcbiAqICAgXCJpZFwiOiBcIjgxYTI3ZjdhLTU1MGMtNDczZC04MzA3LWMyZmJiOWM3NDk1NlwiLFxuICogICBcImNvbnRlbnRcIjogXCJIZXJlJ3MgdGhlIHRyYW5zbGF0aW9uIHRvIEZyZW5jaDpcXG5cXG5KJ2Fkb3JlIGxhIHByb2dyYW1tYXRpb24uXCIsXG4gKiAgIFwicmVzcG9uc2VfbWV0YWRhdGFcIjoge1xuICogICAgIFwiJG1ldGFkYXRhXCI6IHtcbiAqICAgICAgIFwiaHR0cFN0YXR1c0NvZGVcIjogMjAwLFxuICogICAgICAgXCJyZXF1ZXN0SWRcIjogXCI4MWEyN2Y3YS01NTBjLTQ3M2QtODMwNy1jMmZiYjljNzQ5NTZcIixcbiAqICAgICAgIFwiYXR0ZW1wdHNcIjogMSxcbiAqICAgICAgIFwidG90YWxSZXRyeURlbGF5XCI6IDBcbiAqICAgICB9LFxuICogICAgIFwibWV0cmljc1wiOiB7XG4gKiAgICAgICBcImxhdGVuY3lNc1wiOiAxMTA5XG4gKiAgICAgfSxcbiAqICAgICBcInN0b3BSZWFzb25cIjogXCJlbmRfdHVyblwiLFxuICogICAgIFwidXNhZ2VcIjoge1xuICogICAgICAgXCJpbnB1dFRva2Vuc1wiOiAyNSxcbiAqICAgICAgIFwib3V0cHV0VG9rZW5zXCI6IDE5LFxuICogICAgICAgXCJ0b3RhbFRva2Vuc1wiOiA0NFxuICogICAgIH1cbiAqICAgfSxcbiAqICAgXCJ1c2FnZV9tZXRhZGF0YVwiOiB7XG4gKiAgICAgXCJpbnB1dF90b2tlbnNcIjogMjUsXG4gKiAgICAgXCJvdXRwdXRfdG9rZW5zXCI6IDE5LFxuICogICAgIFwidG90YWxfdG9rZW5zXCI6IDQ0XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICogPC9kZXRhaWxzPlxuICpcbiAqIDxiciAvPlxuICpcbiAqIDxkZXRhaWxzPlxuICogPHN1bW1hcnk+PHN0cm9uZz5TdHJlYW1pbmcgQ2h1bmtzPC9zdHJvbmc+PC9zdW1tYXJ5PlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgYXdhaXQgbGxtLnN0cmVhbShpbnB1dCkpIHtcbiAqICAgY29uc29sZS5sb2coY2h1bmspO1xuICogfVxuICogYGBgXG4gKlxuICogYGBgdHh0XG4gKiBBSU1lc3NhZ2VDaHVuayB7XG4gKiAgIFwiY29udGVudFwiOiBcIlwiXG4gKiAgIFwicmVzcG9uc2VfbWV0YWRhdGFcIjoge1xuICogICAgIFwibWVzc2FnZVN0YXJ0XCI6IHtcbiAqICAgICAgIFwicFwiOiBcImFiY2RlZmdoaWprXCIsXG4gKiAgICAgICBcInJvbGVcIjogXCJhc3Npc3RhbnRcIlxuICogICAgIH1cbiAqICAgfVxuICogfVxuICogQUlNZXNzYWdlQ2h1bmsge1xuICogICBcImNvbnRlbnRcIjogXCJIZXJlXCJcbiAqIH1cbiAqIEFJTWVzc2FnZUNodW5rIHtcbiAqICAgXCJjb250ZW50XCI6IFwiJ3NcIlxuICogfVxuICogQUlNZXNzYWdlQ2h1bmsge1xuICogICBcImNvbnRlbnRcIjogXCIgdGhlIHRyYW5zbGF0aW9uXCJcbiAqIH1cbiAqIEFJTWVzc2FnZUNodW5rIHtcbiAqICAgXCJjb250ZW50XCI6IFwiIHRvXCJcbiAqIH1cbiAqIEFJTWVzc2FnZUNodW5rIHtcbiAqICAgXCJjb250ZW50XCI6IFwiIEZyZW5jaDpcXG5cXG5KXCJcbiAqIH1cbiAqIEFJTWVzc2FnZUNodW5rIHtcbiAqICAgXCJjb250ZW50XCI6IFwiJ2Fkb3JlIGxhXCJcbiAqIH1cbiAqIEFJTWVzc2FnZUNodW5rIHtcbiAqICAgXCJjb250ZW50XCI6IFwiIHByb2dyYW1tYXRpb24uXCJcbiAqIH1cbiAqIEFJTWVzc2FnZUNodW5rIHtcbiAqICAgXCJjb250ZW50XCI6IFwiXCJcbiAqICAgXCJyZXNwb25zZV9tZXRhZGF0YVwiOiB7XG4gKiAgICAgXCJjb250ZW50QmxvY2tTdG9wXCI6IHtcbiAqICAgICAgIFwiY29udGVudEJsb2NrSW5kZXhcIjogMCxcbiAqICAgICAgIFwicFwiOiBcImFiY2RlZmdoaWprXCJcbiAqICAgICB9XG4gKiAgIH1cbiAqIH1cbiAqIEFJTWVzc2FnZUNodW5rIHtcbiAqICAgXCJjb250ZW50XCI6IFwiXCJcbiAqICAgXCJyZXNwb25zZV9tZXRhZGF0YVwiOiB7XG4gKiAgICAgXCJtZXNzYWdlU3RvcFwiOiB7XG4gKiAgICAgICBcInN0b3BSZWFzb25cIjogXCJlbmRfdHVyblwiXG4gKiAgICAgfVxuICogICB9XG4gKiB9XG4gKiBBSU1lc3NhZ2VDaHVuayB7XG4gKiAgIFwiY29udGVudFwiOiBcIlwiXG4gKiAgIFwicmVzcG9uc2VfbWV0YWRhdGFcIjoge1xuICogICAgIFwibWV0YWRhdGFcIjoge1xuICogICAgICAgXCJtZXRyaWNzXCI6IHtcbiAqICAgICAgICAgXCJsYXRlbmN5TXNcIjogODM4XG4gKiAgICAgICB9LFxuICogICAgICAgXCJwXCI6IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjAxMjNcIixcbiAqICAgICAgIFwidXNhZ2VcIjoge1xuICogICAgICAgICBcImlucHV0VG9rZW5zXCI6IDI1LFxuICogICAgICAgICBcIm91dHB1dFRva2Vuc1wiOiAxOSxcbiAqICAgICAgICAgXCJ0b3RhbFRva2Vuc1wiOiA0NFxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgfVxuICogICBcInVzYWdlX21ldGFkYXRhXCI6IHtcbiAqICAgICBcImlucHV0X3Rva2Vuc1wiOiAyNSxcbiAqICAgICBcIm91dHB1dF90b2tlbnNcIjogMTksXG4gKiAgICAgXCJ0b3RhbF90b2tlbnNcIjogNDRcbiAqICAgfVxuICogfVxuICogYGBgXG4gKiA8L2RldGFpbHM+XG4gKlxuICogPGJyIC8+XG4gKlxuICogPGRldGFpbHM+XG4gKiA8c3VtbWFyeT48c3Ryb25nPkFnZ3JlZ2F0ZSBTdHJlYW1lZCBDaHVua3M8L3N0cm9uZz48L3N1bW1hcnk+XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgQUlNZXNzYWdlQ2h1bmsgfSBmcm9tICdAbGFuZ2NoYWluL2NvcmUvbWVzc2FnZXMnO1xuICogaW1wb3J0IHsgY29uY2F0IH0gZnJvbSAnQGxhbmdjaGFpbi9jb3JlL3V0aWxzL3N0cmVhbSc7XG4gKlxuICogY29uc3Qgc3RyZWFtID0gYXdhaXQgbGxtLnN0cmVhbShpbnB1dCk7XG4gKiBsZXQgZnVsbDogQUlNZXNzYWdlQ2h1bmsgfCB1bmRlZmluZWQ7XG4gKiBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICogICBmdWxsID0gIWZ1bGwgPyBjaHVuayA6IGNvbmNhdChmdWxsLCBjaHVuayk7XG4gKiB9XG4gKiBjb25zb2xlLmxvZyhmdWxsKTtcbiAqIGBgYFxuICpcbiAqIGBgYHR4dFxuICogQUlNZXNzYWdlQ2h1bmsge1xuICogICBcImNvbnRlbnRcIjogXCJIZXJlJ3MgdGhlIHRyYW5zbGF0aW9uIHRvIEZyZW5jaDpcXG5cXG5KJ2Fkb3JlIGxhIHByb2dyYW1tYXRpb24uXCIsXG4gKiAgIFwicmVzcG9uc2VfbWV0YWRhdGFcIjoge1xuICogICAgIFwibWVzc2FnZVN0YXJ0XCI6IHtcbiAqICAgICAgIFwicFwiOiBcImFiXCIsXG4gKiAgICAgICBcInJvbGVcIjogXCJhc3Npc3RhbnRcIlxuICogICAgIH0sXG4gKiAgICAgXCJjb250ZW50QmxvY2tTdG9wXCI6IHtcbiAqICAgICAgIFwiY29udGVudEJsb2NrSW5kZXhcIjogMCxcbiAqICAgICAgIFwicFwiOiBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktcIlxuICogICAgIH0sXG4gKiAgICAgXCJtZXNzYWdlU3RvcFwiOiB7XG4gKiAgICAgICBcInN0b3BSZWFzb25cIjogXCJlbmRfdHVyblwiXG4gKiAgICAgfSxcbiAqICAgICBcIm1ldGFkYXRhXCI6IHtcbiAqICAgICAgIFwibWV0cmljc1wiOiB7XG4gKiAgICAgICAgIFwibGF0ZW5jeU1zXCI6IDgzOFxuICogICAgICAgfSxcbiAqICAgICAgIFwicFwiOiBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIsXG4gKiAgICAgICBcInVzYWdlXCI6IHtcbiAqICAgICAgICAgXCJpbnB1dFRva2Vuc1wiOiAyNSxcbiAqICAgICAgICAgXCJvdXRwdXRUb2tlbnNcIjogMTksXG4gKiAgICAgICAgIFwidG90YWxUb2tlbnNcIjogNDRcbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIH0sXG4gKiAgIFwidXNhZ2VfbWV0YWRhdGFcIjoge1xuICogICAgIFwiaW5wdXRfdG9rZW5zXCI6IDI1LFxuICogICAgIFwib3V0cHV0X3Rva2Vuc1wiOiAxOSxcbiAqICAgICBcInRvdGFsX3Rva2Vuc1wiOiA0NFxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqIDwvZGV0YWlscz5cbiAqXG4gKiA8YnIgLz5cbiAqXG4gKiA8ZGV0YWlscz5cbiAqIDxzdW1tYXJ5PjxzdHJvbmc+QmluZCB0b29sczwvc3Ryb25nPjwvc3VtbWFyeT5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyB6IH0gZnJvbSAnem9kJztcbiAqXG4gKiBjb25zdCBHZXRXZWF0aGVyID0ge1xuICogICBuYW1lOiBcIkdldFdlYXRoZXJcIixcbiAqICAgZGVzY3JpcHRpb246IFwiR2V0IHRoZSBjdXJyZW50IHdlYXRoZXIgaW4gYSBnaXZlbiBsb2NhdGlvblwiLFxuICogICBzY2hlbWE6IHoub2JqZWN0KHtcbiAqICAgICBsb2NhdGlvbjogei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBjaXR5IGFuZCBzdGF0ZSwgZS5nLiBTYW4gRnJhbmNpc2NvLCBDQVwiKVxuICogICB9KSxcbiAqIH1cbiAqXG4gKiBjb25zdCBHZXRQb3B1bGF0aW9uID0ge1xuICogICBuYW1lOiBcIkdldFBvcHVsYXRpb25cIixcbiAqICAgZGVzY3JpcHRpb246IFwiR2V0IHRoZSBjdXJyZW50IHBvcHVsYXRpb24gaW4gYSBnaXZlbiBsb2NhdGlvblwiLFxuICogICBzY2hlbWE6IHoub2JqZWN0KHtcbiAqICAgICBsb2NhdGlvbjogei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBjaXR5IGFuZCBzdGF0ZSwgZS5nLiBTYW4gRnJhbmNpc2NvLCBDQVwiKVxuICogICB9KSxcbiAqIH1cbiAqXG4gKiBjb25zdCBsbG1XaXRoVG9vbHMgPSBsbG0uYmluZFRvb2xzKFxuICogICBbR2V0V2VhdGhlciwgR2V0UG9wdWxhdGlvbl0sXG4gKiAgIHtcbiAqICAgICAvLyBzdHJpY3Q6IHRydWUgIC8vIGVuZm9yY2UgdG9vbCBhcmdzIHNjaGVtYSBpcyByZXNwZWN0ZWRcbiAqICAgfVxuICogKTtcbiAqIGNvbnN0IGFpTXNnID0gYXdhaXQgbGxtV2l0aFRvb2xzLmludm9rZShcbiAqICAgXCJXaGljaCBjaXR5IGlzIGhvdHRlciB0b2RheSBhbmQgd2hpY2ggaXMgYmlnZ2VyOiBMQSBvciBOWT9cIlxuICogKTtcbiAqIGNvbnNvbGUubG9nKGFpTXNnLnRvb2xfY2FsbHMpO1xuICogYGBgXG4gKlxuICogYGBgdHh0XG4gKiBbXG4gKiAgIHtcbiAqICAgICBpZDogJ3Rvb2x1c2VfaElhaXFmd2VSdFNpSnlpNko0bmFKQScsXG4gKiAgICAgbmFtZTogJ0dldFdlYXRoZXInLFxuICogICAgIGFyZ3M6IHsgbG9jYXRpb246ICdMb3MgQW5nZWxlcywgQ0EnIH0sXG4gKiAgICAgdHlwZTogJ3Rvb2xfY2FsbCdcbiAqICAgfSxcbiAqICAge1xuICogICAgIGlkOiAndG9vbHVzZV9uT1M4QjBVbFRkMkZkcEg0TVNIdzl3JyxcbiAqICAgICBuYW1lOiAnR2V0V2VhdGhlcicsXG4gKiAgICAgYXJnczogeyBsb2NhdGlvbjogJ05ldyBZb3JrLCBOWScgfSxcbiAqICAgICB0eXBlOiAndG9vbF9jYWxsJ1xuICogICB9LFxuICogICB7XG4gKiAgICAgaWQ6ICd0b29sdXNlX1h4TXBaaUVUUTVhVlM1b3BWRHlJYXcnLFxuICogICAgIG5hbWU6ICdHZXRQb3B1bGF0aW9uJyxcbiAqICAgICBhcmdzOiB7IGxvY2F0aW9uOiAnTG9zIEFuZ2VsZXMsIENBJyB9LFxuICogICAgIHR5cGU6ICd0b29sX2NhbGwnXG4gKiAgIH0sXG4gKiAgIHtcbiAqICAgICBpZDogJ3Rvb2x1c2VfR3BZdkFmbGRUMmFSOFZRZkgtcDRQUScsXG4gKiAgICAgbmFtZTogJ0dldFBvcHVsYXRpb24nLFxuICogICAgIGFyZ3M6IHsgbG9jYXRpb246ICdOZXcgWW9yaywgTlknIH0sXG4gKiAgICAgdHlwZTogJ3Rvb2xfY2FsbCdcbiAqICAgfVxuICogXVxuICogYGBgXG4gKiA8L2RldGFpbHM+XG4gKlxuICogPGJyIC8+XG4gKlxuICogPGRldGFpbHM+XG4gKiA8c3VtbWFyeT48c3Ryb25nPlN0cnVjdHVyZWQgT3V0cHV0PC9zdHJvbmc+PC9zdW1tYXJ5PlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IHogfSBmcm9tICd6b2QnO1xuICpcbiAqIGNvbnN0IEpva2UgPSB6Lm9iamVjdCh7XG4gKiAgIHNldHVwOiB6LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIHNldHVwIG9mIHRoZSBqb2tlXCIpLFxuICogICBwdW5jaGxpbmU6IHouc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgcHVuY2hsaW5lIHRvIHRoZSBqb2tlXCIpLFxuICogICByYXRpbmc6IHoubnVtYmVyKCkub3B0aW9uYWwoKS5kZXNjcmliZShcIkhvdyBmdW5ueSB0aGUgam9rZSBpcywgZnJvbSAxIHRvIDEwXCIpXG4gKiB9KS5kZXNjcmliZSgnSm9rZSB0byB0ZWxsIHVzZXIuJyk7XG4gKlxuICogY29uc3Qgc3RydWN0dXJlZExsbSA9IGxsbS53aXRoU3RydWN0dXJlZE91dHB1dChKb2tlLCB7IG5hbWU6IFwiSm9rZVwiIH0pO1xuICogY29uc3Qgam9rZVJlc3VsdCA9IGF3YWl0IHN0cnVjdHVyZWRMbG0uaW52b2tlKFwiVGVsbCBtZSBhIGpva2UgYWJvdXQgY2F0c1wiKTtcbiAqIGNvbnNvbGUubG9nKGpva2VSZXN1bHQpO1xuICogYGBgXG4gKlxuICogYGBgdHh0XG4gKiB7XG4gKiAgIHNldHVwOiBcIldoeSBkb24ndCBjYXRzIHBsYXkgcG9rZXIgaW4gdGhlIGp1bmdsZT9cIixcbiAqICAgcHVuY2hsaW5lOiAnVG9vIG1hbnkgY2hlZXRhaHMhJyxcbiAqICAgcmF0aW5nOiA3XG4gKiB9XG4gKiBgYGBcbiAqIDwvZGV0YWlscz5cbiAqXG4gKiA8YnIgLz5cbiAqXG4gKiA8ZGV0YWlscz5cbiAqIDxzdW1tYXJ5PjxzdHJvbmc+TXVsdGltb2RhbDwvc3Ryb25nPjwvc3VtbWFyeT5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBIdW1hbk1lc3NhZ2UgfSBmcm9tICdAbGFuZ2NoYWluL2NvcmUvbWVzc2FnZXMnO1xuICpcbiAqIGNvbnN0IGltYWdlVXJsID0gXCJodHRwczovL2V4YW1wbGUuY29tL2ltYWdlLmpwZ1wiO1xuICogY29uc3QgaW1hZ2VEYXRhID0gYXdhaXQgZmV0Y2goaW1hZ2VVcmwpLnRoZW4ocmVzID0+IHJlcy5hcnJheUJ1ZmZlcigpKTtcbiAqIGNvbnN0IGJhc2U2NEltYWdlID0gQnVmZmVyLmZyb20oaW1hZ2VEYXRhKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gKlxuICogY29uc3QgbWVzc2FnZSA9IG5ldyBIdW1hbk1lc3NhZ2Uoe1xuICogICBjb250ZW50OiBbXG4gKiAgICAgeyB0eXBlOiBcInRleHRcIiwgdGV4dDogXCJkZXNjcmliZSB0aGUgd2VhdGhlciBpbiB0aGlzIGltYWdlXCIgfSxcbiAqICAgICB7XG4gKiAgICAgICB0eXBlOiBcImltYWdlX3VybFwiLFxuICogICAgICAgaW1hZ2VfdXJsOiB7IHVybDogYGRhdGE6aW1hZ2UvanBlZztiYXNlNjQsJHtiYXNlNjRJbWFnZX1gIH0sXG4gKiAgICAgfSxcbiAqICAgXVxuICogfSk7XG4gKlxuICogY29uc3QgaW1hZ2VEZXNjcmlwdGlvbkFpTXNnID0gYXdhaXQgbGxtLmludm9rZShbbWVzc2FnZV0pO1xuICogY29uc29sZS5sb2coaW1hZ2VEZXNjcmlwdGlvbkFpTXNnLmNvbnRlbnQpO1xuICogYGBgXG4gKlxuICogYGBgdHh0XG4gKiBUaGUgd2VhdGhlciBpbiB0aGlzIGltYWdlIGFwcGVhcnMgdG8gYmUgY2xlYXIgYW5kIHBsZWFzYW50LiBUaGUgc2t5IGlzIGEgdmlicmFudCBibHVlIHdpdGggc2NhdHRlcmVkIHdoaXRlIGNsb3Vkcywgc3VnZ2VzdGluZyBhIHN1bm55IGRheSB3aXRoIGdvb2QgdmlzaWJpbGl0eS4gVGhlIGNsb3VkcyBhcmUgbGlnaHQgYW5kIHdpc3B5LCBpbmRpY2F0aW5nIGZhaXIgd2VhdGhlciBjb25kaXRpb25zLiBUaGVyZSdzIG5vIHNpZ24gb2YgcmFpbiwgc3Rvcm0sIG9yIGFueSBhZHZlcnNlIHdlYXRoZXIgcGF0dGVybnMuIFRoZSBsdXNoIGdyZWVuIGdyYXNzIG9uIHRoZSByb2xsaW5nIGhpbGxzIGxvb2tzIHdlbGwtd2F0ZXJlZCBhbmQgaGVhbHRoeSwgd2hpY2ggY291bGQgaW5kaWNhdGUgcmVjZW50IHJhaW5mYWxsIG9yIGdlbmVyYWxseSBmYXZvcmFibGUgd2VhdGhlciBjb25kaXRpb25zLiBPdmVyYWxsLCB0aGUgaW1hZ2UgZGVwaWN0cyBhIGJlYXV0aWZ1bCwgY2FsbSBkYXkgd2l0aCBibHVlIHNraWVzIGFuZCBzdW5zaGluZSAtIHBlcmZlY3Qgd2VhdGhlciBmb3IgZW5qb3lpbmcgdGhlIG91dGRvb3JzLlxuICogYGBgXG4gKiA8L2RldGFpbHM+XG4gKlxuICogPGJyIC8+XG4gKlxuICogPGRldGFpbHM+XG4gKiA8c3VtbWFyeT48c3Ryb25nPlVzYWdlIE1ldGFkYXRhPC9zdHJvbmc+PC9zdW1tYXJ5PlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGFpTXNnRm9yTWV0YWRhdGEgPSBhd2FpdCBsbG0uaW52b2tlKGlucHV0KTtcbiAqIGNvbnNvbGUubG9nKGFpTXNnRm9yTWV0YWRhdGEudXNhZ2VfbWV0YWRhdGEpO1xuICogYGBgXG4gKlxuICogYGBgdHh0XG4gKiB7IGlucHV0X3Rva2VuczogMjUsIG91dHB1dF90b2tlbnM6IDE5LCB0b3RhbF90b2tlbnM6IDQ0IH1cbiAqIGBgYFxuICogPC9kZXRhaWxzPlxuICpcbiAqIDxiciAvPlxuICpcbiAqIDxkZXRhaWxzPlxuICogPHN1bW1hcnk+PHN0cm9uZz5TdHJlYW0gVXNhZ2UgTWV0YWRhdGE8L3N0cm9uZz48L3N1bW1hcnk+XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3Qgc3RyZWFtRm9yTWV0YWRhdGEgPSBhd2FpdCBsbG0uc3RyZWFtKGlucHV0KTtcbiAqIGxldCBmdWxsRm9yTWV0YWRhdGE6IEFJTWVzc2FnZUNodW5rIHwgdW5kZWZpbmVkO1xuICogZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW1Gb3JNZXRhZGF0YSkge1xuICogICBmdWxsRm9yTWV0YWRhdGEgPSAhZnVsbEZvck1ldGFkYXRhID8gY2h1bmsgOiBjb25jYXQoZnVsbEZvck1ldGFkYXRhLCBjaHVuayk7XG4gKiB9XG4gKiBjb25zb2xlLmxvZyhmdWxsRm9yTWV0YWRhdGE/LnVzYWdlX21ldGFkYXRhKTtcbiAqIGBgYFxuICpcbiAqIGBgYHR4dFxuICogeyBpbnB1dF90b2tlbnM6IDI1LCBvdXRwdXRfdG9rZW5zOiAxOSwgdG90YWxfdG9rZW5zOiA0NCB9XG4gKiBgYGBcbiAqIDwvZGV0YWlscz5cbiAqXG4gKiA8YnIgLz5cbiAqXG4gKiA8ZGV0YWlscz5cbiAqIDxzdW1tYXJ5PjxzdHJvbmc+UmVzcG9uc2UgTWV0YWRhdGE8L3N0cm9uZz48L3N1bW1hcnk+XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgYWlNc2dGb3JSZXNwb25zZU1ldGFkYXRhID0gYXdhaXQgbGxtLmludm9rZShpbnB1dCk7XG4gKiBjb25zb2xlLmxvZyhhaU1zZ0ZvclJlc3BvbnNlTWV0YWRhdGEucmVzcG9uc2VfbWV0YWRhdGEpO1xuICogYGBgXG4gKlxuICogYGBgdHh0XG4gKiB7XG4gKiAgICckbWV0YWRhdGEnOiB7XG4gKiAgICAgaHR0cFN0YXR1c0NvZGU6IDIwMCxcbiAqICAgICByZXF1ZXN0SWQ6ICc1ZGUyYTJlNS1kMWRjLTRkZmYtYmIwMi0zMTM2MWY0MTA3YmMnLFxuICogICAgIGV4dGVuZGVkUmVxdWVzdElkOiB1bmRlZmluZWQsXG4gKiAgICAgY2ZJZDogdW5kZWZpbmVkLFxuICogICAgIGF0dGVtcHRzOiAxLFxuICogICAgIHRvdGFsUmV0cnlEZWxheTogMFxuICogICB9LFxuICogICBtZXRyaWNzOiB7IGxhdGVuY3lNczogMTE2MyB9LFxuICogICBzdG9wUmVhc29uOiAnZW5kX3R1cm4nLFxuICogICB1c2FnZTogeyBpbnB1dFRva2VuczogMjUsIG91dHB1dFRva2VuczogMTksIHRvdGFsVG9rZW5zOiA0NCB9XG4gKiB9XG4gKiBgYGBcbiAqIDwvZGV0YWlscz5cbiAqXG4gKiA8YnIgLz5cbiAqL1xuY2xhc3MgQ2hhdEJlZHJvY2tDb252ZXJzZSBleHRlbmRzIGNoYXRfbW9kZWxzXzEuQmFzZUNoYXRNb2RlbCB7XG4gICAgLy8gVXNlZCBmb3IgdHJhY2luZywgcmVwbGFjZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgeW91ciBjbGFzc1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJDaGF0QmVkcm9ja0NvbnZlcnNlXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcGxhY2Ugd2l0aCBhbnkgc2VjcmV0cyB0aGlzIGNsYXNzIHBhc3NlcyB0byBgc3VwZXJgLlxuICAgICAqIFNlZSB7QGxpbmsgLi4vLi4vbGFuZ2NoYWluLWNvaGVyZS9zcmMvY2hhdF9tb2RlbC50c30gZm9yXG4gICAgICogYW4gZXhhbXBsZS5cbiAgICAgKi9cbiAgICBnZXQgbGNfc2VjcmV0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFwaUtleTogXCJBUElfS0VZX05BTUVcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IGxjX2FsaWFzZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhcGlLZXk6IFwiQVBJX0tFWV9OQU1FXCIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMgPz8ge30pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtb2RlbFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJhbnRocm9waWMuY2xhdWRlLTMtaGFpa3UtMjAyNDAzMDctdjE6MFwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdHJlYW1pbmdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWdpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGVtcGVyYXR1cmVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4VG9rZW5zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVuZHBvaW50SG9zdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3BQXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFkZGl0aW9uYWxNb2RlbFJlcXVlc3RGaWVsZHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RyZWFtVXNhZ2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImd1YXJkcmFpbENvbmZpZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwZXJmb3JtYW5jZUNvbmZpZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjbGllbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2xpZW50T3B0aW9uc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hpY2ggdHlwZXMgb2YgYHRvb2xfY2hvaWNlYCB2YWx1ZXMgdGhlIG1vZGVsIHN1cHBvcnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJbmZlcnJlZCBpZiBub3Qgc3BlY2lmaWVkLiBJbmZlcnJlZCBhcyBbJ2F1dG8nLCAnYW55JywgJ3Rvb2wnXSBpZiBhICdjbGF1ZGUtMydcbiAgICAgICAgICogbW9kZWwgaXMgdXNlZCwgWydhdXRvJywgJ2FueSddIGlmIGEgJ21pc3RyYWwtbGFyZ2UnIG1vZGVsIGlzIHVzZWQsIGVtcHR5IG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN1cHBvcnRzVG9vbENob2ljZVZhbHVlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IHByb2ZpbGUsIGZpbGVwYXRoLCBjb25maWdGaWxlcGF0aCwgaWdub3JlQ2FjaGUsIG1mYUNvZGVQcm92aWRlciwgcm9sZUFzc3VtZXIsIHJvbGVBcm4sIHdlYklkZW50aXR5VG9rZW5GaWxlLCByb2xlQXNzdW1lcldpdGhXZWJJZGVudGl0eSwgLi4ucmVzdCB9ID0gZmllbGRzID8/IHt9O1xuICAgICAgICBjb25zdCBjcmVkZW50aWFscyA9IHJlc3Q/LmNyZWRlbnRpYWxzID8/XG4gICAgICAgICAgICAoMCwgY3JlZGVudGlhbF9wcm92aWRlcl9ub2RlXzEuZGVmYXVsdFByb3ZpZGVyKSh7XG4gICAgICAgICAgICAgICAgcHJvZmlsZSxcbiAgICAgICAgICAgICAgICBmaWxlcGF0aCxcbiAgICAgICAgICAgICAgICBjb25maWdGaWxlcGF0aCxcbiAgICAgICAgICAgICAgICBpZ25vcmVDYWNoZSxcbiAgICAgICAgICAgICAgICBtZmFDb2RlUHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgcm9sZUFzc3VtZXIsXG4gICAgICAgICAgICAgICAgcm9sZUFybixcbiAgICAgICAgICAgICAgICB3ZWJJZGVudGl0eVRva2VuRmlsZSxcbiAgICAgICAgICAgICAgICByb2xlQXNzdW1lcldpdGhXZWJJZGVudGl0eSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZWdpb24gPSByZXN0Py5yZWdpb24gPz8gKDAsIGVudl8xLmdldEVudmlyb25tZW50VmFyaWFibGUpKFwiQVdTX0RFRkFVTFRfUkVHSU9OXCIpO1xuICAgICAgICBpZiAoIXJlZ2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHNldCB0aGUgQVdTX0RFRkFVTFRfUkVHSU9OIGVudmlyb25tZW50IHZhcmlhYmxlIG9yIHBhc3MgaXQgdG8gdGhlIGNvbnN0cnVjdG9yIGFzIHRoZSByZWdpb24gZmllbGQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xpZW50ID1cbiAgICAgICAgICAgIGZpZWxkcz8uY2xpZW50ID8/XG4gICAgICAgICAgICAgICAgbmV3IGNsaWVudF9iZWRyb2NrX3J1bnRpbWVfMS5CZWRyb2NrUnVudGltZUNsaWVudCh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmZpZWxkcz8uY2xpZW50T3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgcmVnaW9uLFxuICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFscyxcbiAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnQ6IHJlc3QuZW5kcG9pbnRIb3N0XG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBodHRwczovLyR7cmVzdC5lbmRwb2ludEhvc3R9YFxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaW9uID0gcmVnaW9uO1xuICAgICAgICB0aGlzLm1vZGVsID0gcmVzdD8ubW9kZWwgPz8gdGhpcy5tb2RlbDtcbiAgICAgICAgdGhpcy5zdHJlYW1pbmcgPSByZXN0Py5zdHJlYW1pbmcgPz8gdGhpcy5zdHJlYW1pbmc7XG4gICAgICAgIHRoaXMudGVtcGVyYXR1cmUgPSByZXN0Py50ZW1wZXJhdHVyZTtcbiAgICAgICAgdGhpcy5tYXhUb2tlbnMgPSByZXN0Py5tYXhUb2tlbnM7XG4gICAgICAgIHRoaXMuZW5kcG9pbnRIb3N0ID0gcmVzdD8uZW5kcG9pbnRIb3N0O1xuICAgICAgICB0aGlzLnRvcFAgPSByZXN0Py50b3BQO1xuICAgICAgICB0aGlzLmFkZGl0aW9uYWxNb2RlbFJlcXVlc3RGaWVsZHMgPSByZXN0Py5hZGRpdGlvbmFsTW9kZWxSZXF1ZXN0RmllbGRzO1xuICAgICAgICB0aGlzLnN0cmVhbVVzYWdlID0gcmVzdD8uc3RyZWFtVXNhZ2UgPz8gdGhpcy5zdHJlYW1Vc2FnZTtcbiAgICAgICAgdGhpcy5ndWFyZHJhaWxDb25maWcgPSByZXN0Py5ndWFyZHJhaWxDb25maWc7XG4gICAgICAgIHRoaXMucGVyZm9ybWFuY2VDb25maWcgPSByZXN0Py5wZXJmb3JtYW5jZUNvbmZpZztcbiAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zID0gcmVzdD8uY2xpZW50T3B0aW9ucztcbiAgICAgICAgaWYgKHJlc3Q/LnN1cHBvcnRzVG9vbENob2ljZVZhbHVlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnN1cHBvcnRzVG9vbENob2ljZVZhbHVlcyA9ICgwLCBjb21tb25fanNfMS5zdXBwb3J0ZWRUb29sQ2hvaWNlVmFsdWVzRm9yTW9kZWwpKHRoaXMubW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdXBwb3J0c1Rvb2xDaG9pY2VWYWx1ZXMgPSByZXN0LnN1cHBvcnRzVG9vbENob2ljZVZhbHVlcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRMc1BhcmFtcyhvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuaW52b2NhdGlvblBhcmFtcyhvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxzX3Byb3ZpZGVyOiBcImFtYXpvbl9iZWRyb2NrXCIsXG4gICAgICAgICAgICBsc19tb2RlbF9uYW1lOiB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgbHNfbW9kZWxfdHlwZTogXCJjaGF0XCIsXG4gICAgICAgICAgICBsc190ZW1wZXJhdHVyZTogcGFyYW1zLmluZmVyZW5jZUNvbmZpZz8udGVtcGVyYXR1cmUgPz8gdGhpcy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICAgIGxzX21heF90b2tlbnM6IHBhcmFtcy5pbmZlcmVuY2VDb25maWc/Lm1heFRva2VucyA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICBsc19zdG9wOiBvcHRpb25zLnN0b3AsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGJpbmRUb29scyh0b29scywga3dhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhDb25maWcoe1xuICAgICAgICAgICAgdG9vbHM6ICgwLCBjb21tb25fanNfMS5jb252ZXJ0VG9Db252ZXJzZVRvb2xzKSh0b29scyksXG4gICAgICAgICAgICAuLi5rd2FyZ3MsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBSZXBsYWNlXG4gICAgX2xsbVR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImNoYXRfYmVkcm9ja19jb252ZXJzZVwiO1xuICAgIH1cbiAgICBpbnZvY2F0aW9uUGFyYW1zKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHRvb2xDb25maWc7XG4gICAgICAgIGlmIChvcHRpb25zPy50b29scyAmJiBvcHRpb25zLnRvb2xzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgdG9vbHMgPSAoMCwgY29tbW9uX2pzXzEuY29udmVydFRvQ29udmVyc2VUb29scykob3B0aW9ucy50b29scyk7XG4gICAgICAgICAgICB0b29sQ29uZmlnID0ge1xuICAgICAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgICAgIHRvb2xDaG9pY2U6IG9wdGlvbnMudG9vbF9jaG9pY2VcbiAgICAgICAgICAgICAgICAgICAgPyAoMCwgY29tbW9uX2pzXzEuY29udmVydFRvQmVkcm9ja1Rvb2xDaG9pY2UpKG9wdGlvbnMudG9vbF9jaG9pY2UsIHRvb2xzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1cHBvcnRzVG9vbENob2ljZVZhbHVlczogdGhpcy5zdXBwb3J0c1Rvb2xDaG9pY2VWYWx1ZXMsXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5mZXJlbmNlQ29uZmlnOiB7XG4gICAgICAgICAgICAgICAgbWF4VG9rZW5zOiB0aGlzLm1heFRva2VucyxcbiAgICAgICAgICAgICAgICB0ZW1wZXJhdHVyZTogdGhpcy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICAgICAgICB0b3BQOiB0aGlzLnRvcFAsXG4gICAgICAgICAgICAgICAgc3RvcFNlcXVlbmNlczogb3B0aW9ucz8uc3RvcCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b29sQ29uZmlnLFxuICAgICAgICAgICAgYWRkaXRpb25hbE1vZGVsUmVxdWVzdEZpZWxkczogdGhpcy5hZGRpdGlvbmFsTW9kZWxSZXF1ZXN0RmllbGRzID8/XG4gICAgICAgICAgICAgICAgb3B0aW9ucz8uYWRkaXRpb25hbE1vZGVsUmVxdWVzdEZpZWxkcyxcbiAgICAgICAgICAgIGd1YXJkcmFpbENvbmZpZzogdGhpcy5ndWFyZHJhaWxDb25maWcgPz8gb3B0aW9ucz8uZ3VhcmRyYWlsQ29uZmlnLFxuICAgICAgICAgICAgcGVyZm9ybWFuY2VDb25maWc6IG9wdGlvbnM/LnBlcmZvcm1hbmNlQ29uZmlnLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBfZ2VuZXJhdGUobWVzc2FnZXMsIG9wdGlvbnMsIHJ1bk1hbmFnZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9zdHJlYW1SZXNwb25zZUNodW5rcyhtZXNzYWdlcywgb3B0aW9ucywgcnVuTWFuYWdlcik7XG4gICAgICAgICAgICBsZXQgZmluYWxSZXN1bHQ7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIGlmIChmaW5hbFJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsUmVzdWx0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaW5hbFJlc3VsdCA9IGZpbmFsUmVzdWx0LmNvbmNhdChjaHVuayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbmFsUmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcGFyc2UgZmluYWwgb3V0cHV0IGZyb20gQmVkcm9jayBzdHJlYW1pbmcgY2FsbC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zOiBbZmluYWxSZXN1bHRdLFxuICAgICAgICAgICAgICAgIGxsbU91dHB1dDogZmluYWxSZXN1bHQuZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmF0ZU5vblN0cmVhbWluZyhtZXNzYWdlcywgb3B0aW9ucywgcnVuTWFuYWdlcik7XG4gICAgfVxuICAgIGFzeW5jIF9nZW5lcmF0ZU5vblN0cmVhbWluZyhtZXNzYWdlcywgb3B0aW9ucywgX3J1bk1hbmFnZXIpIHtcbiAgICAgICAgY29uc3QgeyBjb252ZXJzZU1lc3NhZ2VzLCBjb252ZXJzZVN5c3RlbSB9ID0gKDAsIGNvbW1vbl9qc18xLmNvbnZlcnRUb0NvbnZlcnNlTWVzc2FnZXMpKG1lc3NhZ2VzKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5pbnZvY2F0aW9uUGFyYW1zKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjb21tYW5kID0gbmV3IGNsaWVudF9iZWRyb2NrX3J1bnRpbWVfMS5Db252ZXJzZUNvbW1hbmQoe1xuICAgICAgICAgICAgbW9kZWxJZDogdGhpcy5tb2RlbCxcbiAgICAgICAgICAgIG1lc3NhZ2VzOiBjb252ZXJzZU1lc3NhZ2VzLFxuICAgICAgICAgICAgc3lzdGVtOiBjb252ZXJzZVN5c3RlbSxcbiAgICAgICAgICAgIHJlcXVlc3RNZXRhZGF0YTogb3B0aW9ucy5yZXF1ZXN0TWV0YWRhdGEsXG4gICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnNlbmQoY29tbWFuZCwge1xuICAgICAgICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBvdXRwdXQsIC4uLnJlc3BvbnNlTWV0YWRhdGEgfSA9IHJlc3BvbnNlO1xuICAgICAgICBpZiAoIW91dHB1dD8ubWVzc2FnZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbWVzc2FnZSBmb3VuZCBpbiBCZWRyb2NrIHJlc3BvbnNlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlID0gKDAsIGNvbW1vbl9qc18xLmNvbnZlcnRDb252ZXJzZU1lc3NhZ2VUb0xhbmdDaGFpbk1lc3NhZ2UpKG91dHB1dC5tZXNzYWdlLCByZXNwb25zZU1ldGFkYXRhKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdlbmVyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiID8gbWVzc2FnZS5jb250ZW50IDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgKl9zdHJlYW1SZXNwb25zZUNodW5rcyhtZXNzYWdlcywgb3B0aW9ucywgcnVuTWFuYWdlcikge1xuICAgICAgICBjb25zdCB7IGNvbnZlcnNlTWVzc2FnZXMsIGNvbnZlcnNlU3lzdGVtIH0gPSAoMCwgY29tbW9uX2pzXzEuY29udmVydFRvQ29udmVyc2VNZXNzYWdlcykobWVzc2FnZXMpO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLmludm9jYXRpb25QYXJhbXMob3B0aW9ucyk7XG4gICAgICAgIGxldCB7IHN0cmVhbVVzYWdlIH0gPSB0aGlzO1xuICAgICAgICBpZiAob3B0aW9ucy5zdHJlYW1Vc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdHJlYW1Vc2FnZSA9IG9wdGlvbnMuc3RyZWFtVXNhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tbWFuZCA9IG5ldyBjbGllbnRfYmVkcm9ja19ydW50aW1lXzEuQ29udmVyc2VTdHJlYW1Db21tYW5kKHtcbiAgICAgICAgICAgIG1vZGVsSWQ6IHRoaXMubW9kZWwsXG4gICAgICAgICAgICBtZXNzYWdlczogY29udmVyc2VNZXNzYWdlcyxcbiAgICAgICAgICAgIHN5c3RlbTogY29udmVyc2VTeXN0ZW0sXG4gICAgICAgICAgICByZXF1ZXN0TWV0YWRhdGE6IG9wdGlvbnMucmVxdWVzdE1ldGFkYXRhLFxuICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5zZW5kKGNvbW1hbmQsIHtcbiAgICAgICAgICAgIGFib3J0U2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdHJlYW0pIHtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmVzcG9uc2Uuc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNodW5rLmNvbnRlbnRCbG9ja1N0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkICgwLCBjb21tb25fanNfMS5oYW5kbGVDb252ZXJzZVN0cmVhbUNvbnRlbnRCbG9ja1N0YXJ0KShjaHVuay5jb250ZW50QmxvY2tTdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNodW5rLmNvbnRlbnRCbG9ja0RlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRDaGF0R2VuZXJhdGlvbiA9ICgwLCBjb21tb25fanNfMS5oYW5kbGVDb252ZXJzZVN0cmVhbUNvbnRlbnRCbG9ja0RlbHRhKShjaHVuay5jb250ZW50QmxvY2tEZWx0YSk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRleHRDaGF0R2VuZXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlTExNTmV3VG9rZW4odGV4dENoYXRHZW5lcmF0aW9uLnRleHQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bms6IHRleHRDaGF0R2VuZXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNodW5rLm1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkICgwLCBjb21tb25fanNfMS5oYW5kbGVDb252ZXJzZVN0cmVhbU1ldGFkYXRhKShjaHVuay5tZXRhZGF0YSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtVXNhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgbmV3IG91dHB1dHNfMS5DaGF0R2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBuZXcgbWVzc2FnZXNfMS5BSU1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZV9tZXRhZGF0YTogY2h1bmssXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHdpdGhTdHJ1Y3R1cmVkT3V0cHV0KG91dHB1dFNjaGVtYSwgY29uZmlnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IG91dHB1dFNjaGVtYTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGNvbmZpZz8ubmFtZTtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSAoMCwgdHlwZXNfMS5nZXRTY2hlbWFEZXNjcmlwdGlvbikoc2NoZW1hKSA/PyBcIkEgZnVuY3Rpb24gYXZhaWxhYmxlIHRvIGNhbGwuXCI7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGNvbmZpZz8ubWV0aG9kO1xuICAgICAgICBjb25zdCBpbmNsdWRlUmF3ID0gY29uZmlnPy5pbmNsdWRlUmF3O1xuICAgICAgICBpZiAobWV0aG9kID09PSBcImpzb25Nb2RlXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2hhdEJlZHJvY2tDb252ZXJzZSBkb2VzIG5vdCBzdXBwb3J0ICdqc29uTW9kZScuYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZ1bmN0aW9uTmFtZSA9IG5hbWUgPz8gXCJleHRyYWN0XCI7XG4gICAgICAgIGxldCB0b29scztcbiAgICAgICAgaWYgKCgwLCB0eXBlc18xLmlzSW50ZXJvcFpvZFNjaGVtYSkoc2NoZW1hKSkge1xuICAgICAgICAgICAgdG9vbHMgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6ICgwLCBqc29uX3NjaGVtYV8xLnRvSnNvblNjaGVtYSkoc2NoZW1hKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChcIm5hbWVcIiBpbiBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSBzY2hlbWEubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvb2xzID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBzY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VwcG9ydHNUb29sQ2hvaWNlVmFsdWVzID0gdGhpcy5zdXBwb3J0c1Rvb2xDaG9pY2VWYWx1ZXMgPz8gW107XG4gICAgICAgIGxldCB0b29sQ2hvaWNlT2JqO1xuICAgICAgICBpZiAoc3VwcG9ydHNUb29sQ2hvaWNlVmFsdWVzLmluY2x1ZGVzKFwidG9vbFwiKSkge1xuICAgICAgICAgICAgdG9vbENob2ljZU9iaiA9IHtcbiAgICAgICAgICAgICAgICB0b29sX2Nob2ljZTogdG9vbHNbMF0uZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3VwcG9ydHNUb29sQ2hvaWNlVmFsdWVzLmluY2x1ZGVzKFwiYW55XCIpKSB7XG4gICAgICAgICAgICB0b29sQ2hvaWNlT2JqID0ge1xuICAgICAgICAgICAgICAgIHRvb2xfY2hvaWNlOiBcImFueVwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsbG0gPSB0aGlzLmJpbmRUb29scyh0b29scywgdG9vbENob2ljZU9iaik7XG4gICAgICAgIGNvbnN0IG91dHB1dFBhcnNlciA9IHJ1bm5hYmxlc18xLlJ1bm5hYmxlTGFtYmRhLmZyb20oKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlucHV0LnRvb2xfY2FsbHMgfHwgaW5wdXQudG9vbF9jYWxscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB0b29sIGNhbGxzIGZvdW5kIGluIHRoZSByZXNwb25zZS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0b29sQ2FsbCA9IGlucHV0LnRvb2xfY2FsbHMuZmluZCgodGMpID0+IHRjLm5hbWUgPT09IGZ1bmN0aW9uTmFtZSk7XG4gICAgICAgICAgICBpZiAoIXRvb2xDYWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyB0b29sIGNhbGwgZm91bmQgd2l0aCBuYW1lICR7ZnVuY3Rpb25OYW1lfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b29sQ2FsbC5hcmdzO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFpbmNsdWRlUmF3KSB7XG4gICAgICAgICAgICByZXR1cm4gbGxtLnBpcGUob3V0cHV0UGFyc2VyKS53aXRoQ29uZmlnKHtcbiAgICAgICAgICAgICAgICBydW5OYW1lOiBcIlN0cnVjdHVyZWRPdXRwdXRcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlckFzc2lnbiA9IHJ1bm5hYmxlc18xLlJ1bm5hYmxlUGFzc3Rocm91Z2guYXNzaWduKHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBwYXJzZWQ6IChpbnB1dCwgY29uZmlnKSA9PiBvdXRwdXRQYXJzZXIuaW52b2tlKGlucHV0LnJhdywgY29uZmlnKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHBhcnNlck5vbmUgPSBydW5uYWJsZXNfMS5SdW5uYWJsZVBhc3N0aHJvdWdoLmFzc2lnbih7XG4gICAgICAgICAgICBwYXJzZWQ6ICgpID0+IG51bGwsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwYXJzZWRXaXRoRmFsbGJhY2sgPSBwYXJzZXJBc3NpZ24ud2l0aEZhbGxiYWNrcyh7XG4gICAgICAgICAgICBmYWxsYmFja3M6IFtwYXJzZXJOb25lXSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBydW5uYWJsZXNfMS5SdW5uYWJsZVNlcXVlbmNlLmZyb20oW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJhdzogbGxtLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcnNlZFdpdGhGYWxsYmFjayxcbiAgICAgICAgXSkud2l0aENvbmZpZyh7XG4gICAgICAgICAgICBydW5OYW1lOiBcIlN0cnVjdHVyZWRPdXRwdXRSdW5uYWJsZVwiLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkNoYXRCZWRyb2NrQ29udmVyc2UgPSBDaGF0QmVkcm9ja0NvbnZlcnNlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/aws/dist/chat_models.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/aws/dist/common.cjs":
/*!*****************************************************!*\
  !*** ./node_modules/@langchain/aws/dist/common.cjs ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.extractImageInfo = extractImageInfo;\nexports.convertToConverseMessages = convertToConverseMessages;\nexports.isBedrockTool = isBedrockTool;\nexports.convertToConverseTools = convertToConverseTools;\nexports.convertToBedrockToolChoice = convertToBedrockToolChoice;\nexports.convertConverseMessageToLangChainMessage = convertConverseMessageToLangChainMessage;\nexports.handleConverseStreamContentBlockDelta = handleConverseStreamContentBlockDelta;\nexports.handleConverseStreamContentBlockStart = handleConverseStreamContentBlockStart;\nexports.handleConverseStreamMetadata = handleConverseStreamMetadata;\nexports.bedrockReasoningDeltaToLangchainPartialReasoningBlock = bedrockReasoningDeltaToLangchainPartialReasoningBlock;\nexports.bedrockReasoningBlockToLangchainReasoningBlock = bedrockReasoningBlockToLangchainReasoningBlock;\nexports.langchainReasoningBlockToBedrockReasoningBlock = langchainReasoningBlockToBedrockReasoningBlock;\nexports.concatenateLangchainReasoningBlocks = concatenateLangchainReasoningBlocks;\nexports.supportedToolChoiceValuesForModel = supportedToolChoiceValuesForModel;\nconst messages_1 = __webpack_require__(/*! @langchain/core/messages */ \"(rsc)/./node_modules/@langchain/core/messages.cjs\");\nconst base_1 = __webpack_require__(/*! @langchain/core/language_models/base */ \"(rsc)/./node_modules/@langchain/core/language_models/base.cjs\");\nconst function_calling_1 = __webpack_require__(/*! @langchain/core/utils/function_calling */ \"(rsc)/./node_modules/@langchain/core/utils/function_calling.cjs\");\nconst outputs_1 = __webpack_require__(/*! @langchain/core/outputs */ \"(rsc)/./node_modules/@langchain/core/outputs.cjs\");\nconst types_1 = __webpack_require__(/*! @langchain/core/utils/types */ \"(rsc)/./node_modules/@langchain/core/utils/types.cjs\");\nconst json_schema_1 = __webpack_require__(/*! @langchain/core/utils/json_schema */ \"(rsc)/./node_modules/@langchain/core/utils/json_schema.cjs\");\nfunction isDefaultCachePoint(block) {\n    return Boolean(typeof block === \"object\" &&\n        block !== null &&\n        \"cachePoint\" in block &&\n        block.cachePoint &&\n        typeof block.cachePoint === \"object\" &&\n        block.cachePoint !== null &&\n        \"type\" in block.cachePoint &&\n        block.cachePoint.type === \"default\");\n}\nconst standardContentBlockConverter = {\n    providerName: \"ChatBedrockConverse\",\n    fromStandardTextBlock(block) {\n        return {\n            text: block.text,\n        };\n    },\n    fromStandardImageBlock(block) {\n        let format;\n        if (block.source_type === \"url\") {\n            const parsedData = (0, messages_1.parseBase64DataUrl)({\n                dataUrl: block.url,\n                asTypedArray: true,\n            });\n            if (parsedData) {\n                const parsedMimeType = (0, messages_1.parseMimeType)(parsedData.mime_type);\n                format = parsedMimeType.type;\n                return {\n                    image: {\n                        format,\n                        source: {\n                            bytes: parsedData.data,\n                        },\n                    },\n                };\n            }\n            else {\n                throw new Error(\"Only base64 data URLs are supported for image blocks with source type 'url' with ChatBedrockConverse.\");\n            }\n        }\n        else if (block.source_type === \"base64\") {\n            if (block.mime_type) {\n                const parsedMimeType = (0, messages_1.parseMimeType)(block.mime_type);\n                format = parsedMimeType.subtype;\n            }\n            if (format && ![\"gif\", \"jpeg\", \"png\", \"webp\"].includes(format)) {\n                throw new Error(`Unsupported image mime type: \"${block.mime_type}\" ChatBedrockConverse only supports \"image/gif\", \"image/jpeg\", \"image/png\", and \"image/webp\" formats.`);\n            }\n            return {\n                image: {\n                    format,\n                    source: {\n                        bytes: Uint8Array.from(atob(block.data), (c) => c.charCodeAt(0)),\n                    },\n                },\n            };\n        }\n        else if (block.source_type === \"id\") {\n            throw new Error(\"Image source type 'id' not supported with ChatBedrockConverse.\");\n        }\n        else {\n            throw new Error(`Unsupported image source type: \"${block.source_type}\" with ChatBedrockConverse.`);\n        }\n    },\n    fromStandardFileBlock(block) {\n        const mimeTypeToDocumentFormat = {\n            \"text/csv\": \"csv\",\n            \"application/msword\": \"doc\",\n            \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\": \"docx\",\n            \"text/html\": \"html\",\n            \"text/markdown\": \"md\",\n            \"application/pdf\": \"pdf\",\n            \"text/plain\": \"txt\",\n            \"application/vnd.ms-excel\": \"xls\",\n            \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\": \"xlsx\",\n        };\n        const name = (block.metadata?.name ??\n            block.metadata?.filename ??\n            block.metadata?.title);\n        if (block.source_type === \"text\") {\n            return {\n                document: {\n                    name,\n                    format: \"txt\",\n                    source: {\n                        bytes: new TextEncoder().encode(block.text),\n                    },\n                },\n            };\n        }\n        if (block.source_type === \"url\") {\n            const parsedData = (0, messages_1.parseBase64DataUrl)({\n                dataUrl: block.url,\n                asTypedArray: true,\n            });\n            if (parsedData) {\n                const parsedMimeType = (0, messages_1.parseMimeType)(parsedData.mime_type ?? block.mime_type);\n                const mimeType = `${parsedMimeType.type}/${parsedMimeType.subtype}`;\n                const format = mimeTypeToDocumentFormat[mimeType];\n                return {\n                    document: {\n                        name,\n                        format,\n                        source: {\n                            bytes: parsedData.data,\n                        },\n                    },\n                };\n            }\n            throw new Error(\"Only base64 data URLs are supported for file blocks with source type 'url' with ChatBedrockConverse.\");\n        }\n        if (block.source_type === \"base64\") {\n            let format;\n            if (block.mime_type) {\n                const parsedMimeType = (0, messages_1.parseMimeType)(block.mime_type);\n                const mimeType = `${parsedMimeType.type}/${parsedMimeType.subtype}`;\n                format = mimeTypeToDocumentFormat[mimeType];\n                if (format === undefined) {\n                    throw new Error(`Unsupported file mime type: \"${block.mime_type}\" ChatBedrockConverse only supports ${Object.keys(mimeTypeToDocumentFormat).join(\", \")} formats.`);\n                }\n            }\n            return {\n                document: {\n                    name,\n                    format,\n                    source: {\n                        bytes: Uint8Array.from(atob(block.data), (c) => c.charCodeAt(0)),\n                    },\n                },\n            };\n        }\n        if (block.source_type === \"id\") {\n            throw new Error(\"File source type 'id' not supported with ChatBedrockConverse.\");\n        }\n        throw new Error(`Unsupported file source type: \"${block.source_type}\" with ChatBedrockConverse.`);\n    },\n};\nfunction extractImageInfo(base64) {\n    // Extract the format from the base64 string\n    const formatMatch = base64.match(/^data:image\\/(\\w+);base64,/);\n    let format;\n    if (formatMatch) {\n        const extractedFormat = formatMatch[1].toLowerCase();\n        if ([\"gif\", \"jpeg\", \"png\", \"webp\"].includes(extractedFormat)) {\n            format = extractedFormat;\n        }\n    }\n    // Remove the data URL prefix if present\n    const base64Data = base64.replace(/^data:image\\/\\w+;base64,/, \"\");\n    // Convert base64 to Uint8Array\n    const binaryString = atob(base64Data);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i += 1) {\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    return {\n        image: {\n            format,\n            source: {\n                bytes,\n            },\n        },\n    };\n}\nfunction convertLangChainContentBlockToConverseContentBlock({ block, onUnknown = \"throw\", }) {\n    if (typeof block === \"string\") {\n        return { text: block };\n    }\n    if ((0, messages_1.isDataContentBlock)(block)) {\n        return (0, messages_1.convertToProviderContentBlock)(block, standardContentBlockConverter);\n    }\n    if (block.type === \"text\") {\n        return { text: block.text };\n    }\n    if (block.type === \"image_url\") {\n        return extractImageInfo(typeof block.image_url === \"string\"\n            ? block.image_url\n            : block.image_url.url);\n    }\n    if (block.type === \"document\" && block.document !== undefined) {\n        return {\n            document: block.document,\n        };\n    }\n    if (block.type === \"image\" && block.image !== undefined) {\n        return {\n            image: block.image,\n        };\n    }\n    if (isDefaultCachePoint(block)) {\n        return {\n            cachePoint: {\n                type: \"default\",\n            },\n        };\n    }\n    if (onUnknown === \"throw\") {\n        throw new Error(`Unsupported content block type: ${block.type}`);\n    }\n    else {\n        return block;\n    }\n}\nfunction convertSystemMessageToConverseMessage(msg) {\n    if (typeof msg.content === \"string\") {\n        return [{ text: msg.content }];\n    }\n    else if (Array.isArray(msg.content) && msg.content.length > 0) {\n        const contentBlocks = [];\n        for (const block of msg.content) {\n            if (block.type === \"text\" && typeof block.text === \"string\") {\n                contentBlocks.push({\n                    text: block.text,\n                });\n            }\n            else if (isDefaultCachePoint(block)) {\n                contentBlocks.push({\n                    cachePoint: {\n                        type: \"default\",\n                    },\n                });\n            }\n            else\n                break;\n        }\n        if (msg.content.length === contentBlocks.length)\n            return contentBlocks;\n    }\n    throw new Error(\"System message content must be either a string, or an array of text blocks, optionally including a cache point.\");\n}\nfunction convertAIMessageToConverseMessage(msg) {\n    const assistantMsg = {\n        role: \"assistant\",\n        content: [],\n    };\n    if (typeof msg.content === \"string\" && msg.content !== \"\") {\n        assistantMsg.content?.push({\n            text: msg.content,\n        });\n    }\n    else if (Array.isArray(msg.content)) {\n        const concatenatedBlocks = concatenateLangchainReasoningBlocks(msg.content);\n        const contentBlocks = [];\n        concatenatedBlocks.forEach((block) => {\n            if (block.type === \"text\" && block.text !== \"\") {\n                // Merge whitespace/newlines with previous text blocks to avoid validation errors.\n                const cleanedText = block.text?.replace(/\\n/g, \"\").trim();\n                if (cleanedText === \"\") {\n                    if (contentBlocks.length > 0) {\n                        const mergedTextContent = `${contentBlocks[contentBlocks.length - 1].text}${block.text}`;\n                        contentBlocks[contentBlocks.length - 1].text = mergedTextContent;\n                    }\n                }\n                else {\n                    contentBlocks.push({\n                        text: block.text,\n                    });\n                }\n            }\n            else if (block.type === \"reasoning_content\") {\n                contentBlocks.push({\n                    reasoningContent: langchainReasoningBlockToBedrockReasoningBlock(block),\n                });\n            }\n            else if (isDefaultCachePoint(block)) {\n                contentBlocks.push({\n                    cachePoint: {\n                        type: \"default\",\n                    },\n                });\n            }\n            else {\n                const blockValues = Object.fromEntries(Object.entries(block).filter(([key]) => key !== \"type\"));\n                throw new Error(`Unsupported content block type: ${block.type} with content of ${JSON.stringify(blockValues, null, 2)}`);\n            }\n        });\n        assistantMsg.content = [\n            ...(assistantMsg.content ? assistantMsg.content : []),\n            ...contentBlocks,\n        ];\n    }\n    // Important: this must be placed after any reasoning content blocks, else claude models will return an error.\n    if (msg.tool_calls && msg.tool_calls.length) {\n        assistantMsg.content = [\n            ...(assistantMsg.content ? assistantMsg.content : []),\n            ...msg.tool_calls.map((tc) => ({\n                toolUse: {\n                    toolUseId: tc.id,\n                    name: tc.name,\n                    input: tc.args,\n                },\n            })),\n        ];\n    }\n    return assistantMsg;\n}\nfunction convertHumanMessageToConverseMessage(msg) {\n    if (msg.content === \"\") {\n        throw new Error(`Invalid message content: empty string. '${msg.getType()}' must contain non-empty content.`);\n    }\n    const content = Array.isArray(msg.content)\n        ? msg.content.map((c) => convertLangChainContentBlockToConverseContentBlock({\n            block: c,\n            onUnknown: \"throw\",\n        }))\n        : [\n            convertLangChainContentBlockToConverseContentBlock({\n                block: msg.content,\n                onUnknown: \"throw\",\n            }),\n        ];\n    return {\n        role: \"user\",\n        content,\n    };\n}\nfunction convertToolMessageToConverseMessage(msg) {\n    const castMsg = msg;\n    if (typeof castMsg.content === \"string\") {\n        return {\n            // Tool use messages are always from the user\n            role: \"user\",\n            content: [\n                {\n                    toolResult: {\n                        toolUseId: castMsg.tool_call_id,\n                        content: [\n                            {\n                                text: castMsg.content,\n                            },\n                        ],\n                    },\n                },\n            ],\n        };\n    }\n    else {\n        return {\n            // Tool use messages are always from the user\n            role: \"user\",\n            content: [\n                {\n                    toolResult: {\n                        toolUseId: castMsg.tool_call_id,\n                        content: msg.content.map((c) => {\n                            const converted = convertLangChainContentBlockToConverseContentBlock({\n                                block: c,\n                                onUnknown: \"returnUnmodified\",\n                            });\n                            if (converted !== c) {\n                                return converted;\n                            }\n                            return { json: c };\n                        }),\n                    },\n                },\n            ],\n        };\n    }\n}\nfunction convertToConverseMessages(messages) {\n    const converseSystem = messages\n        .filter((msg) => msg.getType() === \"system\")\n        .flatMap((msg) => convertSystemMessageToConverseMessage(msg));\n    const converseMessages = messages\n        .filter((msg) => msg.getType() !== \"system\")\n        .map((msg) => {\n        if (msg.getType() === \"ai\") {\n            return convertAIMessageToConverseMessage(msg);\n        }\n        else if (msg.getType() === \"human\" || msg.getType() === \"generic\") {\n            return convertHumanMessageToConverseMessage(msg);\n        }\n        else if (msg.getType() === \"tool\") {\n            return convertToolMessageToConverseMessage(msg);\n        }\n        else {\n            throw new Error(`Unsupported message type: ${msg.getType()}`);\n        }\n    });\n    // Combine consecutive user tool result messages into a single message\n    const combinedConverseMessages = converseMessages.reduce((acc, curr) => {\n        const lastMessage = acc[acc.length - 1];\n        if (lastMessage &&\n            lastMessage.role === \"user\" &&\n            lastMessage.content?.some((c) => \"toolResult\" in c) &&\n            curr.role === \"user\" &&\n            curr.content?.some((c) => \"toolResult\" in c)) {\n            lastMessage.content = lastMessage.content.concat(curr.content);\n        }\n        else {\n            acc.push(curr);\n        }\n        return acc;\n    }, []);\n    return { converseMessages: combinedConverseMessages, converseSystem };\n}\nfunction isBedrockTool(tool) {\n    if (typeof tool === \"object\" && tool && \"toolSpec\" in tool) {\n        return true;\n    }\n    return false;\n}\nfunction convertToConverseTools(tools) {\n    if (tools.every(base_1.isOpenAITool)) {\n        return tools.map((tool) => ({\n            toolSpec: {\n                name: tool.function.name,\n                description: tool.function.description,\n                inputSchema: {\n                    json: tool.function.parameters,\n                },\n            },\n        }));\n    }\n    else if (tools.every(function_calling_1.isLangChainTool)) {\n        return tools.map((tool) => ({\n            toolSpec: {\n                name: tool.name,\n                description: tool.description,\n                inputSchema: {\n                    json: ((0, types_1.isInteropZodSchema)(tool.schema)\n                        ? (0, json_schema_1.toJsonSchema)(tool.schema)\n                        : tool.schema),\n                },\n            },\n        }));\n    }\n    else if (tools.every(isBedrockTool)) {\n        return tools;\n    }\n    throw new Error(\"Invalid tools passed. Must be an array of StructuredToolInterface, ToolDefinition, or BedrockTool.\");\n}\nfunction convertToBedrockToolChoice(toolChoice, tools, fields) {\n    const supportsToolChoiceValues = fields.supportsToolChoiceValues ?? [];\n    let bedrockToolChoice;\n    if (typeof toolChoice === \"string\") {\n        switch (toolChoice) {\n            case \"any\":\n                bedrockToolChoice = {\n                    any: {},\n                };\n                break;\n            case \"auto\":\n                bedrockToolChoice = {\n                    auto: {},\n                };\n                break;\n            default: {\n                const foundTool = tools.find((tool) => tool.toolSpec?.name === toolChoice);\n                if (!foundTool) {\n                    throw new Error(`Tool with name ${toolChoice} not found in tools list.`);\n                }\n                bedrockToolChoice = {\n                    tool: {\n                        name: toolChoice,\n                    },\n                };\n            }\n        }\n    }\n    else {\n        bedrockToolChoice = toolChoice;\n    }\n    const toolChoiceType = Object.keys(bedrockToolChoice)[0];\n    if (!supportsToolChoiceValues.includes(toolChoiceType)) {\n        let supportedTxt = \"\";\n        if (supportsToolChoiceValues.length) {\n            supportedTxt =\n                `Model ${fields.model} does not currently support 'tool_choice' ` +\n                    `of type ${toolChoiceType}. The following 'tool_choice' types ` +\n                    `are supported: ${supportsToolChoiceValues.join(\", \")}.`;\n        }\n        else {\n            supportedTxt = `Model ${fields.model} does not currently support 'tool_choice'.`;\n        }\n        throw new Error(`${supportedTxt} Please see` +\n            \"https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_ToolChoice.html\" +\n            \"for the latest documentation on models that support tool choice.\");\n    }\n    return bedrockToolChoice;\n}\nfunction convertConverseMessageToLangChainMessage(message, responseMetadata) {\n    if (!message.content) {\n        throw new Error(\"No message content found in response.\");\n    }\n    if (message.role !== \"assistant\") {\n        throw new Error(`Unsupported message role received in ChatBedrockConverse response: ${message.role}`);\n    }\n    let requestId;\n    if (\"$metadata\" in responseMetadata &&\n        responseMetadata.$metadata &&\n        typeof responseMetadata.$metadata === \"object\" &&\n        \"requestId\" in responseMetadata.$metadata) {\n        requestId = responseMetadata.$metadata.requestId;\n    }\n    let tokenUsage;\n    if (responseMetadata.usage) {\n        const input_tokens = responseMetadata.usage.inputTokens ?? 0;\n        const output_tokens = responseMetadata.usage.outputTokens ?? 0;\n        tokenUsage = {\n            input_tokens,\n            output_tokens,\n            total_tokens: responseMetadata.usage.totalTokens ?? input_tokens + output_tokens,\n        };\n    }\n    if (message.content?.length === 1 &&\n        \"text\" in message.content[0] &&\n        typeof message.content[0].text === \"string\") {\n        return new messages_1.AIMessage({\n            content: message.content[0].text,\n            response_metadata: responseMetadata,\n            usage_metadata: tokenUsage,\n            id: requestId,\n        });\n    }\n    else {\n        const toolCalls = [];\n        const content = [];\n        message.content.forEach((c) => {\n            if (\"toolUse\" in c &&\n                c.toolUse &&\n                c.toolUse.name &&\n                c.toolUse.input &&\n                typeof c.toolUse.input === \"object\") {\n                toolCalls.push({\n                    id: c.toolUse.toolUseId,\n                    name: c.toolUse.name,\n                    args: c.toolUse.input,\n                    type: \"tool_call\",\n                });\n            }\n            else if (\"text\" in c && typeof c.text === \"string\") {\n                content.push({ type: \"text\", text: c.text });\n            }\n            else if (\"reasoningContent\" in c) {\n                content.push(bedrockReasoningBlockToLangchainReasoningBlock(c.reasoningContent));\n            }\n            else {\n                content.push(c);\n            }\n        });\n        return new messages_1.AIMessage({\n            content: content.length ? content : \"\",\n            tool_calls: toolCalls.length ? toolCalls : undefined,\n            response_metadata: responseMetadata,\n            usage_metadata: tokenUsage,\n            id: requestId,\n        });\n    }\n}\nfunction handleConverseStreamContentBlockDelta(contentBlockDelta) {\n    if (!contentBlockDelta.delta) {\n        throw new Error(\"No delta found in content block.\");\n    }\n    if (typeof contentBlockDelta.delta.text === \"string\") {\n        return new outputs_1.ChatGenerationChunk({\n            text: contentBlockDelta.delta.text,\n            message: new messages_1.AIMessageChunk({\n                content: contentBlockDelta.delta.text,\n            }),\n        });\n    }\n    else if (contentBlockDelta.delta.toolUse) {\n        const index = contentBlockDelta.contentBlockIndex;\n        return new outputs_1.ChatGenerationChunk({\n            text: \"\",\n            message: new messages_1.AIMessageChunk({\n                content: \"\",\n                tool_call_chunks: [\n                    {\n                        args: contentBlockDelta.delta.toolUse.input,\n                        index,\n                        type: \"tool_call_chunk\",\n                    },\n                ],\n            }),\n        });\n    }\n    else if (contentBlockDelta.delta.reasoningContent) {\n        return new outputs_1.ChatGenerationChunk({\n            text: \"\",\n            message: new messages_1.AIMessageChunk({\n                content: [\n                    bedrockReasoningDeltaToLangchainPartialReasoningBlock(contentBlockDelta.delta.reasoningContent),\n                ],\n            }),\n        });\n    }\n    else {\n        throw new Error(`Unsupported content block type(s): ${JSON.stringify(contentBlockDelta.delta, null, 2)}`);\n    }\n}\nfunction handleConverseStreamContentBlockStart(contentBlockStart) {\n    const index = contentBlockStart.contentBlockIndex;\n    if (contentBlockStart.start?.toolUse) {\n        return new outputs_1.ChatGenerationChunk({\n            text: \"\",\n            message: new messages_1.AIMessageChunk({\n                content: \"\",\n                tool_call_chunks: [\n                    {\n                        name: contentBlockStart.start.toolUse.name,\n                        id: contentBlockStart.start.toolUse.toolUseId,\n                        index,\n                        type: \"tool_call_chunk\",\n                    },\n                ],\n            }),\n        });\n    }\n    throw new Error(\"Unsupported content block start event.\");\n}\nfunction handleConverseStreamMetadata(metadata, extra) {\n    const inputTokens = metadata.usage?.inputTokens ?? 0;\n    const outputTokens = metadata.usage?.outputTokens ?? 0;\n    const usage_metadata = {\n        input_tokens: inputTokens,\n        output_tokens: outputTokens,\n        total_tokens: metadata.usage?.totalTokens ?? inputTokens + outputTokens,\n    };\n    return new outputs_1.ChatGenerationChunk({\n        text: \"\",\n        message: new messages_1.AIMessageChunk({\n            content: \"\",\n            usage_metadata: extra.streamUsage ? usage_metadata : undefined,\n            response_metadata: {\n                // Use the same key as returned from the Converse API\n                metadata,\n            },\n        }),\n    });\n}\nfunction bedrockReasoningDeltaToLangchainPartialReasoningBlock(reasoningContent) {\n    const { text, redactedContent, signature } = reasoningContent;\n    if (typeof text === \"string\") {\n        return {\n            type: \"reasoning_content\",\n            reasoningText: { text },\n        };\n    }\n    if (signature) {\n        return {\n            type: \"reasoning_content\",\n            reasoningText: { signature },\n        };\n    }\n    if (redactedContent) {\n        return {\n            type: \"reasoning_content\",\n            redactedContent: Buffer.from(redactedContent).toString(\"base64\"),\n        };\n    }\n    throw new Error(\"Invalid reasoning content\");\n}\nfunction bedrockReasoningBlockToLangchainReasoningBlock(reasoningContent) {\n    const { reasoningText, redactedContent } = reasoningContent;\n    if (reasoningText) {\n        return {\n            type: \"reasoning_content\",\n            reasoningText: reasoningText,\n        };\n    }\n    if (redactedContent) {\n        return {\n            type: \"reasoning_content\",\n            redactedContent: Buffer.from(redactedContent).toString(\"base64\"),\n        };\n    }\n    throw new Error(\"Invalid reasoning content\");\n}\nfunction langchainReasoningBlockToBedrockReasoningBlock(content) {\n    if (content.type !== \"reasoning_content\") {\n        throw new Error(\"Invalid reasoning content\");\n    }\n    if (\"reasoningText\" in content) {\n        return {\n            reasoningText: content.reasoningText,\n        };\n    }\n    if (\"redactedContent\" in content) {\n        return {\n            redactedContent: Buffer.from(content.redactedContent, \"base64\"),\n        };\n    }\n    throw new Error(\"Invalid reasoning content\");\n}\nfunction concatenateLangchainReasoningBlocks(content) {\n    const concatenatedBlocks = [];\n    let concatenatedBlock = {};\n    for (const block of content) {\n        if (block.type !== \"reasoning_content\") {\n            // if it's some other block type, end the current block, but keep it so we preserve order\n            if (Object.keys(concatenatedBlock).length > 0) {\n                concatenatedBlocks.push(concatenatedBlock);\n                concatenatedBlock = {};\n            }\n            concatenatedBlocks.push(block);\n            continue;\n        }\n        // non-redacted block\n        if (\"reasoningText\" in block && typeof block.reasoningText === \"object\") {\n            if (\"redactedContent\" in concatenatedBlock) {\n                // new type of block, so end the previous one\n                concatenatedBlocks.push(concatenatedBlock);\n                concatenatedBlock = {};\n            }\n            const { text, signature } = block.reasoningText;\n            const { text: prevText, signature: prevSignature } = (\"reasoningText\" in concatenatedBlock\n                ? concatenatedBlock.reasoningText\n                : {});\n            concatenatedBlock = {\n                type: \"reasoning_content\",\n                reasoningText: {\n                    ...(concatenatedBlock\n                        .reasoningText ?? {}),\n                    ...(prevText !== undefined || text !== undefined\n                        ? { text: (prevText ?? \"\") + (text ?? \"\") }\n                        : {}),\n                    ...(prevSignature !== undefined || signature !== undefined\n                        ? { signature: (prevSignature ?? \"\") + (signature ?? \"\") }\n                        : {}),\n                },\n            };\n            // if a partial block chunk has a signature, the next one will begin a new reasoning block.\n            // full blocks always have signatures, so we start one now, anyway\n            if (\"signature\" in block.reasoningText) {\n                concatenatedBlocks.push(concatenatedBlock);\n                concatenatedBlock = {};\n            }\n        }\n        if (\"redactedContent\" in block) {\n            if (\"reasoningText\" in concatenatedBlock) {\n                // New type of block, so end the previous one. We should't really hit\n                // this, as we'll have created a new block upon encountering the\n                // signature above, but better safe than sorry.\n                concatenatedBlocks.push(concatenatedBlock);\n                concatenatedBlock = {};\n            }\n            const { redactedContent } = block;\n            const prevRedactedContent = (\"redactedContent\" in concatenatedBlock\n                ? concatenatedBlock.redactedContent\n                : \"\");\n            concatenatedBlock = {\n                type: \"reasoning_content\",\n                redactedContent: prevRedactedContent + redactedContent,\n            };\n        }\n    }\n    if (Object.keys(concatenatedBlock).length > 0) {\n        concatenatedBlocks.push(concatenatedBlock);\n    }\n    return concatenatedBlocks;\n}\nfunction supportedToolChoiceValuesForModel(model) {\n    if (model.includes(\"claude-3\") ||\n        model.includes(\"claude-4\") ||\n        model.includes(\"claude-opus-4\") ||\n        model.includes(\"claude-sonnet-4\")) {\n        return [\"auto\", \"any\", \"tool\"];\n    }\n    if (model.includes(\"mistral-large\")) {\n        return [\"auto\", \"any\"];\n    }\n    return undefined;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9hd3MvZGlzdC9jb21tb24uY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4QixpQ0FBaUM7QUFDakMscUJBQXFCO0FBQ3JCLDhCQUE4QjtBQUM5QixrQ0FBa0M7QUFDbEMsZ0RBQWdEO0FBQ2hELDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0Msb0NBQW9DO0FBQ3BDLDZEQUE2RDtBQUM3RCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELDJDQUEyQztBQUMzQyx5Q0FBeUM7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsbUZBQTBCO0FBQ3JELGVBQWUsbUJBQU8sQ0FBQywyR0FBc0M7QUFDN0QsMkJBQTJCLG1CQUFPLENBQUMsK0dBQXdDO0FBQzNFLGtCQUFrQixtQkFBTyxDQUFDLGlGQUF5QjtBQUNuRCxnQkFBZ0IsbUJBQU8sQ0FBQyx5RkFBNkI7QUFDckQsc0JBQXNCLG1CQUFPLENBQUMscUdBQW1DO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZ0JBQWdCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGtCQUFrQjtBQUNqRjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxvQ0FBb0Msb0JBQW9CLEdBQUcsdUJBQXVCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQixHQUFHLHVCQUF1QjtBQUNsRjtBQUNBO0FBQ0Esb0VBQW9FLGdCQUFnQixzQ0FBc0Msa0RBQWtEO0FBQzVLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsa0JBQWtCO0FBQzVFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsOERBQThELDZCQUE2QjtBQUMzRjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFdBQVc7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsNkNBQTZDLEVBQUUsV0FBVztBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsWUFBWSxrQkFBa0IscUNBQXFDO0FBQ3RJO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxjQUFjO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGNBQWM7QUFDdkU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFlBQVk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGNBQWM7QUFDdkMsK0JBQStCLGVBQWU7QUFDOUMsc0NBQXNDLG9DQUFvQztBQUMxRTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixhQUFhO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwrQkFBK0IsNEJBQTRCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSw4REFBOEQsaURBQWlEO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSxtQ0FBbUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlDQUFpQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QyxvQkFBb0IsMkNBQTJDO0FBQy9EO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1QjtBQUNBLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9hd3MvZGlzdC9jb21tb24uY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHRyYWN0SW1hZ2VJbmZvID0gZXh0cmFjdEltYWdlSW5mbztcbmV4cG9ydHMuY29udmVydFRvQ29udmVyc2VNZXNzYWdlcyA9IGNvbnZlcnRUb0NvbnZlcnNlTWVzc2FnZXM7XG5leHBvcnRzLmlzQmVkcm9ja1Rvb2wgPSBpc0JlZHJvY2tUb29sO1xuZXhwb3J0cy5jb252ZXJ0VG9Db252ZXJzZVRvb2xzID0gY29udmVydFRvQ29udmVyc2VUb29scztcbmV4cG9ydHMuY29udmVydFRvQmVkcm9ja1Rvb2xDaG9pY2UgPSBjb252ZXJ0VG9CZWRyb2NrVG9vbENob2ljZTtcbmV4cG9ydHMuY29udmVydENvbnZlcnNlTWVzc2FnZVRvTGFuZ0NoYWluTWVzc2FnZSA9IGNvbnZlcnRDb252ZXJzZU1lc3NhZ2VUb0xhbmdDaGFpbk1lc3NhZ2U7XG5leHBvcnRzLmhhbmRsZUNvbnZlcnNlU3RyZWFtQ29udGVudEJsb2NrRGVsdGEgPSBoYW5kbGVDb252ZXJzZVN0cmVhbUNvbnRlbnRCbG9ja0RlbHRhO1xuZXhwb3J0cy5oYW5kbGVDb252ZXJzZVN0cmVhbUNvbnRlbnRCbG9ja1N0YXJ0ID0gaGFuZGxlQ29udmVyc2VTdHJlYW1Db250ZW50QmxvY2tTdGFydDtcbmV4cG9ydHMuaGFuZGxlQ29udmVyc2VTdHJlYW1NZXRhZGF0YSA9IGhhbmRsZUNvbnZlcnNlU3RyZWFtTWV0YWRhdGE7XG5leHBvcnRzLmJlZHJvY2tSZWFzb25pbmdEZWx0YVRvTGFuZ2NoYWluUGFydGlhbFJlYXNvbmluZ0Jsb2NrID0gYmVkcm9ja1JlYXNvbmluZ0RlbHRhVG9MYW5nY2hhaW5QYXJ0aWFsUmVhc29uaW5nQmxvY2s7XG5leHBvcnRzLmJlZHJvY2tSZWFzb25pbmdCbG9ja1RvTGFuZ2NoYWluUmVhc29uaW5nQmxvY2sgPSBiZWRyb2NrUmVhc29uaW5nQmxvY2tUb0xhbmdjaGFpblJlYXNvbmluZ0Jsb2NrO1xuZXhwb3J0cy5sYW5nY2hhaW5SZWFzb25pbmdCbG9ja1RvQmVkcm9ja1JlYXNvbmluZ0Jsb2NrID0gbGFuZ2NoYWluUmVhc29uaW5nQmxvY2tUb0JlZHJvY2tSZWFzb25pbmdCbG9jaztcbmV4cG9ydHMuY29uY2F0ZW5hdGVMYW5nY2hhaW5SZWFzb25pbmdCbG9ja3MgPSBjb25jYXRlbmF0ZUxhbmdjaGFpblJlYXNvbmluZ0Jsb2NrcztcbmV4cG9ydHMuc3VwcG9ydGVkVG9vbENob2ljZVZhbHVlc0Zvck1vZGVsID0gc3VwcG9ydGVkVG9vbENob2ljZVZhbHVlc0Zvck1vZGVsO1xuY29uc3QgbWVzc2FnZXNfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvbWVzc2FnZXNcIik7XG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL2xhbmd1YWdlX21vZGVscy9iYXNlXCIpO1xuY29uc3QgZnVuY3Rpb25fY2FsbGluZ18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS91dGlscy9mdW5jdGlvbl9jYWxsaW5nXCIpO1xuY29uc3Qgb3V0cHV0c18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9vdXRwdXRzXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvdXRpbHMvdHlwZXNcIik7XG5jb25zdCBqc29uX3NjaGVtYV8xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS91dGlscy9qc29uX3NjaGVtYVwiKTtcbmZ1bmN0aW9uIGlzRGVmYXVsdENhY2hlUG9pbnQoYmxvY2spIHtcbiAgICByZXR1cm4gQm9vbGVhbih0eXBlb2YgYmxvY2sgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgYmxvY2sgIT09IG51bGwgJiZcbiAgICAgICAgXCJjYWNoZVBvaW50XCIgaW4gYmxvY2sgJiZcbiAgICAgICAgYmxvY2suY2FjaGVQb2ludCAmJlxuICAgICAgICB0eXBlb2YgYmxvY2suY2FjaGVQb2ludCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBibG9jay5jYWNoZVBvaW50ICE9PSBudWxsICYmXG4gICAgICAgIFwidHlwZVwiIGluIGJsb2NrLmNhY2hlUG9pbnQgJiZcbiAgICAgICAgYmxvY2suY2FjaGVQb2ludC50eXBlID09PSBcImRlZmF1bHRcIik7XG59XG5jb25zdCBzdGFuZGFyZENvbnRlbnRCbG9ja0NvbnZlcnRlciA9IHtcbiAgICBwcm92aWRlck5hbWU6IFwiQ2hhdEJlZHJvY2tDb252ZXJzZVwiLFxuICAgIGZyb21TdGFuZGFyZFRleHRCbG9jayhibG9jaykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogYmxvY2sudGV4dCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGZyb21TdGFuZGFyZEltYWdlQmxvY2soYmxvY2spIHtcbiAgICAgICAgbGV0IGZvcm1hdDtcbiAgICAgICAgaWYgKGJsb2NrLnNvdXJjZV90eXBlID09PSBcInVybFwiKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWREYXRhID0gKDAsIG1lc3NhZ2VzXzEucGFyc2VCYXNlNjREYXRhVXJsKSh7XG4gICAgICAgICAgICAgICAgZGF0YVVybDogYmxvY2sudXJsLFxuICAgICAgICAgICAgICAgIGFzVHlwZWRBcnJheTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHBhcnNlZERhdGEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRNaW1lVHlwZSA9ICgwLCBtZXNzYWdlc18xLnBhcnNlTWltZVR5cGUpKHBhcnNlZERhdGEubWltZV90eXBlKTtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBwYXJzZWRNaW1lVHlwZS50eXBlO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlczogcGFyc2VkRGF0YS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBiYXNlNjQgZGF0YSBVUkxzIGFyZSBzdXBwb3J0ZWQgZm9yIGltYWdlIGJsb2NrcyB3aXRoIHNvdXJjZSB0eXBlICd1cmwnIHdpdGggQ2hhdEJlZHJvY2tDb252ZXJzZS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmxvY2suc291cmNlX3R5cGUgPT09IFwiYmFzZTY0XCIpIHtcbiAgICAgICAgICAgIGlmIChibG9jay5taW1lX3R5cGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRNaW1lVHlwZSA9ICgwLCBtZXNzYWdlc18xLnBhcnNlTWltZVR5cGUpKGJsb2NrLm1pbWVfdHlwZSk7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gcGFyc2VkTWltZVR5cGUuc3VidHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXQgJiYgIVtcImdpZlwiLCBcImpwZWdcIiwgXCJwbmdcIiwgXCJ3ZWJwXCJdLmluY2x1ZGVzKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGltYWdlIG1pbWUgdHlwZTogXCIke2Jsb2NrLm1pbWVfdHlwZX1cIiBDaGF0QmVkcm9ja0NvbnZlcnNlIG9ubHkgc3VwcG9ydHMgXCJpbWFnZS9naWZcIiwgXCJpbWFnZS9qcGVnXCIsIFwiaW1hZ2UvcG5nXCIsIGFuZCBcImltYWdlL3dlYnBcIiBmb3JtYXRzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbWFnZToge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXM6IFVpbnQ4QXJyYXkuZnJvbShhdG9iKGJsb2NrLmRhdGEpLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChibG9jay5zb3VyY2VfdHlwZSA9PT0gXCJpZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBzb3VyY2UgdHlwZSAnaWQnIG5vdCBzdXBwb3J0ZWQgd2l0aCBDaGF0QmVkcm9ja0NvbnZlcnNlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgaW1hZ2Ugc291cmNlIHR5cGU6IFwiJHtibG9jay5zb3VyY2VfdHlwZX1cIiB3aXRoIENoYXRCZWRyb2NrQ29udmVyc2UuYCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGZyb21TdGFuZGFyZEZpbGVCbG9jayhibG9jaykge1xuICAgICAgICBjb25zdCBtaW1lVHlwZVRvRG9jdW1lbnRGb3JtYXQgPSB7XG4gICAgICAgICAgICBcInRleHQvY3N2XCI6IFwiY3N2XCIsXG4gICAgICAgICAgICBcImFwcGxpY2F0aW9uL21zd29yZFwiOiBcImRvY1wiLFxuICAgICAgICAgICAgXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5kb2N1bWVudFwiOiBcImRvY3hcIixcbiAgICAgICAgICAgIFwidGV4dC9odG1sXCI6IFwiaHRtbFwiLFxuICAgICAgICAgICAgXCJ0ZXh0L21hcmtkb3duXCI6IFwibWRcIixcbiAgICAgICAgICAgIFwiYXBwbGljYXRpb24vcGRmXCI6IFwicGRmXCIsXG4gICAgICAgICAgICBcInRleHQvcGxhaW5cIjogXCJ0eHRcIixcbiAgICAgICAgICAgIFwiYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsXCI6IFwieGxzXCIsXG4gICAgICAgICAgICBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnNoZWV0XCI6IFwieGxzeFwiLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBuYW1lID0gKGJsb2NrLm1ldGFkYXRhPy5uYW1lID8/XG4gICAgICAgICAgICBibG9jay5tZXRhZGF0YT8uZmlsZW5hbWUgPz9cbiAgICAgICAgICAgIGJsb2NrLm1ldGFkYXRhPy50aXRsZSk7XG4gICAgICAgIGlmIChibG9jay5zb3VyY2VfdHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBcInR4dFwiLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzOiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoYmxvY2sudGV4dCksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2NrLnNvdXJjZV90eXBlID09PSBcInVybFwiKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWREYXRhID0gKDAsIG1lc3NhZ2VzXzEucGFyc2VCYXNlNjREYXRhVXJsKSh7XG4gICAgICAgICAgICAgICAgZGF0YVVybDogYmxvY2sudXJsLFxuICAgICAgICAgICAgICAgIGFzVHlwZWRBcnJheTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHBhcnNlZERhdGEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRNaW1lVHlwZSA9ICgwLCBtZXNzYWdlc18xLnBhcnNlTWltZVR5cGUpKHBhcnNlZERhdGEubWltZV90eXBlID8/IGJsb2NrLm1pbWVfdHlwZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWltZVR5cGUgPSBgJHtwYXJzZWRNaW1lVHlwZS50eXBlfS8ke3BhcnNlZE1pbWVUeXBlLnN1YnR5cGV9YDtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3JtYXQgPSBtaW1lVHlwZVRvRG9jdW1lbnRGb3JtYXRbbWltZVR5cGVdO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXM6IHBhcnNlZERhdGEuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgYmFzZTY0IGRhdGEgVVJMcyBhcmUgc3VwcG9ydGVkIGZvciBmaWxlIGJsb2NrcyB3aXRoIHNvdXJjZSB0eXBlICd1cmwnIHdpdGggQ2hhdEJlZHJvY2tDb252ZXJzZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2NrLnNvdXJjZV90eXBlID09PSBcImJhc2U2NFwiKSB7XG4gICAgICAgICAgICBsZXQgZm9ybWF0O1xuICAgICAgICAgICAgaWYgKGJsb2NrLm1pbWVfdHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZE1pbWVUeXBlID0gKDAsIG1lc3NhZ2VzXzEucGFyc2VNaW1lVHlwZSkoYmxvY2subWltZV90eXBlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtaW1lVHlwZSA9IGAke3BhcnNlZE1pbWVUeXBlLnR5cGV9LyR7cGFyc2VkTWltZVR5cGUuc3VidHlwZX1gO1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IG1pbWVUeXBlVG9Eb2N1bWVudEZvcm1hdFttaW1lVHlwZV07XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZmlsZSBtaW1lIHR5cGU6IFwiJHtibG9jay5taW1lX3R5cGV9XCIgQ2hhdEJlZHJvY2tDb252ZXJzZSBvbmx5IHN1cHBvcnRzICR7T2JqZWN0LmtleXMobWltZVR5cGVUb0RvY3VtZW50Rm9ybWF0KS5qb2luKFwiLCBcIil9IGZvcm1hdHMuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudDoge1xuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXM6IFVpbnQ4QXJyYXkuZnJvbShhdG9iKGJsb2NrLmRhdGEpLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2suc291cmNlX3R5cGUgPT09IFwiaWRcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmlsZSBzb3VyY2UgdHlwZSAnaWQnIG5vdCBzdXBwb3J0ZWQgd2l0aCBDaGF0QmVkcm9ja0NvbnZlcnNlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGZpbGUgc291cmNlIHR5cGU6IFwiJHtibG9jay5zb3VyY2VfdHlwZX1cIiB3aXRoIENoYXRCZWRyb2NrQ29udmVyc2UuYCk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBleHRyYWN0SW1hZ2VJbmZvKGJhc2U2NCkge1xuICAgIC8vIEV4dHJhY3QgdGhlIGZvcm1hdCBmcm9tIHRoZSBiYXNlNjQgc3RyaW5nXG4gICAgY29uc3QgZm9ybWF0TWF0Y2ggPSBiYXNlNjQubWF0Y2goL15kYXRhOmltYWdlXFwvKFxcdyspO2Jhc2U2NCwvKTtcbiAgICBsZXQgZm9ybWF0O1xuICAgIGlmIChmb3JtYXRNYXRjaCkge1xuICAgICAgICBjb25zdCBleHRyYWN0ZWRGb3JtYXQgPSBmb3JtYXRNYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoW1wiZ2lmXCIsIFwianBlZ1wiLCBcInBuZ1wiLCBcIndlYnBcIl0uaW5jbHVkZXMoZXh0cmFjdGVkRm9ybWF0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZXh0cmFjdGVkRm9ybWF0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGUgZGF0YSBVUkwgcHJlZml4IGlmIHByZXNlbnRcbiAgICBjb25zdCBiYXNlNjREYXRhID0gYmFzZTY0LnJlcGxhY2UoL15kYXRhOmltYWdlXFwvXFx3KztiYXNlNjQsLywgXCJcIik7XG4gICAgLy8gQ29udmVydCBiYXNlNjQgdG8gVWludDhBcnJheVxuICAgIGNvbnN0IGJpbmFyeVN0cmluZyA9IGF0b2IoYmFzZTY0RGF0YSk7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShiaW5hcnlTdHJpbmcubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBieXRlc1tpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpbWFnZToge1xuICAgICAgICAgICAgZm9ybWF0LFxuICAgICAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgICAgICAgYnl0ZXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0TGFuZ0NoYWluQ29udGVudEJsb2NrVG9Db252ZXJzZUNvbnRlbnRCbG9jayh7IGJsb2NrLCBvblVua25vd24gPSBcInRocm93XCIsIH0pIHtcbiAgICBpZiAodHlwZW9mIGJsb2NrID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7IHRleHQ6IGJsb2NrIH07XG4gICAgfVxuICAgIGlmICgoMCwgbWVzc2FnZXNfMS5pc0RhdGFDb250ZW50QmxvY2spKGJsb2NrKSkge1xuICAgICAgICByZXR1cm4gKDAsIG1lc3NhZ2VzXzEuY29udmVydFRvUHJvdmlkZXJDb250ZW50QmxvY2spKGJsb2NrLCBzdGFuZGFyZENvbnRlbnRCbG9ja0NvbnZlcnRlcik7XG4gICAgfVxuICAgIGlmIChibG9jay50eXBlID09PSBcInRleHRcIikge1xuICAgICAgICByZXR1cm4geyB0ZXh0OiBibG9jay50ZXh0IH07XG4gICAgfVxuICAgIGlmIChibG9jay50eXBlID09PSBcImltYWdlX3VybFwiKSB7XG4gICAgICAgIHJldHVybiBleHRyYWN0SW1hZ2VJbmZvKHR5cGVvZiBibG9jay5pbWFnZV91cmwgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8gYmxvY2suaW1hZ2VfdXJsXG4gICAgICAgICAgICA6IGJsb2NrLmltYWdlX3VybC51cmwpO1xuICAgIH1cbiAgICBpZiAoYmxvY2sudHlwZSA9PT0gXCJkb2N1bWVudFwiICYmIGJsb2NrLmRvY3VtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvY3VtZW50OiBibG9jay5kb2N1bWVudCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGJsb2NrLnR5cGUgPT09IFwiaW1hZ2VcIiAmJiBibG9jay5pbWFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbWFnZTogYmxvY2suaW1hZ2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChpc0RlZmF1bHRDYWNoZVBvaW50KGJsb2NrKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FjaGVQb2ludDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG9uVW5rbm93biA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29udGVudCBibG9jayB0eXBlOiAke2Jsb2NrLnR5cGV9YCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxufVxuZnVuY3Rpb24gY29udmVydFN5c3RlbU1lc3NhZ2VUb0NvbnZlcnNlTWVzc2FnZShtc2cpIHtcbiAgICBpZiAodHlwZW9mIG1zZy5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBbeyB0ZXh0OiBtc2cuY29udGVudCB9XTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtc2cuY29udGVudCkgJiYgbXNnLmNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBjb250ZW50QmxvY2tzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgYmxvY2sgb2YgbXNnLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIGlmIChibG9jay50eXBlID09PSBcInRleHRcIiAmJiB0eXBlb2YgYmxvY2sudGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRCbG9ja3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGJsb2NrLnRleHQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0RlZmF1bHRDYWNoZVBvaW50KGJsb2NrKSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRCbG9ja3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlUG9pbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtc2cuY29udGVudC5sZW5ndGggPT09IGNvbnRlbnRCbG9ja3MubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRCbG9ja3M7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlN5c3RlbSBtZXNzYWdlIGNvbnRlbnQgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIHRleHQgYmxvY2tzLCBvcHRpb25hbGx5IGluY2x1ZGluZyBhIGNhY2hlIHBvaW50LlwiKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRBSU1lc3NhZ2VUb0NvbnZlcnNlTWVzc2FnZShtc2cpIHtcbiAgICBjb25zdCBhc3Npc3RhbnRNc2cgPSB7XG4gICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgIGNvbnRlbnQ6IFtdLFxuICAgIH07XG4gICAgaWYgKHR5cGVvZiBtc2cuY29udGVudCA9PT0gXCJzdHJpbmdcIiAmJiBtc2cuY29udGVudCAhPT0gXCJcIikge1xuICAgICAgICBhc3Npc3RhbnRNc2cuY29udGVudD8ucHVzaCh7XG4gICAgICAgICAgICB0ZXh0OiBtc2cuY29udGVudCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobXNnLmNvbnRlbnQpKSB7XG4gICAgICAgIGNvbnN0IGNvbmNhdGVuYXRlZEJsb2NrcyA9IGNvbmNhdGVuYXRlTGFuZ2NoYWluUmVhc29uaW5nQmxvY2tzKG1zZy5jb250ZW50KTtcbiAgICAgICAgY29uc3QgY29udGVudEJsb2NrcyA9IFtdO1xuICAgICAgICBjb25jYXRlbmF0ZWRCbG9ja3MuZm9yRWFjaCgoYmxvY2spID0+IHtcbiAgICAgICAgICAgIGlmIChibG9jay50eXBlID09PSBcInRleHRcIiAmJiBibG9jay50ZXh0ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgLy8gTWVyZ2Ugd2hpdGVzcGFjZS9uZXdsaW5lcyB3aXRoIHByZXZpb3VzIHRleHQgYmxvY2tzIHRvIGF2b2lkIHZhbGlkYXRpb24gZXJyb3JzLlxuICAgICAgICAgICAgICAgIGNvbnN0IGNsZWFuZWRUZXh0ID0gYmxvY2sudGV4dD8ucmVwbGFjZSgvXFxuL2csIFwiXCIpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xlYW5lZFRleHQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRCbG9ja3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVyZ2VkVGV4dENvbnRlbnQgPSBgJHtjb250ZW50QmxvY2tzW2NvbnRlbnRCbG9ja3MubGVuZ3RoIC0gMV0udGV4dH0ke2Jsb2NrLnRleHR9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRCbG9ja3NbY29udGVudEJsb2Nrcy5sZW5ndGggLSAxXS50ZXh0ID0gbWVyZ2VkVGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRCbG9ja3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBibG9jay50ZXh0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChibG9jay50eXBlID09PSBcInJlYXNvbmluZ19jb250ZW50XCIpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50QmxvY2tzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICByZWFzb25pbmdDb250ZW50OiBsYW5nY2hhaW5SZWFzb25pbmdCbG9ja1RvQmVkcm9ja1JlYXNvbmluZ0Jsb2NrKGJsb2NrKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRGVmYXVsdENhY2hlUG9pbnQoYmxvY2spKSB7XG4gICAgICAgICAgICAgICAgY29udGVudEJsb2Nrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVQb2ludDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkZWZhdWx0XCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBibG9ja1ZhbHVlcyA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhibG9jaykuZmlsdGVyKChba2V5XSkgPT4ga2V5ICE9PSBcInR5cGVcIikpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29udGVudCBibG9jayB0eXBlOiAke2Jsb2NrLnR5cGV9IHdpdGggY29udGVudCBvZiAke0pTT04uc3RyaW5naWZ5KGJsb2NrVmFsdWVzLCBudWxsLCAyKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFzc2lzdGFudE1zZy5jb250ZW50ID0gW1xuICAgICAgICAgICAgLi4uKGFzc2lzdGFudE1zZy5jb250ZW50ID8gYXNzaXN0YW50TXNnLmNvbnRlbnQgOiBbXSksXG4gICAgICAgICAgICAuLi5jb250ZW50QmxvY2tzLFxuICAgICAgICBdO1xuICAgIH1cbiAgICAvLyBJbXBvcnRhbnQ6IHRoaXMgbXVzdCBiZSBwbGFjZWQgYWZ0ZXIgYW55IHJlYXNvbmluZyBjb250ZW50IGJsb2NrcywgZWxzZSBjbGF1ZGUgbW9kZWxzIHdpbGwgcmV0dXJuIGFuIGVycm9yLlxuICAgIGlmIChtc2cudG9vbF9jYWxscyAmJiBtc2cudG9vbF9jYWxscy5sZW5ndGgpIHtcbiAgICAgICAgYXNzaXN0YW50TXNnLmNvbnRlbnQgPSBbXG4gICAgICAgICAgICAuLi4oYXNzaXN0YW50TXNnLmNvbnRlbnQgPyBhc3Npc3RhbnRNc2cuY29udGVudCA6IFtdKSxcbiAgICAgICAgICAgIC4uLm1zZy50b29sX2NhbGxzLm1hcCgodGMpID0+ICh7XG4gICAgICAgICAgICAgICAgdG9vbFVzZToge1xuICAgICAgICAgICAgICAgICAgICB0b29sVXNlSWQ6IHRjLmlkLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0Yy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dDogdGMuYXJncyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gYXNzaXN0YW50TXNnO1xufVxuZnVuY3Rpb24gY29udmVydEh1bWFuTWVzc2FnZVRvQ29udmVyc2VNZXNzYWdlKG1zZykge1xuICAgIGlmIChtc2cuY29udGVudCA9PT0gXCJcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWVzc2FnZSBjb250ZW50OiBlbXB0eSBzdHJpbmcuICcke21zZy5nZXRUeXBlKCl9JyBtdXN0IGNvbnRhaW4gbm9uLWVtcHR5IGNvbnRlbnQuYCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnQgPSBBcnJheS5pc0FycmF5KG1zZy5jb250ZW50KVxuICAgICAgICA/IG1zZy5jb250ZW50Lm1hcCgoYykgPT4gY29udmVydExhbmdDaGFpbkNvbnRlbnRCbG9ja1RvQ29udmVyc2VDb250ZW50QmxvY2soe1xuICAgICAgICAgICAgYmxvY2s6IGMsXG4gICAgICAgICAgICBvblVua25vd246IFwidGhyb3dcIixcbiAgICAgICAgfSkpXG4gICAgICAgIDogW1xuICAgICAgICAgICAgY29udmVydExhbmdDaGFpbkNvbnRlbnRCbG9ja1RvQ29udmVyc2VDb250ZW50QmxvY2soe1xuICAgICAgICAgICAgICAgIGJsb2NrOiBtc2cuY29udGVudCxcbiAgICAgICAgICAgICAgICBvblVua25vd246IFwidGhyb3dcIixcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICBjb250ZW50LFxuICAgIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9vbE1lc3NhZ2VUb0NvbnZlcnNlTWVzc2FnZShtc2cpIHtcbiAgICBjb25zdCBjYXN0TXNnID0gbXNnO1xuICAgIGlmICh0eXBlb2YgY2FzdE1zZy5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBUb29sIHVzZSBtZXNzYWdlcyBhcmUgYWx3YXlzIGZyb20gdGhlIHVzZXJcbiAgICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbFJlc3VsdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbFVzZUlkOiBjYXN0TXNnLnRvb2xfY2FsbF9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNhc3RNc2cuY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBUb29sIHVzZSBtZXNzYWdlcyBhcmUgYWx3YXlzIGZyb20gdGhlIHVzZXJcbiAgICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbFJlc3VsdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbFVzZUlkOiBjYXN0TXNnLnRvb2xfY2FsbF9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG1zZy5jb250ZW50Lm1hcCgoYykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRlZCA9IGNvbnZlcnRMYW5nQ2hhaW5Db250ZW50QmxvY2tUb0NvbnZlcnNlQ29udGVudEJsb2NrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2s6IGMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uVW5rbm93bjogXCJyZXR1cm5Vbm1vZGlmaWVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnZlcnRlZCAhPT0gYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBqc29uOiBjIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Db252ZXJzZU1lc3NhZ2VzKG1lc3NhZ2VzKSB7XG4gICAgY29uc3QgY29udmVyc2VTeXN0ZW0gPSBtZXNzYWdlc1xuICAgICAgICAuZmlsdGVyKChtc2cpID0+IG1zZy5nZXRUeXBlKCkgPT09IFwic3lzdGVtXCIpXG4gICAgICAgIC5mbGF0TWFwKChtc2cpID0+IGNvbnZlcnRTeXN0ZW1NZXNzYWdlVG9Db252ZXJzZU1lc3NhZ2UobXNnKSk7XG4gICAgY29uc3QgY29udmVyc2VNZXNzYWdlcyA9IG1lc3NhZ2VzXG4gICAgICAgIC5maWx0ZXIoKG1zZykgPT4gbXNnLmdldFR5cGUoKSAhPT0gXCJzeXN0ZW1cIilcbiAgICAgICAgLm1hcCgobXNnKSA9PiB7XG4gICAgICAgIGlmIChtc2cuZ2V0VHlwZSgpID09PSBcImFpXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0QUlNZXNzYWdlVG9Db252ZXJzZU1lc3NhZ2UobXNnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtc2cuZ2V0VHlwZSgpID09PSBcImh1bWFuXCIgfHwgbXNnLmdldFR5cGUoKSA9PT0gXCJnZW5lcmljXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0SHVtYW5NZXNzYWdlVG9Db252ZXJzZU1lc3NhZ2UobXNnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtc2cuZ2V0VHlwZSgpID09PSBcInRvb2xcIikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb29sTWVzc2FnZVRvQ29udmVyc2VNZXNzYWdlKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG1lc3NhZ2UgdHlwZTogJHttc2cuZ2V0VHlwZSgpfWApO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gQ29tYmluZSBjb25zZWN1dGl2ZSB1c2VyIHRvb2wgcmVzdWx0IG1lc3NhZ2VzIGludG8gYSBzaW5nbGUgbWVzc2FnZVxuICAgIGNvbnN0IGNvbWJpbmVkQ29udmVyc2VNZXNzYWdlcyA9IGNvbnZlcnNlTWVzc2FnZXMucmVkdWNlKChhY2MsIGN1cnIpID0+IHtcbiAgICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSBhY2NbYWNjLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdE1lc3NhZ2UgJiZcbiAgICAgICAgICAgIGxhc3RNZXNzYWdlLnJvbGUgPT09IFwidXNlclwiICYmXG4gICAgICAgICAgICBsYXN0TWVzc2FnZS5jb250ZW50Py5zb21lKChjKSA9PiBcInRvb2xSZXN1bHRcIiBpbiBjKSAmJlxuICAgICAgICAgICAgY3Vyci5yb2xlID09PSBcInVzZXJcIiAmJlxuICAgICAgICAgICAgY3Vyci5jb250ZW50Py5zb21lKChjKSA9PiBcInRvb2xSZXN1bHRcIiBpbiBjKSkge1xuICAgICAgICAgICAgbGFzdE1lc3NhZ2UuY29udGVudCA9IGxhc3RNZXNzYWdlLmNvbnRlbnQuY29uY2F0KGN1cnIuY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY2MucHVzaChjdXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4geyBjb252ZXJzZU1lc3NhZ2VzOiBjb21iaW5lZENvbnZlcnNlTWVzc2FnZXMsIGNvbnZlcnNlU3lzdGVtIH07XG59XG5mdW5jdGlvbiBpc0JlZHJvY2tUb29sKHRvb2wpIHtcbiAgICBpZiAodHlwZW9mIHRvb2wgPT09IFwib2JqZWN0XCIgJiYgdG9vbCAmJiBcInRvb2xTcGVjXCIgaW4gdG9vbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29udmVydFRvQ29udmVyc2VUb29scyh0b29scykge1xuICAgIGlmICh0b29scy5ldmVyeShiYXNlXzEuaXNPcGVuQUlUb29sKSkge1xuICAgICAgICByZXR1cm4gdG9vbHMubWFwKCh0b29sKSA9PiAoe1xuICAgICAgICAgICAgdG9vbFNwZWM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiB0b29sLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHRvb2wuZnVuY3Rpb24uZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgaW5wdXRTY2hlbWE6IHtcbiAgICAgICAgICAgICAgICAgICAganNvbjogdG9vbC5mdW5jdGlvbi5wYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRvb2xzLmV2ZXJ5KGZ1bmN0aW9uX2NhbGxpbmdfMS5pc0xhbmdDaGFpblRvb2wpKSB7XG4gICAgICAgIHJldHVybiB0b29scy5tYXAoKHRvb2wpID0+ICh7XG4gICAgICAgICAgICB0b29sU3BlYzoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHRvb2wubmFtZSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogdG9vbC5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBpbnB1dFNjaGVtYToge1xuICAgICAgICAgICAgICAgICAgICBqc29uOiAoKDAsIHR5cGVzXzEuaXNJbnRlcm9wWm9kU2NoZW1hKSh0b29sLnNjaGVtYSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKDAsIGpzb25fc2NoZW1hXzEudG9Kc29uU2NoZW1hKSh0b29sLnNjaGVtYSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdG9vbC5zY2hlbWEpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRvb2xzLmV2ZXJ5KGlzQmVkcm9ja1Rvb2wpKSB7XG4gICAgICAgIHJldHVybiB0b29scztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0b29scyBwYXNzZWQuIE11c3QgYmUgYW4gYXJyYXkgb2YgU3RydWN0dXJlZFRvb2xJbnRlcmZhY2UsIFRvb2xEZWZpbml0aW9uLCBvciBCZWRyb2NrVG9vbC5cIik7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9CZWRyb2NrVG9vbENob2ljZSh0b29sQ2hvaWNlLCB0b29scywgZmllbGRzKSB7XG4gICAgY29uc3Qgc3VwcG9ydHNUb29sQ2hvaWNlVmFsdWVzID0gZmllbGRzLnN1cHBvcnRzVG9vbENob2ljZVZhbHVlcyA/PyBbXTtcbiAgICBsZXQgYmVkcm9ja1Rvb2xDaG9pY2U7XG4gICAgaWYgKHR5cGVvZiB0b29sQ2hvaWNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHN3aXRjaCAodG9vbENob2ljZSkge1xuICAgICAgICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICAgICAgICAgIGJlZHJvY2tUb29sQ2hvaWNlID0ge1xuICAgICAgICAgICAgICAgICAgICBhbnk6IHt9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYXV0b1wiOlxuICAgICAgICAgICAgICAgIGJlZHJvY2tUb29sQ2hvaWNlID0ge1xuICAgICAgICAgICAgICAgICAgICBhdXRvOiB7fSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kVG9vbCA9IHRvb2xzLmZpbmQoKHRvb2wpID0+IHRvb2wudG9vbFNwZWM/Lm5hbWUgPT09IHRvb2xDaG9pY2UpO1xuICAgICAgICAgICAgICAgIGlmICghZm91bmRUb29sKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9vbCB3aXRoIG5hbWUgJHt0b29sQ2hvaWNlfSBub3QgZm91bmQgaW4gdG9vbHMgbGlzdC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmVkcm9ja1Rvb2xDaG9pY2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2w6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRvb2xDaG9pY2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYmVkcm9ja1Rvb2xDaG9pY2UgPSB0b29sQ2hvaWNlO1xuICAgIH1cbiAgICBjb25zdCB0b29sQ2hvaWNlVHlwZSA9IE9iamVjdC5rZXlzKGJlZHJvY2tUb29sQ2hvaWNlKVswXTtcbiAgICBpZiAoIXN1cHBvcnRzVG9vbENob2ljZVZhbHVlcy5pbmNsdWRlcyh0b29sQ2hvaWNlVHlwZSkpIHtcbiAgICAgICAgbGV0IHN1cHBvcnRlZFR4dCA9IFwiXCI7XG4gICAgICAgIGlmIChzdXBwb3J0c1Rvb2xDaG9pY2VWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdXBwb3J0ZWRUeHQgPVxuICAgICAgICAgICAgICAgIGBNb2RlbCAke2ZpZWxkcy5tb2RlbH0gZG9lcyBub3QgY3VycmVudGx5IHN1cHBvcnQgJ3Rvb2xfY2hvaWNlJyBgICtcbiAgICAgICAgICAgICAgICAgICAgYG9mIHR5cGUgJHt0b29sQ2hvaWNlVHlwZX0uIFRoZSBmb2xsb3dpbmcgJ3Rvb2xfY2hvaWNlJyB0eXBlcyBgICtcbiAgICAgICAgICAgICAgICAgICAgYGFyZSBzdXBwb3J0ZWQ6ICR7c3VwcG9ydHNUb29sQ2hvaWNlVmFsdWVzLmpvaW4oXCIsIFwiKX0uYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1cHBvcnRlZFR4dCA9IGBNb2RlbCAke2ZpZWxkcy5tb2RlbH0gZG9lcyBub3QgY3VycmVudGx5IHN1cHBvcnQgJ3Rvb2xfY2hvaWNlJy5gO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtzdXBwb3J0ZWRUeHR9IFBsZWFzZSBzZWVgICtcbiAgICAgICAgICAgIFwiaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2JlZHJvY2svbGF0ZXN0L0FQSVJlZmVyZW5jZS9BUElfcnVudGltZV9Ub29sQ2hvaWNlLmh0bWxcIiArXG4gICAgICAgICAgICBcImZvciB0aGUgbGF0ZXN0IGRvY3VtZW50YXRpb24gb24gbW9kZWxzIHRoYXQgc3VwcG9ydCB0b29sIGNob2ljZS5cIik7XG4gICAgfVxuICAgIHJldHVybiBiZWRyb2NrVG9vbENob2ljZTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRDb252ZXJzZU1lc3NhZ2VUb0xhbmdDaGFpbk1lc3NhZ2UobWVzc2FnZSwgcmVzcG9uc2VNZXRhZGF0YSkge1xuICAgIGlmICghbWVzc2FnZS5jb250ZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG1lc3NhZ2UgY29udGVudCBmb3VuZCBpbiByZXNwb25zZS5cIik7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLnJvbGUgIT09IFwiYXNzaXN0YW50XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtZXNzYWdlIHJvbGUgcmVjZWl2ZWQgaW4gQ2hhdEJlZHJvY2tDb252ZXJzZSByZXNwb25zZTogJHttZXNzYWdlLnJvbGV9YCk7XG4gICAgfVxuICAgIGxldCByZXF1ZXN0SWQ7XG4gICAgaWYgKFwiJG1ldGFkYXRhXCIgaW4gcmVzcG9uc2VNZXRhZGF0YSAmJlxuICAgICAgICByZXNwb25zZU1ldGFkYXRhLiRtZXRhZGF0YSAmJlxuICAgICAgICB0eXBlb2YgcmVzcG9uc2VNZXRhZGF0YS4kbWV0YWRhdGEgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgXCJyZXF1ZXN0SWRcIiBpbiByZXNwb25zZU1ldGFkYXRhLiRtZXRhZGF0YSkge1xuICAgICAgICByZXF1ZXN0SWQgPSByZXNwb25zZU1ldGFkYXRhLiRtZXRhZGF0YS5yZXF1ZXN0SWQ7XG4gICAgfVxuICAgIGxldCB0b2tlblVzYWdlO1xuICAgIGlmIChyZXNwb25zZU1ldGFkYXRhLnVzYWdlKSB7XG4gICAgICAgIGNvbnN0IGlucHV0X3Rva2VucyA9IHJlc3BvbnNlTWV0YWRhdGEudXNhZ2UuaW5wdXRUb2tlbnMgPz8gMDtcbiAgICAgICAgY29uc3Qgb3V0cHV0X3Rva2VucyA9IHJlc3BvbnNlTWV0YWRhdGEudXNhZ2Uub3V0cHV0VG9rZW5zID8/IDA7XG4gICAgICAgIHRva2VuVXNhZ2UgPSB7XG4gICAgICAgICAgICBpbnB1dF90b2tlbnMsXG4gICAgICAgICAgICBvdXRwdXRfdG9rZW5zLFxuICAgICAgICAgICAgdG90YWxfdG9rZW5zOiByZXNwb25zZU1ldGFkYXRhLnVzYWdlLnRvdGFsVG9rZW5zID8/IGlucHV0X3Rva2VucyArIG91dHB1dF90b2tlbnMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLmNvbnRlbnQ/Lmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBcInRleHRcIiBpbiBtZXNzYWdlLmNvbnRlbnRbMF0gJiZcbiAgICAgICAgdHlwZW9mIG1lc3NhZ2UuY29udGVudFswXS50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBuZXcgbWVzc2FnZXNfMS5BSU1lc3NhZ2Uoe1xuICAgICAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50WzBdLnRleHQsXG4gICAgICAgICAgICByZXNwb25zZV9tZXRhZGF0YTogcmVzcG9uc2VNZXRhZGF0YSxcbiAgICAgICAgICAgIHVzYWdlX21ldGFkYXRhOiB0b2tlblVzYWdlLFxuICAgICAgICAgICAgaWQ6IHJlcXVlc3RJZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBbXTtcbiAgICAgICAgY29uc3QgY29udGVudCA9IFtdO1xuICAgICAgICBtZXNzYWdlLmNvbnRlbnQuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICAgICAgaWYgKFwidG9vbFVzZVwiIGluIGMgJiZcbiAgICAgICAgICAgICAgICBjLnRvb2xVc2UgJiZcbiAgICAgICAgICAgICAgICBjLnRvb2xVc2UubmFtZSAmJlxuICAgICAgICAgICAgICAgIGMudG9vbFVzZS5pbnB1dCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjLnRvb2xVc2UuaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB0b29sQ2FsbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBjLnRvb2xVc2UudG9vbFVzZUlkLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBjLnRvb2xVc2UubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogYy50b29sVXNlLmlucHV0LFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2xfY2FsbFwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoXCJ0ZXh0XCIgaW4gYyAmJiB0eXBlb2YgYy50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IGMudGV4dCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFwicmVhc29uaW5nQ29udGVudFwiIGluIGMpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goYmVkcm9ja1JlYXNvbmluZ0Jsb2NrVG9MYW5nY2hhaW5SZWFzb25pbmdCbG9jayhjLnJlYXNvbmluZ0NvbnRlbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgbWVzc2FnZXNfMS5BSU1lc3NhZ2Uoe1xuICAgICAgICAgICAgY29udGVudDogY29udGVudC5sZW5ndGggPyBjb250ZW50IDogXCJcIixcbiAgICAgICAgICAgIHRvb2xfY2FsbHM6IHRvb2xDYWxscy5sZW5ndGggPyB0b29sQ2FsbHMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICByZXNwb25zZV9tZXRhZGF0YTogcmVzcG9uc2VNZXRhZGF0YSxcbiAgICAgICAgICAgIHVzYWdlX21ldGFkYXRhOiB0b2tlblVzYWdlLFxuICAgICAgICAgICAgaWQ6IHJlcXVlc3RJZCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlQ29udmVyc2VTdHJlYW1Db250ZW50QmxvY2tEZWx0YShjb250ZW50QmxvY2tEZWx0YSkge1xuICAgIGlmICghY29udGVudEJsb2NrRGVsdGEuZGVsdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZGVsdGEgZm91bmQgaW4gY29udGVudCBibG9jay5cIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29udGVudEJsb2NrRGVsdGEuZGVsdGEudGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gbmV3IG91dHB1dHNfMS5DaGF0R2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgIHRleHQ6IGNvbnRlbnRCbG9ja0RlbHRhLmRlbHRhLnRleHQsXG4gICAgICAgICAgICBtZXNzYWdlOiBuZXcgbWVzc2FnZXNfMS5BSU1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICAgICAgY29udGVudDogY29udGVudEJsb2NrRGVsdGEuZGVsdGEudGV4dCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGVudEJsb2NrRGVsdGEuZGVsdGEudG9vbFVzZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IGNvbnRlbnRCbG9ja0RlbHRhLmNvbnRlbnRCbG9ja0luZGV4O1xuICAgICAgICByZXR1cm4gbmV3IG91dHB1dHNfMS5DaGF0R2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBuZXcgbWVzc2FnZXNfMS5BSU1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICAgICAgICB0b29sX2NhbGxfY2h1bmtzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IGNvbnRlbnRCbG9ja0RlbHRhLmRlbHRhLnRvb2xVc2UuaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbF9jYWxsX2NodW5rXCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGVudEJsb2NrRGVsdGEuZGVsdGEucmVhc29uaW5nQ29udGVudCkge1xuICAgICAgICByZXR1cm4gbmV3IG91dHB1dHNfMS5DaGF0R2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBuZXcgbWVzc2FnZXNfMS5BSU1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAgICAgICAgICBiZWRyb2NrUmVhc29uaW5nRGVsdGFUb0xhbmdjaGFpblBhcnRpYWxSZWFzb25pbmdCbG9jayhjb250ZW50QmxvY2tEZWx0YS5kZWx0YS5yZWFzb25pbmdDb250ZW50KSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb250ZW50IGJsb2NrIHR5cGUocyk6ICR7SlNPTi5zdHJpbmdpZnkoY29udGVudEJsb2NrRGVsdGEuZGVsdGEsIG51bGwsIDIpfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUNvbnZlcnNlU3RyZWFtQ29udGVudEJsb2NrU3RhcnQoY29udGVudEJsb2NrU3RhcnQpIHtcbiAgICBjb25zdCBpbmRleCA9IGNvbnRlbnRCbG9ja1N0YXJ0LmNvbnRlbnRCbG9ja0luZGV4O1xuICAgIGlmIChjb250ZW50QmxvY2tTdGFydC5zdGFydD8udG9vbFVzZSkge1xuICAgICAgICByZXR1cm4gbmV3IG91dHB1dHNfMS5DaGF0R2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBuZXcgbWVzc2FnZXNfMS5BSU1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICAgICAgICB0b29sX2NhbGxfY2h1bmtzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGNvbnRlbnRCbG9ja1N0YXJ0LnN0YXJ0LnRvb2xVc2UubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjb250ZW50QmxvY2tTdGFydC5zdGFydC50b29sVXNlLnRvb2xVc2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sX2NhbGxfY2h1bmtcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBjb250ZW50IGJsb2NrIHN0YXJ0IGV2ZW50LlwiKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUNvbnZlcnNlU3RyZWFtTWV0YWRhdGEobWV0YWRhdGEsIGV4dHJhKSB7XG4gICAgY29uc3QgaW5wdXRUb2tlbnMgPSBtZXRhZGF0YS51c2FnZT8uaW5wdXRUb2tlbnMgPz8gMDtcbiAgICBjb25zdCBvdXRwdXRUb2tlbnMgPSBtZXRhZGF0YS51c2FnZT8ub3V0cHV0VG9rZW5zID8/IDA7XG4gICAgY29uc3QgdXNhZ2VfbWV0YWRhdGEgPSB7XG4gICAgICAgIGlucHV0X3Rva2VuczogaW5wdXRUb2tlbnMsXG4gICAgICAgIG91dHB1dF90b2tlbnM6IG91dHB1dFRva2VucyxcbiAgICAgICAgdG90YWxfdG9rZW5zOiBtZXRhZGF0YS51c2FnZT8udG90YWxUb2tlbnMgPz8gaW5wdXRUb2tlbnMgKyBvdXRwdXRUb2tlbnMsXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IG91dHB1dHNfMS5DaGF0R2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgbWVzc2FnZTogbmV3IG1lc3NhZ2VzXzEuQUlNZXNzYWdlQ2h1bmsoe1xuICAgICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICAgIHVzYWdlX21ldGFkYXRhOiBleHRyYS5zdHJlYW1Vc2FnZSA/IHVzYWdlX21ldGFkYXRhIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmVzcG9uc2VfbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIHNhbWUga2V5IGFzIHJldHVybmVkIGZyb20gdGhlIENvbnZlcnNlIEFQSVxuICAgICAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSksXG4gICAgfSk7XG59XG5mdW5jdGlvbiBiZWRyb2NrUmVhc29uaW5nRGVsdGFUb0xhbmdjaGFpblBhcnRpYWxSZWFzb25pbmdCbG9jayhyZWFzb25pbmdDb250ZW50KSB7XG4gICAgY29uc3QgeyB0ZXh0LCByZWRhY3RlZENvbnRlbnQsIHNpZ25hdHVyZSB9ID0gcmVhc29uaW5nQ29udGVudDtcbiAgICBpZiAodHlwZW9mIHRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nX2NvbnRlbnRcIixcbiAgICAgICAgICAgIHJlYXNvbmluZ1RleHQ6IHsgdGV4dCB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoc2lnbmF0dXJlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ19jb250ZW50XCIsXG4gICAgICAgICAgICByZWFzb25pbmdUZXh0OiB7IHNpZ25hdHVyZSB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAocmVkYWN0ZWRDb250ZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ19jb250ZW50XCIsXG4gICAgICAgICAgICByZWRhY3RlZENvbnRlbnQ6IEJ1ZmZlci5mcm9tKHJlZGFjdGVkQ29udGVudCkudG9TdHJpbmcoXCJiYXNlNjRcIiksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVhc29uaW5nIGNvbnRlbnRcIik7XG59XG5mdW5jdGlvbiBiZWRyb2NrUmVhc29uaW5nQmxvY2tUb0xhbmdjaGFpblJlYXNvbmluZ0Jsb2NrKHJlYXNvbmluZ0NvbnRlbnQpIHtcbiAgICBjb25zdCB7IHJlYXNvbmluZ1RleHQsIHJlZGFjdGVkQ29udGVudCB9ID0gcmVhc29uaW5nQ29udGVudDtcbiAgICBpZiAocmVhc29uaW5nVGV4dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdfY29udGVudFwiLFxuICAgICAgICAgICAgcmVhc29uaW5nVGV4dDogcmVhc29uaW5nVGV4dCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHJlZGFjdGVkQ29udGVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdfY29udGVudFwiLFxuICAgICAgICAgICAgcmVkYWN0ZWRDb250ZW50OiBCdWZmZXIuZnJvbShyZWRhY3RlZENvbnRlbnQpLnRvU3RyaW5nKFwiYmFzZTY0XCIpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlYXNvbmluZyBjb250ZW50XCIpO1xufVxuZnVuY3Rpb24gbGFuZ2NoYWluUmVhc29uaW5nQmxvY2tUb0JlZHJvY2tSZWFzb25pbmdCbG9jayhjb250ZW50KSB7XG4gICAgaWYgKGNvbnRlbnQudHlwZSAhPT0gXCJyZWFzb25pbmdfY29udGVudFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVhc29uaW5nIGNvbnRlbnRcIik7XG4gICAgfVxuICAgIGlmIChcInJlYXNvbmluZ1RleHRcIiBpbiBjb250ZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWFzb25pbmdUZXh0OiBjb250ZW50LnJlYXNvbmluZ1RleHQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChcInJlZGFjdGVkQ29udGVudFwiIGluIGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlZGFjdGVkQ29udGVudDogQnVmZmVyLmZyb20oY29udGVudC5yZWRhY3RlZENvbnRlbnQsIFwiYmFzZTY0XCIpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlYXNvbmluZyBjb250ZW50XCIpO1xufVxuZnVuY3Rpb24gY29uY2F0ZW5hdGVMYW5nY2hhaW5SZWFzb25pbmdCbG9ja3MoY29udGVudCkge1xuICAgIGNvbnN0IGNvbmNhdGVuYXRlZEJsb2NrcyA9IFtdO1xuICAgIGxldCBjb25jYXRlbmF0ZWRCbG9jayA9IHt9O1xuICAgIGZvciAoY29uc3QgYmxvY2sgb2YgY29udGVudCkge1xuICAgICAgICBpZiAoYmxvY2sudHlwZSAhPT0gXCJyZWFzb25pbmdfY29udGVudFwiKSB7XG4gICAgICAgICAgICAvLyBpZiBpdCdzIHNvbWUgb3RoZXIgYmxvY2sgdHlwZSwgZW5kIHRoZSBjdXJyZW50IGJsb2NrLCBidXQga2VlcCBpdCBzbyB3ZSBwcmVzZXJ2ZSBvcmRlclxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGNvbmNhdGVuYXRlZEJsb2NrKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uY2F0ZW5hdGVkQmxvY2tzLnB1c2goY29uY2F0ZW5hdGVkQmxvY2spO1xuICAgICAgICAgICAgICAgIGNvbmNhdGVuYXRlZEJsb2NrID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25jYXRlbmF0ZWRCbG9ja3MucHVzaChibG9jayk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub24tcmVkYWN0ZWQgYmxvY2tcbiAgICAgICAgaWYgKFwicmVhc29uaW5nVGV4dFwiIGluIGJsb2NrICYmIHR5cGVvZiBibG9jay5yZWFzb25pbmdUZXh0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAoXCJyZWRhY3RlZENvbnRlbnRcIiBpbiBjb25jYXRlbmF0ZWRCbG9jaykge1xuICAgICAgICAgICAgICAgIC8vIG5ldyB0eXBlIG9mIGJsb2NrLCBzbyBlbmQgdGhlIHByZXZpb3VzIG9uZVxuICAgICAgICAgICAgICAgIGNvbmNhdGVuYXRlZEJsb2Nrcy5wdXNoKGNvbmNhdGVuYXRlZEJsb2NrKTtcbiAgICAgICAgICAgICAgICBjb25jYXRlbmF0ZWRCbG9jayA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB0ZXh0LCBzaWduYXR1cmUgfSA9IGJsb2NrLnJlYXNvbmluZ1RleHQ7XG4gICAgICAgICAgICBjb25zdCB7IHRleHQ6IHByZXZUZXh0LCBzaWduYXR1cmU6IHByZXZTaWduYXR1cmUgfSA9IChcInJlYXNvbmluZ1RleHRcIiBpbiBjb25jYXRlbmF0ZWRCbG9ja1xuICAgICAgICAgICAgICAgID8gY29uY2F0ZW5hdGVkQmxvY2sucmVhc29uaW5nVGV4dFxuICAgICAgICAgICAgICAgIDoge30pO1xuICAgICAgICAgICAgY29uY2F0ZW5hdGVkQmxvY2sgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdfY29udGVudFwiLFxuICAgICAgICAgICAgICAgIHJlYXNvbmluZ1RleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uKGNvbmNhdGVuYXRlZEJsb2NrXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVhc29uaW5nVGV4dCA/PyB7fSksXG4gICAgICAgICAgICAgICAgICAgIC4uLihwcmV2VGV4dCAhPT0gdW5kZWZpbmVkIHx8IHRleHQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7IHRleHQ6IChwcmV2VGV4dCA/PyBcIlwiKSArICh0ZXh0ID8/IFwiXCIpIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgICAgICAgICAuLi4ocHJldlNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkIHx8IHNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHsgc2lnbmF0dXJlOiAocHJldlNpZ25hdHVyZSA/PyBcIlwiKSArIChzaWduYXR1cmUgPz8gXCJcIikgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBpZiBhIHBhcnRpYWwgYmxvY2sgY2h1bmsgaGFzIGEgc2lnbmF0dXJlLCB0aGUgbmV4dCBvbmUgd2lsbCBiZWdpbiBhIG5ldyByZWFzb25pbmcgYmxvY2suXG4gICAgICAgICAgICAvLyBmdWxsIGJsb2NrcyBhbHdheXMgaGF2ZSBzaWduYXR1cmVzLCBzbyB3ZSBzdGFydCBvbmUgbm93LCBhbnl3YXlcbiAgICAgICAgICAgIGlmIChcInNpZ25hdHVyZVwiIGluIGJsb2NrLnJlYXNvbmluZ1RleHQpIHtcbiAgICAgICAgICAgICAgICBjb25jYXRlbmF0ZWRCbG9ja3MucHVzaChjb25jYXRlbmF0ZWRCbG9jayk7XG4gICAgICAgICAgICAgICAgY29uY2F0ZW5hdGVkQmxvY2sgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJyZWRhY3RlZENvbnRlbnRcIiBpbiBibG9jaykge1xuICAgICAgICAgICAgaWYgKFwicmVhc29uaW5nVGV4dFwiIGluIGNvbmNhdGVuYXRlZEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgLy8gTmV3IHR5cGUgb2YgYmxvY2ssIHNvIGVuZCB0aGUgcHJldmlvdXMgb25lLiBXZSBzaG91bGQndCByZWFsbHkgaGl0XG4gICAgICAgICAgICAgICAgLy8gdGhpcywgYXMgd2UnbGwgaGF2ZSBjcmVhdGVkIGEgbmV3IGJsb2NrIHVwb24gZW5jb3VudGVyaW5nIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNpZ25hdHVyZSBhYm92ZSwgYnV0IGJldHRlciBzYWZlIHRoYW4gc29ycnkuXG4gICAgICAgICAgICAgICAgY29uY2F0ZW5hdGVkQmxvY2tzLnB1c2goY29uY2F0ZW5hdGVkQmxvY2spO1xuICAgICAgICAgICAgICAgIGNvbmNhdGVuYXRlZEJsb2NrID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHJlZGFjdGVkQ29udGVudCB9ID0gYmxvY2s7XG4gICAgICAgICAgICBjb25zdCBwcmV2UmVkYWN0ZWRDb250ZW50ID0gKFwicmVkYWN0ZWRDb250ZW50XCIgaW4gY29uY2F0ZW5hdGVkQmxvY2tcbiAgICAgICAgICAgICAgICA/IGNvbmNhdGVuYXRlZEJsb2NrLnJlZGFjdGVkQ29udGVudFxuICAgICAgICAgICAgICAgIDogXCJcIik7XG4gICAgICAgICAgICBjb25jYXRlbmF0ZWRCbG9jayA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ19jb250ZW50XCIsXG4gICAgICAgICAgICAgICAgcmVkYWN0ZWRDb250ZW50OiBwcmV2UmVkYWN0ZWRDb250ZW50ICsgcmVkYWN0ZWRDb250ZW50LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXMoY29uY2F0ZW5hdGVkQmxvY2spLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uY2F0ZW5hdGVkQmxvY2tzLnB1c2goY29uY2F0ZW5hdGVkQmxvY2spO1xuICAgIH1cbiAgICByZXR1cm4gY29uY2F0ZW5hdGVkQmxvY2tzO1xufVxuZnVuY3Rpb24gc3VwcG9ydGVkVG9vbENob2ljZVZhbHVlc0Zvck1vZGVsKG1vZGVsKSB7XG4gICAgaWYgKG1vZGVsLmluY2x1ZGVzKFwiY2xhdWRlLTNcIikgfHxcbiAgICAgICAgbW9kZWwuaW5jbHVkZXMoXCJjbGF1ZGUtNFwiKSB8fFxuICAgICAgICBtb2RlbC5pbmNsdWRlcyhcImNsYXVkZS1vcHVzLTRcIikgfHxcbiAgICAgICAgbW9kZWwuaW5jbHVkZXMoXCJjbGF1ZGUtc29ubmV0LTRcIikpIHtcbiAgICAgICAgcmV0dXJuIFtcImF1dG9cIiwgXCJhbnlcIiwgXCJ0b29sXCJdO1xuICAgIH1cbiAgICBpZiAobW9kZWwuaW5jbHVkZXMoXCJtaXN0cmFsLWxhcmdlXCIpKSB7XG4gICAgICAgIHJldHVybiBbXCJhdXRvXCIsIFwiYW55XCJdO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/aws/dist/common.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/aws/dist/embeddings.cjs":
/*!*********************************************************!*\
  !*** ./node_modules/@langchain/aws/dist/embeddings.cjs ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BedrockEmbeddings = void 0;\nconst client_bedrock_runtime_1 = __webpack_require__(/*! @aws-sdk/client-bedrock-runtime */ \"(rsc)/./node_modules/@aws-sdk/client-bedrock-runtime/dist-es/index.js\");\nconst embeddings_1 = __webpack_require__(/*! @langchain/core/embeddings */ \"(rsc)/./node_modules/@langchain/core/embeddings.cjs\");\n/**\n * Class that extends the Embeddings class and provides methods for\n * generating embeddings using the Bedrock API.\n * @example\n * ```typescript\n * const embeddings = new BedrockEmbeddings({\n *   region: \"your-aws-region\",\n *   credentials: {\n *     accessKeyId: \"your-access-key-id\",\n *     secretAccessKey: \"your-secret-access-key\",\n *   },\n *   model: \"amazon.titan-embed-text-v1\",\n *   // Configure client options (e.g., custom request handler)\n *   // clientOptions: {\n *   //   requestHandler: myCustomRequestHandler,\n *   // },\n * });\n *\n * // Embed a query and log the result\n * const res = await embeddings.embedQuery(\n *   \"What would be a good company name for a company that makes colorful socks?\"\n * );\n * console.log({ res });\n * ```\n */\nclass BedrockEmbeddings extends embeddings_1.Embeddings {\n    constructor(fields) {\n        super(fields ?? {});\n        Object.defineProperty(this, \"model\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"clientOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"batchSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 512\n        });\n        this.model = fields?.model ?? \"amazon.titan-embed-text-v1\";\n        this.clientOptions = fields?.clientOptions;\n        this.client =\n            fields?.client ??\n                new client_bedrock_runtime_1.BedrockRuntimeClient({\n                    ...fields?.clientOptions,\n                    region: fields?.region,\n                    credentials: fields?.credentials,\n                });\n    }\n    /**\n     * Protected method to make a request to the Bedrock API to generate\n     * embeddings. Handles the retry logic and returns the response from the\n     * API.\n     * @param request Request to send to the Bedrock API.\n     * @returns Promise that resolves to the response from the API.\n     */\n    async _embedText(text) {\n        return this.caller.call(async () => {\n            try {\n                // replace newlines, which can negatively affect performance.\n                const cleanedText = text.replace(/\\n/g, \" \");\n                const res = await this.client.send(new client_bedrock_runtime_1.InvokeModelCommand({\n                    modelId: this.model,\n                    body: JSON.stringify({\n                        inputText: cleanedText,\n                    }),\n                    contentType: \"application/json\",\n                    accept: \"application/json\",\n                }));\n                const body = new TextDecoder().decode(res.body);\n                return JSON.parse(body).embedding;\n            }\n            catch (e) {\n                console.error({\n                    error: e,\n                });\n                // eslint-disable-next-line no-instanceof/no-instanceof\n                if (e instanceof Error) {\n                    throw new Error(`An error occurred while embedding documents with Bedrock: ${e.message}`);\n                }\n                throw new Error(\"An error occurred while embedding documents with Bedrock\");\n            }\n        });\n    }\n    /**\n     * Method that takes a document as input and returns a promise that\n     * resolves to an embedding for the document. It calls the _embedText\n     * method with the document as the input.\n     * @param document Document for which to generate an embedding.\n     * @returns Promise that resolves to an embedding for the input document.\n     */\n    embedQuery(document) {\n        return this.caller.callWithOptions({}, this._embedText.bind(this), document);\n    }\n    /**\n     * Method to generate embeddings for an array of texts. Calls _embedText\n     * method which batches and handles retry logic when calling the AWS Bedrock API.\n     * @param documents Array of texts for which to generate embeddings.\n     * @returns Promise that resolves to a 2D array of embeddings for each input document.\n     */\n    async embedDocuments(documents) {\n        return Promise.all(documents.map((document) => this._embedText(document)));\n    }\n}\nexports.BedrockEmbeddings = BedrockEmbeddings;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9hd3MvZGlzdC9lbWJlZGRpbmdzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekIsaUNBQWlDLG1CQUFPLENBQUMsOEdBQWlDO0FBQzFFLHFCQUFxQixtQkFBTyxDQUFDLHVGQUE0QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixLQUFLO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpR0FBaUcsVUFBVTtBQUMzRztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2F3cy9kaXN0L2VtYmVkZGluZ3MuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWRyb2NrRW1iZWRkaW5ncyA9IHZvaWQgMDtcbmNvbnN0IGNsaWVudF9iZWRyb2NrX3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJAYXdzLXNkay9jbGllbnQtYmVkcm9jay1ydW50aW1lXCIpO1xuY29uc3QgZW1iZWRkaW5nc18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9lbWJlZGRpbmdzXCIpO1xuLyoqXG4gKiBDbGFzcyB0aGF0IGV4dGVuZHMgdGhlIEVtYmVkZGluZ3MgY2xhc3MgYW5kIHByb3ZpZGVzIG1ldGhvZHMgZm9yXG4gKiBnZW5lcmF0aW5nIGVtYmVkZGluZ3MgdXNpbmcgdGhlIEJlZHJvY2sgQVBJLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGVtYmVkZGluZ3MgPSBuZXcgQmVkcm9ja0VtYmVkZGluZ3Moe1xuICogICByZWdpb246IFwieW91ci1hd3MtcmVnaW9uXCIsXG4gKiAgIGNyZWRlbnRpYWxzOiB7XG4gKiAgICAgYWNjZXNzS2V5SWQ6IFwieW91ci1hY2Nlc3Mta2V5LWlkXCIsXG4gKiAgICAgc2VjcmV0QWNjZXNzS2V5OiBcInlvdXItc2VjcmV0LWFjY2Vzcy1rZXlcIixcbiAqICAgfSxcbiAqICAgbW9kZWw6IFwiYW1hem9uLnRpdGFuLWVtYmVkLXRleHQtdjFcIixcbiAqICAgLy8gQ29uZmlndXJlIGNsaWVudCBvcHRpb25zIChlLmcuLCBjdXN0b20gcmVxdWVzdCBoYW5kbGVyKVxuICogICAvLyBjbGllbnRPcHRpb25zOiB7XG4gKiAgIC8vICAgcmVxdWVzdEhhbmRsZXI6IG15Q3VzdG9tUmVxdWVzdEhhbmRsZXIsXG4gKiAgIC8vIH0sXG4gKiB9KTtcbiAqXG4gKiAvLyBFbWJlZCBhIHF1ZXJ5IGFuZCBsb2cgdGhlIHJlc3VsdFxuICogY29uc3QgcmVzID0gYXdhaXQgZW1iZWRkaW5ncy5lbWJlZFF1ZXJ5KFxuICogICBcIldoYXQgd291bGQgYmUgYSBnb29kIGNvbXBhbnkgbmFtZSBmb3IgYSBjb21wYW55IHRoYXQgbWFrZXMgY29sb3JmdWwgc29ja3M/XCJcbiAqICk7XG4gKiBjb25zb2xlLmxvZyh7IHJlcyB9KTtcbiAqIGBgYFxuICovXG5jbGFzcyBCZWRyb2NrRW1iZWRkaW5ncyBleHRlbmRzIGVtYmVkZGluZ3NfMS5FbWJlZGRpbmdzIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzID8/IHt9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibW9kZWxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2xpZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNsaWVudE9wdGlvbnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYmF0Y2hTaXplXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiA1MTJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubW9kZWwgPSBmaWVsZHM/Lm1vZGVsID8/IFwiYW1hem9uLnRpdGFuLWVtYmVkLXRleHQtdjFcIjtcbiAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zID0gZmllbGRzPy5jbGllbnRPcHRpb25zO1xuICAgICAgICB0aGlzLmNsaWVudCA9XG4gICAgICAgICAgICBmaWVsZHM/LmNsaWVudCA/P1xuICAgICAgICAgICAgICAgIG5ldyBjbGllbnRfYmVkcm9ja19ydW50aW1lXzEuQmVkcm9ja1J1bnRpbWVDbGllbnQoe1xuICAgICAgICAgICAgICAgICAgICAuLi5maWVsZHM/LmNsaWVudE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHJlZ2lvbjogZmllbGRzPy5yZWdpb24sXG4gICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzOiBmaWVsZHM/LmNyZWRlbnRpYWxzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm90ZWN0ZWQgbWV0aG9kIHRvIG1ha2UgYSByZXF1ZXN0IHRvIHRoZSBCZWRyb2NrIEFQSSB0byBnZW5lcmF0ZVxuICAgICAqIGVtYmVkZGluZ3MuIEhhbmRsZXMgdGhlIHJldHJ5IGxvZ2ljIGFuZCByZXR1cm5zIHRoZSByZXNwb25zZSBmcm9tIHRoZVxuICAgICAqIEFQSS5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdCBSZXF1ZXN0IHRvIHNlbmQgdG8gdGhlIEJlZHJvY2sgQVBJLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqL1xuICAgIGFzeW5jIF9lbWJlZFRleHQodGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgbmV3bGluZXMsIHdoaWNoIGNhbiBuZWdhdGl2ZWx5IGFmZmVjdCBwZXJmb3JtYW5jZS5cbiAgICAgICAgICAgICAgICBjb25zdCBjbGVhbmVkVGV4dCA9IHRleHQucmVwbGFjZSgvXFxuL2csIFwiIFwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmNsaWVudC5zZW5kKG5ldyBjbGllbnRfYmVkcm9ja19ydW50aW1lXzEuSW52b2tlTW9kZWxDb21tYW5kKHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxJZDogdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRUZXh0OiBjbGVhbmVkVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAgICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShyZXMuYm9keSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoYm9keSkuZW1iZWRkaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBlbWJlZGRpbmcgZG9jdW1lbnRzIHdpdGggQmVkcm9jazogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFuIGVycm9yIG9jY3VycmVkIHdoaWxlIGVtYmVkZGluZyBkb2N1bWVudHMgd2l0aCBCZWRyb2NrXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgdGFrZXMgYSBkb2N1bWVudCBhcyBpbnB1dCBhbmQgcmV0dXJucyBhIHByb21pc2UgdGhhdFxuICAgICAqIHJlc29sdmVzIHRvIGFuIGVtYmVkZGluZyBmb3IgdGhlIGRvY3VtZW50LiBJdCBjYWxscyB0aGUgX2VtYmVkVGV4dFxuICAgICAqIG1ldGhvZCB3aXRoIHRoZSBkb2N1bWVudCBhcyB0aGUgaW5wdXQuXG4gICAgICogQHBhcmFtIGRvY3VtZW50IERvY3VtZW50IGZvciB3aGljaCB0byBnZW5lcmF0ZSBhbiBlbWJlZGRpbmcuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGVtYmVkZGluZyBmb3IgdGhlIGlucHV0IGRvY3VtZW50LlxuICAgICAqL1xuICAgIGVtYmVkUXVlcnkoZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbGVyLmNhbGxXaXRoT3B0aW9ucyh7fSwgdGhpcy5fZW1iZWRUZXh0LmJpbmQodGhpcyksIGRvY3VtZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGdlbmVyYXRlIGVtYmVkZGluZ3MgZm9yIGFuIGFycmF5IG9mIHRleHRzLiBDYWxscyBfZW1iZWRUZXh0XG4gICAgICogbWV0aG9kIHdoaWNoIGJhdGNoZXMgYW5kIGhhbmRsZXMgcmV0cnkgbG9naWMgd2hlbiBjYWxsaW5nIHRoZSBBV1MgQmVkcm9jayBBUEkuXG4gICAgICogQHBhcmFtIGRvY3VtZW50cyBBcnJheSBvZiB0ZXh0cyBmb3Igd2hpY2ggdG8gZ2VuZXJhdGUgZW1iZWRkaW5ncy5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSAyRCBhcnJheSBvZiBlbWJlZGRpbmdzIGZvciBlYWNoIGlucHV0IGRvY3VtZW50LlxuICAgICAqL1xuICAgIGFzeW5jIGVtYmVkRG9jdW1lbnRzKGRvY3VtZW50cykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZG9jdW1lbnRzLm1hcCgoZG9jdW1lbnQpID0+IHRoaXMuX2VtYmVkVGV4dChkb2N1bWVudCkpKTtcbiAgICB9XG59XG5leHBvcnRzLkJlZHJvY2tFbWJlZGRpbmdzID0gQmVkcm9ja0VtYmVkZGluZ3M7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/aws/dist/embeddings.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/aws/dist/index.cjs":
/*!****************************************************!*\
  !*** ./node_modules/@langchain/aws/dist/index.cjs ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./chat_models.cjs */ \"(rsc)/./node_modules/@langchain/aws/dist/chat_models.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./types.cjs */ \"(rsc)/./node_modules/@langchain/aws/dist/types.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./retrievers/index.cjs */ \"(rsc)/./node_modules/@langchain/aws/dist/retrievers/index.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./embeddings.cjs */ \"(rsc)/./node_modules/@langchain/aws/dist/embeddings.cjs\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9hd3MvZGlzdC9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLG1GQUFtQjtBQUN4QyxhQUFhLG1CQUFPLENBQUMsdUVBQWE7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLDZGQUF3QjtBQUM3QyxhQUFhLG1CQUFPLENBQUMsaUZBQWtCIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9hd3MvZGlzdC9pbmRleC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jaGF0X21vZGVscy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVzLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcmV0cmlldmVycy9pbmRleC5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2VtYmVkZGluZ3MuY2pzXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/aws/dist/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/aws/dist/retrievers/bedrock.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/aws/dist/retrievers/bedrock.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AmazonKnowledgeBaseRetriever = void 0;\nconst client_bedrock_agent_runtime_1 = __webpack_require__(/*! @aws-sdk/client-bedrock-agent-runtime */ \"(rsc)/./node_modules/@aws-sdk/client-bedrock-agent-runtime/dist-es/index.js\");\nconst retrievers_1 = __webpack_require__(/*! @langchain/core/retrievers */ \"(rsc)/./node_modules/@langchain/core/retrievers.cjs\");\n/**\n * Class for interacting with Amazon Bedrock Knowledge Bases, a RAG workflow oriented service\n * provided by AWS. Extends the BaseRetriever class.\n * @example\n * ```typescript\n * const retriever = new AmazonKnowledgeBaseRetriever({\n *   topK: 10,\n *   knowledgeBaseId: \"YOUR_KNOWLEDGE_BASE_ID\",\n *   region: \"us-east-2\",\n *   clientOptions: {\n *     credentials: {\n *       accessKeyId: \"YOUR_ACCESS_KEY_ID\",\n *       secretAccessKey: \"YOUR_SECRET_ACCESS_KEY\",\n *     },\n *   },\n * });\n *\n * const docs = await retriever.getRelevantDocuments(\"How are clouds formed?\");\n * ```\n */\nclass AmazonKnowledgeBaseRetriever extends retrievers_1.BaseRetriever {\n    static lc_name() {\n        return \"AmazonKnowledgeBaseRetriever\";\n    }\n    constructor({ knowledgeBaseId, topK = 10, clientOptions, region, filter, overrideSearchType, }) {\n        super();\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"retrievers\", \"amazon_bedrock_knowledge_base\"]\n        });\n        Object.defineProperty(this, \"knowledgeBaseId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"topK\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"bedrockAgentRuntimeClient\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"filter\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"overrideSearchType\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.topK = topK;\n        this.filter = filter;\n        this.overrideSearchType = overrideSearchType;\n        this.bedrockAgentRuntimeClient = new client_bedrock_agent_runtime_1.BedrockAgentRuntimeClient({\n            region,\n            ...clientOptions,\n        });\n        this.knowledgeBaseId = knowledgeBaseId;\n    }\n    /**\n     * Cleans the result text by replacing sequences of whitespace with a\n     * single space and removing ellipses.\n     * @param resText The result text to clean.\n     * @returns The cleaned result text.\n     */\n    cleanResult(resText) {\n        const res = resText.replace(/\\s+/g, \" \").replace(/\\.\\.\\./g, \"\");\n        return res;\n    }\n    async queryKnowledgeBase(query, topK, filter, overrideSearchType) {\n        const retrieveCommand = new client_bedrock_agent_runtime_1.RetrieveCommand({\n            knowledgeBaseId: this.knowledgeBaseId,\n            retrievalQuery: {\n                text: query,\n            },\n            retrievalConfiguration: {\n                vectorSearchConfiguration: {\n                    numberOfResults: topK,\n                    overrideSearchType,\n                    filter,\n                },\n            },\n        });\n        const retrieveResponse = await this.bedrockAgentRuntimeClient.send(retrieveCommand);\n        return (retrieveResponse.retrievalResults?.map((result) => {\n            let source;\n            switch (result.location?.type) {\n                case \"CONFLUENCE\":\n                    source = result.location?.confluenceLocation?.url;\n                    break;\n                case \"S3\":\n                    source = result.location?.s3Location?.uri;\n                    break;\n                case \"SALESFORCE\":\n                    source = result.location?.salesforceLocation?.url;\n                    break;\n                case \"SHAREPOINT\":\n                    source = result.location?.sharePointLocation?.url;\n                    break;\n                case \"WEB\":\n                    source = result.location?.webLocation?.url;\n                    break;\n                default:\n                    source = result.location?.s3Location?.uri;\n                    break;\n            }\n            return {\n                pageContent: this.cleanResult(result.content?.text || \"\"),\n                metadata: {\n                    source,\n                    score: result.score,\n                    ...result.metadata,\n                },\n            };\n        }) ?? []);\n    }\n    async _getRelevantDocuments(query) {\n        const docs = await this.queryKnowledgeBase(query, this.topK, this.filter, this.overrideSearchType);\n        return docs;\n    }\n}\nexports.AmazonKnowledgeBaseRetriever = AmazonKnowledgeBaseRetriever;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9hd3MvZGlzdC9yZXRyaWV2ZXJzL2JlZHJvY2suY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9DQUFvQztBQUNwQyx1Q0FBdUMsbUJBQU8sQ0FBQywwSEFBdUM7QUFDdEYscUJBQXFCLG1CQUFPLENBQUMsdUZBQTRCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnRkFBZ0Y7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2F3cy9kaXN0L3JldHJpZXZlcnMvYmVkcm9jay5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFtYXpvbktub3dsZWRnZUJhc2VSZXRyaWV2ZXIgPSB2b2lkIDA7XG5jb25zdCBjbGllbnRfYmVkcm9ja19hZ2VudF9ydW50aW1lXzEgPSByZXF1aXJlKFwiQGF3cy1zZGsvY2xpZW50LWJlZHJvY2stYWdlbnQtcnVudGltZVwiKTtcbmNvbnN0IHJldHJpZXZlcnNfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvcmV0cmlldmVyc1wiKTtcbi8qKlxuICogQ2xhc3MgZm9yIGludGVyYWN0aW5nIHdpdGggQW1hem9uIEJlZHJvY2sgS25vd2xlZGdlIEJhc2VzLCBhIFJBRyB3b3JrZmxvdyBvcmllbnRlZCBzZXJ2aWNlXG4gKiBwcm92aWRlZCBieSBBV1MuIEV4dGVuZHMgdGhlIEJhc2VSZXRyaWV2ZXIgY2xhc3MuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgcmV0cmlldmVyID0gbmV3IEFtYXpvbktub3dsZWRnZUJhc2VSZXRyaWV2ZXIoe1xuICogICB0b3BLOiAxMCxcbiAqICAga25vd2xlZGdlQmFzZUlkOiBcIllPVVJfS05PV0xFREdFX0JBU0VfSURcIixcbiAqICAgcmVnaW9uOiBcInVzLWVhc3QtMlwiLFxuICogICBjbGllbnRPcHRpb25zOiB7XG4gKiAgICAgY3JlZGVudGlhbHM6IHtcbiAqICAgICAgIGFjY2Vzc0tleUlkOiBcIllPVVJfQUNDRVNTX0tFWV9JRFwiLFxuICogICAgICAgc2VjcmV0QWNjZXNzS2V5OiBcIllPVVJfU0VDUkVUX0FDQ0VTU19LRVlcIixcbiAqICAgICB9LFxuICogICB9LFxuICogfSk7XG4gKlxuICogY29uc3QgZG9jcyA9IGF3YWl0IHJldHJpZXZlci5nZXRSZWxldmFudERvY3VtZW50cyhcIkhvdyBhcmUgY2xvdWRzIGZvcm1lZD9cIik7XG4gKiBgYGBcbiAqL1xuY2xhc3MgQW1hem9uS25vd2xlZGdlQmFzZVJldHJpZXZlciBleHRlbmRzIHJldHJpZXZlcnNfMS5CYXNlUmV0cmlldmVyIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQW1hem9uS25vd2xlZGdlQmFzZVJldHJpZXZlclwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih7IGtub3dsZWRnZUJhc2VJZCwgdG9wSyA9IDEwLCBjbGllbnRPcHRpb25zLCByZWdpb24sIGZpbHRlciwgb3ZlcnJpZGVTZWFyY2hUeXBlLCB9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluXCIsIFwicmV0cmlldmVyc1wiLCBcImFtYXpvbl9iZWRyb2NrX2tub3dsZWRnZV9iYXNlXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJrbm93bGVkZ2VCYXNlSWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9wS1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJiZWRyb2NrQWdlbnRSdW50aW1lQ2xpZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZpbHRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvdmVycmlkZVNlYXJjaFR5cGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b3BLID0gdG9wSztcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgIHRoaXMub3ZlcnJpZGVTZWFyY2hUeXBlID0gb3ZlcnJpZGVTZWFyY2hUeXBlO1xuICAgICAgICB0aGlzLmJlZHJvY2tBZ2VudFJ1bnRpbWVDbGllbnQgPSBuZXcgY2xpZW50X2JlZHJvY2tfYWdlbnRfcnVudGltZV8xLkJlZHJvY2tBZ2VudFJ1bnRpbWVDbGllbnQoe1xuICAgICAgICAgICAgcmVnaW9uLFxuICAgICAgICAgICAgLi4uY2xpZW50T3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMua25vd2xlZGdlQmFzZUlkID0ga25vd2xlZGdlQmFzZUlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhbnMgdGhlIHJlc3VsdCB0ZXh0IGJ5IHJlcGxhY2luZyBzZXF1ZW5jZXMgb2Ygd2hpdGVzcGFjZSB3aXRoIGFcbiAgICAgKiBzaW5nbGUgc3BhY2UgYW5kIHJlbW92aW5nIGVsbGlwc2VzLlxuICAgICAqIEBwYXJhbSByZXNUZXh0IFRoZSByZXN1bHQgdGV4dCB0byBjbGVhbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgY2xlYW5lZCByZXN1bHQgdGV4dC5cbiAgICAgKi9cbiAgICBjbGVhblJlc3VsdChyZXNUZXh0KSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHJlc1RleHQucmVwbGFjZSgvXFxzKy9nLCBcIiBcIikucmVwbGFjZSgvXFwuXFwuXFwuL2csIFwiXCIpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBhc3luYyBxdWVyeUtub3dsZWRnZUJhc2UocXVlcnksIHRvcEssIGZpbHRlciwgb3ZlcnJpZGVTZWFyY2hUeXBlKSB7XG4gICAgICAgIGNvbnN0IHJldHJpZXZlQ29tbWFuZCA9IG5ldyBjbGllbnRfYmVkcm9ja19hZ2VudF9ydW50aW1lXzEuUmV0cmlldmVDb21tYW5kKHtcbiAgICAgICAgICAgIGtub3dsZWRnZUJhc2VJZDogdGhpcy5rbm93bGVkZ2VCYXNlSWQsXG4gICAgICAgICAgICByZXRyaWV2YWxRdWVyeToge1xuICAgICAgICAgICAgICAgIHRleHQ6IHF1ZXJ5LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJldHJpZXZhbENvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgICAgICB2ZWN0b3JTZWFyY2hDb25maWd1cmF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIG51bWJlck9mUmVzdWx0czogdG9wSyxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVTZWFyY2hUeXBlLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXRyaWV2ZVJlc3BvbnNlID0gYXdhaXQgdGhpcy5iZWRyb2NrQWdlbnRSdW50aW1lQ2xpZW50LnNlbmQocmV0cmlldmVDb21tYW5kKTtcbiAgICAgICAgcmV0dXJuIChyZXRyaWV2ZVJlc3BvbnNlLnJldHJpZXZhbFJlc3VsdHM/Lm1hcCgocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBsZXQgc291cmNlO1xuICAgICAgICAgICAgc3dpdGNoIChyZXN1bHQubG9jYXRpb24/LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiQ09ORkxVRU5DRVwiOlxuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSByZXN1bHQubG9jYXRpb24/LmNvbmZsdWVuY2VMb2NhdGlvbj8udXJsO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiUzNcIjpcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gcmVzdWx0LmxvY2F0aW9uPy5zM0xvY2F0aW9uPy51cmk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJTQUxFU0ZPUkNFXCI6XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IHJlc3VsdC5sb2NhdGlvbj8uc2FsZXNmb3JjZUxvY2F0aW9uPy51cmw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJTSEFSRVBPSU5UXCI6XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IHJlc3VsdC5sb2NhdGlvbj8uc2hhcmVQb2ludExvY2F0aW9uPy51cmw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJXRUJcIjpcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gcmVzdWx0LmxvY2F0aW9uPy53ZWJMb2NhdGlvbj8udXJsO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSByZXN1bHQubG9jYXRpb24/LnMzTG9jYXRpb24/LnVyaTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhZ2VDb250ZW50OiB0aGlzLmNsZWFuUmVzdWx0KHJlc3VsdC5jb250ZW50Py50ZXh0IHx8IFwiXCIpLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgc2NvcmU6IHJlc3VsdC5zY29yZSxcbiAgICAgICAgICAgICAgICAgICAgLi4ucmVzdWx0Lm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSA/PyBbXSk7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRSZWxldmFudERvY3VtZW50cyhxdWVyeSkge1xuICAgICAgICBjb25zdCBkb2NzID0gYXdhaXQgdGhpcy5xdWVyeUtub3dsZWRnZUJhc2UocXVlcnksIHRoaXMudG9wSywgdGhpcy5maWx0ZXIsIHRoaXMub3ZlcnJpZGVTZWFyY2hUeXBlKTtcbiAgICAgICAgcmV0dXJuIGRvY3M7XG4gICAgfVxufVxuZXhwb3J0cy5BbWF6b25Lbm93bGVkZ2VCYXNlUmV0cmlldmVyID0gQW1hem9uS25vd2xlZGdlQmFzZVJldHJpZXZlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/aws/dist/retrievers/bedrock.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/aws/dist/retrievers/index.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/aws/dist/retrievers/index.cjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./bedrock.cjs */ \"(rsc)/./node_modules/@langchain/aws/dist/retrievers/bedrock.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./kendra.cjs */ \"(rsc)/./node_modules/@langchain/aws/dist/retrievers/kendra.cjs\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9hd3MvZGlzdC9yZXRyaWV2ZXJzL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsc0ZBQWU7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLG9GQUFjIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9hd3MvZGlzdC9yZXRyaWV2ZXJzL2luZGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2JlZHJvY2suY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9rZW5kcmEuY2pzXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/aws/dist/retrievers/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/aws/dist/retrievers/kendra.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/aws/dist/retrievers/kendra.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AmazonKendraRetriever = void 0;\nconst client_kendra_1 = __webpack_require__(/*! @aws-sdk/client-kendra */ \"(rsc)/./node_modules/@aws-sdk/client-kendra/dist-es/index.js\");\nconst retrievers_1 = __webpack_require__(/*! @langchain/core/retrievers */ \"(rsc)/./node_modules/@langchain/core/retrievers.cjs\");\nconst documents_1 = __webpack_require__(/*! @langchain/core/documents */ \"(rsc)/./node_modules/@langchain/core/documents.cjs\");\n/**\n * Class for interacting with Amazon Kendra, an intelligent search service\n * provided by AWS. Extends the BaseRetriever class.\n * @example\n * ```typescript\n * const retriever = new AmazonKendraRetriever({\n *   topK: 10,\n *   indexId: \"YOUR_INDEX_ID\",\n *   region: \"us-east-2\",\n *   clientOptions: {\n *     credentials: {\n *       accessKeyId: \"YOUR_ACCESS_KEY_ID\",\n *       secretAccessKey: \"YOUR_SECRET_ACCESS_KEY\",\n *     },\n *   },\n * });\n *\n * const docs = await retriever.getRelevantDocuments(\"How are clouds formed?\");\n * ```\n */\nclass AmazonKendraRetriever extends retrievers_1.BaseRetriever {\n    static lc_name() {\n        return \"AmazonKendraRetriever\";\n    }\n    constructor({ indexId, topK = 10, clientOptions, attributeFilter, region, }) {\n        super();\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"retrievers\", \"amazon_kendra\"]\n        });\n        Object.defineProperty(this, \"indexId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"topK\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"kendraClient\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"attributeFilter\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (!region) {\n            throw new Error(\"Please pass regionName field to the constructor!\");\n        }\n        if (!indexId) {\n            throw new Error(\"Please pass Kendra Index Id to the constructor\");\n        }\n        this.topK = topK;\n        this.kendraClient = new client_kendra_1.KendraClient({\n            region,\n            ...clientOptions,\n        });\n        this.attributeFilter = attributeFilter;\n        this.indexId = indexId;\n    }\n    // A method to combine title and excerpt into a single string.\n    /**\n     * Combines title and excerpt into a single string.\n     * @param title The title of the document.\n     * @param excerpt An excerpt from the document.\n     * @returns A single string combining the title and excerpt.\n     */\n    combineText(title, excerpt) {\n        let text = \"\";\n        if (title) {\n            text += `Document Title: ${title}\\n`;\n        }\n        if (excerpt) {\n            text += `Document Excerpt: \\n${excerpt}\\n`;\n        }\n        return text;\n    }\n    // A method to clean the result text by replacing sequences of whitespace with a single space and removing ellipses.\n    /**\n     * Cleans the result text by replacing sequences of whitespace with a\n     * single space and removing ellipses.\n     * @param resText The result text to clean.\n     * @returns The cleaned result text.\n     */\n    cleanResult(resText) {\n        const res = resText.replace(/\\s+/g, \" \").replace(/\\.\\.\\./g, \"\");\n        return res;\n    }\n    // A method to extract the attribute value from a DocumentAttributeValue object.\n    /**\n     * Extracts the attribute value from a DocumentAttributeValue object.\n     * @param value The DocumentAttributeValue object to extract the value from.\n     * @returns The extracted attribute value.\n     */\n    getDocAttributeValue(value) {\n        if (value.DateValue) {\n            return value.DateValue;\n        }\n        if (value.LongValue) {\n            return value.LongValue;\n        }\n        if (value.StringListValue) {\n            return value.StringListValue;\n        }\n        if (value.StringValue) {\n            return value.StringValue;\n        }\n        return \"\";\n    }\n    // A method to extract the attribute key-value pairs from an array of DocumentAttribute objects.\n    /**\n     * Extracts the attribute key-value pairs from an array of\n     * DocumentAttribute objects.\n     * @param documentAttributes The array of DocumentAttribute objects to extract the key-value pairs from.\n     * @returns An object containing the extracted attribute key-value pairs.\n     */\n    getDocAttributes(documentAttributes) {\n        const attributes = {};\n        if (documentAttributes) {\n            for (const attr of documentAttributes) {\n                if (attr.Key && attr.Value) {\n                    attributes[attr.Key] = this.getDocAttributeValue(attr.Value);\n                }\n            }\n        }\n        return attributes;\n    }\n    // A method to convert a RetrieveResultItem object into a Document object.\n    /**\n     * Converts a RetrieveResultItem object into a Document object.\n     * @param item The RetrieveResultItem object to convert.\n     * @returns A Document object.\n     */\n    convertRetrieverItem(item) {\n        const title = item.DocumentTitle || \"\";\n        const excerpt = item.Content ? this.cleanResult(item.Content) : \"\";\n        const pageContent = this.combineText(title, excerpt);\n        const source = item.DocumentURI;\n        const attributes = this.getDocAttributes(item.DocumentAttributes);\n        const metadata = {\n            source,\n            title,\n            excerpt,\n            document_attributes: attributes,\n        };\n        return new documents_1.Document({ pageContent, metadata });\n    }\n    // A method to extract the top-k documents from a RetrieveCommandOutput object.\n    /**\n     * Extracts the top-k documents from a RetrieveCommandOutput object.\n     * @param response The RetrieveCommandOutput object to extract the documents from.\n     * @param pageSize The number of documents to extract.\n     * @returns An array of Document objects.\n     */\n    getRetrieverDocs(response, pageSize) {\n        if (!response.ResultItems)\n            return [];\n        const { length } = response.ResultItems;\n        const count = length < pageSize ? length : pageSize;\n        return response.ResultItems.slice(0, count).map((item) => this.convertRetrieverItem(item));\n    }\n    // A method to extract the excerpt text from a QueryResultItem object.\n    /**\n     * Extracts the excerpt text from a QueryResultItem object.\n     * @param item The QueryResultItem object to extract the excerpt text from.\n     * @returns The extracted excerpt text.\n     */\n    getQueryItemExcerpt(item) {\n        if (item.AdditionalAttributes &&\n            item.AdditionalAttributes.length &&\n            item.AdditionalAttributes[0].Key === \"AnswerText\") {\n            if (!item.AdditionalAttributes) {\n                return \"\";\n            }\n            if (!item.AdditionalAttributes[0]) {\n                return \"\";\n            }\n            return this.cleanResult(item.AdditionalAttributes[0].Value?.TextWithHighlightsValue?.Text || \"\");\n        }\n        else if (item.DocumentExcerpt) {\n            return this.cleanResult(item.DocumentExcerpt.Text || \"\");\n        }\n        else {\n            return \"\";\n        }\n    }\n    // A method to convert a QueryResultItem object into a Document object.\n    /**\n     * Converts a QueryResultItem object into a Document object.\n     * @param item The QueryResultItem object to convert.\n     * @returns A Document object.\n     */\n    convertQueryItem(item) {\n        const title = item.DocumentTitle?.Text || \"\";\n        const excerpt = this.getQueryItemExcerpt(item);\n        const pageContent = this.combineText(title, excerpt);\n        const source = item.DocumentURI;\n        const attributes = this.getDocAttributes(item.DocumentAttributes);\n        const metadata = {\n            source,\n            title,\n            excerpt,\n            document_attributes: attributes,\n        };\n        return new documents_1.Document({ pageContent, metadata });\n    }\n    // A method to extract the top-k documents from a QueryCommandOutput object.\n    /**\n     * Extracts the top-k documents from a QueryCommandOutput object.\n     * @param response The QueryCommandOutput object to extract the documents from.\n     * @param pageSize The number of documents to extract.\n     * @returns An array of Document objects.\n     */\n    getQueryDocs(response, pageSize) {\n        if (!response.ResultItems)\n            return [];\n        const { length } = response.ResultItems;\n        const count = length < pageSize ? length : pageSize;\n        return response.ResultItems.slice(0, count).map((item) => this.convertQueryItem(item));\n    }\n    // A method to send a retrieve or query request to Kendra and return the top-k documents.\n    /**\n     * Sends a retrieve or query request to Kendra and returns the top-k\n     * documents.\n     * @param query The query to send to Kendra.\n     * @param topK The number of top documents to return.\n     * @param attributeFilter Optional filter to apply when retrieving documents.\n     * @returns A Promise that resolves to an array of Document objects.\n     */\n    async queryKendra(query, topK, attributeFilter) {\n        const retrieveCommand = new client_kendra_1.RetrieveCommand({\n            IndexId: this.indexId,\n            QueryText: query,\n            PageSize: topK,\n            AttributeFilter: attributeFilter,\n        });\n        const retrieveResponse = await this.kendraClient.send(retrieveCommand);\n        const retriveLength = retrieveResponse.ResultItems?.length;\n        if (retriveLength === 0) {\n            // Retrieve API returned 0 results, call query API\n            const queryCommand = new client_kendra_1.QueryCommand({\n                IndexId: this.indexId,\n                QueryText: query,\n                PageSize: topK,\n                AttributeFilter: attributeFilter,\n            });\n            const queryResponse = await this.kendraClient.send(queryCommand);\n            return this.getQueryDocs(queryResponse, this.topK);\n        }\n        else {\n            return this.getRetrieverDocs(retrieveResponse, this.topK);\n        }\n    }\n    async _getRelevantDocuments(query) {\n        const docs = await this.queryKendra(query, this.topK, this.attributeFilter);\n        return docs;\n    }\n}\nexports.AmazonKendraRetriever = AmazonKendraRetriever;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9hd3MvZGlzdC9yZXRyaWV2ZXJzL2tlbmRyYS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCO0FBQzdCLHdCQUF3QixtQkFBTyxDQUFDLDRGQUF3QjtBQUN4RCxxQkFBcUIsbUJBQU8sQ0FBQyx1RkFBNEI7QUFDekQsb0JBQW9CLG1CQUFPLENBQUMscUZBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2REFBNkQ7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsTUFBTTtBQUM3QztBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx1QkFBdUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHVCQUF1QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2F3cy9kaXN0L3JldHJpZXZlcnMva2VuZHJhLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQW1hem9uS2VuZHJhUmV0cmlldmVyID0gdm9pZCAwO1xuY29uc3QgY2xpZW50X2tlbmRyYV8xID0gcmVxdWlyZShcIkBhd3Mtc2RrL2NsaWVudC1rZW5kcmFcIik7XG5jb25zdCByZXRyaWV2ZXJzXzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL3JldHJpZXZlcnNcIik7XG5jb25zdCBkb2N1bWVudHNfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvZG9jdW1lbnRzXCIpO1xuLyoqXG4gKiBDbGFzcyBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBBbWF6b24gS2VuZHJhLCBhbiBpbnRlbGxpZ2VudCBzZWFyY2ggc2VydmljZVxuICogcHJvdmlkZWQgYnkgQVdTLiBFeHRlbmRzIHRoZSBCYXNlUmV0cmlldmVyIGNsYXNzLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHJldHJpZXZlciA9IG5ldyBBbWF6b25LZW5kcmFSZXRyaWV2ZXIoe1xuICogICB0b3BLOiAxMCxcbiAqICAgaW5kZXhJZDogXCJZT1VSX0lOREVYX0lEXCIsXG4gKiAgIHJlZ2lvbjogXCJ1cy1lYXN0LTJcIixcbiAqICAgY2xpZW50T3B0aW9uczoge1xuICogICAgIGNyZWRlbnRpYWxzOiB7XG4gKiAgICAgICBhY2Nlc3NLZXlJZDogXCJZT1VSX0FDQ0VTU19LRVlfSURcIixcbiAqICAgICAgIHNlY3JldEFjY2Vzc0tleTogXCJZT1VSX1NFQ1JFVF9BQ0NFU1NfS0VZXCIsXG4gKiAgICAgfSxcbiAqICAgfSxcbiAqIH0pO1xuICpcbiAqIGNvbnN0IGRvY3MgPSBhd2FpdCByZXRyaWV2ZXIuZ2V0UmVsZXZhbnREb2N1bWVudHMoXCJIb3cgYXJlIGNsb3VkcyBmb3JtZWQ/XCIpO1xuICogYGBgXG4gKi9cbmNsYXNzIEFtYXpvbktlbmRyYVJldHJpZXZlciBleHRlbmRzIHJldHJpZXZlcnNfMS5CYXNlUmV0cmlldmVyIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQW1hem9uS2VuZHJhUmV0cmlldmVyXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHsgaW5kZXhJZCwgdG9wSyA9IDEwLCBjbGllbnRPcHRpb25zLCBhdHRyaWJ1dGVGaWx0ZXIsIHJlZ2lvbiwgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpblwiLCBcInJldHJpZXZlcnNcIiwgXCJhbWF6b25fa2VuZHJhXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmRleElkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvcEtcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwia2VuZHJhQ2xpZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF0dHJpYnV0ZUZpbHRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlZ2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHBhc3MgcmVnaW9uTmFtZSBmaWVsZCB0byB0aGUgY29uc3RydWN0b3IhXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW5kZXhJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHBhc3MgS2VuZHJhIEluZGV4IElkIHRvIHRoZSBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvcEsgPSB0b3BLO1xuICAgICAgICB0aGlzLmtlbmRyYUNsaWVudCA9IG5ldyBjbGllbnRfa2VuZHJhXzEuS2VuZHJhQ2xpZW50KHtcbiAgICAgICAgICAgIHJlZ2lvbixcbiAgICAgICAgICAgIC4uLmNsaWVudE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZUZpbHRlciA9IGF0dHJpYnV0ZUZpbHRlcjtcbiAgICAgICAgdGhpcy5pbmRleElkID0gaW5kZXhJZDtcbiAgICB9XG4gICAgLy8gQSBtZXRob2QgdG8gY29tYmluZSB0aXRsZSBhbmQgZXhjZXJwdCBpbnRvIGEgc2luZ2xlIHN0cmluZy5cbiAgICAvKipcbiAgICAgKiBDb21iaW5lcyB0aXRsZSBhbmQgZXhjZXJwdCBpbnRvIGEgc2luZ2xlIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gdGl0bGUgVGhlIHRpdGxlIG9mIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcGFyYW0gZXhjZXJwdCBBbiBleGNlcnB0IGZyb20gdGhlIGRvY3VtZW50LlxuICAgICAqIEByZXR1cm5zIEEgc2luZ2xlIHN0cmluZyBjb21iaW5pbmcgdGhlIHRpdGxlIGFuZCBleGNlcnB0LlxuICAgICAqL1xuICAgIGNvbWJpbmVUZXh0KHRpdGxlLCBleGNlcnB0KSB7XG4gICAgICAgIGxldCB0ZXh0ID0gXCJcIjtcbiAgICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgICB0ZXh0ICs9IGBEb2N1bWVudCBUaXRsZTogJHt0aXRsZX1cXG5gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleGNlcnB0KSB7XG4gICAgICAgICAgICB0ZXh0ICs9IGBEb2N1bWVudCBFeGNlcnB0OiBcXG4ke2V4Y2VycHR9XFxuYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgLy8gQSBtZXRob2QgdG8gY2xlYW4gdGhlIHJlc3VsdCB0ZXh0IGJ5IHJlcGxhY2luZyBzZXF1ZW5jZXMgb2Ygd2hpdGVzcGFjZSB3aXRoIGEgc2luZ2xlIHNwYWNlIGFuZCByZW1vdmluZyBlbGxpcHNlcy5cbiAgICAvKipcbiAgICAgKiBDbGVhbnMgdGhlIHJlc3VsdCB0ZXh0IGJ5IHJlcGxhY2luZyBzZXF1ZW5jZXMgb2Ygd2hpdGVzcGFjZSB3aXRoIGFcbiAgICAgKiBzaW5nbGUgc3BhY2UgYW5kIHJlbW92aW5nIGVsbGlwc2VzLlxuICAgICAqIEBwYXJhbSByZXNUZXh0IFRoZSByZXN1bHQgdGV4dCB0byBjbGVhbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgY2xlYW5lZCByZXN1bHQgdGV4dC5cbiAgICAgKi9cbiAgICBjbGVhblJlc3VsdChyZXNUZXh0KSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHJlc1RleHQucmVwbGFjZSgvXFxzKy9nLCBcIiBcIikucmVwbGFjZSgvXFwuXFwuXFwuL2csIFwiXCIpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICAvLyBBIG1ldGhvZCB0byBleHRyYWN0IHRoZSBhdHRyaWJ1dGUgdmFsdWUgZnJvbSBhIERvY3VtZW50QXR0cmlidXRlVmFsdWUgb2JqZWN0LlxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSBhdHRyaWJ1dGUgdmFsdWUgZnJvbSBhIERvY3VtZW50QXR0cmlidXRlVmFsdWUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgRG9jdW1lbnRBdHRyaWJ1dGVWYWx1ZSBvYmplY3QgdG8gZXh0cmFjdCB0aGUgdmFsdWUgZnJvbS5cbiAgICAgKiBAcmV0dXJucyBUaGUgZXh0cmFjdGVkIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXREb2NBdHRyaWJ1dGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUuRGF0ZVZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuRGF0ZVZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5Mb25nVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5Mb25nVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLlN0cmluZ0xpc3RWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLlN0cmluZ0xpc3RWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUuU3RyaW5nVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5TdHJpbmdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgLy8gQSBtZXRob2QgdG8gZXh0cmFjdCB0aGUgYXR0cmlidXRlIGtleS12YWx1ZSBwYWlycyBmcm9tIGFuIGFycmF5IG9mIERvY3VtZW50QXR0cmlidXRlIG9iamVjdHMuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIGF0dHJpYnV0ZSBrZXktdmFsdWUgcGFpcnMgZnJvbSBhbiBhcnJheSBvZlxuICAgICAqIERvY3VtZW50QXR0cmlidXRlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIGRvY3VtZW50QXR0cmlidXRlcyBUaGUgYXJyYXkgb2YgRG9jdW1lbnRBdHRyaWJ1dGUgb2JqZWN0cyB0byBleHRyYWN0IHRoZSBrZXktdmFsdWUgcGFpcnMgZnJvbS5cbiAgICAgKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZXh0cmFjdGVkIGF0dHJpYnV0ZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICovXG4gICAgZ2V0RG9jQXR0cmlidXRlcyhkb2N1bWVudEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBpZiAoZG9jdW1lbnRBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgZG9jdW1lbnRBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHIuS2V5ICYmIGF0dHIuVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1thdHRyLktleV0gPSB0aGlzLmdldERvY0F0dHJpYnV0ZVZhbHVlKGF0dHIuVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICB9XG4gICAgLy8gQSBtZXRob2QgdG8gY29udmVydCBhIFJldHJpZXZlUmVzdWx0SXRlbSBvYmplY3QgaW50byBhIERvY3VtZW50IG9iamVjdC5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIFJldHJpZXZlUmVzdWx0SXRlbSBvYmplY3QgaW50byBhIERvY3VtZW50IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gaXRlbSBUaGUgUmV0cmlldmVSZXN1bHRJdGVtIG9iamVjdCB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIEEgRG9jdW1lbnQgb2JqZWN0LlxuICAgICAqL1xuICAgIGNvbnZlcnRSZXRyaWV2ZXJJdGVtKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgdGl0bGUgPSBpdGVtLkRvY3VtZW50VGl0bGUgfHwgXCJcIjtcbiAgICAgICAgY29uc3QgZXhjZXJwdCA9IGl0ZW0uQ29udGVudCA/IHRoaXMuY2xlYW5SZXN1bHQoaXRlbS5Db250ZW50KSA6IFwiXCI7XG4gICAgICAgIGNvbnN0IHBhZ2VDb250ZW50ID0gdGhpcy5jb21iaW5lVGV4dCh0aXRsZSwgZXhjZXJwdCk7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGl0ZW0uRG9jdW1lbnRVUkk7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB0aGlzLmdldERvY0F0dHJpYnV0ZXMoaXRlbS5Eb2N1bWVudEF0dHJpYnV0ZXMpO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgZXhjZXJwdCxcbiAgICAgICAgICAgIGRvY3VtZW50X2F0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgZG9jdW1lbnRzXzEuRG9jdW1lbnQoeyBwYWdlQ29udGVudCwgbWV0YWRhdGEgfSk7XG4gICAgfVxuICAgIC8vIEEgbWV0aG9kIHRvIGV4dHJhY3QgdGhlIHRvcC1rIGRvY3VtZW50cyBmcm9tIGEgUmV0cmlldmVDb21tYW5kT3V0cHV0IG9iamVjdC5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgdG9wLWsgZG9jdW1lbnRzIGZyb20gYSBSZXRyaWV2ZUNvbW1hbmRPdXRwdXQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSByZXNwb25zZSBUaGUgUmV0cmlldmVDb21tYW5kT3V0cHV0IG9iamVjdCB0byBleHRyYWN0IHRoZSBkb2N1bWVudHMgZnJvbS5cbiAgICAgKiBAcGFyYW0gcGFnZVNpemUgVGhlIG51bWJlciBvZiBkb2N1bWVudHMgdG8gZXh0cmFjdC5cbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBEb2N1bWVudCBvYmplY3RzLlxuICAgICAqL1xuICAgIGdldFJldHJpZXZlckRvY3MocmVzcG9uc2UsIHBhZ2VTaXplKSB7XG4gICAgICAgIGlmICghcmVzcG9uc2UuUmVzdWx0SXRlbXMpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSByZXNwb25zZS5SZXN1bHRJdGVtcztcbiAgICAgICAgY29uc3QgY291bnQgPSBsZW5ndGggPCBwYWdlU2l6ZSA/IGxlbmd0aCA6IHBhZ2VTaXplO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuUmVzdWx0SXRlbXMuc2xpY2UoMCwgY291bnQpLm1hcCgoaXRlbSkgPT4gdGhpcy5jb252ZXJ0UmV0cmlldmVySXRlbShpdGVtKSk7XG4gICAgfVxuICAgIC8vIEEgbWV0aG9kIHRvIGV4dHJhY3QgdGhlIGV4Y2VycHQgdGV4dCBmcm9tIGEgUXVlcnlSZXN1bHRJdGVtIG9iamVjdC5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgZXhjZXJwdCB0ZXh0IGZyb20gYSBRdWVyeVJlc3VsdEl0ZW0gb2JqZWN0LlxuICAgICAqIEBwYXJhbSBpdGVtIFRoZSBRdWVyeVJlc3VsdEl0ZW0gb2JqZWN0IHRvIGV4dHJhY3QgdGhlIGV4Y2VycHQgdGV4dCBmcm9tLlxuICAgICAqIEByZXR1cm5zIFRoZSBleHRyYWN0ZWQgZXhjZXJwdCB0ZXh0LlxuICAgICAqL1xuICAgIGdldFF1ZXJ5SXRlbUV4Y2VycHQoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5BZGRpdGlvbmFsQXR0cmlidXRlcyAmJlxuICAgICAgICAgICAgaXRlbS5BZGRpdGlvbmFsQXR0cmlidXRlcy5sZW5ndGggJiZcbiAgICAgICAgICAgIGl0ZW0uQWRkaXRpb25hbEF0dHJpYnV0ZXNbMF0uS2V5ID09PSBcIkFuc3dlclRleHRcIikge1xuICAgICAgICAgICAgaWYgKCFpdGVtLkFkZGl0aW9uYWxBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWl0ZW0uQWRkaXRpb25hbEF0dHJpYnV0ZXNbMF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsZWFuUmVzdWx0KGl0ZW0uQWRkaXRpb25hbEF0dHJpYnV0ZXNbMF0uVmFsdWU/LlRleHRXaXRoSGlnaGxpZ2h0c1ZhbHVlPy5UZXh0IHx8IFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGl0ZW0uRG9jdW1lbnRFeGNlcnB0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGVhblJlc3VsdChpdGVtLkRvY3VtZW50RXhjZXJwdC5UZXh0IHx8IFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQSBtZXRob2QgdG8gY29udmVydCBhIFF1ZXJ5UmVzdWx0SXRlbSBvYmplY3QgaW50byBhIERvY3VtZW50IG9iamVjdC5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIFF1ZXJ5UmVzdWx0SXRlbSBvYmplY3QgaW50byBhIERvY3VtZW50IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gaXRlbSBUaGUgUXVlcnlSZXN1bHRJdGVtIG9iamVjdCB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIEEgRG9jdW1lbnQgb2JqZWN0LlxuICAgICAqL1xuICAgIGNvbnZlcnRRdWVyeUl0ZW0oaXRlbSkge1xuICAgICAgICBjb25zdCB0aXRsZSA9IGl0ZW0uRG9jdW1lbnRUaXRsZT8uVGV4dCB8fCBcIlwiO1xuICAgICAgICBjb25zdCBleGNlcnB0ID0gdGhpcy5nZXRRdWVyeUl0ZW1FeGNlcnB0KGl0ZW0pO1xuICAgICAgICBjb25zdCBwYWdlQ29udGVudCA9IHRoaXMuY29tYmluZVRleHQodGl0bGUsIGV4Y2VycHQpO1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBpdGVtLkRvY3VtZW50VVJJO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy5nZXREb2NBdHRyaWJ1dGVzKGl0ZW0uRG9jdW1lbnRBdHRyaWJ1dGVzKTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgIGV4Y2VycHQsXG4gICAgICAgICAgICBkb2N1bWVudF9hdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IGRvY3VtZW50c18xLkRvY3VtZW50KHsgcGFnZUNvbnRlbnQsIG1ldGFkYXRhIH0pO1xuICAgIH1cbiAgICAvLyBBIG1ldGhvZCB0byBleHRyYWN0IHRoZSB0b3AtayBkb2N1bWVudHMgZnJvbSBhIFF1ZXJ5Q29tbWFuZE91dHB1dCBvYmplY3QuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHRvcC1rIGRvY3VtZW50cyBmcm9tIGEgUXVlcnlDb21tYW5kT3V0cHV0IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gcmVzcG9uc2UgVGhlIFF1ZXJ5Q29tbWFuZE91dHB1dCBvYmplY3QgdG8gZXh0cmFjdCB0aGUgZG9jdW1lbnRzIGZyb20uXG4gICAgICogQHBhcmFtIHBhZ2VTaXplIFRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIHRvIGV4dHJhY3QuXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgRG9jdW1lbnQgb2JqZWN0cy5cbiAgICAgKi9cbiAgICBnZXRRdWVyeURvY3MocmVzcG9uc2UsIHBhZ2VTaXplKSB7XG4gICAgICAgIGlmICghcmVzcG9uc2UuUmVzdWx0SXRlbXMpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSByZXNwb25zZS5SZXN1bHRJdGVtcztcbiAgICAgICAgY29uc3QgY291bnQgPSBsZW5ndGggPCBwYWdlU2l6ZSA/IGxlbmd0aCA6IHBhZ2VTaXplO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuUmVzdWx0SXRlbXMuc2xpY2UoMCwgY291bnQpLm1hcCgoaXRlbSkgPT4gdGhpcy5jb252ZXJ0UXVlcnlJdGVtKGl0ZW0pKTtcbiAgICB9XG4gICAgLy8gQSBtZXRob2QgdG8gc2VuZCBhIHJldHJpZXZlIG9yIHF1ZXJ5IHJlcXVlc3QgdG8gS2VuZHJhIGFuZCByZXR1cm4gdGhlIHRvcC1rIGRvY3VtZW50cy5cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIHJldHJpZXZlIG9yIHF1ZXJ5IHJlcXVlc3QgdG8gS2VuZHJhIGFuZCByZXR1cm5zIHRoZSB0b3Ata1xuICAgICAqIGRvY3VtZW50cy5cbiAgICAgKiBAcGFyYW0gcXVlcnkgVGhlIHF1ZXJ5IHRvIHNlbmQgdG8gS2VuZHJhLlxuICAgICAqIEBwYXJhbSB0b3BLIFRoZSBudW1iZXIgb2YgdG9wIGRvY3VtZW50cyB0byByZXR1cm4uXG4gICAgICogQHBhcmFtIGF0dHJpYnV0ZUZpbHRlciBPcHRpb25hbCBmaWx0ZXIgdG8gYXBwbHkgd2hlbiByZXRyaWV2aW5nIGRvY3VtZW50cy5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhcnJheSBvZiBEb2N1bWVudCBvYmplY3RzLlxuICAgICAqL1xuICAgIGFzeW5jIHF1ZXJ5S2VuZHJhKHF1ZXJ5LCB0b3BLLCBhdHRyaWJ1dGVGaWx0ZXIpIHtcbiAgICAgICAgY29uc3QgcmV0cmlldmVDb21tYW5kID0gbmV3IGNsaWVudF9rZW5kcmFfMS5SZXRyaWV2ZUNvbW1hbmQoe1xuICAgICAgICAgICAgSW5kZXhJZDogdGhpcy5pbmRleElkLFxuICAgICAgICAgICAgUXVlcnlUZXh0OiBxdWVyeSxcbiAgICAgICAgICAgIFBhZ2VTaXplOiB0b3BLLFxuICAgICAgICAgICAgQXR0cmlidXRlRmlsdGVyOiBhdHRyaWJ1dGVGaWx0ZXIsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXRyaWV2ZVJlc3BvbnNlID0gYXdhaXQgdGhpcy5rZW5kcmFDbGllbnQuc2VuZChyZXRyaWV2ZUNvbW1hbmQpO1xuICAgICAgICBjb25zdCByZXRyaXZlTGVuZ3RoID0gcmV0cmlldmVSZXNwb25zZS5SZXN1bHRJdGVtcz8ubGVuZ3RoO1xuICAgICAgICBpZiAocmV0cml2ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gUmV0cmlldmUgQVBJIHJldHVybmVkIDAgcmVzdWx0cywgY2FsbCBxdWVyeSBBUElcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5Q29tbWFuZCA9IG5ldyBjbGllbnRfa2VuZHJhXzEuUXVlcnlDb21tYW5kKHtcbiAgICAgICAgICAgICAgICBJbmRleElkOiB0aGlzLmluZGV4SWQsXG4gICAgICAgICAgICAgICAgUXVlcnlUZXh0OiBxdWVyeSxcbiAgICAgICAgICAgICAgICBQYWdlU2l6ZTogdG9wSyxcbiAgICAgICAgICAgICAgICBBdHRyaWJ1dGVGaWx0ZXI6IGF0dHJpYnV0ZUZpbHRlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcXVlcnlSZXNwb25zZSA9IGF3YWl0IHRoaXMua2VuZHJhQ2xpZW50LnNlbmQocXVlcnlDb21tYW5kKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFF1ZXJ5RG9jcyhxdWVyeVJlc3BvbnNlLCB0aGlzLnRvcEspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmV0cmlldmVyRG9jcyhyZXRyaWV2ZVJlc3BvbnNlLCB0aGlzLnRvcEspO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9nZXRSZWxldmFudERvY3VtZW50cyhxdWVyeSkge1xuICAgICAgICBjb25zdCBkb2NzID0gYXdhaXQgdGhpcy5xdWVyeUtlbmRyYShxdWVyeSwgdGhpcy50b3BLLCB0aGlzLmF0dHJpYnV0ZUZpbHRlcik7XG4gICAgICAgIHJldHVybiBkb2NzO1xuICAgIH1cbn1cbmV4cG9ydHMuQW1hem9uS2VuZHJhUmV0cmlldmVyID0gQW1hem9uS2VuZHJhUmV0cmlldmVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/aws/dist/retrievers/kendra.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/aws/dist/types.cjs":
/*!****************************************************!*\
  !*** ./node_modules/@langchain/aws/dist/types.cjs ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9hd3MvZGlzdC90eXBlcy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2F3cy9kaXN0L3R5cGVzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/aws/dist/types.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/aws/index.cjs":
/*!***********************************************!*\
  !*** ./node_modules/@langchain/aws/index.cjs ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/index.cjs */ \"(rsc)/./node_modules/@langchain/aws/dist/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9hd3MvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFBLGtIQUE0QyIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vYXdzL2luZGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9pbmRleC5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/aws/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/community/dist/llms/ollama.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/community/dist/llms/ollama.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Ollama = void 0;\nconst outputs_1 = __webpack_require__(/*! @langchain/core/outputs */ \"(rsc)/./node_modules/@langchain/core/outputs.cjs\");\nconst llms_1 = __webpack_require__(/*! @langchain/core/language_models/llms */ \"(rsc)/./node_modules/@langchain/core/language_models/llms.cjs\");\nconst ollama_js_1 = __webpack_require__(/*! ../utils/ollama.cjs */ \"(rsc)/./node_modules/@langchain/community/dist/utils/ollama.cjs\");\n/**\n * @deprecated Ollama LLM has moved to the `@langchain/ollama` package. Please install it using `npm install @langchain/ollama` and import it from there.\n *\n * Class that represents the Ollama language model. It extends the base\n * LLM class and implements the OllamaInput interface.\n * @example\n * ```typescript\n * const ollama = new Ollama({\n *   baseUrl: \"http://api.example.com\",\n *   model: \"llama2\",\n * });\n *\n * // Streaming translation from English to German\n * const stream = await ollama.stream(\n *   `Translate \"I love programming\" into German.`\n * );\n *\n * const chunks = [];\n * for await (const chunk of stream) {\n *   chunks.push(chunk);\n * }\n *\n * console.log(chunks.join(\"\"));\n * ```\n */\nclass Ollama extends llms_1.LLM {\n    static lc_name() {\n        return \"Ollama\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"model\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"llama2\"\n        });\n        Object.defineProperty(this, \"baseUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"http://localhost:11434\"\n        });\n        Object.defineProperty(this, \"keepAlive\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"5m\"\n        });\n        Object.defineProperty(this, \"embeddingOnly\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"f16KV\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"frequencyPenalty\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"headers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"logitsAll\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"lowVram\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"mainGpu\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"mirostat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"mirostatEta\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"mirostatTau\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"numBatch\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"numCtx\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"numGpu\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"numGqa\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"numKeep\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"numPredict\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"numThread\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"penalizeNewline\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"presencePenalty\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"repeatLastN\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"repeatPenalty\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"ropeFrequencyBase\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"ropeFrequencyScale\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"temperature\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"stop\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tfsZ\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"topK\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"topP\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"typicalP\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"useMLock\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"useMMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"vocabOnly\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"format\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.model = fields.model ?? this.model;\n        this.baseUrl = fields.baseUrl?.endsWith(\"/\")\n            ? fields.baseUrl.slice(0, -1)\n            : fields.baseUrl ?? this.baseUrl;\n        this.keepAlive = fields.keepAlive ?? this.keepAlive;\n        this.headers = fields.headers ?? this.headers;\n        this.embeddingOnly = fields.embeddingOnly;\n        this.f16KV = fields.f16KV;\n        this.frequencyPenalty = fields.frequencyPenalty;\n        this.logitsAll = fields.logitsAll;\n        this.lowVram = fields.lowVram;\n        this.mainGpu = fields.mainGpu;\n        this.mirostat = fields.mirostat;\n        this.mirostatEta = fields.mirostatEta;\n        this.mirostatTau = fields.mirostatTau;\n        this.numBatch = fields.numBatch;\n        this.numCtx = fields.numCtx;\n        this.numGpu = fields.numGpu;\n        this.numGqa = fields.numGqa;\n        this.numKeep = fields.numKeep;\n        this.numPredict = fields.numPredict;\n        this.numThread = fields.numThread;\n        this.penalizeNewline = fields.penalizeNewline;\n        this.presencePenalty = fields.presencePenalty;\n        this.repeatLastN = fields.repeatLastN;\n        this.repeatPenalty = fields.repeatPenalty;\n        this.ropeFrequencyBase = fields.ropeFrequencyBase;\n        this.ropeFrequencyScale = fields.ropeFrequencyScale;\n        this.temperature = fields.temperature;\n        this.stop = fields.stop;\n        this.tfsZ = fields.tfsZ;\n        this.topK = fields.topK;\n        this.topP = fields.topP;\n        this.typicalP = fields.typicalP;\n        this.useMLock = fields.useMLock;\n        this.useMMap = fields.useMMap;\n        this.vocabOnly = fields.vocabOnly;\n        this.format = fields.format;\n    }\n    _llmType() {\n        return \"ollama\";\n    }\n    invocationParams(options) {\n        return {\n            model: this.model,\n            format: this.format,\n            keep_alive: this.keepAlive,\n            images: options?.images,\n            options: {\n                embedding_only: this.embeddingOnly,\n                f16_kv: this.f16KV,\n                frequency_penalty: this.frequencyPenalty,\n                logits_all: this.logitsAll,\n                low_vram: this.lowVram,\n                main_gpu: this.mainGpu,\n                mirostat: this.mirostat,\n                mirostat_eta: this.mirostatEta,\n                mirostat_tau: this.mirostatTau,\n                num_batch: this.numBatch,\n                num_ctx: this.numCtx,\n                num_gpu: this.numGpu,\n                num_gqa: this.numGqa,\n                num_keep: this.numKeep,\n                num_predict: this.numPredict,\n                num_thread: this.numThread,\n                penalize_newline: this.penalizeNewline,\n                presence_penalty: this.presencePenalty,\n                repeat_last_n: this.repeatLastN,\n                repeat_penalty: this.repeatPenalty,\n                rope_frequency_base: this.ropeFrequencyBase,\n                rope_frequency_scale: this.ropeFrequencyScale,\n                temperature: this.temperature,\n                stop: options?.stop ?? this.stop,\n                tfs_z: this.tfsZ,\n                top_k: this.topK,\n                top_p: this.topP,\n                typical_p: this.typicalP,\n                use_mlock: this.useMLock,\n                use_mmap: this.useMMap,\n                vocab_only: this.vocabOnly,\n            },\n        };\n    }\n    async *_streamResponseChunks(prompt, options, runManager) {\n        const stream = await this.caller.call(async () => (0, ollama_js_1.createOllamaGenerateStream)(this.baseUrl, { ...this.invocationParams(options), prompt }, {\n            ...options,\n            headers: this.headers,\n        }));\n        for await (const chunk of stream) {\n            if (!chunk.done) {\n                yield new outputs_1.GenerationChunk({\n                    text: chunk.response,\n                    generationInfo: {\n                        ...chunk,\n                        response: undefined,\n                    },\n                });\n                await runManager?.handleLLMNewToken(chunk.response ?? \"\");\n            }\n            else {\n                yield new outputs_1.GenerationChunk({\n                    text: \"\",\n                    generationInfo: {\n                        model: chunk.model,\n                        total_duration: chunk.total_duration,\n                        load_duration: chunk.load_duration,\n                        prompt_eval_count: chunk.prompt_eval_count,\n                        prompt_eval_duration: chunk.prompt_eval_duration,\n                        eval_count: chunk.eval_count,\n                        eval_duration: chunk.eval_duration,\n                    },\n                });\n            }\n        }\n    }\n    /** @ignore */\n    async _call(prompt, options, runManager) {\n        const chunks = [];\n        for await (const chunk of this._streamResponseChunks(prompt, options, runManager)) {\n            chunks.push(chunk.text);\n        }\n        return chunks.join(\"\");\n    }\n}\nexports.Ollama = Ollama;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb21tdW5pdHkvZGlzdC9sbG1zL29sbGFtYS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLGtCQUFrQixtQkFBTyxDQUFDLGlGQUF5QjtBQUNuRCxlQUFlLG1CQUFPLENBQUMsMkdBQXNDO0FBQzdELG9CQUFvQixtQkFBTyxDQUFDLDRGQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHNIQUFzSCwyQ0FBMkM7QUFDaks7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvbW11bml0eS9kaXN0L2xsbXMvb2xsYW1hLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT2xsYW1hID0gdm9pZCAwO1xuY29uc3Qgb3V0cHV0c18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9vdXRwdXRzXCIpO1xuY29uc3QgbGxtc18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9sYW5ndWFnZV9tb2RlbHMvbGxtc1wiKTtcbmNvbnN0IG9sbGFtYV9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL29sbGFtYS5janNcIik7XG4vKipcbiAqIEBkZXByZWNhdGVkIE9sbGFtYSBMTE0gaGFzIG1vdmVkIHRvIHRoZSBgQGxhbmdjaGFpbi9vbGxhbWFgIHBhY2thZ2UuIFBsZWFzZSBpbnN0YWxsIGl0IHVzaW5nIGBucG0gaW5zdGFsbCBAbGFuZ2NoYWluL29sbGFtYWAgYW5kIGltcG9ydCBpdCBmcm9tIHRoZXJlLlxuICpcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyB0aGUgT2xsYW1hIGxhbmd1YWdlIG1vZGVsLiBJdCBleHRlbmRzIHRoZSBiYXNlXG4gKiBMTE0gY2xhc3MgYW5kIGltcGxlbWVudHMgdGhlIE9sbGFtYUlucHV0IGludGVyZmFjZS5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBvbGxhbWEgPSBuZXcgT2xsYW1hKHtcbiAqICAgYmFzZVVybDogXCJodHRwOi8vYXBpLmV4YW1wbGUuY29tXCIsXG4gKiAgIG1vZGVsOiBcImxsYW1hMlwiLFxuICogfSk7XG4gKlxuICogLy8gU3RyZWFtaW5nIHRyYW5zbGF0aW9uIGZyb20gRW5nbGlzaCB0byBHZXJtYW5cbiAqIGNvbnN0IHN0cmVhbSA9IGF3YWl0IG9sbGFtYS5zdHJlYW0oXG4gKiAgIGBUcmFuc2xhdGUgXCJJIGxvdmUgcHJvZ3JhbW1pbmdcIiBpbnRvIEdlcm1hbi5gXG4gKiApO1xuICpcbiAqIGNvbnN0IGNodW5rcyA9IFtdO1xuICogZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAqICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICogfVxuICpcbiAqIGNvbnNvbGUubG9nKGNodW5rcy5qb2luKFwiXCIpKTtcbiAqIGBgYFxuICovXG5jbGFzcyBPbGxhbWEgZXh0ZW5kcyBsbG1zXzEuTExNIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiT2xsYW1hXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1vZGVsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImxsYW1hMlwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJiYXNlVXJsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImh0dHA6Ly9sb2NhbGhvc3Q6MTE0MzRcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwia2VlcEFsaXZlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcIjVtXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVtYmVkZGluZ09ubHlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZjE2S1ZcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZnJlcXVlbmN5UGVuYWx0eVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoZWFkZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxvZ2l0c0FsbFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsb3dWcmFtXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1haW5HcHVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWlyb3N0YXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWlyb3N0YXRFdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWlyb3N0YXRUYXVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibnVtQmF0Y2hcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibnVtQ3R4XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm51bUdwdVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJudW1HcWFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibnVtS2VlcFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJudW1QcmVkaWN0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm51bVRocmVhZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwZW5hbGl6ZU5ld2xpbmVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicHJlc2VuY2VQZW5hbHR5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlcGVhdExhc3ROXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlcGVhdFBlbmFsdHlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicm9wZUZyZXF1ZW5jeUJhc2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicm9wZUZyZXF1ZW5jeVNjYWxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRlbXBlcmF0dXJlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0b3BcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGZzWlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3BLXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvcFBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHlwaWNhbFBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidXNlTUxvY2tcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidXNlTU1hcFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2b2NhYk9ubHlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZm9ybWF0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubW9kZWwgPSBmaWVsZHMubW9kZWwgPz8gdGhpcy5tb2RlbDtcbiAgICAgICAgdGhpcy5iYXNlVXJsID0gZmllbGRzLmJhc2VVcmw/LmVuZHNXaXRoKFwiL1wiKVxuICAgICAgICAgICAgPyBmaWVsZHMuYmFzZVVybC5zbGljZSgwLCAtMSlcbiAgICAgICAgICAgIDogZmllbGRzLmJhc2VVcmwgPz8gdGhpcy5iYXNlVXJsO1xuICAgICAgICB0aGlzLmtlZXBBbGl2ZSA9IGZpZWxkcy5rZWVwQWxpdmUgPz8gdGhpcy5rZWVwQWxpdmU7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGZpZWxkcy5oZWFkZXJzID8/IHRoaXMuaGVhZGVycztcbiAgICAgICAgdGhpcy5lbWJlZGRpbmdPbmx5ID0gZmllbGRzLmVtYmVkZGluZ09ubHk7XG4gICAgICAgIHRoaXMuZjE2S1YgPSBmaWVsZHMuZjE2S1Y7XG4gICAgICAgIHRoaXMuZnJlcXVlbmN5UGVuYWx0eSA9IGZpZWxkcy5mcmVxdWVuY3lQZW5hbHR5O1xuICAgICAgICB0aGlzLmxvZ2l0c0FsbCA9IGZpZWxkcy5sb2dpdHNBbGw7XG4gICAgICAgIHRoaXMubG93VnJhbSA9IGZpZWxkcy5sb3dWcmFtO1xuICAgICAgICB0aGlzLm1haW5HcHUgPSBmaWVsZHMubWFpbkdwdTtcbiAgICAgICAgdGhpcy5taXJvc3RhdCA9IGZpZWxkcy5taXJvc3RhdDtcbiAgICAgICAgdGhpcy5taXJvc3RhdEV0YSA9IGZpZWxkcy5taXJvc3RhdEV0YTtcbiAgICAgICAgdGhpcy5taXJvc3RhdFRhdSA9IGZpZWxkcy5taXJvc3RhdFRhdTtcbiAgICAgICAgdGhpcy5udW1CYXRjaCA9IGZpZWxkcy5udW1CYXRjaDtcbiAgICAgICAgdGhpcy5udW1DdHggPSBmaWVsZHMubnVtQ3R4O1xuICAgICAgICB0aGlzLm51bUdwdSA9IGZpZWxkcy5udW1HcHU7XG4gICAgICAgIHRoaXMubnVtR3FhID0gZmllbGRzLm51bUdxYTtcbiAgICAgICAgdGhpcy5udW1LZWVwID0gZmllbGRzLm51bUtlZXA7XG4gICAgICAgIHRoaXMubnVtUHJlZGljdCA9IGZpZWxkcy5udW1QcmVkaWN0O1xuICAgICAgICB0aGlzLm51bVRocmVhZCA9IGZpZWxkcy5udW1UaHJlYWQ7XG4gICAgICAgIHRoaXMucGVuYWxpemVOZXdsaW5lID0gZmllbGRzLnBlbmFsaXplTmV3bGluZTtcbiAgICAgICAgdGhpcy5wcmVzZW5jZVBlbmFsdHkgPSBmaWVsZHMucHJlc2VuY2VQZW5hbHR5O1xuICAgICAgICB0aGlzLnJlcGVhdExhc3ROID0gZmllbGRzLnJlcGVhdExhc3ROO1xuICAgICAgICB0aGlzLnJlcGVhdFBlbmFsdHkgPSBmaWVsZHMucmVwZWF0UGVuYWx0eTtcbiAgICAgICAgdGhpcy5yb3BlRnJlcXVlbmN5QmFzZSA9IGZpZWxkcy5yb3BlRnJlcXVlbmN5QmFzZTtcbiAgICAgICAgdGhpcy5yb3BlRnJlcXVlbmN5U2NhbGUgPSBmaWVsZHMucm9wZUZyZXF1ZW5jeVNjYWxlO1xuICAgICAgICB0aGlzLnRlbXBlcmF0dXJlID0gZmllbGRzLnRlbXBlcmF0dXJlO1xuICAgICAgICB0aGlzLnN0b3AgPSBmaWVsZHMuc3RvcDtcbiAgICAgICAgdGhpcy50ZnNaID0gZmllbGRzLnRmc1o7XG4gICAgICAgIHRoaXMudG9wSyA9IGZpZWxkcy50b3BLO1xuICAgICAgICB0aGlzLnRvcFAgPSBmaWVsZHMudG9wUDtcbiAgICAgICAgdGhpcy50eXBpY2FsUCA9IGZpZWxkcy50eXBpY2FsUDtcbiAgICAgICAgdGhpcy51c2VNTG9jayA9IGZpZWxkcy51c2VNTG9jaztcbiAgICAgICAgdGhpcy51c2VNTWFwID0gZmllbGRzLnVzZU1NYXA7XG4gICAgICAgIHRoaXMudm9jYWJPbmx5ID0gZmllbGRzLnZvY2FiT25seTtcbiAgICAgICAgdGhpcy5mb3JtYXQgPSBmaWVsZHMuZm9ybWF0O1xuICAgIH1cbiAgICBfbGxtVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwib2xsYW1hXCI7XG4gICAgfVxuICAgIGludm9jYXRpb25QYXJhbXMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuZm9ybWF0LFxuICAgICAgICAgICAga2VlcF9hbGl2ZTogdGhpcy5rZWVwQWxpdmUsXG4gICAgICAgICAgICBpbWFnZXM6IG9wdGlvbnM/LmltYWdlcyxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBlbWJlZGRpbmdfb25seTogdGhpcy5lbWJlZGRpbmdPbmx5LFxuICAgICAgICAgICAgICAgIGYxNl9rdjogdGhpcy5mMTZLVixcbiAgICAgICAgICAgICAgICBmcmVxdWVuY3lfcGVuYWx0eTogdGhpcy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgICAgIGxvZ2l0c19hbGw6IHRoaXMubG9naXRzQWxsLFxuICAgICAgICAgICAgICAgIGxvd192cmFtOiB0aGlzLmxvd1ZyYW0sXG4gICAgICAgICAgICAgICAgbWFpbl9ncHU6IHRoaXMubWFpbkdwdSxcbiAgICAgICAgICAgICAgICBtaXJvc3RhdDogdGhpcy5taXJvc3RhdCxcbiAgICAgICAgICAgICAgICBtaXJvc3RhdF9ldGE6IHRoaXMubWlyb3N0YXRFdGEsXG4gICAgICAgICAgICAgICAgbWlyb3N0YXRfdGF1OiB0aGlzLm1pcm9zdGF0VGF1LFxuICAgICAgICAgICAgICAgIG51bV9iYXRjaDogdGhpcy5udW1CYXRjaCxcbiAgICAgICAgICAgICAgICBudW1fY3R4OiB0aGlzLm51bUN0eCxcbiAgICAgICAgICAgICAgICBudW1fZ3B1OiB0aGlzLm51bUdwdSxcbiAgICAgICAgICAgICAgICBudW1fZ3FhOiB0aGlzLm51bUdxYSxcbiAgICAgICAgICAgICAgICBudW1fa2VlcDogdGhpcy5udW1LZWVwLFxuICAgICAgICAgICAgICAgIG51bV9wcmVkaWN0OiB0aGlzLm51bVByZWRpY3QsXG4gICAgICAgICAgICAgICAgbnVtX3RocmVhZDogdGhpcy5udW1UaHJlYWQsXG4gICAgICAgICAgICAgICAgcGVuYWxpemVfbmV3bGluZTogdGhpcy5wZW5hbGl6ZU5ld2xpbmUsXG4gICAgICAgICAgICAgICAgcHJlc2VuY2VfcGVuYWx0eTogdGhpcy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgcmVwZWF0X2xhc3RfbjogdGhpcy5yZXBlYXRMYXN0TixcbiAgICAgICAgICAgICAgICByZXBlYXRfcGVuYWx0eTogdGhpcy5yZXBlYXRQZW5hbHR5LFxuICAgICAgICAgICAgICAgIHJvcGVfZnJlcXVlbmN5X2Jhc2U6IHRoaXMucm9wZUZyZXF1ZW5jeUJhc2UsXG4gICAgICAgICAgICAgICAgcm9wZV9mcmVxdWVuY3lfc2NhbGU6IHRoaXMucm9wZUZyZXF1ZW5jeVNjYWxlLFxuICAgICAgICAgICAgICAgIHRlbXBlcmF0dXJlOiB0aGlzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgIHN0b3A6IG9wdGlvbnM/LnN0b3AgPz8gdGhpcy5zdG9wLFxuICAgICAgICAgICAgICAgIHRmc196OiB0aGlzLnRmc1osXG4gICAgICAgICAgICAgICAgdG9wX2s6IHRoaXMudG9wSyxcbiAgICAgICAgICAgICAgICB0b3BfcDogdGhpcy50b3BQLFxuICAgICAgICAgICAgICAgIHR5cGljYWxfcDogdGhpcy50eXBpY2FsUCxcbiAgICAgICAgICAgICAgICB1c2VfbWxvY2s6IHRoaXMudXNlTUxvY2ssXG4gICAgICAgICAgICAgICAgdXNlX21tYXA6IHRoaXMudXNlTU1hcCxcbiAgICAgICAgICAgICAgICB2b2NhYl9vbmx5OiB0aGlzLnZvY2FiT25seSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jICpfc3RyZWFtUmVzcG9uc2VDaHVua3MocHJvbXB0LCBvcHRpb25zLCBydW5NYW5hZ2VyKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4gKDAsIG9sbGFtYV9qc18xLmNyZWF0ZU9sbGFtYUdlbmVyYXRlU3RyZWFtKSh0aGlzLmJhc2VVcmwsIHsgLi4udGhpcy5pbnZvY2F0aW9uUGFyYW1zKG9wdGlvbnMpLCBwcm9tcHQgfSwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgfSkpO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgaWYgKCFjaHVuay5kb25lKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgbmV3IG91dHB1dHNfMS5HZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjaHVuay5yZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbkluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNodW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVMTE1OZXdUb2tlbihjaHVuay5yZXNwb25zZSA/PyBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHlpZWxkIG5ldyBvdXRwdXRzXzEuR2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbkluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsOiBjaHVuay5tb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsX2R1cmF0aW9uOiBjaHVuay50b3RhbF9kdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRfZHVyYXRpb246IGNodW5rLmxvYWRfZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9tcHRfZXZhbF9jb3VudDogY2h1bmsucHJvbXB0X2V2YWxfY291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9tcHRfZXZhbF9kdXJhdGlvbjogY2h1bmsucHJvbXB0X2V2YWxfZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBldmFsX2NvdW50OiBjaHVuay5ldmFsX2NvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZhbF9kdXJhdGlvbjogY2h1bmsuZXZhbF9kdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIGFzeW5jIF9jYWxsKHByb21wdCwgb3B0aW9ucywgcnVuTWFuYWdlcikge1xuICAgICAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiB0aGlzLl9zdHJlYW1SZXNwb25zZUNodW5rcyhwcm9tcHQsIG9wdGlvbnMsIHJ1bk1hbmFnZXIpKSB7XG4gICAgICAgICAgICBjaHVua3MucHVzaChjaHVuay50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2h1bmtzLmpvaW4oXCJcIik7XG4gICAgfVxufVxuZXhwb3J0cy5PbGxhbWEgPSBPbGxhbWE7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/community/dist/llms/ollama.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/community/dist/utils/ollama.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/community/dist/utils/ollama.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createOllamaGenerateStream = createOllamaGenerateStream;\nexports.createOllamaChatStream = createOllamaChatStream;\nconst stream_1 = __webpack_require__(/*! @langchain/core/utils/stream */ \"(rsc)/./node_modules/@langchain/core/utils/stream.cjs\");\nasync function* createOllamaStream(url, params, options) {\n    let formattedUrl = url;\n    if (formattedUrl.startsWith(\"http://localhost:\")) {\n        // Node 18 has issues with resolving \"localhost\"\n        // See https://github.com/node-fetch/node-fetch/issues/1624\n        formattedUrl = formattedUrl.replace(\"http://localhost:\", \"http://127.0.0.1:\");\n    }\n    const response = await fetch(formattedUrl, {\n        method: \"POST\",\n        body: JSON.stringify(params),\n        headers: {\n            \"Content-Type\": \"application/json\",\n            ...options.headers,\n        },\n        signal: options.signal,\n    });\n    if (!response.ok) {\n        let error;\n        const responseText = await response.text();\n        try {\n            const json = JSON.parse(responseText);\n            error = new Error(`Ollama call failed with status code ${response.status}: ${json.error}`);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            error = new Error(`Ollama call failed with status code ${response.status}: ${responseText}`);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        error.response = response;\n        throw error;\n    }\n    if (!response.body) {\n        throw new Error(\"Could not begin Ollama stream. Please check the given URL and try again.\");\n    }\n    const stream = stream_1.IterableReadableStream.fromReadableStream(response.body);\n    const decoder = new TextDecoder();\n    let extra = \"\";\n    for await (const chunk of stream) {\n        const decoded = extra + decoder.decode(chunk);\n        const lines = decoded.split(\"\\n\");\n        extra = lines.pop() || \"\";\n        for (const line of lines) {\n            try {\n                yield JSON.parse(line);\n            }\n            catch (e) {\n                console.warn(`Received a non-JSON parseable chunk: ${line}`);\n            }\n        }\n    }\n}\nasync function* createOllamaGenerateStream(baseUrl, params, options) {\n    yield* createOllamaStream(`${baseUrl}/api/generate`, params, options);\n}\nasync function* createOllamaChatStream(baseUrl, params, options) {\n    yield* createOllamaStream(`${baseUrl}/api/chat`, params, options);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb21tdW5pdHkvZGlzdC91dGlscy9vbGxhbWEuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtDQUFrQztBQUNsQyw4QkFBOEI7QUFDOUIsaUJBQWlCLG1CQUFPLENBQUMsMkZBQThCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsZ0JBQWdCLElBQUksV0FBVztBQUNwRztBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsZ0JBQWdCLElBQUksYUFBYTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLEtBQUs7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QyIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29tbXVuaXR5L2Rpc3QvdXRpbHMvb2xsYW1hLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlT2xsYW1hR2VuZXJhdGVTdHJlYW0gPSBjcmVhdGVPbGxhbWFHZW5lcmF0ZVN0cmVhbTtcbmV4cG9ydHMuY3JlYXRlT2xsYW1hQ2hhdFN0cmVhbSA9IGNyZWF0ZU9sbGFtYUNoYXRTdHJlYW07XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvdXRpbHMvc3RyZWFtXCIpO1xuYXN5bmMgZnVuY3Rpb24qIGNyZWF0ZU9sbGFtYVN0cmVhbSh1cmwsIHBhcmFtcywgb3B0aW9ucykge1xuICAgIGxldCBmb3JtYXR0ZWRVcmwgPSB1cmw7XG4gICAgaWYgKGZvcm1hdHRlZFVybC5zdGFydHNXaXRoKFwiaHR0cDovL2xvY2FsaG9zdDpcIikpIHtcbiAgICAgICAgLy8gTm9kZSAxOCBoYXMgaXNzdWVzIHdpdGggcmVzb2x2aW5nIFwibG9jYWxob3N0XCJcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWZldGNoL25vZGUtZmV0Y2gvaXNzdWVzLzE2MjRcbiAgICAgICAgZm9ybWF0dGVkVXJsID0gZm9ybWF0dGVkVXJsLnJlcGxhY2UoXCJodHRwOi8vbG9jYWxob3N0OlwiLCBcImh0dHA6Ly8xMjcuMC4wLjE6XCIpO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGZvcm1hdHRlZFVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXJhbXMpLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgfSxcbiAgICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UocmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKGBPbGxhbWEgY2FsbCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAke3Jlc3BvbnNlLnN0YXR1c306ICR7anNvbi5lcnJvcn1gKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKGBPbGxhbWEgY2FsbCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2VUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGJlZ2luIE9sbGFtYSBzdHJlYW0uIFBsZWFzZSBjaGVjayB0aGUgZ2l2ZW4gVVJMIGFuZCB0cnkgYWdhaW4uXCIpO1xuICAgIH1cbiAgICBjb25zdCBzdHJlYW0gPSBzdHJlYW1fMS5JdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21SZWFkYWJsZVN0cmVhbShyZXNwb25zZS5ib2R5KTtcbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgbGV0IGV4dHJhID0gXCJcIjtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gZXh0cmEgKyBkZWNvZGVyLmRlY29kZShjaHVuayk7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gZGVjb2RlZC5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgZXh0cmEgPSBsaW5lcy5wb3AoKSB8fCBcIlwiO1xuICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgeWllbGQgSlNPTi5wYXJzZShsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBSZWNlaXZlZCBhIG5vbi1KU09OIHBhcnNlYWJsZSBjaHVuazogJHtsaW5lfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24qIGNyZWF0ZU9sbGFtYUdlbmVyYXRlU3RyZWFtKGJhc2VVcmwsIHBhcmFtcywgb3B0aW9ucykge1xuICAgIHlpZWxkKiBjcmVhdGVPbGxhbWFTdHJlYW0oYCR7YmFzZVVybH0vYXBpL2dlbmVyYXRlYCwgcGFyYW1zLCBvcHRpb25zKTtcbn1cbmFzeW5jIGZ1bmN0aW9uKiBjcmVhdGVPbGxhbWFDaGF0U3RyZWFtKGJhc2VVcmwsIHBhcmFtcywgb3B0aW9ucykge1xuICAgIHlpZWxkKiBjcmVhdGVPbGxhbWFTdHJlYW0oYCR7YmFzZVVybH0vYXBpL2NoYXRgLCBwYXJhbXMsIG9wdGlvbnMpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/community/dist/utils/ollama.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/community/llms/ollama.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/community/llms/ollama.cjs ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/llms/ollama.cjs */ \"(rsc)/./node_modules/@langchain/community/dist/llms/ollama.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb21tdW5pdHkvbGxtcy9vbGxhbWEuY2pzIiwibWFwcGluZ3MiOiJBQUFBLHFJQUFtRCIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29tbXVuaXR5L2xsbXMvb2xsYW1hLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Rpc3QvbGxtcy9vbGxhbWEuY2pzJyk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/community/llms/ollama.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/callbacks/base.cjs":
/*!*********************************************************!*\
  !*** ./node_modules/@langchain/core/callbacks/base.cjs ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/callbacks/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/base.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2NhbGxiYWNrcy9iYXNlLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSxzSUFBc0QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvY2FsbGJhY2tzL2Jhc2UuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vZGlzdC9jYWxsYmFja3MvYmFzZS5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/callbacks/base.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/callbacks/manager.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/callbacks/manager.cjs ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/callbacks/manager.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2NhbGxiYWNrcy9tYW5hZ2VyLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSw0SUFBeUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvY2FsbGJhY2tzL21hbmFnZXIuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vZGlzdC9jYWxsYmFja3MvbWFuYWdlci5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/callbacks/manager.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/callbacks/promises.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/callbacks/promises.cjs ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/callbacks/promises.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/promises.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2NhbGxiYWNrcy9wcm9taXNlcy5janMiLCJtYXBwaW5ncyI6IkFBQUEsOElBQTBEIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2NhbGxiYWNrcy9wcm9taXNlcy5janMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9kaXN0L2NhbGxiYWNrcy9wcm9taXNlcy5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/callbacks/promises.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/caches/base.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/caches/base.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InMemoryCache = exports.BaseCache = exports.getCacheKey = void 0;\nexports.deserializeStoredGeneration = deserializeStoredGeneration;\nexports.serializeGeneration = serializeGeneration;\nconst hash_js_1 = __webpack_require__(/*! ../utils/hash.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/hash.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ../messages/utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs\");\n/**\n * This cache key should be consistent across all versions of LangChain.\n * It is currently NOT consistent across versions of LangChain.\n *\n * A huge benefit of having a remote cache (like redis) is that you can\n * access the cache from different processes/machines. The allows you to\n * separate concerns and scale horizontally.\n *\n * TODO: Make cache key consistent across versions of LangChain.\n *\n * @deprecated Use `makeDefaultKeyEncoder()` to create a custom key encoder.\n * This function will be removed in a future version.\n */\nconst getCacheKey = (...strings) => (0, hash_js_1.insecureHash)(strings.join(\"_\"));\nexports.getCacheKey = getCacheKey;\nfunction deserializeStoredGeneration(storedGeneration) {\n    if (storedGeneration.message !== undefined) {\n        return {\n            text: storedGeneration.text,\n            message: (0, utils_js_1.mapStoredMessageToChatMessage)(storedGeneration.message),\n        };\n    }\n    else {\n        return { text: storedGeneration.text };\n    }\n}\nfunction serializeGeneration(generation) {\n    const serializedValue = {\n        text: generation.text,\n    };\n    if (generation.message !== undefined) {\n        serializedValue.message = generation.message.toDict();\n    }\n    return serializedValue;\n}\n/**\n * Base class for all caches. All caches should extend this class.\n */\nclass BaseCache {\n    constructor() {\n        // For backwards compatibility, we use a default key encoder\n        // that uses SHA-1 to hash the prompt and LLM key. This will also print a warning\n        // about the security implications of using SHA-1 as a cache key.\n        Object.defineProperty(this, \"keyEncoder\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: exports.getCacheKey\n        });\n    }\n    /**\n     * Sets a custom key encoder function for the cache.\n     * This function should take a prompt and an LLM key and return a string\n     * that will be used as the cache key.\n     * @param keyEncoderFn The custom key encoder function.\n     */\n    makeDefaultKeyEncoder(keyEncoderFn) {\n        this.keyEncoder = keyEncoderFn;\n    }\n}\nexports.BaseCache = BaseCache;\nconst GLOBAL_MAP = new Map();\n/**\n * A cache for storing LLM generations that stores data in memory.\n */\nclass InMemoryCache extends BaseCache {\n    constructor(map) {\n        super();\n        Object.defineProperty(this, \"cache\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.cache = map ?? new Map();\n    }\n    /**\n     * Retrieves data from the cache using a prompt and an LLM key. If the\n     * data is not found, it returns null.\n     * @param prompt The prompt used to find the data.\n     * @param llmKey The LLM key used to find the data.\n     * @returns The data corresponding to the prompt and LLM key, or null if not found.\n     */\n    lookup(prompt, llmKey) {\n        return Promise.resolve(this.cache.get(this.keyEncoder(prompt, llmKey)) ?? null);\n    }\n    /**\n     * Updates the cache with new data using a prompt and an LLM key.\n     * @param prompt The prompt used to store the data.\n     * @param llmKey The LLM key used to store the data.\n     * @param value The data to be stored.\n     */\n    async update(prompt, llmKey, value) {\n        this.cache.set(this.keyEncoder(prompt, llmKey), value);\n    }\n    /**\n     * Returns a global instance of InMemoryCache using a predefined global\n     * map as the initial cache.\n     * @returns A global instance of InMemoryCache.\n     */\n    static global() {\n        return new InMemoryCache(GLOBAL_MAP);\n    }\n}\nexports.InMemoryCache = InMemoryCache;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvY2FjaGVzL2Jhc2UuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLGlCQUFpQixHQUFHLG1CQUFtQjtBQUMvRCxtQ0FBbUM7QUFDbkMsMkJBQTJCO0FBQzNCLGtCQUFrQixtQkFBTyxDQUFDLG1GQUFtQjtBQUM3QyxtQkFBbUIsbUJBQU8sQ0FBQywyRkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9jYWNoZXMvYmFzZS5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkluTWVtb3J5Q2FjaGUgPSBleHBvcnRzLkJhc2VDYWNoZSA9IGV4cG9ydHMuZ2V0Q2FjaGVLZXkgPSB2b2lkIDA7XG5leHBvcnRzLmRlc2VyaWFsaXplU3RvcmVkR2VuZXJhdGlvbiA9IGRlc2VyaWFsaXplU3RvcmVkR2VuZXJhdGlvbjtcbmV4cG9ydHMuc2VyaWFsaXplR2VuZXJhdGlvbiA9IHNlcmlhbGl6ZUdlbmVyYXRpb247XG5jb25zdCBoYXNoX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaGFzaC5janNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4uL21lc3NhZ2VzL3V0aWxzLmNqc1wiKTtcbi8qKlxuICogVGhpcyBjYWNoZSBrZXkgc2hvdWxkIGJlIGNvbnNpc3RlbnQgYWNyb3NzIGFsbCB2ZXJzaW9ucyBvZiBMYW5nQ2hhaW4uXG4gKiBJdCBpcyBjdXJyZW50bHkgTk9UIGNvbnNpc3RlbnQgYWNyb3NzIHZlcnNpb25zIG9mIExhbmdDaGFpbi5cbiAqXG4gKiBBIGh1Z2UgYmVuZWZpdCBvZiBoYXZpbmcgYSByZW1vdGUgY2FjaGUgKGxpa2UgcmVkaXMpIGlzIHRoYXQgeW91IGNhblxuICogYWNjZXNzIHRoZSBjYWNoZSBmcm9tIGRpZmZlcmVudCBwcm9jZXNzZXMvbWFjaGluZXMuIFRoZSBhbGxvd3MgeW91IHRvXG4gKiBzZXBhcmF0ZSBjb25jZXJucyBhbmQgc2NhbGUgaG9yaXpvbnRhbGx5LlxuICpcbiAqIFRPRE86IE1ha2UgY2FjaGUga2V5IGNvbnNpc3RlbnQgYWNyb3NzIHZlcnNpb25zIG9mIExhbmdDaGFpbi5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYG1ha2VEZWZhdWx0S2V5RW5jb2RlcigpYCB0byBjcmVhdGUgYSBjdXN0b20ga2V5IGVuY29kZXIuXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlxuICovXG5jb25zdCBnZXRDYWNoZUtleSA9ICguLi5zdHJpbmdzKSA9PiAoMCwgaGFzaF9qc18xLmluc2VjdXJlSGFzaCkoc3RyaW5ncy5qb2luKFwiX1wiKSk7XG5leHBvcnRzLmdldENhY2hlS2V5ID0gZ2V0Q2FjaGVLZXk7XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVN0b3JlZEdlbmVyYXRpb24oc3RvcmVkR2VuZXJhdGlvbikge1xuICAgIGlmIChzdG9yZWRHZW5lcmF0aW9uLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogc3RvcmVkR2VuZXJhdGlvbi50ZXh0LFxuICAgICAgICAgICAgbWVzc2FnZTogKDAsIHV0aWxzX2pzXzEubWFwU3RvcmVkTWVzc2FnZVRvQ2hhdE1lc3NhZ2UpKHN0b3JlZEdlbmVyYXRpb24ubWVzc2FnZSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyB0ZXh0OiBzdG9yZWRHZW5lcmF0aW9uLnRleHQgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXJpYWxpemVHZW5lcmF0aW9uKGdlbmVyYXRpb24pIHtcbiAgICBjb25zdCBzZXJpYWxpemVkVmFsdWUgPSB7XG4gICAgICAgIHRleHQ6IGdlbmVyYXRpb24udGV4dCxcbiAgICB9O1xuICAgIGlmIChnZW5lcmF0aW9uLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXJpYWxpemVkVmFsdWUubWVzc2FnZSA9IGdlbmVyYXRpb24ubWVzc2FnZS50b0RpY3QoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRWYWx1ZTtcbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIGNhY2hlcy4gQWxsIGNhY2hlcyBzaG91bGQgZXh0ZW5kIHRoaXMgY2xhc3MuXG4gKi9cbmNsYXNzIEJhc2VDYWNoZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgd2UgdXNlIGEgZGVmYXVsdCBrZXkgZW5jb2RlclxuICAgICAgICAvLyB0aGF0IHVzZXMgU0hBLTEgdG8gaGFzaCB0aGUgcHJvbXB0IGFuZCBMTE0ga2V5LiBUaGlzIHdpbGwgYWxzbyBwcmludCBhIHdhcm5pbmdcbiAgICAgICAgLy8gYWJvdXQgdGhlIHNlY3VyaXR5IGltcGxpY2F0aW9ucyBvZiB1c2luZyBTSEEtMSBhcyBhIGNhY2hlIGtleS5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwia2V5RW5jb2RlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZXhwb3J0cy5nZXRDYWNoZUtleVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIGN1c3RvbSBrZXkgZW5jb2RlciBmdW5jdGlvbiBmb3IgdGhlIGNhY2hlLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIHRha2UgYSBwcm9tcHQgYW5kIGFuIExMTSBrZXkgYW5kIHJldHVybiBhIHN0cmluZ1xuICAgICAqIHRoYXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBjYWNoZSBrZXkuXG4gICAgICogQHBhcmFtIGtleUVuY29kZXJGbiBUaGUgY3VzdG9tIGtleSBlbmNvZGVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIG1ha2VEZWZhdWx0S2V5RW5jb2RlcihrZXlFbmNvZGVyRm4pIHtcbiAgICAgICAgdGhpcy5rZXlFbmNvZGVyID0ga2V5RW5jb2RlckZuO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUNhY2hlID0gQmFzZUNhY2hlO1xuY29uc3QgR0xPQkFMX01BUCA9IG5ldyBNYXAoKTtcbi8qKlxuICogQSBjYWNoZSBmb3Igc3RvcmluZyBMTE0gZ2VuZXJhdGlvbnMgdGhhdCBzdG9yZXMgZGF0YSBpbiBtZW1vcnkuXG4gKi9cbmNsYXNzIEluTWVtb3J5Q2FjaGUgZXh0ZW5kcyBCYXNlQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKG1hcCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYWNoZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhY2hlID0gbWFwID8/IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGRhdGEgZnJvbSB0aGUgY2FjaGUgdXNpbmcgYSBwcm9tcHQgYW5kIGFuIExMTSBrZXkuIElmIHRoZVxuICAgICAqIGRhdGEgaXMgbm90IGZvdW5kLCBpdCByZXR1cm5zIG51bGwuXG4gICAgICogQHBhcmFtIHByb21wdCBUaGUgcHJvbXB0IHVzZWQgdG8gZmluZCB0aGUgZGF0YS5cbiAgICAgKiBAcGFyYW0gbGxtS2V5IFRoZSBMTE0ga2V5IHVzZWQgdG8gZmluZCB0aGUgZGF0YS5cbiAgICAgKiBAcmV0dXJucyBUaGUgZGF0YSBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9tcHQgYW5kIExMTSBrZXksIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuICAgICAqL1xuICAgIGxvb2t1cChwcm9tcHQsIGxsbUtleSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuY2FjaGUuZ2V0KHRoaXMua2V5RW5jb2Rlcihwcm9tcHQsIGxsbUtleSkpID8/IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjYWNoZSB3aXRoIG5ldyBkYXRhIHVzaW5nIGEgcHJvbXB0IGFuZCBhbiBMTE0ga2V5LlxuICAgICAqIEBwYXJhbSBwcm9tcHQgVGhlIHByb21wdCB1c2VkIHRvIHN0b3JlIHRoZSBkYXRhLlxuICAgICAqIEBwYXJhbSBsbG1LZXkgVGhlIExMTSBrZXkgdXNlZCB0byBzdG9yZSB0aGUgZGF0YS5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIGRhdGEgdG8gYmUgc3RvcmVkLlxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZShwcm9tcHQsIGxsbUtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5jYWNoZS5zZXQodGhpcy5rZXlFbmNvZGVyKHByb21wdCwgbGxtS2V5KSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZ2xvYmFsIGluc3RhbmNlIG9mIEluTWVtb3J5Q2FjaGUgdXNpbmcgYSBwcmVkZWZpbmVkIGdsb2JhbFxuICAgICAqIG1hcCBhcyB0aGUgaW5pdGlhbCBjYWNoZS5cbiAgICAgKiBAcmV0dXJucyBBIGdsb2JhbCBpbnN0YW5jZSBvZiBJbk1lbW9yeUNhY2hlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnbG9iYWwoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5NZW1vcnlDYWNoZShHTE9CQUxfTUFQKTtcbiAgICB9XG59XG5leHBvcnRzLkluTWVtb3J5Q2FjaGUgPSBJbk1lbW9yeUNhY2hlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/caches/base.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/callbacks/base.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/callbacks/base.cjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isBaseCallbackHandler = exports.BaseCallbackHandler = void 0;\nexports.callbackHandlerPrefersStreaming = callbackHandlerPrefersStreaming;\nconst uuid = __importStar(__webpack_require__(/*! uuid */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/index.js\"));\nconst serializable_js_1 = __webpack_require__(/*! ../load/serializable.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.cjs\");\nconst env_js_1 = __webpack_require__(/*! ../utils/env.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/env.cjs\");\n/**\n * Abstract class that provides a set of optional methods that can be\n * overridden in derived classes to handle various events during the\n * execution of a LangChain application.\n */\nclass BaseCallbackHandlerMethodsClass {\n}\nfunction callbackHandlerPrefersStreaming(x) {\n    return \"lc_prefer_streaming\" in x && x.lc_prefer_streaming;\n}\n/**\n * Abstract base class for creating callback handlers in the LangChain\n * framework. It provides a set of optional methods that can be overridden\n * in derived classes to handle various events during the execution of a\n * LangChain application.\n */\nclass BaseCallbackHandler extends BaseCallbackHandlerMethodsClass {\n    get lc_namespace() {\n        return [\"langchain_core\", \"callbacks\", this.name];\n    }\n    get lc_secrets() {\n        return undefined;\n    }\n    get lc_attributes() {\n        return undefined;\n    }\n    get lc_aliases() {\n        return undefined;\n    }\n    get lc_serializable_keys() {\n        return undefined;\n    }\n    /**\n     * The name of the serializable. Override to provide an alias or\n     * to preserve the serialized module name in minified environments.\n     *\n     * Implemented as a static method to support loading logic.\n     */\n    static lc_name() {\n        return this.name;\n    }\n    /**\n     * The final serialized identifier for the module.\n     */\n    get lc_id() {\n        return [\n            ...this.lc_namespace,\n            (0, serializable_js_1.get_lc_unique_name)(this.constructor),\n        ];\n    }\n    constructor(input) {\n        super();\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"ignoreLLM\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"ignoreChain\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"ignoreAgent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"ignoreRetriever\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"ignoreCustomEvent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"raiseError\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"awaitHandlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: (0, env_js_1.getEnvironmentVariable)(\"LANGCHAIN_CALLBACKS_BACKGROUND\") === \"false\"\n        });\n        this.lc_kwargs = input || {};\n        if (input) {\n            this.ignoreLLM = input.ignoreLLM ?? this.ignoreLLM;\n            this.ignoreChain = input.ignoreChain ?? this.ignoreChain;\n            this.ignoreAgent = input.ignoreAgent ?? this.ignoreAgent;\n            this.ignoreRetriever = input.ignoreRetriever ?? this.ignoreRetriever;\n            this.ignoreCustomEvent =\n                input.ignoreCustomEvent ?? this.ignoreCustomEvent;\n            this.raiseError = input.raiseError ?? this.raiseError;\n            this.awaitHandlers =\n                this.raiseError || (input._awaitHandler ?? this.awaitHandlers);\n        }\n    }\n    copy() {\n        return new this.constructor(this);\n    }\n    toJSON() {\n        return serializable_js_1.Serializable.prototype.toJSON.call(this);\n    }\n    toJSONNotImplemented() {\n        return serializable_js_1.Serializable.prototype.toJSONNotImplemented.call(this);\n    }\n    static fromMethods(methods) {\n        class Handler extends BaseCallbackHandler {\n            constructor() {\n                super();\n                Object.defineProperty(this, \"name\", {\n                    enumerable: true,\n                    configurable: true,\n                    writable: true,\n                    value: uuid.v4()\n                });\n                Object.assign(this, methods);\n            }\n        }\n        return new Handler();\n    }\n}\nexports.BaseCallbackHandler = BaseCallbackHandler;\nconst isBaseCallbackHandler = (x) => {\n    const callbackHandler = x;\n    return (callbackHandler !== undefined &&\n        typeof callbackHandler.copy === \"function\" &&\n        typeof callbackHandler.name === \"string\" &&\n        typeof callbackHandler.awaitHandlers === \"boolean\");\n};\nexports.isBaseCallbackHandler = isBaseCallbackHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvY2FsbGJhY2tzL2Jhc2UuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsY0FBYztBQUN6RTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QixHQUFHLDJCQUEyQjtBQUMzRCx1Q0FBdUM7QUFDdkMsMEJBQTBCLG1CQUFPLENBQUMsMkZBQU07QUFDeEMsMEJBQTBCLG1CQUFPLENBQUMsaUdBQTBCO0FBQzVELGlCQUFpQixtQkFBTyxDQUFDLGlGQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2NhbGxiYWNrcy9iYXNlLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0Jhc2VDYWxsYmFja0hhbmRsZXIgPSBleHBvcnRzLkJhc2VDYWxsYmFja0hhbmRsZXIgPSB2b2lkIDA7XG5leHBvcnRzLmNhbGxiYWNrSGFuZGxlclByZWZlcnNTdHJlYW1pbmcgPSBjYWxsYmFja0hhbmRsZXJQcmVmZXJzU3RyZWFtaW5nO1xuY29uc3QgdXVpZCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwidXVpZFwiKSk7XG5jb25zdCBzZXJpYWxpemFibGVfanNfMSA9IHJlcXVpcmUoXCIuLi9sb2FkL3NlcmlhbGl6YWJsZS5janNcIik7XG5jb25zdCBlbnZfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9lbnYuY2pzXCIpO1xuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyB0aGF0IHByb3ZpZGVzIGEgc2V0IG9mIG9wdGlvbmFsIG1ldGhvZHMgdGhhdCBjYW4gYmVcbiAqIG92ZXJyaWRkZW4gaW4gZGVyaXZlZCBjbGFzc2VzIHRvIGhhbmRsZSB2YXJpb3VzIGV2ZW50cyBkdXJpbmcgdGhlXG4gKiBleGVjdXRpb24gb2YgYSBMYW5nQ2hhaW4gYXBwbGljYXRpb24uXG4gKi9cbmNsYXNzIEJhc2VDYWxsYmFja0hhbmRsZXJNZXRob2RzQ2xhc3Mge1xufVxuZnVuY3Rpb24gY2FsbGJhY2tIYW5kbGVyUHJlZmVyc1N0cmVhbWluZyh4KSB7XG4gICAgcmV0dXJuIFwibGNfcHJlZmVyX3N0cmVhbWluZ1wiIGluIHggJiYgeC5sY19wcmVmZXJfc3RyZWFtaW5nO1xufVxuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBjcmVhdGluZyBjYWxsYmFjayBoYW5kbGVycyBpbiB0aGUgTGFuZ0NoYWluXG4gKiBmcmFtZXdvcmsuIEl0IHByb3ZpZGVzIGEgc2V0IG9mIG9wdGlvbmFsIG1ldGhvZHMgdGhhdCBjYW4gYmUgb3ZlcnJpZGRlblxuICogaW4gZGVyaXZlZCBjbGFzc2VzIHRvIGhhbmRsZSB2YXJpb3VzIGV2ZW50cyBkdXJpbmcgdGhlIGV4ZWN1dGlvbiBvZiBhXG4gKiBMYW5nQ2hhaW4gYXBwbGljYXRpb24uXG4gKi9cbmNsYXNzIEJhc2VDYWxsYmFja0hhbmRsZXIgZXh0ZW5kcyBCYXNlQ2FsbGJhY2tIYW5kbGVyTWV0aG9kc0NsYXNzIHtcbiAgICBnZXQgbGNfbmFtZXNwYWNlKCkge1xuICAgICAgICByZXR1cm4gW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJjYWxsYmFja3NcIiwgdGhpcy5uYW1lXTtcbiAgICB9XG4gICAgZ2V0IGxjX3NlY3JldHMoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBsY19hdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgbGNfYWxpYXNlcygpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IGxjX3NlcmlhbGl6YWJsZV9rZXlzKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgc2VyaWFsaXphYmxlLiBPdmVycmlkZSB0byBwcm92aWRlIGFuIGFsaWFzIG9yXG4gICAgICogdG8gcHJlc2VydmUgdGhlIHNlcmlhbGl6ZWQgbW9kdWxlIG5hbWUgaW4gbWluaWZpZWQgZW52aXJvbm1lbnRzLlxuICAgICAqXG4gICAgICogSW1wbGVtZW50ZWQgYXMgYSBzdGF0aWMgbWV0aG9kIHRvIHN1cHBvcnQgbG9hZGluZyBsb2dpYy5cbiAgICAgKi9cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGZpbmFsIHNlcmlhbGl6ZWQgaWRlbnRpZmllciBmb3IgdGhlIG1vZHVsZS5cbiAgICAgKi9cbiAgICBnZXQgbGNfaWQoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi50aGlzLmxjX25hbWVzcGFjZSxcbiAgICAgICAgICAgICgwLCBzZXJpYWxpemFibGVfanNfMS5nZXRfbGNfdW5pcXVlX25hbWUpKHRoaXMuY29uc3RydWN0b3IpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19rd2FyZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWdub3JlTExNXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWdub3JlQ2hhaW5cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZ25vcmVBZ2VudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlnbm9yZVJldHJpZXZlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlnbm9yZUN1c3RvbUV2ZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmFpc2VFcnJvclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF3YWl0SGFuZGxlcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICgwLCBlbnZfanNfMS5nZXRFbnZpcm9ubWVudFZhcmlhYmxlKShcIkxBTkdDSEFJTl9DQUxMQkFDS1NfQkFDS0dST1VORFwiKSA9PT0gXCJmYWxzZVwiXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxjX2t3YXJncyA9IGlucHV0IHx8IHt9O1xuICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuaWdub3JlTExNID0gaW5wdXQuaWdub3JlTExNID8/IHRoaXMuaWdub3JlTExNO1xuICAgICAgICAgICAgdGhpcy5pZ25vcmVDaGFpbiA9IGlucHV0Lmlnbm9yZUNoYWluID8/IHRoaXMuaWdub3JlQ2hhaW47XG4gICAgICAgICAgICB0aGlzLmlnbm9yZUFnZW50ID0gaW5wdXQuaWdub3JlQWdlbnQgPz8gdGhpcy5pZ25vcmVBZ2VudDtcbiAgICAgICAgICAgIHRoaXMuaWdub3JlUmV0cmlldmVyID0gaW5wdXQuaWdub3JlUmV0cmlldmVyID8/IHRoaXMuaWdub3JlUmV0cmlldmVyO1xuICAgICAgICAgICAgdGhpcy5pZ25vcmVDdXN0b21FdmVudCA9XG4gICAgICAgICAgICAgICAgaW5wdXQuaWdub3JlQ3VzdG9tRXZlbnQgPz8gdGhpcy5pZ25vcmVDdXN0b21FdmVudDtcbiAgICAgICAgICAgIHRoaXMucmFpc2VFcnJvciA9IGlucHV0LnJhaXNlRXJyb3IgPz8gdGhpcy5yYWlzZUVycm9yO1xuICAgICAgICAgICAgdGhpcy5hd2FpdEhhbmRsZXJzID1cbiAgICAgICAgICAgICAgICB0aGlzLnJhaXNlRXJyb3IgfHwgKGlucHV0Ll9hd2FpdEhhbmRsZXIgPz8gdGhpcy5hd2FpdEhhbmRsZXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb3B5KCkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6YWJsZV9qc18xLlNlcmlhbGl6YWJsZS5wcm90b3R5cGUudG9KU09OLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIHRvSlNPTk5vdEltcGxlbWVudGVkKCkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXphYmxlX2pzXzEuU2VyaWFsaXphYmxlLnByb3RvdHlwZS50b0pTT05Ob3RJbXBsZW1lbnRlZC5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU1ldGhvZHMobWV0aG9kcykge1xuICAgICAgICBjbGFzcyBIYW5kbGVyIGV4dGVuZHMgQmFzZUNhbGxiYWNrSGFuZGxlciB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdXVpZC52NCgpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBtZXRob2RzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEhhbmRsZXIoKTtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VDYWxsYmFja0hhbmRsZXIgPSBCYXNlQ2FsbGJhY2tIYW5kbGVyO1xuY29uc3QgaXNCYXNlQ2FsbGJhY2tIYW5kbGVyID0gKHgpID0+IHtcbiAgICBjb25zdCBjYWxsYmFja0hhbmRsZXIgPSB4O1xuICAgIHJldHVybiAoY2FsbGJhY2tIYW5kbGVyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIGNhbGxiYWNrSGFuZGxlci5jb3B5ID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgdHlwZW9mIGNhbGxiYWNrSGFuZGxlci5uYW1lID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgIHR5cGVvZiBjYWxsYmFja0hhbmRsZXIuYXdhaXRIYW5kbGVycyA9PT0gXCJib29sZWFuXCIpO1xufTtcbmV4cG9ydHMuaXNCYXNlQ2FsbGJhY2tIYW5kbGVyID0gaXNCYXNlQ2FsbGJhY2tIYW5kbGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/callbacks/base.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/callbacks/manager.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TraceGroup = exports.CallbackManager = exports.CallbackManagerForToolRun = exports.CallbackManagerForChainRun = exports.CallbackManagerForLLMRun = exports.CallbackManagerForRetrieverRun = exports.BaseRunManager = exports.BaseCallbackManager = void 0;\nexports.parseCallbackConfigArg = parseCallbackConfigArg;\nexports.ensureHandler = ensureHandler;\nexports.traceAsGroup = traceAsGroup;\nconst uuid_1 = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/index.js\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/base.cjs\");\nconst console_js_1 = __webpack_require__(/*! ../tracers/console.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/console.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ../messages/utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs\");\nconst env_js_1 = __webpack_require__(/*! ../utils/env.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/env.cjs\");\nconst tracer_langchain_js_1 = __webpack_require__(/*! ../tracers/tracer_langchain.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/tracer_langchain.cjs\");\nconst promises_js_1 = __webpack_require__(/*! ./promises.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/promises.cjs\");\nconst callbacks_js_1 = __webpack_require__(/*! ../utils/callbacks.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/callbacks.cjs\");\nconst base_js_2 = __webpack_require__(/*! ../tracers/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.cjs\");\nconst context_js_1 = __webpack_require__(/*! ../singletons/async_local_storage/context.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/context.cjs\");\nfunction parseCallbackConfigArg(arg) {\n    if (!arg) {\n        return {};\n    }\n    else if (Array.isArray(arg) || \"name\" in arg) {\n        return { callbacks: arg };\n    }\n    else {\n        return arg;\n    }\n}\n/**\n * Manage callbacks from different components of LangChain.\n */\nclass BaseCallbackManager {\n    setHandler(handler) {\n        return this.setHandlers([handler]);\n    }\n}\nexports.BaseCallbackManager = BaseCallbackManager;\n/**\n * Base class for run manager in LangChain.\n */\nclass BaseRunManager {\n    constructor(runId, handlers, inheritableHandlers, tags, inheritableTags, metadata, inheritableMetadata, _parentRunId) {\n        Object.defineProperty(this, \"runId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: runId\n        });\n        Object.defineProperty(this, \"handlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: handlers\n        });\n        Object.defineProperty(this, \"inheritableHandlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: inheritableHandlers\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: tags\n        });\n        Object.defineProperty(this, \"inheritableTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: inheritableTags\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: metadata\n        });\n        Object.defineProperty(this, \"inheritableMetadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: inheritableMetadata\n        });\n        Object.defineProperty(this, \"_parentRunId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: _parentRunId\n        });\n    }\n    get parentRunId() {\n        return this._parentRunId;\n    }\n    async handleText(text) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            try {\n                await handler.handleText?.(text, this.runId, this._parentRunId, this.tags);\n            }\n            catch (err) {\n                const logFunction = handler.raiseError\n                    ? console.error\n                    : console.warn;\n                logFunction(`Error in handler ${handler.constructor.name}, handleText: ${err}`);\n                if (handler.raiseError) {\n                    throw err;\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleCustomEvent(eventName, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data, _runId, _tags, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _metadata) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            try {\n                await handler.handleCustomEvent?.(eventName, data, this.runId, this.tags, this.metadata);\n            }\n            catch (err) {\n                const logFunction = handler.raiseError\n                    ? console.error\n                    : console.warn;\n                logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);\n                if (handler.raiseError) {\n                    throw err;\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nexports.BaseRunManager = BaseRunManager;\n/**\n * Manages callbacks for retriever runs.\n */\nclass CallbackManagerForRetrieverRun extends BaseRunManager {\n    getChild(tag) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const manager = new CallbackManager(this.runId);\n        manager.setHandlers(this.inheritableHandlers);\n        manager.addTags(this.inheritableTags);\n        manager.addMetadata(this.inheritableMetadata);\n        if (tag) {\n            manager.addTags([tag], false);\n        }\n        return manager;\n    }\n    async handleRetrieverEnd(documents) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreRetriever) {\n                try {\n                    await handler.handleRetrieverEnd?.(documents, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleRetriever`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleRetrieverError(err) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreRetriever) {\n                try {\n                    await handler.handleRetrieverError?.(err, this.runId, this._parentRunId, this.tags);\n                }\n                catch (error) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverError: ${error}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nexports.CallbackManagerForRetrieverRun = CallbackManagerForRetrieverRun;\nclass CallbackManagerForLLMRun extends BaseRunManager {\n    async handleLLMNewToken(token, idx, _runId, _parentRunId, _tags, fields) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreLLM) {\n                try {\n                    await handler.handleLLMNewToken?.(token, idx ?? { prompt: 0, completion: 0 }, this.runId, this._parentRunId, this.tags, fields);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleLLMNewToken: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleLLMError(err, _runId, _parentRunId, _tags, extraParams) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreLLM) {\n                try {\n                    await handler.handleLLMError?.(err, this.runId, this._parentRunId, this.tags, extraParams);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleLLMError: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleLLMEnd(output, _runId, _parentRunId, _tags, extraParams) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreLLM) {\n                try {\n                    await handler.handleLLMEnd?.(output, this.runId, this._parentRunId, this.tags, extraParams);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleLLMEnd: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nexports.CallbackManagerForLLMRun = CallbackManagerForLLMRun;\nclass CallbackManagerForChainRun extends BaseRunManager {\n    getChild(tag) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const manager = new CallbackManager(this.runId);\n        manager.setHandlers(this.inheritableHandlers);\n        manager.addTags(this.inheritableTags);\n        manager.addMetadata(this.inheritableMetadata);\n        if (tag) {\n            manager.addTags([tag], false);\n        }\n        return manager;\n    }\n    async handleChainError(err, _runId, _parentRunId, _tags, kwargs) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreChain) {\n                try {\n                    await handler.handleChainError?.(err, this.runId, this._parentRunId, this.tags, kwargs);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleChainError: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleChainEnd(output, _runId, _parentRunId, _tags, kwargs) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreChain) {\n                try {\n                    await handler.handleChainEnd?.(output, this.runId, this._parentRunId, this.tags, kwargs);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleChainEnd: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleAgentAction(action) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleAgentAction?.(action, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleAgentAction: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleAgentEnd(action) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleAgentEnd?.(action, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleAgentEnd: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nexports.CallbackManagerForChainRun = CallbackManagerForChainRun;\nclass CallbackManagerForToolRun extends BaseRunManager {\n    getChild(tag) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const manager = new CallbackManager(this.runId);\n        manager.setHandlers(this.inheritableHandlers);\n        manager.addTags(this.inheritableTags);\n        manager.addMetadata(this.inheritableMetadata);\n        if (tag) {\n            manager.addTags([tag], false);\n        }\n        return manager;\n    }\n    async handleToolError(err) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleToolError?.(err, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleToolError: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async handleToolEnd(output) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleToolEnd?.(output, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleToolEnd: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nexports.CallbackManagerForToolRun = CallbackManagerForToolRun;\n/**\n * @example\n * ```typescript\n * const prompt = PromptTemplate.fromTemplate(\"What is the answer to {question}?\");\n *\n * // Example of using LLMChain with OpenAI and a simple prompt\n * const chain = new LLMChain({\n *   llm: new ChatOpenAI({ model: \"gpt-4o-mini\", temperature: 0.9 }),\n *   prompt,\n * });\n *\n * // Running the chain with a single question\n * const result = await chain.call({\n *   question: \"What is the airspeed velocity of an unladen swallow?\",\n * });\n * console.log(\"The answer is:\", result);\n * ```\n */\nclass CallbackManager extends BaseCallbackManager {\n    constructor(parentRunId, options) {\n        super();\n        Object.defineProperty(this, \"handlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"inheritableHandlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"inheritableTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"inheritableMetadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"callback_manager\"\n        });\n        Object.defineProperty(this, \"_parentRunId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.handlers = options?.handlers ?? this.handlers;\n        this.inheritableHandlers =\n            options?.inheritableHandlers ?? this.inheritableHandlers;\n        this.tags = options?.tags ?? this.tags;\n        this.inheritableTags = options?.inheritableTags ?? this.inheritableTags;\n        this.metadata = options?.metadata ?? this.metadata;\n        this.inheritableMetadata =\n            options?.inheritableMetadata ?? this.inheritableMetadata;\n        this._parentRunId = parentRunId;\n    }\n    /**\n     * Gets the parent run ID, if any.\n     *\n     * @returns The parent run ID.\n     */\n    getParentRunId() {\n        return this._parentRunId;\n    }\n    async handleLLMStart(llm, prompts, runId = undefined, _parentRunId = undefined, extraParams = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        return Promise.all(prompts.map(async (prompt, idx) => {\n            // Can't have duplicate runs with the same run ID (if provided)\n            const runId_ = idx === 0 && runId ? runId : (0, uuid_1.v4)();\n            await Promise.all(this.handlers.map((handler) => {\n                if (handler.ignoreLLM) {\n                    return;\n                }\n                if ((0, base_js_2.isBaseTracer)(handler)) {\n                    // Create and add run to the run map.\n                    // We do this synchronously to avoid race conditions\n                    // when callbacks are backgrounded.\n                    handler._createRunForLLMStart(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                }\n                return (0, promises_js_1.consumeCallback)(async () => {\n                    try {\n                        await handler.handleLLMStart?.(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                    }\n                    catch (err) {\n                        const logFunction = handler.raiseError\n                            ? console.error\n                            : console.warn;\n                        logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);\n                        if (handler.raiseError) {\n                            throw err;\n                        }\n                    }\n                }, handler.awaitHandlers);\n            }));\n            return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n        }));\n    }\n    async handleChatModelStart(llm, messages, runId = undefined, _parentRunId = undefined, extraParams = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        return Promise.all(messages.map(async (messageGroup, idx) => {\n            // Can't have duplicate runs with the same run ID (if provided)\n            const runId_ = idx === 0 && runId ? runId : (0, uuid_1.v4)();\n            await Promise.all(this.handlers.map((handler) => {\n                if (handler.ignoreLLM) {\n                    return;\n                }\n                if ((0, base_js_2.isBaseTracer)(handler)) {\n                    // Create and add run to the run map.\n                    // We do this synchronously to avoid race conditions\n                    // when callbacks are backgrounded.\n                    handler._createRunForChatModelStart(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                }\n                return (0, promises_js_1.consumeCallback)(async () => {\n                    try {\n                        if (handler.handleChatModelStart) {\n                            await handler.handleChatModelStart?.(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                        }\n                        else if (handler.handleLLMStart) {\n                            const messageString = (0, utils_js_1.getBufferString)(messageGroup);\n                            await handler.handleLLMStart?.(llm, [messageString], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                        }\n                    }\n                    catch (err) {\n                        const logFunction = handler.raiseError\n                            ? console.error\n                            : console.warn;\n                        logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);\n                        if (handler.raiseError) {\n                            throw err;\n                        }\n                    }\n                }, handler.awaitHandlers);\n            }));\n            return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n        }));\n    }\n    async handleChainStart(chain, inputs, runId = (0, uuid_1.v4)(), runType = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        await Promise.all(this.handlers.map((handler) => {\n            if (handler.ignoreChain) {\n                return;\n            }\n            if ((0, base_js_2.isBaseTracer)(handler)) {\n                // Create and add run to the run map.\n                // We do this synchronously to avoid race conditions\n                // when callbacks are backgrounded.\n                handler._createRunForChainStart(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);\n            }\n            return (0, promises_js_1.consumeCallback)(async () => {\n                try {\n                    await handler.handleChainStart?.(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleChainStart: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }, handler.awaitHandlers);\n        }));\n        return new CallbackManagerForChainRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n    }\n    async handleToolStart(tool, input, runId = (0, uuid_1.v4)(), _parentRunId = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        await Promise.all(this.handlers.map((handler) => {\n            if (handler.ignoreAgent) {\n                return;\n            }\n            if ((0, base_js_2.isBaseTracer)(handler)) {\n                // Create and add run to the run map.\n                // We do this synchronously to avoid race conditions\n                // when callbacks are backgrounded.\n                handler._createRunForToolStart(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);\n            }\n            return (0, promises_js_1.consumeCallback)(async () => {\n                try {\n                    await handler.handleToolStart?.(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleToolStart: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }, handler.awaitHandlers);\n        }));\n        return new CallbackManagerForToolRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n    }\n    async handleRetrieverStart(retriever, query, runId = (0, uuid_1.v4)(), _parentRunId = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        await Promise.all(this.handlers.map((handler) => {\n            if (handler.ignoreRetriever) {\n                return;\n            }\n            if ((0, base_js_2.isBaseTracer)(handler)) {\n                // Create and add run to the run map.\n                // We do this synchronously to avoid race conditions\n                // when callbacks are backgrounded.\n                handler._createRunForRetrieverStart(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);\n            }\n            return (0, promises_js_1.consumeCallback)(async () => {\n                try {\n                    await handler.handleRetrieverStart?.(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverStart: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }, handler.awaitHandlers);\n        }));\n        return new CallbackManagerForRetrieverRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n    }\n    async handleCustomEvent(eventName, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data, runId, _tags, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _metadata) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreCustomEvent) {\n                try {\n                    await handler.handleCustomEvent?.(eventName, data, runId, this.tags, this.metadata);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    addHandler(handler, inherit = true) {\n        this.handlers.push(handler);\n        if (inherit) {\n            this.inheritableHandlers.push(handler);\n        }\n    }\n    removeHandler(handler) {\n        this.handlers = this.handlers.filter((_handler) => _handler !== handler);\n        this.inheritableHandlers = this.inheritableHandlers.filter((_handler) => _handler !== handler);\n    }\n    setHandlers(handlers, inherit = true) {\n        this.handlers = [];\n        this.inheritableHandlers = [];\n        for (const handler of handlers) {\n            this.addHandler(handler, inherit);\n        }\n    }\n    addTags(tags, inherit = true) {\n        this.removeTags(tags); // Remove duplicates\n        this.tags.push(...tags);\n        if (inherit) {\n            this.inheritableTags.push(...tags);\n        }\n    }\n    removeTags(tags) {\n        this.tags = this.tags.filter((tag) => !tags.includes(tag));\n        this.inheritableTags = this.inheritableTags.filter((tag) => !tags.includes(tag));\n    }\n    addMetadata(metadata, inherit = true) {\n        this.metadata = { ...this.metadata, ...metadata };\n        if (inherit) {\n            this.inheritableMetadata = { ...this.inheritableMetadata, ...metadata };\n        }\n    }\n    removeMetadata(metadata) {\n        for (const key of Object.keys(metadata)) {\n            delete this.metadata[key];\n            delete this.inheritableMetadata[key];\n        }\n    }\n    copy(additionalHandlers = [], inherit = true) {\n        const manager = new CallbackManager(this._parentRunId);\n        for (const handler of this.handlers) {\n            const inheritable = this.inheritableHandlers.includes(handler);\n            manager.addHandler(handler, inheritable);\n        }\n        for (const tag of this.tags) {\n            const inheritable = this.inheritableTags.includes(tag);\n            manager.addTags([tag], inheritable);\n        }\n        for (const key of Object.keys(this.metadata)) {\n            const inheritable = Object.keys(this.inheritableMetadata).includes(key);\n            manager.addMetadata({ [key]: this.metadata[key] }, inheritable);\n        }\n        for (const handler of additionalHandlers) {\n            if (\n            // Prevent multiple copies of console_callback_handler\n            manager.handlers\n                .filter((h) => h.name === \"console_callback_handler\")\n                .some((h) => h.name === handler.name)) {\n                continue;\n            }\n            manager.addHandler(handler, inherit);\n        }\n        return manager;\n    }\n    static fromHandlers(handlers) {\n        class Handler extends base_js_1.BaseCallbackHandler {\n            constructor() {\n                super();\n                Object.defineProperty(this, \"name\", {\n                    enumerable: true,\n                    configurable: true,\n                    writable: true,\n                    value: (0, uuid_1.v4)()\n                });\n                Object.assign(this, handlers);\n            }\n        }\n        const manager = new this();\n        manager.addHandler(new Handler());\n        return manager;\n    }\n    static configure(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {\n        return this._configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options);\n    }\n    // TODO: Deprecate async method in favor of this one.\n    static _configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {\n        let callbackManager;\n        if (inheritableHandlers || localHandlers) {\n            if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {\n                callbackManager = new CallbackManager();\n                callbackManager.setHandlers(inheritableHandlers?.map(ensureHandler) ?? [], true);\n            }\n            else {\n                callbackManager = inheritableHandlers;\n            }\n            callbackManager = callbackManager.copy(Array.isArray(localHandlers)\n                ? localHandlers.map(ensureHandler)\n                : localHandlers?.handlers, false);\n        }\n        const verboseEnabled = (0, env_js_1.getEnvironmentVariable)(\"LANGCHAIN_VERBOSE\") === \"true\" ||\n            options?.verbose;\n        const tracingV2Enabled = tracer_langchain_js_1.LangChainTracer.getTraceableRunTree()?.tracingEnabled ||\n            (0, callbacks_js_1.isTracingEnabled)();\n        const tracingEnabled = tracingV2Enabled ||\n            ((0, env_js_1.getEnvironmentVariable)(\"LANGCHAIN_TRACING\") ?? false);\n        if (verboseEnabled || tracingEnabled) {\n            if (!callbackManager) {\n                callbackManager = new CallbackManager();\n            }\n            if (verboseEnabled &&\n                !callbackManager.handlers.some((handler) => handler.name === console_js_1.ConsoleCallbackHandler.prototype.name)) {\n                const consoleHandler = new console_js_1.ConsoleCallbackHandler();\n                callbackManager.addHandler(consoleHandler, true);\n            }\n            if (tracingEnabled &&\n                !callbackManager.handlers.some((handler) => handler.name === \"langchain_tracer\")) {\n                if (tracingV2Enabled) {\n                    const tracerV2 = new tracer_langchain_js_1.LangChainTracer();\n                    callbackManager.addHandler(tracerV2, true);\n                }\n            }\n            if (tracingV2Enabled) {\n                // handoff between langchain and langsmith/traceable\n                // override the parent run ID\n                const implicitRunTree = tracer_langchain_js_1.LangChainTracer.getTraceableRunTree();\n                if (implicitRunTree && callbackManager._parentRunId === undefined) {\n                    callbackManager._parentRunId = implicitRunTree.id;\n                    const tracerV2 = callbackManager.handlers.find((handler) => handler.name === \"langchain_tracer\");\n                    tracerV2?.updateFromRunTree(implicitRunTree);\n                }\n            }\n        }\n        for (const { contextVar, inheritable = true, handlerClass, envVar, } of (0, context_js_1._getConfigureHooks)()) {\n            const createIfNotInContext = envVar && (0, env_js_1.getEnvironmentVariable)(envVar) === \"true\" && handlerClass;\n            let handler;\n            const contextVarValue = contextVar !== undefined ? (0, context_js_1.getContextVariable)(contextVar) : undefined;\n            if (contextVarValue && (0, base_js_1.isBaseCallbackHandler)(contextVarValue)) {\n                handler = contextVarValue;\n            }\n            else if (createIfNotInContext) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                handler = new handlerClass({});\n            }\n            if (handler !== undefined) {\n                if (!callbackManager) {\n                    callbackManager = new CallbackManager();\n                }\n                if (!callbackManager.handlers.some((h) => h.name === handler.name)) {\n                    callbackManager.addHandler(handler, inheritable);\n                }\n            }\n        }\n        if (inheritableTags || localTags) {\n            if (callbackManager) {\n                callbackManager.addTags(inheritableTags ?? []);\n                callbackManager.addTags(localTags ?? [], false);\n            }\n        }\n        if (inheritableMetadata || localMetadata) {\n            if (callbackManager) {\n                callbackManager.addMetadata(inheritableMetadata ?? {});\n                callbackManager.addMetadata(localMetadata ?? {}, false);\n            }\n        }\n        return callbackManager;\n    }\n}\nexports.CallbackManager = CallbackManager;\nfunction ensureHandler(handler) {\n    if (\"name\" in handler) {\n        return handler;\n    }\n    return base_js_1.BaseCallbackHandler.fromMethods(handler);\n}\n/**\n * @deprecated Use [`traceable`](https://docs.smith.langchain.com/observability/how_to_guides/tracing/annotate_code)\n * from \"langsmith\" instead.\n */\nclass TraceGroup {\n    constructor(groupName, options) {\n        Object.defineProperty(this, \"groupName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: groupName\n        });\n        Object.defineProperty(this, \"options\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: options\n        });\n        Object.defineProperty(this, \"runManager\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    async getTraceGroupCallbackManager(group_name, inputs, options) {\n        const cb = new tracer_langchain_js_1.LangChainTracer(options);\n        const cm = await CallbackManager.configure([cb]);\n        const runManager = await cm?.handleChainStart({\n            lc: 1,\n            type: \"not_implemented\",\n            id: [\"langchain\", \"callbacks\", \"groups\", group_name],\n        }, inputs ?? {});\n        if (!runManager) {\n            throw new Error(\"Failed to create run group callback manager.\");\n        }\n        return runManager;\n    }\n    async start(inputs) {\n        if (!this.runManager) {\n            this.runManager = await this.getTraceGroupCallbackManager(this.groupName, inputs, this.options);\n        }\n        return this.runManager.getChild();\n    }\n    async error(err) {\n        if (this.runManager) {\n            await this.runManager.handleChainError(err);\n            this.runManager = undefined;\n        }\n    }\n    async end(output) {\n        if (this.runManager) {\n            await this.runManager.handleChainEnd(output ?? {});\n            this.runManager = undefined;\n        }\n    }\n}\nexports.TraceGroup = TraceGroup;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n    return value && !Array.isArray(value) && typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function traceAsGroup(groupOptions, enclosedCode, ...args) {\n    const traceGroup = new TraceGroup(groupOptions.name, groupOptions);\n    const callbackManager = await traceGroup.start({ ...args });\n    try {\n        const result = await enclosedCode(callbackManager, ...args);\n        await traceGroup.end(_coerceToDict(result, \"output\"));\n        return result;\n    }\n    catch (err) {\n        await traceGroup.error(err);\n        throw err;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvY2FsbGJhY2tzL21hbmFnZXIuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLHVCQUF1QixHQUFHLGlDQUFpQyxHQUFHLGtDQUFrQyxHQUFHLGdDQUFnQyxHQUFHLHNDQUFzQyxHQUFHLHNCQUFzQixHQUFHLDJCQUEyQjtBQUN4UCw4QkFBOEI7QUFDOUIscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQixlQUFlLG1CQUFPLENBQUMsMkZBQU07QUFDN0Isa0JBQWtCLG1CQUFPLENBQUMsZ0ZBQVk7QUFDdEMscUJBQXFCLG1CQUFPLENBQUMsNkZBQXdCO0FBQ3JELG1CQUFtQixtQkFBTyxDQUFDLDJGQUF1QjtBQUNsRCxpQkFBaUIsbUJBQU8sQ0FBQyxpRkFBa0I7QUFDM0MsOEJBQThCLG1CQUFPLENBQUMsK0dBQWlDO0FBQ3ZFLHNCQUFzQixtQkFBTyxDQUFDLHdGQUFnQjtBQUM5Qyx1QkFBdUIsbUJBQU8sQ0FBQyw2RkFBd0I7QUFDdkQsa0JBQWtCLG1CQUFPLENBQUMsdUZBQXFCO0FBQy9DLHFCQUFxQixtQkFBTyxDQUFDLDJJQUErQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QseUJBQXlCLGdCQUFnQixJQUFJO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QseUJBQXlCLHVCQUF1QixJQUFJO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUIsMEJBQTBCLE1BQU07QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsMEJBQTBCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCLHVCQUF1QixJQUFJO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUIsb0JBQW9CLElBQUk7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QixrQkFBa0IsSUFBSTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCLHNCQUFzQixJQUFJO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUIsb0JBQW9CLElBQUk7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5Qix1QkFBdUIsSUFBSTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCLG9CQUFvQixJQUFJO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUIscUJBQXFCLElBQUk7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCLG1CQUFtQixJQUFJO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsU0FBUztBQUMvRTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0NBQXdDO0FBQ25FO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx5QkFBeUIsb0JBQW9CLElBQUk7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QseUJBQXlCLG9CQUFvQixJQUFJO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QixzQkFBc0IsSUFBSTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QixxQkFBcUIsSUFBSTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QiwwQkFBMEIsSUFBSTtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCLHVCQUF1QixJQUFJO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywyQkFBMkI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQXdEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGNBQWM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2NhbGxiYWNrcy9tYW5hZ2VyLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJhY2VHcm91cCA9IGV4cG9ydHMuQ2FsbGJhY2tNYW5hZ2VyID0gZXhwb3J0cy5DYWxsYmFja01hbmFnZXJGb3JUb29sUnVuID0gZXhwb3J0cy5DYWxsYmFja01hbmFnZXJGb3JDaGFpblJ1biA9IGV4cG9ydHMuQ2FsbGJhY2tNYW5hZ2VyRm9yTExNUnVuID0gZXhwb3J0cy5DYWxsYmFja01hbmFnZXJGb3JSZXRyaWV2ZXJSdW4gPSBleHBvcnRzLkJhc2VSdW5NYW5hZ2VyID0gZXhwb3J0cy5CYXNlQ2FsbGJhY2tNYW5hZ2VyID0gdm9pZCAwO1xuZXhwb3J0cy5wYXJzZUNhbGxiYWNrQ29uZmlnQXJnID0gcGFyc2VDYWxsYmFja0NvbmZpZ0FyZztcbmV4cG9ydHMuZW5zdXJlSGFuZGxlciA9IGVuc3VyZUhhbmRsZXI7XG5leHBvcnRzLnRyYWNlQXNHcm91cCA9IHRyYWNlQXNHcm91cDtcbmNvbnN0IHV1aWRfMSA9IHJlcXVpcmUoXCJ1dWlkXCIpO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG5jb25zdCBjb25zb2xlX2pzXzEgPSByZXF1aXJlKFwiLi4vdHJhY2Vycy9jb25zb2xlLmNqc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi4vbWVzc2FnZXMvdXRpbHMuY2pzXCIpO1xuY29uc3QgZW52X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvZW52LmNqc1wiKTtcbmNvbnN0IHRyYWNlcl9sYW5nY2hhaW5fanNfMSA9IHJlcXVpcmUoXCIuLi90cmFjZXJzL3RyYWNlcl9sYW5nY2hhaW4uY2pzXCIpO1xuY29uc3QgcHJvbWlzZXNfanNfMSA9IHJlcXVpcmUoXCIuL3Byb21pc2VzLmNqc1wiKTtcbmNvbnN0IGNhbGxiYWNrc19qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2NhbGxiYWNrcy5janNcIik7XG5jb25zdCBiYXNlX2pzXzIgPSByZXF1aXJlKFwiLi4vdHJhY2Vycy9iYXNlLmNqc1wiKTtcbmNvbnN0IGNvbnRleHRfanNfMSA9IHJlcXVpcmUoXCIuLi9zaW5nbGV0b25zL2FzeW5jX2xvY2FsX3N0b3JhZ2UvY29udGV4dC5janNcIik7XG5mdW5jdGlvbiBwYXJzZUNhbGxiYWNrQ29uZmlnQXJnKGFyZykge1xuICAgIGlmICghYXJnKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpIHx8IFwibmFtZVwiIGluIGFyZykge1xuICAgICAgICByZXR1cm4geyBjYWxsYmFja3M6IGFyZyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICB9XG59XG4vKipcbiAqIE1hbmFnZSBjYWxsYmFja3MgZnJvbSBkaWZmZXJlbnQgY29tcG9uZW50cyBvZiBMYW5nQ2hhaW4uXG4gKi9cbmNsYXNzIEJhc2VDYWxsYmFja01hbmFnZXIge1xuICAgIHNldEhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRIYW5kbGVycyhbaGFuZGxlcl0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUNhbGxiYWNrTWFuYWdlciA9IEJhc2VDYWxsYmFja01hbmFnZXI7XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIHJ1biBtYW5hZ2VyIGluIExhbmdDaGFpbi5cbiAqL1xuY2xhc3MgQmFzZVJ1bk1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHJ1bklkLCBoYW5kbGVycywgaW5oZXJpdGFibGVIYW5kbGVycywgdGFncywgaW5oZXJpdGFibGVUYWdzLCBtZXRhZGF0YSwgaW5oZXJpdGFibGVNZXRhZGF0YSwgX3BhcmVudFJ1bklkKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJ1bklkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBydW5JZFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGhhbmRsZXJzXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmhlcml0YWJsZUhhbmRsZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBpbmhlcml0YWJsZUhhbmRsZXJzXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0YWdzXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmhlcml0YWJsZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGluaGVyaXRhYmxlVGFnc1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG1ldGFkYXRhXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmhlcml0YWJsZU1ldGFkYXRhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBpbmhlcml0YWJsZU1ldGFkYXRhXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcGFyZW50UnVuSWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IF9wYXJlbnRSdW5JZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IHBhcmVudFJ1bklkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50UnVuSWQ7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRleHQodGV4dCkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gKDAsIHByb21pc2VzX2pzXzEuY29uc3VtZUNhbGxiYWNrKShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlVGV4dD8uKHRleHQsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZVRleHQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDdXN0b21FdmVudChldmVudE5hbWUsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZGF0YSwgX3J1bklkLCBfdGFncywgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBfbWV0YWRhdGEpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+ICgwLCBwcm9taXNlc19qc18xLmNvbnN1bWVDYWxsYmFjaykoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUN1c3RvbUV2ZW50Py4oZXZlbnROYW1lLCBkYXRhLCB0aGlzLnJ1bklkLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUN1c3RvbUV2ZW50OiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VSdW5NYW5hZ2VyID0gQmFzZVJ1bk1hbmFnZXI7XG4vKipcbiAqIE1hbmFnZXMgY2FsbGJhY2tzIGZvciByZXRyaWV2ZXIgcnVucy5cbiAqL1xuY2xhc3MgQ2FsbGJhY2tNYW5hZ2VyRm9yUmV0cmlldmVyUnVuIGV4dGVuZHMgQmFzZVJ1bk1hbmFnZXIge1xuICAgIGdldENoaWxkKHRhZykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKHRoaXMucnVuSWQpO1xuICAgICAgICBtYW5hZ2VyLnNldEhhbmRsZXJzKHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycyk7XG4gICAgICAgIG1hbmFnZXIuYWRkVGFncyh0aGlzLmluaGVyaXRhYmxlVGFncyk7XG4gICAgICAgIG1hbmFnZXIuYWRkTWV0YWRhdGEodGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhKTtcbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgbWFuYWdlci5hZGRUYWdzKFt0YWddLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hbmFnZXI7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVJldHJpZXZlckVuZChkb2N1bWVudHMpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+ICgwLCBwcm9taXNlc19qc18xLmNvbnN1bWVDYWxsYmFjaykoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZVJldHJpZXZlcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlUmV0cmlldmVyRW5kPy4oZG9jdW1lbnRzLCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVSZXRyaWV2ZXJgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVJldHJpZXZlckVycm9yKGVycikge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gKDAsIHByb21pc2VzX2pzXzEuY29uc3VtZUNhbGxiYWNrKShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlUmV0cmlldmVyKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVSZXRyaWV2ZXJFcnJvcj8uKGVyciwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVSZXRyaWV2ZXJFcnJvcjogJHtlcnJvcn1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxufVxuZXhwb3J0cy5DYWxsYmFja01hbmFnZXJGb3JSZXRyaWV2ZXJSdW4gPSBDYWxsYmFja01hbmFnZXJGb3JSZXRyaWV2ZXJSdW47XG5jbGFzcyBDYWxsYmFja01hbmFnZXJGb3JMTE1SdW4gZXh0ZW5kcyBCYXNlUnVuTWFuYWdlciB7XG4gICAgYXN5bmMgaGFuZGxlTExNTmV3VG9rZW4odG9rZW4sIGlkeCwgX3J1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBmaWVsZHMpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+ICgwLCBwcm9taXNlc19qc18xLmNvbnN1bWVDYWxsYmFjaykoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZUxMTSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlTExNTmV3VG9rZW4/Lih0b2tlbiwgaWR4ID8/IHsgcHJvbXB0OiAwLCBjb21wbGV0aW9uOiAwIH0sIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIGZpZWxkcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlTExNTmV3VG9rZW46ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTExNRXJyb3IoZXJyLCBfcnVuSWQsIF9wYXJlbnRSdW5JZCwgX3RhZ3MsIGV4dHJhUGFyYW1zKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiAoMCwgcHJvbWlzZXNfanNfMS5jb25zdW1lQ2FsbGJhY2spKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVMTE0pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUxMTUVycm9yPy4oZXJyLCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzLCBleHRyYVBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlTExNRXJyb3I6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTExNRW5kKG91dHB1dCwgX3J1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBleHRyYVBhcmFtcykge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gKDAsIHByb21pc2VzX2pzXzEuY29uc3VtZUNhbGxiYWNrKShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlTExNKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVMTE1FbmQ/LihvdXRwdXQsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIGV4dHJhUGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVMTE1FbmQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG59XG5leHBvcnRzLkNhbGxiYWNrTWFuYWdlckZvckxMTVJ1biA9IENhbGxiYWNrTWFuYWdlckZvckxMTVJ1bjtcbmNsYXNzIENhbGxiYWNrTWFuYWdlckZvckNoYWluUnVuIGV4dGVuZHMgQmFzZVJ1bk1hbmFnZXIge1xuICAgIGdldENoaWxkKHRhZykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKHRoaXMucnVuSWQpO1xuICAgICAgICBtYW5hZ2VyLnNldEhhbmRsZXJzKHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycyk7XG4gICAgICAgIG1hbmFnZXIuYWRkVGFncyh0aGlzLmluaGVyaXRhYmxlVGFncyk7XG4gICAgICAgIG1hbmFnZXIuYWRkTWV0YWRhdGEodGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhKTtcbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgbWFuYWdlci5hZGRUYWdzKFt0YWddLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hbmFnZXI7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUNoYWluRXJyb3IoZXJyLCBfcnVuSWQsIF9wYXJlbnRSdW5JZCwgX3RhZ3MsIGt3YXJncykge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gKDAsIHByb21pc2VzX2pzXzEuY29uc3VtZUNhbGxiYWNrKShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQ2hhaW4pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUNoYWluRXJyb3I/LihlcnIsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIGt3YXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlQ2hhaW5FcnJvcjogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGFpbkVuZChvdXRwdXQsIF9ydW5JZCwgX3BhcmVudFJ1bklkLCBfdGFncywga3dhcmdzKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiAoMCwgcHJvbWlzZXNfanNfMS5jb25zdW1lQ2FsbGJhY2spKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVDaGFpbikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlQ2hhaW5FbmQ/LihvdXRwdXQsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIGt3YXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlQ2hhaW5FbmQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQWdlbnRBY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiAoMCwgcHJvbWlzZXNfanNfMS5jb25zdW1lQ2FsbGJhY2spKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVBZ2VudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlQWdlbnRBY3Rpb24/LihhY3Rpb24sIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUFnZW50QWN0aW9uOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUFnZW50RW5kKGFjdGlvbikge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gKDAsIHByb21pc2VzX2pzXzEuY29uc3VtZUNhbGxiYWNrKShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUFnZW50RW5kPy4oYWN0aW9uLCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVBZ2VudEVuZDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2FsbGJhY2tNYW5hZ2VyRm9yQ2hhaW5SdW4gPSBDYWxsYmFja01hbmFnZXJGb3JDaGFpblJ1bjtcbmNsYXNzIENhbGxiYWNrTWFuYWdlckZvclRvb2xSdW4gZXh0ZW5kcyBCYXNlUnVuTWFuYWdlciB7XG4gICAgZ2V0Q2hpbGQodGFnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgY29uc3QgbWFuYWdlciA9IG5ldyBDYWxsYmFja01hbmFnZXIodGhpcy5ydW5JZCk7XG4gICAgICAgIG1hbmFnZXIuc2V0SGFuZGxlcnModGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzKTtcbiAgICAgICAgbWFuYWdlci5hZGRUYWdzKHRoaXMuaW5oZXJpdGFibGVUYWdzKTtcbiAgICAgICAgbWFuYWdlci5hZGRNZXRhZGF0YSh0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEpO1xuICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICBtYW5hZ2VyLmFkZFRhZ3MoW3RhZ10sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFuYWdlcjtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlVG9vbEVycm9yKGVycikge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gKDAsIHByb21pc2VzX2pzXzEuY29uc3VtZUNhbGxiYWNrKShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZVRvb2xFcnJvcj8uKGVyciwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlVG9vbEVycm9yOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgYXN5bmMgaGFuZGxlVG9vbEVuZChvdXRwdXQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+ICgwLCBwcm9taXNlc19qc18xLmNvbnN1bWVDYWxsYmFjaykoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZUFnZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVUb29sRW5kPy4ob3V0cHV0LCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVUb29sRW5kOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxufVxuZXhwb3J0cy5DYWxsYmFja01hbmFnZXJGb3JUb29sUnVuID0gQ2FsbGJhY2tNYW5hZ2VyRm9yVG9vbFJ1bjtcbi8qKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHByb21wdCA9IFByb21wdFRlbXBsYXRlLmZyb21UZW1wbGF0ZShcIldoYXQgaXMgdGhlIGFuc3dlciB0byB7cXVlc3Rpb259P1wiKTtcbiAqXG4gKiAvLyBFeGFtcGxlIG9mIHVzaW5nIExMTUNoYWluIHdpdGggT3BlbkFJIGFuZCBhIHNpbXBsZSBwcm9tcHRcbiAqIGNvbnN0IGNoYWluID0gbmV3IExMTUNoYWluKHtcbiAqICAgbGxtOiBuZXcgQ2hhdE9wZW5BSSh7IG1vZGVsOiBcImdwdC00by1taW5pXCIsIHRlbXBlcmF0dXJlOiAwLjkgfSksXG4gKiAgIHByb21wdCxcbiAqIH0pO1xuICpcbiAqIC8vIFJ1bm5pbmcgdGhlIGNoYWluIHdpdGggYSBzaW5nbGUgcXVlc3Rpb25cbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNoYWluLmNhbGwoe1xuICogICBxdWVzdGlvbjogXCJXaGF0IGlzIHRoZSBhaXJzcGVlZCB2ZWxvY2l0eSBvZiBhbiB1bmxhZGVuIHN3YWxsb3c/XCIsXG4gKiB9KTtcbiAqIGNvbnNvbGUubG9nKFwiVGhlIGFuc3dlciBpczpcIiwgcmVzdWx0KTtcbiAqIGBgYFxuICovXG5jbGFzcyBDYWxsYmFja01hbmFnZXIgZXh0ZW5kcyBCYXNlQ2FsbGJhY2tNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRSdW5JZCwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYW5kbGVyc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaGVyaXRhYmxlSGFuZGxlcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5oZXJpdGFibGVUYWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmhlcml0YWJsZU1ldGFkYXRhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJjYWxsYmFja19tYW5hZ2VyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9wYXJlbnRSdW5JZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gb3B0aW9ucz8uaGFuZGxlcnMgPz8gdGhpcy5oYW5kbGVycztcbiAgICAgICAgdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzID1cbiAgICAgICAgICAgIG9wdGlvbnM/LmluaGVyaXRhYmxlSGFuZGxlcnMgPz8gdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzO1xuICAgICAgICB0aGlzLnRhZ3MgPSBvcHRpb25zPy50YWdzID8/IHRoaXMudGFncztcbiAgICAgICAgdGhpcy5pbmhlcml0YWJsZVRhZ3MgPSBvcHRpb25zPy5pbmhlcml0YWJsZVRhZ3MgPz8gdGhpcy5pbmhlcml0YWJsZVRhZ3M7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBvcHRpb25zPy5tZXRhZGF0YSA/PyB0aGlzLm1ldGFkYXRhO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEgPVxuICAgICAgICAgICAgb3B0aW9ucz8uaW5oZXJpdGFibGVNZXRhZGF0YSA/PyB0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGE7XG4gICAgICAgIHRoaXMuX3BhcmVudFJ1bklkID0gcGFyZW50UnVuSWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBhcmVudCBydW4gSUQsIGlmIGFueS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYXJlbnQgcnVuIElELlxuICAgICAqL1xuICAgIGdldFBhcmVudFJ1bklkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50UnVuSWQ7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUxMTVN0YXJ0KGxsbSwgcHJvbXB0cywgcnVuSWQgPSB1bmRlZmluZWQsIF9wYXJlbnRSdW5JZCA9IHVuZGVmaW5lZCwgZXh0cmFQYXJhbXMgPSB1bmRlZmluZWQsIF90YWdzID0gdW5kZWZpbmVkLCBfbWV0YWRhdGEgPSB1bmRlZmluZWQsIHJ1bk5hbWUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21wdHMubWFwKGFzeW5jIChwcm9tcHQsIGlkeCkgPT4ge1xuICAgICAgICAgICAgLy8gQ2FuJ3QgaGF2ZSBkdXBsaWNhdGUgcnVucyB3aXRoIHRoZSBzYW1lIHJ1biBJRCAoaWYgcHJvdmlkZWQpXG4gICAgICAgICAgICBjb25zdCBydW5JZF8gPSBpZHggPT09IDAgJiYgcnVuSWQgPyBydW5JZCA6ICgwLCB1dWlkXzEudjQpKCk7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLmlnbm9yZUxMTSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoMCwgYmFzZV9qc18yLmlzQmFzZVRyYWNlcikoaGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGFuZCBhZGQgcnVuIHRvIHRoZSBydW4gbWFwLlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkbyB0aGlzIHN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQuXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuX2NyZWF0ZVJ1bkZvckxMTVN0YXJ0KGxsbSwgW3Byb21wdF0sIHJ1bklkXywgdGhpcy5fcGFyZW50UnVuSWQsIGV4dHJhUGFyYW1zLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEsIHJ1bk5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHByb21pc2VzX2pzXzEuY29uc3VtZUNhbGxiYWNrKShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUxMTVN0YXJ0Py4obGxtLCBbcHJvbXB0XSwgcnVuSWRfLCB0aGlzLl9wYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRoaXMudGFncywgdGhpcy5tZXRhZGF0YSwgcnVuTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlTExNU3RhcnQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycyk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENhbGxiYWNrTWFuYWdlckZvckxMTVJ1bihydW5JZF8sIHRoaXMuaGFuZGxlcnMsIHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycywgdGhpcy50YWdzLCB0aGlzLmluaGVyaXRhYmxlVGFncywgdGhpcy5tZXRhZGF0YSwgdGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhLCB0aGlzLl9wYXJlbnRSdW5JZCk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQ2hhdE1vZGVsU3RhcnQobGxtLCBtZXNzYWdlcywgcnVuSWQgPSB1bmRlZmluZWQsIF9wYXJlbnRSdW5JZCA9IHVuZGVmaW5lZCwgZXh0cmFQYXJhbXMgPSB1bmRlZmluZWQsIF90YWdzID0gdW5kZWZpbmVkLCBfbWV0YWRhdGEgPSB1bmRlZmluZWQsIHJ1bk5hbWUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG1lc3NhZ2VzLm1hcChhc3luYyAobWVzc2FnZUdyb3VwLCBpZHgpID0+IHtcbiAgICAgICAgICAgIC8vIENhbid0IGhhdmUgZHVwbGljYXRlIHJ1bnMgd2l0aCB0aGUgc2FtZSBydW4gSUQgKGlmIHByb3ZpZGVkKVxuICAgICAgICAgICAgY29uc3QgcnVuSWRfID0gaWR4ID09PSAwICYmIHJ1bklkID8gcnVuSWQgOiAoMCwgdXVpZF8xLnY0KSgpO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5pZ25vcmVMTE0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKDAsIGJhc2VfanNfMi5pc0Jhc2VUcmFjZXIpKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhbmQgYWRkIHJ1biB0byB0aGUgcnVuIG1hcC5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG8gdGhpcyBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGNhbGxiYWNrcyBhcmUgYmFja2dyb3VuZGVkLlxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLl9jcmVhdGVSdW5Gb3JDaGF0TW9kZWxTdGFydChsbG0sIFttZXNzYWdlR3JvdXBdLCBydW5JZF8sIHRoaXMuX3BhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBwcm9taXNlc19qc18xLmNvbnN1bWVDYWxsYmFjaykoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIuaGFuZGxlQ2hhdE1vZGVsU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUNoYXRNb2RlbFN0YXJ0Py4obGxtLCBbbWVzc2FnZUdyb3VwXSwgcnVuSWRfLCB0aGlzLl9wYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRoaXMudGFncywgdGhpcy5tZXRhZGF0YSwgcnVuTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChoYW5kbGVyLmhhbmRsZUxMTVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVN0cmluZyA9ICgwLCB1dGlsc19qc18xLmdldEJ1ZmZlclN0cmluZykobWVzc2FnZUdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUxMTVN0YXJ0Py4obGxtLCBbbWVzc2FnZVN0cmluZ10sIHJ1bklkXywgdGhpcy5fcGFyZW50UnVuSWQsIGV4dHJhUGFyYW1zLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEsIHJ1bk5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUxMTVN0YXJ0OiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYWxsYmFja01hbmFnZXJGb3JMTE1SdW4ocnVuSWRfLCB0aGlzLmhhbmRsZXJzLCB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMsIHRoaXMudGFncywgdGhpcy5pbmhlcml0YWJsZVRhZ3MsIHRoaXMubWV0YWRhdGEsIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSwgdGhpcy5fcGFyZW50UnVuSWQpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUNoYWluU3RhcnQoY2hhaW4sIGlucHV0cywgcnVuSWQgPSAoMCwgdXVpZF8xLnY0KSgpLCBydW5UeXBlID0gdW5kZWZpbmVkLCBfdGFncyA9IHVuZGVmaW5lZCwgX21ldGFkYXRhID0gdW5kZWZpbmVkLCBydW5OYW1lID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAoaGFuZGxlci5pZ25vcmVDaGFpbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoMCwgYmFzZV9qc18yLmlzQmFzZVRyYWNlcikoaGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYW5kIGFkZCBydW4gdG8gdGhlIHJ1biBtYXAuXG4gICAgICAgICAgICAgICAgLy8gV2UgZG8gdGhpcyBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQuXG4gICAgICAgICAgICAgICAgaGFuZGxlci5fY3JlYXRlUnVuRm9yQ2hhaW5TdGFydChjaGFpbiwgaW5wdXRzLCBydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncywgdGhpcy5tZXRhZGF0YSwgcnVuVHlwZSwgcnVuTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIHByb21pc2VzX2pzXzEuY29uc3VtZUNhbGxiYWNrKShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVDaGFpblN0YXJ0Py4oY2hhaW4sIGlucHV0cywgcnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEsIHJ1blR5cGUsIHJ1bk5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUNoYWluU3RhcnQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBuZXcgQ2FsbGJhY2tNYW5hZ2VyRm9yQ2hhaW5SdW4ocnVuSWQsIHRoaXMuaGFuZGxlcnMsIHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycywgdGhpcy50YWdzLCB0aGlzLmluaGVyaXRhYmxlVGFncywgdGhpcy5tZXRhZGF0YSwgdGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhLCB0aGlzLl9wYXJlbnRSdW5JZCk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRvb2xTdGFydCh0b29sLCBpbnB1dCwgcnVuSWQgPSAoMCwgdXVpZF8xLnY0KSgpLCBfcGFyZW50UnVuSWQgPSB1bmRlZmluZWQsIF90YWdzID0gdW5kZWZpbmVkLCBfbWV0YWRhdGEgPSB1bmRlZmluZWQsIHJ1bk5hbWUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyLmlnbm9yZUFnZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCgwLCBiYXNlX2pzXzIuaXNCYXNlVHJhY2VyKShoYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhbmQgYWRkIHJ1biB0byB0aGUgcnVuIG1hcC5cbiAgICAgICAgICAgICAgICAvLyBXZSBkbyB0aGlzIHN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBjYWxsYmFja3MgYXJlIGJhY2tncm91bmRlZC5cbiAgICAgICAgICAgICAgICBoYW5kbGVyLl9jcmVhdGVSdW5Gb3JUb29sU3RhcnQodG9vbCwgaW5wdXQsIHJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgcHJvbWlzZXNfanNfMS5jb25zdW1lQ2FsbGJhY2spKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZVRvb2xTdGFydD8uKHRvb2wsIGlucHV0LCBydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncywgdGhpcy5tZXRhZGF0YSwgcnVuTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlVG9vbFN0YXJ0OiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gbmV3IENhbGxiYWNrTWFuYWdlckZvclRvb2xSdW4ocnVuSWQsIHRoaXMuaGFuZGxlcnMsIHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycywgdGhpcy50YWdzLCB0aGlzLmluaGVyaXRhYmxlVGFncywgdGhpcy5tZXRhZGF0YSwgdGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhLCB0aGlzLl9wYXJlbnRSdW5JZCk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVJldHJpZXZlclN0YXJ0KHJldHJpZXZlciwgcXVlcnksIHJ1bklkID0gKDAsIHV1aWRfMS52NCkoKSwgX3BhcmVudFJ1bklkID0gdW5kZWZpbmVkLCBfdGFncyA9IHVuZGVmaW5lZCwgX21ldGFkYXRhID0gdW5kZWZpbmVkLCBydW5OYW1lID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAoaGFuZGxlci5pZ25vcmVSZXRyaWV2ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIGJhc2VfanNfMi5pc0Jhc2VUcmFjZXIpKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGFuZCBhZGQgcnVuIHRvIHRoZSBydW4gbWFwLlxuICAgICAgICAgICAgICAgIC8vIFdlIGRvIHRoaXMgc3luY2hyb25vdXNseSB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGNhbGxiYWNrcyBhcmUgYmFja2dyb3VuZGVkLlxuICAgICAgICAgICAgICAgIGhhbmRsZXIuX2NyZWF0ZVJ1bkZvclJldHJpZXZlclN0YXJ0KHJldHJpZXZlciwgcXVlcnksIHJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgcHJvbWlzZXNfanNfMS5jb25zdW1lQ2FsbGJhY2spKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZVJldHJpZXZlclN0YXJ0Py4ocmV0cmlldmVyLCBxdWVyeSwgcnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEsIHJ1bk5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZVJldHJpZXZlclN0YXJ0OiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gbmV3IENhbGxiYWNrTWFuYWdlckZvclJldHJpZXZlclJ1bihydW5JZCwgdGhpcy5oYW5kbGVycywgdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzLCB0aGlzLnRhZ3MsIHRoaXMuaW5oZXJpdGFibGVUYWdzLCB0aGlzLm1ldGFkYXRhLCB0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEsIHRoaXMuX3BhcmVudFJ1bklkKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGRhdGEsIHJ1bklkLCBfdGFncywgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBfbWV0YWRhdGEpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+ICgwLCBwcm9taXNlc19qc18xLmNvbnN1bWVDYWxsYmFjaykoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZUN1c3RvbUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVDdXN0b21FdmVudD8uKGV2ZW50TmFtZSwgZGF0YSwgcnVuSWQsIHRoaXMudGFncywgdGhpcy5tZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlQ3VzdG9tRXZlbnQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG4gICAgYWRkSGFuZGxlcihoYW5kbGVyLCBpbmhlcml0ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgICAgIGlmIChpbmhlcml0KSB7XG4gICAgICAgICAgICB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHRoaXMuaGFuZGxlcnMuZmlsdGVyKChfaGFuZGxlcikgPT4gX2hhbmRsZXIgIT09IGhhbmRsZXIpO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMgPSB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMuZmlsdGVyKChfaGFuZGxlcikgPT4gX2hhbmRsZXIgIT09IGhhbmRsZXIpO1xuICAgIH1cbiAgICBzZXRIYW5kbGVycyhoYW5kbGVycywgaW5oZXJpdCA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGhhbmRsZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEhhbmRsZXIoaGFuZGxlciwgaW5oZXJpdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkVGFncyh0YWdzLCBpbmhlcml0ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnJlbW92ZVRhZ3ModGFncyk7IC8vIFJlbW92ZSBkdXBsaWNhdGVzXG4gICAgICAgIHRoaXMudGFncy5wdXNoKC4uLnRhZ3MpO1xuICAgICAgICBpZiAoaW5oZXJpdCkge1xuICAgICAgICAgICAgdGhpcy5pbmhlcml0YWJsZVRhZ3MucHVzaCguLi50YWdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVUYWdzKHRhZ3MpIHtcbiAgICAgICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiAhdGFncy5pbmNsdWRlcyh0YWcpKTtcbiAgICAgICAgdGhpcy5pbmhlcml0YWJsZVRhZ3MgPSB0aGlzLmluaGVyaXRhYmxlVGFncy5maWx0ZXIoKHRhZykgPT4gIXRhZ3MuaW5jbHVkZXModGFnKSk7XG4gICAgfVxuICAgIGFkZE1ldGFkYXRhKG1ldGFkYXRhLCBpbmhlcml0ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0geyAuLi50aGlzLm1ldGFkYXRhLCAuLi5tZXRhZGF0YSB9O1xuICAgICAgICBpZiAoaW5oZXJpdCkge1xuICAgICAgICAgICAgdGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhID0geyAuLi50aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEsIC4uLm1ldGFkYXRhIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobWV0YWRhdGEpKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5tZXRhZGF0YVtrZXldO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvcHkoYWRkaXRpb25hbEhhbmRsZXJzID0gW10sIGluaGVyaXQgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKHRoaXMuX3BhcmVudFJ1bklkKTtcbiAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIHRoaXMuaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGluaGVyaXRhYmxlID0gdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzLmluY2x1ZGVzKGhhbmRsZXIpO1xuICAgICAgICAgICAgbWFuYWdlci5hZGRIYW5kbGVyKGhhbmRsZXIsIGluaGVyaXRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHRhZyBvZiB0aGlzLnRhZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGluaGVyaXRhYmxlID0gdGhpcy5pbmhlcml0YWJsZVRhZ3MuaW5jbHVkZXModGFnKTtcbiAgICAgICAgICAgIG1hbmFnZXIuYWRkVGFncyhbdGFnXSwgaW5oZXJpdGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMubWV0YWRhdGEpKSB7XG4gICAgICAgICAgICBjb25zdCBpbmhlcml0YWJsZSA9IE9iamVjdC5rZXlzKHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSkuaW5jbHVkZXMoa2V5KTtcbiAgICAgICAgICAgIG1hbmFnZXIuYWRkTWV0YWRhdGEoeyBba2V5XTogdGhpcy5tZXRhZGF0YVtrZXldIH0sIGluaGVyaXRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgYWRkaXRpb25hbEhhbmRsZXJzKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBQcmV2ZW50IG11bHRpcGxlIGNvcGllcyBvZiBjb25zb2xlX2NhbGxiYWNrX2hhbmRsZXJcbiAgICAgICAgICAgIG1hbmFnZXIuaGFuZGxlcnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChoKSA9PiBoLm5hbWUgPT09IFwiY29uc29sZV9jYWxsYmFja19oYW5kbGVyXCIpXG4gICAgICAgICAgICAgICAgLnNvbWUoKGgpID0+IGgubmFtZSA9PT0gaGFuZGxlci5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFuYWdlci5hZGRIYW5kbGVyKGhhbmRsZXIsIGluaGVyaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYW5hZ2VyO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhhbmRsZXJzKGhhbmRsZXJzKSB7XG4gICAgICAgIGNsYXNzIEhhbmRsZXIgZXh0ZW5kcyBiYXNlX2pzXzEuQmFzZUNhbGxiYWNrSGFuZGxlciB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogKDAsIHV1aWRfMS52NCkoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgaGFuZGxlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgdGhpcygpO1xuICAgICAgICBtYW5hZ2VyLmFkZEhhbmRsZXIobmV3IEhhbmRsZXIoKSk7XG4gICAgICAgIHJldHVybiBtYW5hZ2VyO1xuICAgIH1cbiAgICBzdGF0aWMgY29uZmlndXJlKGluaGVyaXRhYmxlSGFuZGxlcnMsIGxvY2FsSGFuZGxlcnMsIGluaGVyaXRhYmxlVGFncywgbG9jYWxUYWdzLCBpbmhlcml0YWJsZU1ldGFkYXRhLCBsb2NhbE1ldGFkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWd1cmVTeW5jKGluaGVyaXRhYmxlSGFuZGxlcnMsIGxvY2FsSGFuZGxlcnMsIGluaGVyaXRhYmxlVGFncywgbG9jYWxUYWdzLCBpbmhlcml0YWJsZU1ldGFkYXRhLCBsb2NhbE1ldGFkYXRhLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gVE9ETzogRGVwcmVjYXRlIGFzeW5jIG1ldGhvZCBpbiBmYXZvciBvZiB0aGlzIG9uZS5cbiAgICBzdGF0aWMgX2NvbmZpZ3VyZVN5bmMoaW5oZXJpdGFibGVIYW5kbGVycywgbG9jYWxIYW5kbGVycywgaW5oZXJpdGFibGVUYWdzLCBsb2NhbFRhZ3MsIGluaGVyaXRhYmxlTWV0YWRhdGEsIGxvY2FsTWV0YWRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGNhbGxiYWNrTWFuYWdlcjtcbiAgICAgICAgaWYgKGluaGVyaXRhYmxlSGFuZGxlcnMgfHwgbG9jYWxIYW5kbGVycykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5oZXJpdGFibGVIYW5kbGVycykgfHwgIWluaGVyaXRhYmxlSGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyLnNldEhhbmRsZXJzKGluaGVyaXRhYmxlSGFuZGxlcnM/Lm1hcChlbnN1cmVIYW5kbGVyKSA/PyBbXSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIgPSBpbmhlcml0YWJsZUhhbmRsZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyID0gY2FsbGJhY2tNYW5hZ2VyLmNvcHkoQXJyYXkuaXNBcnJheShsb2NhbEhhbmRsZXJzKVxuICAgICAgICAgICAgICAgID8gbG9jYWxIYW5kbGVycy5tYXAoZW5zdXJlSGFuZGxlcilcbiAgICAgICAgICAgICAgICA6IGxvY2FsSGFuZGxlcnM/LmhhbmRsZXJzLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVyYm9zZUVuYWJsZWQgPSAoMCwgZW52X2pzXzEuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSkoXCJMQU5HQ0hBSU5fVkVSQk9TRVwiKSA9PT0gXCJ0cnVlXCIgfHxcbiAgICAgICAgICAgIG9wdGlvbnM/LnZlcmJvc2U7XG4gICAgICAgIGNvbnN0IHRyYWNpbmdWMkVuYWJsZWQgPSB0cmFjZXJfbGFuZ2NoYWluX2pzXzEuTGFuZ0NoYWluVHJhY2VyLmdldFRyYWNlYWJsZVJ1blRyZWUoKT8udHJhY2luZ0VuYWJsZWQgfHxcbiAgICAgICAgICAgICgwLCBjYWxsYmFja3NfanNfMS5pc1RyYWNpbmdFbmFibGVkKSgpO1xuICAgICAgICBjb25zdCB0cmFjaW5nRW5hYmxlZCA9IHRyYWNpbmdWMkVuYWJsZWQgfHxcbiAgICAgICAgICAgICgoMCwgZW52X2pzXzEuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSkoXCJMQU5HQ0hBSU5fVFJBQ0lOR1wiKSA/PyBmYWxzZSk7XG4gICAgICAgIGlmICh2ZXJib3NlRW5hYmxlZCB8fCB0cmFjaW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgaWYgKCFjYWxsYmFja01hbmFnZXIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmVyYm9zZUVuYWJsZWQgJiZcbiAgICAgICAgICAgICAgICAhY2FsbGJhY2tNYW5hZ2VyLmhhbmRsZXJzLnNvbWUoKGhhbmRsZXIpID0+IGhhbmRsZXIubmFtZSA9PT0gY29uc29sZV9qc18xLkNvbnNvbGVDYWxsYmFja0hhbmRsZXIucHJvdG90eXBlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uc29sZUhhbmRsZXIgPSBuZXcgY29uc29sZV9qc18xLkNvbnNvbGVDYWxsYmFja0hhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuYWRkSGFuZGxlcihjb25zb2xlSGFuZGxlciwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhY2luZ0VuYWJsZWQgJiZcbiAgICAgICAgICAgICAgICAhY2FsbGJhY2tNYW5hZ2VyLmhhbmRsZXJzLnNvbWUoKGhhbmRsZXIpID0+IGhhbmRsZXIubmFtZSA9PT0gXCJsYW5nY2hhaW5fdHJhY2VyXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNpbmdWMkVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhY2VyVjIgPSBuZXcgdHJhY2VyX2xhbmdjaGFpbl9qc18xLkxhbmdDaGFpblRyYWNlcigpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuYWRkSGFuZGxlcih0cmFjZXJWMiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyYWNpbmdWMkVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBoYW5kb2ZmIGJldHdlZW4gbGFuZ2NoYWluIGFuZCBsYW5nc21pdGgvdHJhY2VhYmxlXG4gICAgICAgICAgICAgICAgLy8gb3ZlcnJpZGUgdGhlIHBhcmVudCBydW4gSURcbiAgICAgICAgICAgICAgICBjb25zdCBpbXBsaWNpdFJ1blRyZWUgPSB0cmFjZXJfbGFuZ2NoYWluX2pzXzEuTGFuZ0NoYWluVHJhY2VyLmdldFRyYWNlYWJsZVJ1blRyZWUoKTtcbiAgICAgICAgICAgICAgICBpZiAoaW1wbGljaXRSdW5UcmVlICYmIGNhbGxiYWNrTWFuYWdlci5fcGFyZW50UnVuSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuX3BhcmVudFJ1bklkID0gaW1wbGljaXRSdW5UcmVlLmlkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFjZXJWMiA9IGNhbGxiYWNrTWFuYWdlci5oYW5kbGVycy5maW5kKChoYW5kbGVyKSA9PiBoYW5kbGVyLm5hbWUgPT09IFwibGFuZ2NoYWluX3RyYWNlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VyVjI/LnVwZGF0ZUZyb21SdW5UcmVlKGltcGxpY2l0UnVuVHJlZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgeyBjb250ZXh0VmFyLCBpbmhlcml0YWJsZSA9IHRydWUsIGhhbmRsZXJDbGFzcywgZW52VmFyLCB9IG9mICgwLCBjb250ZXh0X2pzXzEuX2dldENvbmZpZ3VyZUhvb2tzKSgpKSB7XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVJZk5vdEluQ29udGV4dCA9IGVudlZhciAmJiAoMCwgZW52X2pzXzEuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSkoZW52VmFyKSA9PT0gXCJ0cnVlXCIgJiYgaGFuZGxlckNsYXNzO1xuICAgICAgICAgICAgbGV0IGhhbmRsZXI7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0VmFyVmFsdWUgPSBjb250ZXh0VmFyICE9PSB1bmRlZmluZWQgPyAoMCwgY29udGV4dF9qc18xLmdldENvbnRleHRWYXJpYWJsZSkoY29udGV4dFZhcikgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoY29udGV4dFZhclZhbHVlICYmICgwLCBiYXNlX2pzXzEuaXNCYXNlQ2FsbGJhY2tIYW5kbGVyKShjb250ZXh0VmFyVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IGNvbnRleHRWYXJWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNyZWF0ZUlmTm90SW5Db250ZXh0KSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gbmV3IGhhbmRsZXJDbGFzcyh7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWxsYmFja01hbmFnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyID0gbmV3IENhbGxiYWNrTWFuYWdlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrTWFuYWdlci5oYW5kbGVycy5zb21lKChoKSA9PiBoLm5hbWUgPT09IGhhbmRsZXIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyLmFkZEhhbmRsZXIoaGFuZGxlciwgaW5oZXJpdGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5oZXJpdGFibGVUYWdzIHx8IGxvY2FsVGFncykge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrTWFuYWdlcikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlci5hZGRUYWdzKGluaGVyaXRhYmxlVGFncyA/PyBbXSk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyLmFkZFRhZ3MobG9jYWxUYWdzID8/IFtdLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaGVyaXRhYmxlTWV0YWRhdGEgfHwgbG9jYWxNZXRhZGF0YSkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrTWFuYWdlcikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlci5hZGRNZXRhZGF0YShpbmhlcml0YWJsZU1ldGFkYXRhID8/IHt9KTtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuYWRkTWV0YWRhdGEobG9jYWxNZXRhZGF0YSA/PyB7fSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFja01hbmFnZXI7XG4gICAgfVxufVxuZXhwb3J0cy5DYWxsYmFja01hbmFnZXIgPSBDYWxsYmFja01hbmFnZXI7XG5mdW5jdGlvbiBlbnN1cmVIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICBpZiAoXCJuYW1lXCIgaW4gaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gaGFuZGxlcjtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2VfanNfMS5CYXNlQ2FsbGJhY2tIYW5kbGVyLmZyb21NZXRob2RzKGhhbmRsZXIpO1xufVxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgW2B0cmFjZWFibGVgXShodHRwczovL2RvY3Muc21pdGgubGFuZ2NoYWluLmNvbS9vYnNlcnZhYmlsaXR5L2hvd190b19ndWlkZXMvdHJhY2luZy9hbm5vdGF0ZV9jb2RlKVxuICogZnJvbSBcImxhbmdzbWl0aFwiIGluc3RlYWQuXG4gKi9cbmNsYXNzIFRyYWNlR3JvdXAge1xuICAgIGNvbnN0cnVjdG9yKGdyb3VwTmFtZSwgb3B0aW9ucykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJncm91cE5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGdyb3VwTmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3B0aW9uc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicnVuTWFuYWdlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFjZUdyb3VwQ2FsbGJhY2tNYW5hZ2VyKGdyb3VwX25hbWUsIGlucHV0cywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjYiA9IG5ldyB0cmFjZXJfbGFuZ2NoYWluX2pzXzEuTGFuZ0NoYWluVHJhY2VyKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjbSA9IGF3YWl0IENhbGxiYWNrTWFuYWdlci5jb25maWd1cmUoW2NiXSk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjbT8uaGFuZGxlQ2hhaW5TdGFydCh7XG4gICAgICAgICAgICBsYzogMSxcbiAgICAgICAgICAgIHR5cGU6IFwibm90X2ltcGxlbWVudGVkXCIsXG4gICAgICAgICAgICBpZDogW1wibGFuZ2NoYWluXCIsIFwiY2FsbGJhY2tzXCIsIFwiZ3JvdXBzXCIsIGdyb3VwX25hbWVdLFxuICAgICAgICB9LCBpbnB1dHMgPz8ge30pO1xuICAgICAgICBpZiAoIXJ1bk1hbmFnZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgcnVuIGdyb3VwIGNhbGxiYWNrIG1hbmFnZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW5NYW5hZ2VyO1xuICAgIH1cbiAgICBhc3luYyBzdGFydChpbnB1dHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJ1bk1hbmFnZXIpIHtcbiAgICAgICAgICAgIHRoaXMucnVuTWFuYWdlciA9IGF3YWl0IHRoaXMuZ2V0VHJhY2VHcm91cENhbGxiYWNrTWFuYWdlcih0aGlzLmdyb3VwTmFtZSwgaW5wdXRzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJ1bk1hbmFnZXIuZ2V0Q2hpbGQoKTtcbiAgICB9XG4gICAgYXN5bmMgZXJyb3IoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bk1hbmFnZXIpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucnVuTWFuYWdlci5oYW5kbGVDaGFpbkVycm9yKGVycik7XG4gICAgICAgICAgICB0aGlzLnJ1bk1hbmFnZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZW5kKG91dHB1dCkge1xuICAgICAgICBpZiAodGhpcy5ydW5NYW5hZ2VyKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJ1bk1hbmFnZXIuaGFuZGxlQ2hhaW5FbmQob3V0cHV0ID8/IHt9KTtcbiAgICAgICAgICAgIHRoaXMucnVuTWFuYWdlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVHJhY2VHcm91cCA9IFRyYWNlR3JvdXA7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gX2NvZXJjZVRvRGljdCh2YWx1ZSwgZGVmYXVsdEtleSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiB7IFtkZWZhdWx0S2V5XTogdmFsdWUgfTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5hc3luYyBmdW5jdGlvbiB0cmFjZUFzR3JvdXAoZ3JvdXBPcHRpb25zLCBlbmNsb3NlZENvZGUsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCB0cmFjZUdyb3VwID0gbmV3IFRyYWNlR3JvdXAoZ3JvdXBPcHRpb25zLm5hbWUsIGdyb3VwT3B0aW9ucyk7XG4gICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyID0gYXdhaXQgdHJhY2VHcm91cC5zdGFydCh7IC4uLmFyZ3MgfSk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZW5jbG9zZWRDb2RlKGNhbGxiYWNrTWFuYWdlciwgLi4uYXJncyk7XG4gICAgICAgIGF3YWl0IHRyYWNlR3JvdXAuZW5kKF9jb2VyY2VUb0RpY3QocmVzdWx0LCBcIm91dHB1dFwiKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgYXdhaXQgdHJhY2VHcm91cC5lcnJvcihlcnIpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/callbacks/promises.cjs":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/callbacks/promises.cjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.consumeCallback = exports.awaitAllCallbacks = void 0;\nconst callbacks_js_1 = __webpack_require__(/*! ../singletons/callbacks.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/callbacks.cjs\");\nObject.defineProperty(exports, \"awaitAllCallbacks\", ({ enumerable: true, get: function () { return callbacks_js_1.awaitAllCallbacks; } }));\nObject.defineProperty(exports, \"consumeCallback\", ({ enumerable: true, get: function () { return callbacks_js_1.consumeCallback; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvY2FsbGJhY2tzL3Byb21pc2VzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyx5QkFBeUI7QUFDbkQsdUJBQXVCLG1CQUFPLENBQUMsdUdBQTZCO0FBQzVELHFEQUFvRCxFQUFFLHFDQUFxQyw0Q0FBNEMsRUFBQztBQUN4SSxtREFBa0QsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9jYWxsYmFja3MvcHJvbWlzZXMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb25zdW1lQ2FsbGJhY2sgPSBleHBvcnRzLmF3YWl0QWxsQ2FsbGJhY2tzID0gdm9pZCAwO1xuY29uc3QgY2FsbGJhY2tzX2pzXzEgPSByZXF1aXJlKFwiLi4vc2luZ2xldG9ucy9jYWxsYmFja3MuY2pzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXdhaXRBbGxDYWxsYmFja3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGxiYWNrc19qc18xLmF3YWl0QWxsQ2FsbGJhY2tzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uc3VtZUNhbGxiYWNrXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFja3NfanNfMS5jb25zdW1lQ2FsbGJhY2s7IH0gfSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/callbacks/promises.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/documents/document.cjs":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/documents/document.cjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Document = void 0;\n/**\n * Interface for interacting with a document.\n */\nclass Document {\n    constructor(fields) {\n        Object.defineProperty(this, \"pageContent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // The ID field is optional at the moment.\n        // It will likely become required in a future major release after\n        // it has been adopted by enough vectorstore implementations.\n        /**\n         * An optional identifier for the document.\n         *\n         * Ideally this should be unique across the document collection and formatted\n         * as a UUID, but this will not be enforced.\n         */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.pageContent =\n            fields.pageContent !== undefined ? fields.pageContent.toString() : \"\";\n        this.metadata = fields.metadata ?? {};\n        this.id = fields.id;\n    }\n}\nexports.Document = Document;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZG9jdW1lbnRzL2RvY3VtZW50LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2RvY3VtZW50cy9kb2N1bWVudC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRvY3VtZW50ID0gdm9pZCAwO1xuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIGludGVyYWN0aW5nIHdpdGggYSBkb2N1bWVudC5cbiAqL1xuY2xhc3MgRG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwYWdlQ29udGVudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaGUgSUQgZmllbGQgaXMgb3B0aW9uYWwgYXQgdGhlIG1vbWVudC5cbiAgICAgICAgLy8gSXQgd2lsbCBsaWtlbHkgYmVjb21lIHJlcXVpcmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UgYWZ0ZXJcbiAgICAgICAgLy8gaXQgaGFzIGJlZW4gYWRvcHRlZCBieSBlbm91Z2ggdmVjdG9yc3RvcmUgaW1wbGVtZW50YXRpb25zLlxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gb3B0aW9uYWwgaWRlbnRpZmllciBmb3IgdGhlIGRvY3VtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZGVhbGx5IHRoaXMgc2hvdWxkIGJlIHVuaXF1ZSBhY3Jvc3MgdGhlIGRvY3VtZW50IGNvbGxlY3Rpb24gYW5kIGZvcm1hdHRlZFxuICAgICAgICAgKiBhcyBhIFVVSUQsIGJ1dCB0aGlzIHdpbGwgbm90IGJlIGVuZm9yY2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wYWdlQ29udGVudCA9XG4gICAgICAgICAgICBmaWVsZHMucGFnZUNvbnRlbnQgIT09IHVuZGVmaW5lZCA/IGZpZWxkcy5wYWdlQ29udGVudC50b1N0cmluZygpIDogXCJcIjtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IGZpZWxkcy5tZXRhZGF0YSA/PyB7fTtcbiAgICAgICAgdGhpcy5pZCA9IGZpZWxkcy5pZDtcbiAgICB9XG59XG5leHBvcnRzLkRvY3VtZW50ID0gRG9jdW1lbnQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/documents/document.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/documents/index.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/documents/index.cjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./document.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/documents/document.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./transformers.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/documents/transformers.cjs\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZG9jdW1lbnRzL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsd0ZBQWdCO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyxnR0FBb0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9kb2N1bWVudHMvaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZG9jdW1lbnQuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90cmFuc2Zvcm1lcnMuY2pzXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/documents/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/documents/transformers.cjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/documents/transformers.cjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MappingDocumentTransformer = exports.BaseDocumentTransformer = void 0;\nconst base_js_1 = __webpack_require__(/*! ../runnables/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\n/**\n * Abstract base class for document transformation systems.\n *\n * A document transformation system takes an array of Documents and returns an\n * array of transformed Documents. These arrays do not necessarily have to have\n * the same length.\n *\n * One example of this is a text splitter that splits a large document into\n * many smaller documents.\n */\nclass BaseDocumentTransformer extends base_js_1.Runnable {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"documents\", \"transformers\"]\n        });\n    }\n    /**\n     * Method to invoke the document transformation. This method calls the\n     * transformDocuments method with the provided input.\n     * @param input The input documents to be transformed.\n     * @param _options Optional configuration object to customize the behavior of callbacks.\n     * @returns A Promise that resolves to the transformed documents.\n     */\n    invoke(input, _options) {\n        return this.transformDocuments(input);\n    }\n}\nexports.BaseDocumentTransformer = BaseDocumentTransformer;\n/**\n * Class for document transformers that return exactly one transformed document\n * for each input document.\n */\nclass MappingDocumentTransformer extends BaseDocumentTransformer {\n    async transformDocuments(documents) {\n        const newDocuments = [];\n        for (const document of documents) {\n            const transformedDocument = await this._transformDocument(document);\n            newDocuments.push(transformedDocument);\n        }\n        return newDocuments;\n    }\n}\nexports.MappingDocumentTransformer = MappingDocumentTransformer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZG9jdW1lbnRzL3RyYW5zZm9ybWVycy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0NBQWtDLEdBQUcsK0JBQStCO0FBQ3BFLGtCQUFrQixtQkFBTyxDQUFDLDJGQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9kb2N1bWVudHMvdHJhbnNmb3JtZXJzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFwcGluZ0RvY3VtZW50VHJhbnNmb3JtZXIgPSBleHBvcnRzLkJhc2VEb2N1bWVudFRyYW5zZm9ybWVyID0gdm9pZCAwO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4uL3J1bm5hYmxlcy9iYXNlLmNqc1wiKTtcbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgZG9jdW1lbnQgdHJhbnNmb3JtYXRpb24gc3lzdGVtcy5cbiAqXG4gKiBBIGRvY3VtZW50IHRyYW5zZm9ybWF0aW9uIHN5c3RlbSB0YWtlcyBhbiBhcnJheSBvZiBEb2N1bWVudHMgYW5kIHJldHVybnMgYW5cbiAqIGFycmF5IG9mIHRyYW5zZm9ybWVkIERvY3VtZW50cy4gVGhlc2UgYXJyYXlzIGRvIG5vdCBuZWNlc3NhcmlseSBoYXZlIHRvIGhhdmVcbiAqIHRoZSBzYW1lIGxlbmd0aC5cbiAqXG4gKiBPbmUgZXhhbXBsZSBvZiB0aGlzIGlzIGEgdGV4dCBzcGxpdHRlciB0aGF0IHNwbGl0cyBhIGxhcmdlIGRvY3VtZW50IGludG9cbiAqIG1hbnkgc21hbGxlciBkb2N1bWVudHMuXG4gKi9cbmNsYXNzIEJhc2VEb2N1bWVudFRyYW5zZm9ybWVyIGV4dGVuZHMgYmFzZV9qc18xLlJ1bm5hYmxlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcImRvY3VtZW50c1wiLCBcInRyYW5zZm9ybWVyc1wiXVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGludm9rZSB0aGUgZG9jdW1lbnQgdHJhbnNmb3JtYXRpb24uIFRoaXMgbWV0aG9kIGNhbGxzIHRoZVxuICAgICAqIHRyYW5zZm9ybURvY3VtZW50cyBtZXRob2Qgd2l0aCB0aGUgcHJvdmlkZWQgaW5wdXQuXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCBkb2N1bWVudHMgdG8gYmUgdHJhbnNmb3JtZWQuXG4gICAgICogQHBhcmFtIF9vcHRpb25zIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHRvIGN1c3RvbWl6ZSB0aGUgYmVoYXZpb3Igb2YgY2FsbGJhY2tzLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSB0cmFuc2Zvcm1lZCBkb2N1bWVudHMuXG4gICAgICovXG4gICAgaW52b2tlKGlucHV0LCBfb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1Eb2N1bWVudHMoaW5wdXQpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZURvY3VtZW50VHJhbnNmb3JtZXIgPSBCYXNlRG9jdW1lbnRUcmFuc2Zvcm1lcjtcbi8qKlxuICogQ2xhc3MgZm9yIGRvY3VtZW50IHRyYW5zZm9ybWVycyB0aGF0IHJldHVybiBleGFjdGx5IG9uZSB0cmFuc2Zvcm1lZCBkb2N1bWVudFxuICogZm9yIGVhY2ggaW5wdXQgZG9jdW1lbnQuXG4gKi9cbmNsYXNzIE1hcHBpbmdEb2N1bWVudFRyYW5zZm9ybWVyIGV4dGVuZHMgQmFzZURvY3VtZW50VHJhbnNmb3JtZXIge1xuICAgIGFzeW5jIHRyYW5zZm9ybURvY3VtZW50cyhkb2N1bWVudHMpIHtcbiAgICAgICAgY29uc3QgbmV3RG9jdW1lbnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZG9jdW1lbnQgb2YgZG9jdW1lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZERvY3VtZW50ID0gYXdhaXQgdGhpcy5fdHJhbnNmb3JtRG9jdW1lbnQoZG9jdW1lbnQpO1xuICAgICAgICAgICAgbmV3RG9jdW1lbnRzLnB1c2godHJhbnNmb3JtZWREb2N1bWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RvY3VtZW50cztcbiAgICB9XG59XG5leHBvcnRzLk1hcHBpbmdEb2N1bWVudFRyYW5zZm9ybWVyID0gTWFwcGluZ0RvY3VtZW50VHJhbnNmb3JtZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/documents/transformers.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/embeddings.cjs":
/*!**********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/embeddings.cjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Embeddings = void 0;\nconst async_caller_js_1 = __webpack_require__(/*! ./utils/async_caller.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.cjs\");\n/**\n * An abstract class that provides methods for embedding documents and\n * queries using LangChain.\n */\nclass Embeddings {\n    constructor(params) {\n        /**\n         * The async caller should be used by subclasses to make any async calls,\n         * which will thus benefit from the concurrency and retry logic.\n         */\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.caller = new async_caller_js_1.AsyncCaller(params ?? {});\n    }\n}\nexports.Embeddings = Embeddings;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZW1iZWRkaW5ncy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLDBCQUEwQixtQkFBTyxDQUFDLGtHQUEwQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQSxrQkFBa0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9lbWJlZGRpbmdzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRW1iZWRkaW5ncyA9IHZvaWQgMDtcbmNvbnN0IGFzeW5jX2NhbGxlcl9qc18xID0gcmVxdWlyZShcIi4vdXRpbHMvYXN5bmNfY2FsbGVyLmNqc1wiKTtcbi8qKlxuICogQW4gYWJzdHJhY3QgY2xhc3MgdGhhdCBwcm92aWRlcyBtZXRob2RzIGZvciBlbWJlZGRpbmcgZG9jdW1lbnRzIGFuZFxuICogcXVlcmllcyB1c2luZyBMYW5nQ2hhaW4uXG4gKi9cbmNsYXNzIEVtYmVkZGluZ3Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFzeW5jIGNhbGxlciBzaG91bGQgYmUgdXNlZCBieSBzdWJjbGFzc2VzIHRvIG1ha2UgYW55IGFzeW5jIGNhbGxzLFxuICAgICAgICAgKiB3aGljaCB3aWxsIHRodXMgYmVuZWZpdCBmcm9tIHRoZSBjb25jdXJyZW5jeSBhbmQgcmV0cnkgbG9naWMuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYWxsZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYWxsZXIgPSBuZXcgYXN5bmNfY2FsbGVyX2pzXzEuQXN5bmNDYWxsZXIocGFyYW1zID8/IHt9KTtcbiAgICB9XG59XG5leHBvcnRzLkVtYmVkZGluZ3MgPSBFbWJlZGRpbmdzO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/embeddings.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/errors/index.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/errors/index.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable no-param-reassign */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.addLangChainErrorFields = addLangChainErrorFields;\nfunction addLangChainErrorFields(error, lc_error_code) {\n    error.lc_error_code = lc_error_code;\n    error.message = `${error.message}\\n\\nTroubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${lc_error_code}/\\n`;\n    return error;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZXJyb3JzL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYyxnRkFBZ0YsY0FBYztBQUNuSTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZXJyb3JzL2luZGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFkZExhbmdDaGFpbkVycm9yRmllbGRzID0gYWRkTGFuZ0NoYWluRXJyb3JGaWVsZHM7XG5mdW5jdGlvbiBhZGRMYW5nQ2hhaW5FcnJvckZpZWxkcyhlcnJvciwgbGNfZXJyb3JfY29kZSkge1xuICAgIGVycm9yLmxjX2Vycm9yX2NvZGUgPSBsY19lcnJvcl9jb2RlO1xuICAgIGVycm9yLm1lc3NhZ2UgPSBgJHtlcnJvci5tZXNzYWdlfVxcblxcblRyb3VibGVzaG9vdGluZyBVUkw6IGh0dHBzOi8vanMubGFuZ2NoYWluLmNvbS9kb2NzL3Ryb3VibGVzaG9vdGluZy9lcnJvcnMvJHtsY19lcnJvcl9jb2RlfS9cXG5gO1xuICAgIHJldHVybiBlcnJvcjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/errors/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/language_models/base.cjs":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/language_models/base.cjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseLanguageModel = exports.BaseLangChain = exports.calculateMaxTokens = exports.getModelContextSize = exports.getEmbeddingContextSize = exports.getModelNameForTiktoken = void 0;\nexports.isOpenAITool = isOpenAITool;\nconst base_js_1 = __webpack_require__(/*! ../caches/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/caches/base.cjs\");\nconst prompt_values_js_1 = __webpack_require__(/*! ../prompt_values.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/prompt_values.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ../messages/utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs\");\nconst async_caller_js_1 = __webpack_require__(/*! ../utils/async_caller.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.cjs\");\nconst tiktoken_js_1 = __webpack_require__(/*! ../utils/tiktoken.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/tiktoken.cjs\");\nconst base_js_2 = __webpack_require__(/*! ../runnables/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\n// https://www.npmjs.com/package/js-tiktoken\nconst getModelNameForTiktoken = (modelName) => {\n    if (modelName.startsWith(\"gpt-3.5-turbo-16k\")) {\n        return \"gpt-3.5-turbo-16k\";\n    }\n    if (modelName.startsWith(\"gpt-3.5-turbo-\")) {\n        return \"gpt-3.5-turbo\";\n    }\n    if (modelName.startsWith(\"gpt-4-32k\")) {\n        return \"gpt-4-32k\";\n    }\n    if (modelName.startsWith(\"gpt-4-\")) {\n        return \"gpt-4\";\n    }\n    if (modelName.startsWith(\"gpt-4o\")) {\n        return \"gpt-4o\";\n    }\n    return modelName;\n};\nexports.getModelNameForTiktoken = getModelNameForTiktoken;\nconst getEmbeddingContextSize = (modelName) => {\n    switch (modelName) {\n        case \"text-embedding-ada-002\":\n            return 8191;\n        default:\n            return 2046;\n    }\n};\nexports.getEmbeddingContextSize = getEmbeddingContextSize;\nconst getModelContextSize = (modelName) => {\n    switch ((0, exports.getModelNameForTiktoken)(modelName)) {\n        case \"gpt-3.5-turbo-16k\":\n            return 16384;\n        case \"gpt-3.5-turbo\":\n            return 4096;\n        case \"gpt-4-32k\":\n            return 32768;\n        case \"gpt-4\":\n            return 8192;\n        case \"text-davinci-003\":\n            return 4097;\n        case \"text-curie-001\":\n            return 2048;\n        case \"text-babbage-001\":\n            return 2048;\n        case \"text-ada-001\":\n            return 2048;\n        case \"code-davinci-002\":\n            return 8000;\n        case \"code-cushman-001\":\n            return 2048;\n        default:\n            return 4097;\n    }\n};\nexports.getModelContextSize = getModelContextSize;\n/**\n * Whether or not the input matches the OpenAI tool definition.\n * @param {unknown} tool The input to check.\n * @returns {boolean} Whether the input is an OpenAI tool definition.\n */\nfunction isOpenAITool(tool) {\n    if (typeof tool !== \"object\" || !tool)\n        return false;\n    if (\"type\" in tool &&\n        tool.type === \"function\" &&\n        \"function\" in tool &&\n        typeof tool.function === \"object\" &&\n        tool.function &&\n        \"name\" in tool.function &&\n        \"parameters\" in tool.function) {\n        return true;\n    }\n    return false;\n}\nconst calculateMaxTokens = async ({ prompt, modelName, }) => {\n    let numTokens;\n    try {\n        numTokens = (await (0, tiktoken_js_1.encodingForModel)((0, exports.getModelNameForTiktoken)(modelName))).encode(prompt).length;\n    }\n    catch (error) {\n        console.warn(\"Failed to calculate number of tokens, falling back to approximate count\");\n        // fallback to approximate calculation if tiktoken is not available\n        // each token is ~4 characters: https://help.openai.com/en/articles/4936856-what-are-tokens-and-how-to-count-them#\n        numTokens = Math.ceil(prompt.length / 4);\n    }\n    const maxTokens = (0, exports.getModelContextSize)(modelName);\n    return maxTokens - numTokens;\n};\nexports.calculateMaxTokens = calculateMaxTokens;\nconst getVerbosity = () => false;\n/**\n * Base class for language models, chains, tools.\n */\nclass BaseLangChain extends base_js_2.Runnable {\n    get lc_attributes() {\n        return {\n            callbacks: undefined,\n            verbose: undefined,\n        };\n    }\n    constructor(params) {\n        super(params);\n        /**\n         * Whether to print out response text.\n         */\n        Object.defineProperty(this, \"verbose\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"callbacks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.verbose = params.verbose ?? getVerbosity();\n        this.callbacks = params.callbacks;\n        this.tags = params.tags ?? [];\n        this.metadata = params.metadata ?? {};\n    }\n}\nexports.BaseLangChain = BaseLangChain;\n/**\n * Base class for language models.\n */\nclass BaseLanguageModel extends BaseLangChain {\n    /**\n     * Keys that the language model accepts as call options.\n     */\n    get callKeys() {\n        return [\"stop\", \"timeout\", \"signal\", \"tags\", \"metadata\", \"callbacks\"];\n    }\n    constructor({ callbacks, callbackManager, ...params }) {\n        const { cache, ...rest } = params;\n        super({\n            callbacks: callbacks ?? callbackManager,\n            ...rest,\n        });\n        /**\n         * The async caller should be used by subclasses to make any async calls,\n         * which will thus benefit from the concurrency and retry logic.\n         */\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"cache\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_encoding\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (typeof cache === \"object\") {\n            this.cache = cache;\n        }\n        else if (cache) {\n            this.cache = base_js_1.InMemoryCache.global();\n        }\n        else {\n            this.cache = undefined;\n        }\n        this.caller = new async_caller_js_1.AsyncCaller(params ?? {});\n    }\n    /**\n     * Get the number of tokens in the content.\n     * @param content The content to get the number of tokens for.\n     * @returns The number of tokens in the content.\n     */\n    async getNumTokens(content) {\n        // Extract text content from MessageContent\n        let textContent;\n        if (typeof content === \"string\") {\n            textContent = content;\n        }\n        else {\n            /**\n             * Content is an array of MessageContentComplex\n             *\n             * ToDo(@christian-bromann): This is a temporary fix to get the number of tokens for the content.\n             * We need to find a better way to do this.\n             * @see https://github.com/langchain-ai/langchainjs/pull/8341#pullrequestreview-2933713116\n             */\n            textContent = content\n                .map((item) => {\n                if (typeof item === \"string\")\n                    return item;\n                if (item.type === \"text\" && \"text\" in item)\n                    return item.text;\n                return \"\";\n            })\n                .join(\"\");\n        }\n        // fallback to approximate calculation if tiktoken is not available\n        let numTokens = Math.ceil(textContent.length / 4);\n        if (!this._encoding) {\n            try {\n                this._encoding = await (0, tiktoken_js_1.encodingForModel)(\"modelName\" in this\n                    ? (0, exports.getModelNameForTiktoken)(this.modelName)\n                    : \"gpt2\");\n            }\n            catch (error) {\n                console.warn(\"Failed to calculate number of tokens, falling back to approximate count\", error);\n            }\n        }\n        if (this._encoding) {\n            try {\n                numTokens = this._encoding.encode(textContent).length;\n            }\n            catch (error) {\n                console.warn(\"Failed to calculate number of tokens, falling back to approximate count\", error);\n            }\n        }\n        return numTokens;\n    }\n    static _convertInputToPromptValue(input) {\n        if (typeof input === \"string\") {\n            return new prompt_values_js_1.StringPromptValue(input);\n        }\n        else if (Array.isArray(input)) {\n            return new prompt_values_js_1.ChatPromptValue(input.map(utils_js_1.coerceMessageLikeToMessage));\n        }\n        else {\n            return input;\n        }\n    }\n    /**\n     * Get the identifying parameters of the LLM.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _identifyingParams() {\n        return {};\n    }\n    /**\n     * Create a unique cache key for a specific call to a specific language model.\n     * @param callOptions Call options for the model\n     * @returns A unique cache key.\n     */\n    _getSerializedCacheKeyParametersForCall(\n    // TODO: Fix when we remove the RunnableLambda backwards compatibility shim.\n    { config, ...callOptions }) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const params = {\n            ...this._identifyingParams(),\n            ...callOptions,\n            _type: this._llmType(),\n            _model: this._modelType(),\n        };\n        const filteredEntries = Object.entries(params).filter(([_, value]) => value !== undefined);\n        const serializedEntries = filteredEntries\n            .map(([key, value]) => `${key}:${JSON.stringify(value)}`)\n            .sort()\n            .join(\",\");\n        return serializedEntries;\n    }\n    /**\n     * @deprecated\n     * Return a json-like object representing this LLM.\n     */\n    serialize() {\n        return {\n            ...this._identifyingParams(),\n            _type: this._llmType(),\n            _model: this._modelType(),\n        };\n    }\n    /**\n     * @deprecated\n     * Load an LLM from a json-like object describing it.\n     */\n    static async deserialize(_data) {\n        throw new Error(\"Use .toJSON() instead\");\n    }\n}\nexports.BaseLanguageModel = BaseLanguageModel;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbGFuZ3VhZ2VfbW9kZWxzL2Jhc2UuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLHFCQUFxQixHQUFHLDBCQUEwQixHQUFHLDJCQUEyQixHQUFHLCtCQUErQixHQUFHLCtCQUErQjtBQUNoTCxvQkFBb0I7QUFDcEIsa0JBQWtCLG1CQUFPLENBQUMscUZBQW9CO0FBQzlDLDJCQUEyQixtQkFBTyxDQUFDLHlGQUFzQjtBQUN6RCxtQkFBbUIsbUJBQU8sQ0FBQywyRkFBdUI7QUFDbEQsMEJBQTBCLG1CQUFPLENBQUMsbUdBQTJCO0FBQzdELHNCQUFzQixtQkFBTyxDQUFDLDJGQUF1QjtBQUNyRCxrQkFBa0IsbUJBQU8sQ0FBQywyRkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1Q0FBdUM7QUFDekQsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx3QkFBd0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLElBQUksR0FBRyxzQkFBc0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2xhbmd1YWdlX21vZGVscy9iYXNlLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZUxhbmd1YWdlTW9kZWwgPSBleHBvcnRzLkJhc2VMYW5nQ2hhaW4gPSBleHBvcnRzLmNhbGN1bGF0ZU1heFRva2VucyA9IGV4cG9ydHMuZ2V0TW9kZWxDb250ZXh0U2l6ZSA9IGV4cG9ydHMuZ2V0RW1iZWRkaW5nQ29udGV4dFNpemUgPSBleHBvcnRzLmdldE1vZGVsTmFtZUZvclRpa3Rva2VuID0gdm9pZCAwO1xuZXhwb3J0cy5pc09wZW5BSVRvb2wgPSBpc09wZW5BSVRvb2w7XG5jb25zdCBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi4vY2FjaGVzL2Jhc2UuY2pzXCIpO1xuY29uc3QgcHJvbXB0X3ZhbHVlc19qc18xID0gcmVxdWlyZShcIi4uL3Byb21wdF92YWx1ZXMuY2pzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuLi9tZXNzYWdlcy91dGlscy5janNcIik7XG5jb25zdCBhc3luY19jYWxsZXJfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9hc3luY19jYWxsZXIuY2pzXCIpO1xuY29uc3QgdGlrdG9rZW5fanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy90aWt0b2tlbi5janNcIik7XG5jb25zdCBiYXNlX2pzXzIgPSByZXF1aXJlKFwiLi4vcnVubmFibGVzL2Jhc2UuY2pzXCIpO1xuLy8gaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvanMtdGlrdG9rZW5cbmNvbnN0IGdldE1vZGVsTmFtZUZvclRpa3Rva2VuID0gKG1vZGVsTmFtZSkgPT4ge1xuICAgIGlmIChtb2RlbE5hbWUuc3RhcnRzV2l0aChcImdwdC0zLjUtdHVyYm8tMTZrXCIpKSB7XG4gICAgICAgIHJldHVybiBcImdwdC0zLjUtdHVyYm8tMTZrXCI7XG4gICAgfVxuICAgIGlmIChtb2RlbE5hbWUuc3RhcnRzV2l0aChcImdwdC0zLjUtdHVyYm8tXCIpKSB7XG4gICAgICAgIHJldHVybiBcImdwdC0zLjUtdHVyYm9cIjtcbiAgICB9XG4gICAgaWYgKG1vZGVsTmFtZS5zdGFydHNXaXRoKFwiZ3B0LTQtMzJrXCIpKSB7XG4gICAgICAgIHJldHVybiBcImdwdC00LTMya1wiO1xuICAgIH1cbiAgICBpZiAobW9kZWxOYW1lLnN0YXJ0c1dpdGgoXCJncHQtNC1cIikpIHtcbiAgICAgICAgcmV0dXJuIFwiZ3B0LTRcIjtcbiAgICB9XG4gICAgaWYgKG1vZGVsTmFtZS5zdGFydHNXaXRoKFwiZ3B0LTRvXCIpKSB7XG4gICAgICAgIHJldHVybiBcImdwdC00b1wiO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWxOYW1lO1xufTtcbmV4cG9ydHMuZ2V0TW9kZWxOYW1lRm9yVGlrdG9rZW4gPSBnZXRNb2RlbE5hbWVGb3JUaWt0b2tlbjtcbmNvbnN0IGdldEVtYmVkZGluZ0NvbnRleHRTaXplID0gKG1vZGVsTmFtZSkgPT4ge1xuICAgIHN3aXRjaCAobW9kZWxOYW1lKSB7XG4gICAgICAgIGNhc2UgXCJ0ZXh0LWVtYmVkZGluZy1hZGEtMDAyXCI6XG4gICAgICAgICAgICByZXR1cm4gODE5MTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAyMDQ2O1xuICAgIH1cbn07XG5leHBvcnRzLmdldEVtYmVkZGluZ0NvbnRleHRTaXplID0gZ2V0RW1iZWRkaW5nQ29udGV4dFNpemU7XG5jb25zdCBnZXRNb2RlbENvbnRleHRTaXplID0gKG1vZGVsTmFtZSkgPT4ge1xuICAgIHN3aXRjaCAoKDAsIGV4cG9ydHMuZ2V0TW9kZWxOYW1lRm9yVGlrdG9rZW4pKG1vZGVsTmFtZSkpIHtcbiAgICAgICAgY2FzZSBcImdwdC0zLjUtdHVyYm8tMTZrXCI6XG4gICAgICAgICAgICByZXR1cm4gMTYzODQ7XG4gICAgICAgIGNhc2UgXCJncHQtMy41LXR1cmJvXCI6XG4gICAgICAgICAgICByZXR1cm4gNDA5NjtcbiAgICAgICAgY2FzZSBcImdwdC00LTMya1wiOlxuICAgICAgICAgICAgcmV0dXJuIDMyNzY4O1xuICAgICAgICBjYXNlIFwiZ3B0LTRcIjpcbiAgICAgICAgICAgIHJldHVybiA4MTkyO1xuICAgICAgICBjYXNlIFwidGV4dC1kYXZpbmNpLTAwM1wiOlxuICAgICAgICAgICAgcmV0dXJuIDQwOTc7XG4gICAgICAgIGNhc2UgXCJ0ZXh0LWN1cmllLTAwMVwiOlxuICAgICAgICAgICAgcmV0dXJuIDIwNDg7XG4gICAgICAgIGNhc2UgXCJ0ZXh0LWJhYmJhZ2UtMDAxXCI6XG4gICAgICAgICAgICByZXR1cm4gMjA0ODtcbiAgICAgICAgY2FzZSBcInRleHQtYWRhLTAwMVwiOlxuICAgICAgICAgICAgcmV0dXJuIDIwNDg7XG4gICAgICAgIGNhc2UgXCJjb2RlLWRhdmluY2ktMDAyXCI6XG4gICAgICAgICAgICByZXR1cm4gODAwMDtcbiAgICAgICAgY2FzZSBcImNvZGUtY3VzaG1hbi0wMDFcIjpcbiAgICAgICAgICAgIHJldHVybiAyMDQ4O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIDQwOTc7XG4gICAgfVxufTtcbmV4cG9ydHMuZ2V0TW9kZWxDb250ZXh0U2l6ZSA9IGdldE1vZGVsQ29udGV4dFNpemU7XG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCBtYXRjaGVzIHRoZSBPcGVuQUkgdG9vbCBkZWZpbml0aW9uLlxuICogQHBhcmFtIHt1bmtub3dufSB0b29sIFRoZSBpbnB1dCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBpbnB1dCBpcyBhbiBPcGVuQUkgdG9vbCBkZWZpbml0aW9uLlxuICovXG5mdW5jdGlvbiBpc09wZW5BSVRvb2wodG9vbCkge1xuICAgIGlmICh0eXBlb2YgdG9vbCAhPT0gXCJvYmplY3RcIiB8fCAhdG9vbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChcInR5cGVcIiBpbiB0b29sICYmXG4gICAgICAgIHRvb2wudHlwZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiBpbiB0b29sICYmXG4gICAgICAgIHR5cGVvZiB0b29sLmZ1bmN0aW9uID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHRvb2wuZnVuY3Rpb24gJiZcbiAgICAgICAgXCJuYW1lXCIgaW4gdG9vbC5mdW5jdGlvbiAmJlxuICAgICAgICBcInBhcmFtZXRlcnNcIiBpbiB0b29sLmZ1bmN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBjYWxjdWxhdGVNYXhUb2tlbnMgPSBhc3luYyAoeyBwcm9tcHQsIG1vZGVsTmFtZSwgfSkgPT4ge1xuICAgIGxldCBudW1Ub2tlbnM7XG4gICAgdHJ5IHtcbiAgICAgICAgbnVtVG9rZW5zID0gKGF3YWl0ICgwLCB0aWt0b2tlbl9qc18xLmVuY29kaW5nRm9yTW9kZWwpKCgwLCBleHBvcnRzLmdldE1vZGVsTmFtZUZvclRpa3Rva2VuKShtb2RlbE5hbWUpKSkuZW5jb2RlKHByb21wdCkubGVuZ3RoO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGNhbGN1bGF0ZSBudW1iZXIgb2YgdG9rZW5zLCBmYWxsaW5nIGJhY2sgdG8gYXBwcm94aW1hdGUgY291bnRcIik7XG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIGFwcHJveGltYXRlIGNhbGN1bGF0aW9uIGlmIHRpa3Rva2VuIGlzIG5vdCBhdmFpbGFibGVcbiAgICAgICAgLy8gZWFjaCB0b2tlbiBpcyB+NCBjaGFyYWN0ZXJzOiBodHRwczovL2hlbHAub3BlbmFpLmNvbS9lbi9hcnRpY2xlcy80OTM2ODU2LXdoYXQtYXJlLXRva2Vucy1hbmQtaG93LXRvLWNvdW50LXRoZW0jXG4gICAgICAgIG51bVRva2VucyA9IE1hdGguY2VpbChwcm9tcHQubGVuZ3RoIC8gNCk7XG4gICAgfVxuICAgIGNvbnN0IG1heFRva2VucyA9ICgwLCBleHBvcnRzLmdldE1vZGVsQ29udGV4dFNpemUpKG1vZGVsTmFtZSk7XG4gICAgcmV0dXJuIG1heFRva2VucyAtIG51bVRva2Vucztcbn07XG5leHBvcnRzLmNhbGN1bGF0ZU1heFRva2VucyA9IGNhbGN1bGF0ZU1heFRva2VucztcbmNvbnN0IGdldFZlcmJvc2l0eSA9ICgpID0+IGZhbHNlO1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBsYW5ndWFnZSBtb2RlbHMsIGNoYWlucywgdG9vbHMuXG4gKi9cbmNsYXNzIEJhc2VMYW5nQ2hhaW4gZXh0ZW5kcyBiYXNlX2pzXzIuUnVubmFibGUge1xuICAgIGdldCBsY19hdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FsbGJhY2tzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB2ZXJib3NlOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBzdXBlcihwYXJhbXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0byBwcmludCBvdXQgcmVzcG9uc2UgdGV4dC5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcmJvc2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FsbGJhY2tzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52ZXJib3NlID0gcGFyYW1zLnZlcmJvc2UgPz8gZ2V0VmVyYm9zaXR5KCk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gcGFyYW1zLmNhbGxiYWNrcztcbiAgICAgICAgdGhpcy50YWdzID0gcGFyYW1zLnRhZ3MgPz8gW107XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBwYXJhbXMubWV0YWRhdGEgPz8ge307XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlTGFuZ0NoYWluID0gQmFzZUxhbmdDaGFpbjtcbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgbGFuZ3VhZ2UgbW9kZWxzLlxuICovXG5jbGFzcyBCYXNlTGFuZ3VhZ2VNb2RlbCBleHRlbmRzIEJhc2VMYW5nQ2hhaW4ge1xuICAgIC8qKlxuICAgICAqIEtleXMgdGhhdCB0aGUgbGFuZ3VhZ2UgbW9kZWwgYWNjZXB0cyBhcyBjYWxsIG9wdGlvbnMuXG4gICAgICovXG4gICAgZ2V0IGNhbGxLZXlzKCkge1xuICAgICAgICByZXR1cm4gW1wic3RvcFwiLCBcInRpbWVvdXRcIiwgXCJzaWduYWxcIiwgXCJ0YWdzXCIsIFwibWV0YWRhdGFcIiwgXCJjYWxsYmFja3NcIl07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHsgY2FsbGJhY2tzLCBjYWxsYmFja01hbmFnZXIsIC4uLnBhcmFtcyB9KSB7XG4gICAgICAgIGNvbnN0IHsgY2FjaGUsIC4uLnJlc3QgfSA9IHBhcmFtcztcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgY2FsbGJhY2tzOiBjYWxsYmFja3MgPz8gY2FsbGJhY2tNYW5hZ2VyLFxuICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYXN5bmMgY2FsbGVyIHNob3VsZCBiZSB1c2VkIGJ5IHN1YmNsYXNzZXMgdG8gbWFrZSBhbnkgYXN5bmMgY2FsbHMsXG4gICAgICAgICAqIHdoaWNoIHdpbGwgdGh1cyBiZW5lZml0IGZyb20gdGhlIGNvbmN1cnJlbmN5IGFuZCByZXRyeSBsb2dpYy5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhbGxlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYWNoZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZW5jb2RpbmdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWNoZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdGhpcy5jYWNoZSA9IGNhY2hlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlID0gYmFzZV9qc18xLkluTWVtb3J5Q2FjaGUuZ2xvYmFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbGVyID0gbmV3IGFzeW5jX2NhbGxlcl9qc18xLkFzeW5jQ2FsbGVyKHBhcmFtcyA/PyB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIHRva2VucyBpbiB0aGUgY29udGVudC5cbiAgICAgKiBAcGFyYW0gY29udGVudCBUaGUgY29udGVudCB0byBnZXQgdGhlIG51bWJlciBvZiB0b2tlbnMgZm9yLlxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgdG9rZW5zIGluIHRoZSBjb250ZW50LlxuICAgICAqL1xuICAgIGFzeW5jIGdldE51bVRva2Vucyhjb250ZW50KSB7XG4gICAgICAgIC8vIEV4dHJhY3QgdGV4dCBjb250ZW50IGZyb20gTWVzc2FnZUNvbnRlbnRcbiAgICAgICAgbGV0IHRleHRDb250ZW50O1xuICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRleHRDb250ZW50ID0gY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29udGVudCBpcyBhbiBhcnJheSBvZiBNZXNzYWdlQ29udGVudENvbXBsZXhcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUb0RvKEBjaHJpc3RpYW4tYnJvbWFubik6IFRoaXMgaXMgYSB0ZW1wb3JhcnkgZml4IHRvIGdldCB0aGUgbnVtYmVyIG9mIHRva2VucyBmb3IgdGhlIGNvbnRlbnQuXG4gICAgICAgICAgICAgKiBXZSBuZWVkIHRvIGZpbmQgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoaXMuXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9sYW5nY2hhaW4tYWkvbGFuZ2NoYWluanMvcHVsbC84MzQxI3B1bGxyZXF1ZXN0cmV2aWV3LTI5MzM3MTMxMTZcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGV4dENvbnRlbnQgPSBjb250ZW50XG4gICAgICAgICAgICAgICAgLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiYgXCJ0ZXh0XCIgaW4gaXRlbSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0udGV4dDtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gYXBwcm94aW1hdGUgY2FsY3VsYXRpb24gaWYgdGlrdG9rZW4gaXMgbm90IGF2YWlsYWJsZVxuICAgICAgICBsZXQgbnVtVG9rZW5zID0gTWF0aC5jZWlsKHRleHRDb250ZW50Lmxlbmd0aCAvIDQpO1xuICAgICAgICBpZiAoIXRoaXMuX2VuY29kaW5nKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuY29kaW5nID0gYXdhaXQgKDAsIHRpa3Rva2VuX2pzXzEuZW5jb2RpbmdGb3JNb2RlbCkoXCJtb2RlbE5hbWVcIiBpbiB0aGlzXG4gICAgICAgICAgICAgICAgICAgID8gKDAsIGV4cG9ydHMuZ2V0TW9kZWxOYW1lRm9yVGlrdG9rZW4pKHRoaXMubW9kZWxOYW1lKVxuICAgICAgICAgICAgICAgICAgICA6IFwiZ3B0MlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBjYWxjdWxhdGUgbnVtYmVyIG9mIHRva2VucywgZmFsbGluZyBiYWNrIHRvIGFwcHJveGltYXRlIGNvdW50XCIsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbnVtVG9rZW5zID0gdGhpcy5fZW5jb2RpbmcuZW5jb2RlKHRleHRDb250ZW50KS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gY2FsY3VsYXRlIG51bWJlciBvZiB0b2tlbnMsIGZhbGxpbmcgYmFjayB0byBhcHByb3hpbWF0ZSBjb3VudFwiLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bVRva2VucztcbiAgICB9XG4gICAgc3RhdGljIF9jb252ZXJ0SW5wdXRUb1Byb21wdFZhbHVlKGlucHV0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgcHJvbXB0X3ZhbHVlc19qc18xLlN0cmluZ1Byb21wdFZhbHVlKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm9tcHRfdmFsdWVzX2pzXzEuQ2hhdFByb21wdFZhbHVlKGlucHV0Lm1hcCh1dGlsc19qc18xLmNvZXJjZU1lc3NhZ2VMaWtlVG9NZXNzYWdlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpZGVudGlmeWluZyBwYXJhbWV0ZXJzIG9mIHRoZSBMTE0uXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBfaWRlbnRpZnlpbmdQYXJhbXMoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgdW5pcXVlIGNhY2hlIGtleSBmb3IgYSBzcGVjaWZpYyBjYWxsIHRvIGEgc3BlY2lmaWMgbGFuZ3VhZ2UgbW9kZWwuXG4gICAgICogQHBhcmFtIGNhbGxPcHRpb25zIENhbGwgb3B0aW9ucyBmb3IgdGhlIG1vZGVsXG4gICAgICogQHJldHVybnMgQSB1bmlxdWUgY2FjaGUga2V5LlxuICAgICAqL1xuICAgIF9nZXRTZXJpYWxpemVkQ2FjaGVLZXlQYXJhbWV0ZXJzRm9yQ2FsbChcbiAgICAvLyBUT0RPOiBGaXggd2hlbiB3ZSByZW1vdmUgdGhlIFJ1bm5hYmxlTGFtYmRhIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHNoaW0uXG4gICAgeyBjb25maWcsIC4uLmNhbGxPcHRpb25zIH0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgLi4udGhpcy5faWRlbnRpZnlpbmdQYXJhbXMoKSxcbiAgICAgICAgICAgIC4uLmNhbGxPcHRpb25zLFxuICAgICAgICAgICAgX3R5cGU6IHRoaXMuX2xsbVR5cGUoKSxcbiAgICAgICAgICAgIF9tb2RlbDogdGhpcy5fbW9kZWxUeXBlKCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHBhcmFtcykuZmlsdGVyKChbXywgdmFsdWVdKSA9PiB2YWx1ZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZEVudHJpZXMgPSBmaWx0ZXJlZEVudHJpZXNcbiAgICAgICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7a2V5fToke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKVxuICAgICAgICAgICAgLnNvcnQoKVxuICAgICAgICAgICAgLmpvaW4oXCIsXCIpO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplZEVudHJpZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogUmV0dXJuIGEganNvbi1saWtlIG9iamVjdCByZXByZXNlbnRpbmcgdGhpcyBMTE0uXG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udGhpcy5faWRlbnRpZnlpbmdQYXJhbXMoKSxcbiAgICAgICAgICAgIF90eXBlOiB0aGlzLl9sbG1UeXBlKCksXG4gICAgICAgICAgICBfbW9kZWw6IHRoaXMuX21vZGVsVHlwZSgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIExvYWQgYW4gTExNIGZyb20gYSBqc29uLWxpa2Ugb2JqZWN0IGRlc2NyaWJpbmcgaXQuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKF9kYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVzZSAudG9KU09OKCkgaW5zdGVhZFwiKTtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VMYW5ndWFnZU1vZGVsID0gQmFzZUxhbmd1YWdlTW9kZWw7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/language_models/base.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/language_models/chat_models.cjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/language_models/chat_models.cjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SimpleChatModel = exports.BaseChatModel = void 0;\nexports.createChatMessageChunkEncoderStream = createChatMessageChunkEncoderStream;\nconst index_js_1 = __webpack_require__(/*! ../messages/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/index.cjs\");\nconst outputs_js_1 = __webpack_require__(/*! ../outputs.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/outputs.cjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/language_models/base.cjs\");\nconst manager_js_1 = __webpack_require__(/*! ../callbacks/manager.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.cjs\");\nconst base_js_2 = __webpack_require__(/*! ../runnables/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\nconst passthrough_js_1 = __webpack_require__(/*! ../runnables/passthrough.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/passthrough.cjs\");\nconst zod_js_1 = __webpack_require__(/*! ../utils/types/zod.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.cjs\");\nconst base_js_3 = __webpack_require__(/*! ../callbacks/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/base.cjs\");\nconst json_schema_js_1 = __webpack_require__(/*! ../utils/json_schema.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_schema.cjs\");\n/**\n * Creates a transform stream for encoding chat message chunks.\n * @deprecated Use {@link BytesOutputParser} instead\n * @returns A TransformStream instance that encodes chat message chunks.\n */\nfunction createChatMessageChunkEncoderStream() {\n    const textEncoder = new TextEncoder();\n    return new TransformStream({\n        transform(chunk, controller) {\n            controller.enqueue(textEncoder.encode(typeof chunk.content === \"string\"\n                ? chunk.content\n                : JSON.stringify(chunk.content)));\n        },\n    });\n}\nfunction _formatForTracing(messages) {\n    const messagesToTrace = [];\n    for (const message of messages) {\n        let messageToTrace = message;\n        if (Array.isArray(message.content)) {\n            for (let idx = 0; idx < message.content.length; idx++) {\n                const block = message.content[idx];\n                if ((0, index_js_1.isURLContentBlock)(block) || (0, index_js_1.isBase64ContentBlock)(block)) {\n                    if (messageToTrace === message) {\n                        // Also shallow-copy content\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        messageToTrace = new message.constructor({\n                            ...messageToTrace,\n                            content: [\n                                ...message.content.slice(0, idx),\n                                (0, index_js_1.convertToOpenAIImageBlock)(block),\n                                ...message.content.slice(idx + 1),\n                            ],\n                        });\n                    }\n                }\n            }\n        }\n        messagesToTrace.push(messageToTrace);\n    }\n    return messagesToTrace;\n}\n/**\n * Base class for chat models. It extends the BaseLanguageModel class and\n * provides methods for generating chat based on input messages.\n */\nclass BaseChatModel extends base_js_1.BaseLanguageModel {\n    constructor(fields) {\n        super(fields);\n        // Only ever instantiated in main LangChain\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"chat_models\", this._llmType()]\n        });\n        Object.defineProperty(this, \"disableStreaming\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n    }\n    _separateRunnableConfigFromCallOptionsCompat(options) {\n        // For backwards compat, keep `signal` in both runnableConfig and callOptions\n        const [runnableConfig, callOptions] = super._separateRunnableConfigFromCallOptions(options);\n        callOptions.signal = runnableConfig.signal;\n        return [runnableConfig, callOptions];\n    }\n    /**\n     * Invokes the chat model with a single input.\n     * @param input The input for the language model.\n     * @param options The call options.\n     * @returns A Promise that resolves to a BaseMessageChunk.\n     */\n    async invoke(input, options) {\n        const promptValue = BaseChatModel._convertInputToPromptValue(input);\n        const result = await this.generatePrompt([promptValue], options, options?.callbacks);\n        const chatGeneration = result.generations[0][0];\n        // TODO: Remove cast after figuring out inheritance\n        return chatGeneration.message;\n    }\n    // eslint-disable-next-line require-yield\n    async *_streamResponseChunks(_messages, _options, _runManager) {\n        throw new Error(\"Not implemented.\");\n    }\n    async *_streamIterator(input, options) {\n        // Subclass check required to avoid double callbacks with default implementation\n        if (this._streamResponseChunks ===\n            BaseChatModel.prototype._streamResponseChunks ||\n            this.disableStreaming) {\n            yield this.invoke(input, options);\n        }\n        else {\n            const prompt = BaseChatModel._convertInputToPromptValue(input);\n            const messages = prompt.toChatMessages();\n            const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(options);\n            const inheritableMetadata = {\n                ...runnableConfig.metadata,\n                ...this.getLsParams(callOptions),\n            };\n            const callbackManager_ = await manager_js_1.CallbackManager.configure(runnableConfig.callbacks, this.callbacks, runnableConfig.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });\n            const extra = {\n                options: callOptions,\n                invocation_params: this?.invocationParams(callOptions),\n                batch_size: 1,\n            };\n            const runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), [_formatForTracing(messages)], runnableConfig.runId, undefined, extra, undefined, undefined, runnableConfig.runName);\n            let generationChunk;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            let llmOutput;\n            try {\n                for await (const chunk of this._streamResponseChunks(messages, callOptions, runManagers?.[0])) {\n                    if (chunk.message.id == null) {\n                        const runId = runManagers?.at(0)?.runId;\n                        if (runId != null)\n                            chunk.message._updateId(`run-${runId}`);\n                    }\n                    chunk.message.response_metadata = {\n                        ...chunk.generationInfo,\n                        ...chunk.message.response_metadata,\n                    };\n                    yield chunk.message;\n                    if (!generationChunk) {\n                        generationChunk = chunk;\n                    }\n                    else {\n                        generationChunk = generationChunk.concat(chunk);\n                    }\n                    if ((0, index_js_1.isAIMessageChunk)(chunk.message) &&\n                        chunk.message.usage_metadata !== undefined) {\n                        llmOutput = {\n                            tokenUsage: {\n                                promptTokens: chunk.message.usage_metadata.input_tokens,\n                                completionTokens: chunk.message.usage_metadata.output_tokens,\n                                totalTokens: chunk.message.usage_metadata.total_tokens,\n                            },\n                        };\n                    }\n                }\n            }\n            catch (err) {\n                await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));\n                throw err;\n            }\n            await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMEnd({\n                // TODO: Remove cast after figuring out inheritance\n                generations: [[generationChunk]],\n                llmOutput,\n            })));\n        }\n    }\n    getLsParams(options) {\n        const providerName = this.getName().startsWith(\"Chat\")\n            ? this.getName().replace(\"Chat\", \"\")\n            : this.getName();\n        return {\n            ls_model_type: \"chat\",\n            ls_stop: options.stop,\n            ls_provider: providerName,\n        };\n    }\n    /** @ignore */\n    async _generateUncached(messages, parsedOptions, handledOptions, startedRunManagers) {\n        const baseMessages = messages.map((messageList) => messageList.map(index_js_1.coerceMessageLikeToMessage));\n        let runManagers;\n        if (startedRunManagers !== undefined &&\n            startedRunManagers.length === baseMessages.length) {\n            runManagers = startedRunManagers;\n        }\n        else {\n            const inheritableMetadata = {\n                ...handledOptions.metadata,\n                ...this.getLsParams(parsedOptions),\n            };\n            // create callback manager and start run\n            const callbackManager_ = await manager_js_1.CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });\n            const extra = {\n                options: parsedOptions,\n                invocation_params: this?.invocationParams(parsedOptions),\n                batch_size: 1,\n            };\n            runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), baseMessages.map(_formatForTracing), handledOptions.runId, undefined, extra, undefined, undefined, handledOptions.runName);\n        }\n        const generations = [];\n        const llmOutputs = [];\n        // Even if stream is not explicitly called, check if model is implicitly\n        // called from streamEvents() or streamLog() to get all streamed events.\n        // Bail out if _streamResponseChunks not overridden\n        const hasStreamingHandler = !!runManagers?.[0].handlers.find(base_js_3.callbackHandlerPrefersStreaming);\n        if (hasStreamingHandler &&\n            !this.disableStreaming &&\n            baseMessages.length === 1 &&\n            this._streamResponseChunks !==\n                BaseChatModel.prototype._streamResponseChunks) {\n            try {\n                const stream = await this._streamResponseChunks(baseMessages[0], parsedOptions, runManagers?.[0]);\n                let aggregated;\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                let llmOutput;\n                for await (const chunk of stream) {\n                    if (chunk.message.id == null) {\n                        const runId = runManagers?.at(0)?.runId;\n                        if (runId != null)\n                            chunk.message._updateId(`run-${runId}`);\n                    }\n                    if (aggregated === undefined) {\n                        aggregated = chunk;\n                    }\n                    else {\n                        aggregated = (0, stream_js_1.concat)(aggregated, chunk);\n                    }\n                    if ((0, index_js_1.isAIMessageChunk)(chunk.message) &&\n                        chunk.message.usage_metadata !== undefined) {\n                        llmOutput = {\n                            tokenUsage: {\n                                promptTokens: chunk.message.usage_metadata.input_tokens,\n                                completionTokens: chunk.message.usage_metadata.output_tokens,\n                                totalTokens: chunk.message.usage_metadata.total_tokens,\n                            },\n                        };\n                    }\n                }\n                if (aggregated === undefined) {\n                    throw new Error(\"Received empty response from chat model call.\");\n                }\n                generations.push([aggregated]);\n                await runManagers?.[0].handleLLMEnd({\n                    generations,\n                    llmOutput,\n                });\n            }\n            catch (e) {\n                await runManagers?.[0].handleLLMError(e);\n                throw e;\n            }\n        }\n        else {\n            // generate results\n            const results = await Promise.allSettled(baseMessages.map((messageList, i) => this._generate(messageList, { ...parsedOptions, promptIndex: i }, runManagers?.[i])));\n            // handle results\n            await Promise.all(results.map(async (pResult, i) => {\n                if (pResult.status === \"fulfilled\") {\n                    const result = pResult.value;\n                    for (const generation of result.generations) {\n                        if (generation.message.id == null) {\n                            const runId = runManagers?.at(0)?.runId;\n                            if (runId != null)\n                                generation.message._updateId(`run-${runId}`);\n                        }\n                        generation.message.response_metadata = {\n                            ...generation.generationInfo,\n                            ...generation.message.response_metadata,\n                        };\n                    }\n                    if (result.generations.length === 1) {\n                        result.generations[0].message.response_metadata = {\n                            ...result.llmOutput,\n                            ...result.generations[0].message.response_metadata,\n                        };\n                    }\n                    generations[i] = result.generations;\n                    llmOutputs[i] = result.llmOutput;\n                    return runManagers?.[i]?.handleLLMEnd({\n                        generations: [result.generations],\n                        llmOutput: result.llmOutput,\n                    });\n                }\n                else {\n                    // status === \"rejected\"\n                    await runManagers?.[i]?.handleLLMError(pResult.reason);\n                    return Promise.reject(pResult.reason);\n                }\n            }));\n        }\n        // create combined output\n        const output = {\n            generations,\n            llmOutput: llmOutputs.length\n                ? this._combineLLMOutput?.(...llmOutputs)\n                : undefined,\n        };\n        Object.defineProperty(output, outputs_js_1.RUN_KEY, {\n            value: runManagers\n                ? { runIds: runManagers?.map((manager) => manager.runId) }\n                : undefined,\n            configurable: true,\n        });\n        return output;\n    }\n    async _generateCached({ messages, cache, llmStringKey, parsedOptions, handledOptions, }) {\n        const baseMessages = messages.map((messageList) => messageList.map(index_js_1.coerceMessageLikeToMessage));\n        const inheritableMetadata = {\n            ...handledOptions.metadata,\n            ...this.getLsParams(parsedOptions),\n        };\n        // create callback manager and start run\n        const callbackManager_ = await manager_js_1.CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });\n        const extra = {\n            options: parsedOptions,\n            invocation_params: this?.invocationParams(parsedOptions),\n            batch_size: 1,\n        };\n        const runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), baseMessages.map(_formatForTracing), handledOptions.runId, undefined, extra, undefined, undefined, handledOptions.runName);\n        // generate results\n        const missingPromptIndices = [];\n        const results = await Promise.allSettled(baseMessages.map(async (baseMessage, index) => {\n            // Join all content into one string for the prompt index\n            const prompt = BaseChatModel._convertInputToPromptValue(baseMessage).toString();\n            const result = await cache.lookup(prompt, llmStringKey);\n            if (result == null) {\n                missingPromptIndices.push(index);\n            }\n            return result;\n        }));\n        // Map run managers to the results before filtering out null results\n        // Null results are just absent from the cache.\n        const cachedResults = results\n            .map((result, index) => ({ result, runManager: runManagers?.[index] }))\n            .filter(({ result }) => (result.status === \"fulfilled\" && result.value != null) ||\n            result.status === \"rejected\");\n        // Handle results and call run managers\n        const generations = [];\n        await Promise.all(cachedResults.map(async ({ result: promiseResult, runManager }, i) => {\n            if (promiseResult.status === \"fulfilled\") {\n                const result = promiseResult.value;\n                generations[i] = result.map((result) => {\n                    if (\"message\" in result &&\n                        (0, index_js_1.isBaseMessage)(result.message) &&\n                        (0, index_js_1.isAIMessage)(result.message)) {\n                        // eslint-disable-next-line no-param-reassign\n                        result.message.usage_metadata = {\n                            input_tokens: 0,\n                            output_tokens: 0,\n                            total_tokens: 0,\n                        };\n                    }\n                    // eslint-disable-next-line no-param-reassign\n                    result.generationInfo = {\n                        ...result.generationInfo,\n                        tokenUsage: {},\n                    };\n                    return result;\n                });\n                if (result.length) {\n                    await runManager?.handleLLMNewToken(result[0].text);\n                }\n                return runManager?.handleLLMEnd({\n                    generations: [result],\n                }, undefined, undefined, undefined, {\n                    cached: true,\n                });\n            }\n            else {\n                // status === \"rejected\"\n                await runManager?.handleLLMError(promiseResult.reason, undefined, undefined, undefined, {\n                    cached: true,\n                });\n                return Promise.reject(promiseResult.reason);\n            }\n        }));\n        const output = {\n            generations,\n            missingPromptIndices,\n            startedRunManagers: runManagers,\n        };\n        // This defines RUN_KEY as a non-enumerable property on the output object\n        // so that it is not serialized when the output is stringified, and so that\n        // it isnt included when listing the keys of the output object.\n        Object.defineProperty(output, outputs_js_1.RUN_KEY, {\n            value: runManagers\n                ? { runIds: runManagers?.map((manager) => manager.runId) }\n                : undefined,\n            configurable: true,\n        });\n        return output;\n    }\n    /**\n     * Generates chat based on the input messages.\n     * @param messages An array of arrays of BaseMessage instances.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to an LLMResult.\n     */\n    async generate(messages, options, callbacks) {\n        // parse call options\n        let parsedOptions;\n        if (Array.isArray(options)) {\n            parsedOptions = { stop: options };\n        }\n        else {\n            parsedOptions = options;\n        }\n        const baseMessages = messages.map((messageList) => messageList.map(index_js_1.coerceMessageLikeToMessage));\n        const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);\n        runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;\n        if (!this.cache) {\n            return this._generateUncached(baseMessages, callOptions, runnableConfig);\n        }\n        const { cache } = this;\n        const llmStringKey = this._getSerializedCacheKeyParametersForCall(callOptions);\n        const { generations, missingPromptIndices, startedRunManagers } = await this._generateCached({\n            messages: baseMessages,\n            cache,\n            llmStringKey,\n            parsedOptions: callOptions,\n            handledOptions: runnableConfig,\n        });\n        let llmOutput = {};\n        if (missingPromptIndices.length > 0) {\n            const results = await this._generateUncached(missingPromptIndices.map((i) => baseMessages[i]), callOptions, runnableConfig, startedRunManagers !== undefined\n                ? missingPromptIndices.map((i) => startedRunManagers?.[i])\n                : undefined);\n            await Promise.all(results.generations.map(async (generation, index) => {\n                const promptIndex = missingPromptIndices[index];\n                generations[promptIndex] = generation;\n                // Join all content into one string for the prompt index\n                const prompt = BaseChatModel._convertInputToPromptValue(baseMessages[promptIndex]).toString();\n                return cache.update(prompt, llmStringKey, generation);\n            }));\n            llmOutput = results.llmOutput ?? {};\n        }\n        return { generations, llmOutput };\n    }\n    /**\n     * Get the parameters used to invoke the model\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    invocationParams(_options) {\n        return {};\n    }\n    _modelType() {\n        return \"base_chat_model\";\n    }\n    /**\n     * @deprecated\n     * Return a json-like object representing this LLM.\n     */\n    serialize() {\n        return {\n            ...this.invocationParams(),\n            _type: this._llmType(),\n            _model: this._modelType(),\n        };\n    }\n    /**\n     * Generates a prompt based on the input prompt values.\n     * @param promptValues An array of BasePromptValue instances.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to an LLMResult.\n     */\n    async generatePrompt(promptValues, options, callbacks) {\n        const promptMessages = promptValues.map((promptValue) => promptValue.toChatMessages());\n        return this.generate(promptMessages, options, callbacks);\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * Makes a single call to the chat model.\n     * @param messages An array of BaseMessage instances.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to a BaseMessage.\n     */\n    async call(messages, options, callbacks) {\n        const result = await this.generate([messages.map(index_js_1.coerceMessageLikeToMessage)], options, callbacks);\n        const generations = result.generations;\n        return generations[0][0].message;\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * Makes a single call to the chat model with a prompt value.\n     * @param promptValue The value of the prompt.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to a BaseMessage.\n     */\n    async callPrompt(promptValue, options, callbacks) {\n        const promptMessages = promptValue.toChatMessages();\n        return this.call(promptMessages, options, callbacks);\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * Predicts the next message based on the input messages.\n     * @param messages An array of BaseMessage instances.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to a BaseMessage.\n     */\n    async predictMessages(messages, options, callbacks) {\n        return this.call(messages, options, callbacks);\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * Predicts the next message based on a text input.\n     * @param text The text input.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to a string.\n     */\n    async predict(text, options, callbacks) {\n        const message = new index_js_1.HumanMessage(text);\n        const result = await this.call([message], options, callbacks);\n        if (typeof result.content !== \"string\") {\n            throw new Error(\"Cannot use predict when output is not a string.\");\n        }\n        return result.content;\n    }\n    withStructuredOutput(outputSchema, config) {\n        if (typeof this.bindTools !== \"function\") {\n            throw new Error(`Chat model must implement \".bindTools()\" to use withStructuredOutput.`);\n        }\n        if (config?.strict) {\n            throw new Error(`\"strict\" mode is not supported for this model by default.`);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const schema = outputSchema;\n        const name = config?.name;\n        const description = (0, zod_js_1.getSchemaDescription)(schema) ?? \"A function available to call.\";\n        const method = config?.method;\n        const includeRaw = config?.includeRaw;\n        if (method === \"jsonMode\") {\n            throw new Error(`Base withStructuredOutput implementation only supports \"functionCalling\" as a method.`);\n        }\n        let functionName = name ?? \"extract\";\n        let tools;\n        if ((0, zod_js_1.isInteropZodSchema)(schema)) {\n            tools = [\n                {\n                    type: \"function\",\n                    function: {\n                        name: functionName,\n                        description,\n                        parameters: (0, json_schema_js_1.toJsonSchema)(schema),\n                    },\n                },\n            ];\n        }\n        else {\n            if (\"name\" in schema) {\n                functionName = schema.name;\n            }\n            tools = [\n                {\n                    type: \"function\",\n                    function: {\n                        name: functionName,\n                        description,\n                        parameters: schema,\n                    },\n                },\n            ];\n        }\n        const llm = this.bindTools(tools);\n        const outputParser = base_js_2.RunnableLambda.from((input) => {\n            if (!input.tool_calls || input.tool_calls.length === 0) {\n                throw new Error(\"No tool calls found in the response.\");\n            }\n            const toolCall = input.tool_calls.find((tc) => tc.name === functionName);\n            if (!toolCall) {\n                throw new Error(`No tool call found with name ${functionName}.`);\n            }\n            return toolCall.args;\n        });\n        if (!includeRaw) {\n            return llm.pipe(outputParser).withConfig({\n                runName: \"StructuredOutput\",\n            });\n        }\n        const parserAssign = passthrough_js_1.RunnablePassthrough.assign({\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            parsed: (input, config) => outputParser.invoke(input.raw, config),\n        });\n        const parserNone = passthrough_js_1.RunnablePassthrough.assign({\n            parsed: () => null,\n        });\n        const parsedWithFallback = parserAssign.withFallbacks({\n            fallbacks: [parserNone],\n        });\n        return base_js_2.RunnableSequence.from([\n            {\n                raw: llm,\n            },\n            parsedWithFallback,\n        ]).withConfig({\n            runName: \"StructuredOutputRunnable\",\n        });\n    }\n}\nexports.BaseChatModel = BaseChatModel;\n/**\n * An abstract class that extends BaseChatModel and provides a simple\n * implementation of _generate.\n */\nclass SimpleChatModel extends BaseChatModel {\n    async _generate(messages, options, runManager) {\n        const text = await this._call(messages, options, runManager);\n        const message = new index_js_1.AIMessage(text);\n        if (typeof message.content !== \"string\") {\n            throw new Error(\"Cannot generate with a simple chat model when output is not a string.\");\n        }\n        return {\n            generations: [\n                {\n                    text: message.content,\n                    message,\n                },\n            ],\n        };\n    }\n}\nexports.SimpleChatModel = SimpleChatModel;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbGFuZ3VhZ2VfbW9kZWxzL2NoYXRfbW9kZWxzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyxxQkFBcUI7QUFDL0MsMkNBQTJDO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLDJGQUF1QjtBQUNsRCxxQkFBcUIsbUJBQU8sQ0FBQyw2RUFBZ0I7QUFDN0Msa0JBQWtCLG1CQUFPLENBQUMsc0ZBQVk7QUFDdEMscUJBQXFCLG1CQUFPLENBQUMsaUdBQTBCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLDJGQUF1QjtBQUNqRCxvQkFBb0IsbUJBQU8sQ0FBQyx1RkFBcUI7QUFDakQseUJBQXlCLG1CQUFPLENBQUMseUdBQThCO0FBQy9ELGlCQUFpQixtQkFBTyxDQUFDLDZGQUF3QjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQywyRkFBdUI7QUFDakQseUJBQXlCLG1CQUFPLENBQUMsaUdBQTBCO0FBQzNEO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhCQUE4QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa01BQWtNLHVCQUF1QjtBQUN6TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELE1BQU07QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrTUFBa00sdUJBQXVCO0FBQ3pOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxNQUFNO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdIQUF3SCxrQ0FBa0M7QUFDMUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxNQUFNO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0Q7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOExBQThMLHVCQUF1QjtBQUNyTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMENBQTBDO0FBQ2pGLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxtQ0FBbUM7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQSxnQkFBZ0Isd0RBQXdEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGFBQWE7QUFDN0U7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2xhbmd1YWdlX21vZGVscy9jaGF0X21vZGVscy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNpbXBsZUNoYXRNb2RlbCA9IGV4cG9ydHMuQmFzZUNoYXRNb2RlbCA9IHZvaWQgMDtcbmV4cG9ydHMuY3JlYXRlQ2hhdE1lc3NhZ2VDaHVua0VuY29kZXJTdHJlYW0gPSBjcmVhdGVDaGF0TWVzc2FnZUNodW5rRW5jb2RlclN0cmVhbTtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vbWVzc2FnZXMvaW5kZXguY2pzXCIpO1xuY29uc3Qgb3V0cHV0c19qc18xID0gcmVxdWlyZShcIi4uL291dHB1dHMuY2pzXCIpO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG5jb25zdCBtYW5hZ2VyX2pzXzEgPSByZXF1aXJlKFwiLi4vY2FsbGJhY2tzL21hbmFnZXIuY2pzXCIpO1xuY29uc3QgYmFzZV9qc18yID0gcmVxdWlyZShcIi4uL3J1bm5hYmxlcy9iYXNlLmNqc1wiKTtcbmNvbnN0IHN0cmVhbV9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL3N0cmVhbS5janNcIik7XG5jb25zdCBwYXNzdGhyb3VnaF9qc18xID0gcmVxdWlyZShcIi4uL3J1bm5hYmxlcy9wYXNzdGhyb3VnaC5janNcIik7XG5jb25zdCB6b2RfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy90eXBlcy96b2QuY2pzXCIpO1xuY29uc3QgYmFzZV9qc18zID0gcmVxdWlyZShcIi4uL2NhbGxiYWNrcy9iYXNlLmNqc1wiKTtcbmNvbnN0IGpzb25fc2NoZW1hX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvanNvbl9zY2hlbWEuY2pzXCIpO1xuLyoqXG4gKiBDcmVhdGVzIGEgdHJhbnNmb3JtIHN0cmVhbSBmb3IgZW5jb2RpbmcgY2hhdCBtZXNzYWdlIGNodW5rcy5cbiAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgQnl0ZXNPdXRwdXRQYXJzZXJ9IGluc3RlYWRcbiAqIEByZXR1cm5zIEEgVHJhbnNmb3JtU3RyZWFtIGluc3RhbmNlIHRoYXQgZW5jb2RlcyBjaGF0IG1lc3NhZ2UgY2h1bmtzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDaGF0TWVzc2FnZUNodW5rRW5jb2RlclN0cmVhbSgpIHtcbiAgICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dEVuY29kZXIuZW5jb2RlKHR5cGVvZiBjaHVuay5jb250ZW50ID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgPyBjaHVuay5jb250ZW50XG4gICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShjaHVuay5jb250ZW50KSkpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuZnVuY3Rpb24gX2Zvcm1hdEZvclRyYWNpbmcobWVzc2FnZXMpIHtcbiAgICBjb25zdCBtZXNzYWdlc1RvVHJhY2UgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2VUb1RyYWNlID0gbWVzc2FnZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZS5jb250ZW50KSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgbWVzc2FnZS5jb250ZW50Lmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBibG9jayA9IG1lc3NhZ2UuY29udGVudFtpZHhdO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgaW5kZXhfanNfMS5pc1VSTENvbnRlbnRCbG9jaykoYmxvY2spIHx8ICgwLCBpbmRleF9qc18xLmlzQmFzZTY0Q29udGVudEJsb2NrKShibG9jaykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VUb1RyYWNlID09PSBtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbHNvIHNoYWxsb3ctY29weSBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVRvVHJhY2UgPSBuZXcgbWVzc2FnZS5jb25zdHJ1Y3Rvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ubWVzc2FnZVRvVHJhY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5tZXNzYWdlLmNvbnRlbnQuc2xpY2UoMCwgaWR4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzEuY29udmVydFRvT3BlbkFJSW1hZ2VCbG9jaykoYmxvY2spLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5tZXNzYWdlLmNvbnRlbnQuc2xpY2UoaWR4ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2VzVG9UcmFjZS5wdXNoKG1lc3NhZ2VUb1RyYWNlKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2VzVG9UcmFjZTtcbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgY2hhdCBtb2RlbHMuIEl0IGV4dGVuZHMgdGhlIEJhc2VMYW5ndWFnZU1vZGVsIGNsYXNzIGFuZFxuICogcHJvdmlkZXMgbWV0aG9kcyBmb3IgZ2VuZXJhdGluZyBjaGF0IGJhc2VkIG9uIGlucHV0IG1lc3NhZ2VzLlxuICovXG5jbGFzcyBCYXNlQ2hhdE1vZGVsIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VMYW5ndWFnZU1vZGVsIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgLy8gT25seSBldmVyIGluc3RhbnRpYXRlZCBpbiBtYWluIExhbmdDaGFpblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpblwiLCBcImNoYXRfbW9kZWxzXCIsIHRoaXMuX2xsbVR5cGUoKV1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRpc2FibGVTdHJlYW1pbmdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfc2VwYXJhdGVSdW5uYWJsZUNvbmZpZ0Zyb21DYWxsT3B0aW9uc0NvbXBhdChvcHRpb25zKSB7XG4gICAgICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0LCBrZWVwIGBzaWduYWxgIGluIGJvdGggcnVubmFibGVDb25maWcgYW5kIGNhbGxPcHRpb25zXG4gICAgICAgIGNvbnN0IFtydW5uYWJsZUNvbmZpZywgY2FsbE9wdGlvbnNdID0gc3VwZXIuX3NlcGFyYXRlUnVubmFibGVDb25maWdGcm9tQ2FsbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGNhbGxPcHRpb25zLnNpZ25hbCA9IHJ1bm5hYmxlQ29uZmlnLnNpZ25hbDtcbiAgICAgICAgcmV0dXJuIFtydW5uYWJsZUNvbmZpZywgY2FsbE9wdGlvbnNdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBjaGF0IG1vZGVsIHdpdGggYSBzaW5nbGUgaW5wdXQuXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCBmb3IgdGhlIGxhbmd1YWdlIG1vZGVsLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBjYWxsIG9wdGlvbnMuXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBCYXNlTWVzc2FnZUNodW5rLlxuICAgICAqL1xuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBwcm9tcHRWYWx1ZSA9IEJhc2VDaGF0TW9kZWwuX2NvbnZlcnRJbnB1dFRvUHJvbXB0VmFsdWUoaW5wdXQpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmdlbmVyYXRlUHJvbXB0KFtwcm9tcHRWYWx1ZV0sIG9wdGlvbnMsIG9wdGlvbnM/LmNhbGxiYWNrcyk7XG4gICAgICAgIGNvbnN0IGNoYXRHZW5lcmF0aW9uID0gcmVzdWx0LmdlbmVyYXRpb25zWzBdWzBdO1xuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgY2FzdCBhZnRlciBmaWd1cmluZyBvdXQgaW5oZXJpdGFuY2VcbiAgICAgICAgcmV0dXJuIGNoYXRHZW5lcmF0aW9uLm1lc3NhZ2U7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLXlpZWxkXG4gICAgYXN5bmMgKl9zdHJlYW1SZXNwb25zZUNodW5rcyhfbWVzc2FnZXMsIF9vcHRpb25zLCBfcnVuTWFuYWdlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIFN1YmNsYXNzIGNoZWNrIHJlcXVpcmVkIHRvIGF2b2lkIGRvdWJsZSBjYWxsYmFja3Mgd2l0aCBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgICAgIGlmICh0aGlzLl9zdHJlYW1SZXNwb25zZUNodW5rcyA9PT1cbiAgICAgICAgICAgIEJhc2VDaGF0TW9kZWwucHJvdG90eXBlLl9zdHJlYW1SZXNwb25zZUNodW5rcyB8fFxuICAgICAgICAgICAgdGhpcy5kaXNhYmxlU3RyZWFtaW5nKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmludm9rZShpbnB1dCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwcm9tcHQgPSBCYXNlQ2hhdE1vZGVsLl9jb252ZXJ0SW5wdXRUb1Byb21wdFZhbHVlKGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gcHJvbXB0LnRvQ2hhdE1lc3NhZ2VzKCk7XG4gICAgICAgICAgICBjb25zdCBbcnVubmFibGVDb25maWcsIGNhbGxPcHRpb25zXSA9IHRoaXMuX3NlcGFyYXRlUnVubmFibGVDb25maWdGcm9tQ2FsbE9wdGlvbnNDb21wYXQob3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBpbmhlcml0YWJsZU1ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgIC4uLnJ1bm5hYmxlQ29uZmlnLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZ2V0THNQYXJhbXMoY2FsbE9wdGlvbnMpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCBtYW5hZ2VyX2pzXzEuQ2FsbGJhY2tNYW5hZ2VyLmNvbmZpZ3VyZShydW5uYWJsZUNvbmZpZy5jYWxsYmFja3MsIHRoaXMuY2FsbGJhY2tzLCBydW5uYWJsZUNvbmZpZy50YWdzLCB0aGlzLnRhZ3MsIGluaGVyaXRhYmxlTWV0YWRhdGEsIHRoaXMubWV0YWRhdGEsIHsgdmVyYm9zZTogdGhpcy52ZXJib3NlIH0pO1xuICAgICAgICAgICAgY29uc3QgZXh0cmEgPSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uczogY2FsbE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgaW52b2NhdGlvbl9wYXJhbXM6IHRoaXM/Lmludm9jYXRpb25QYXJhbXMoY2FsbE9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIGJhdGNoX3NpemU6IDEsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcnVuTWFuYWdlcnMgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGF0TW9kZWxTdGFydCh0aGlzLnRvSlNPTigpLCBbX2Zvcm1hdEZvclRyYWNpbmcobWVzc2FnZXMpXSwgcnVubmFibGVDb25maWcucnVuSWQsIHVuZGVmaW5lZCwgZXh0cmEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBydW5uYWJsZUNvbmZpZy5ydW5OYW1lKTtcbiAgICAgICAgICAgIGxldCBnZW5lcmF0aW9uQ2h1bms7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgbGV0IGxsbU91dHB1dDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiB0aGlzLl9zdHJlYW1SZXNwb25zZUNodW5rcyhtZXNzYWdlcywgY2FsbE9wdGlvbnMsIHJ1bk1hbmFnZXJzPy5bMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVuay5tZXNzYWdlLmlkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ1bklkID0gcnVuTWFuYWdlcnM/LmF0KDApPy5ydW5JZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydW5JZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLm1lc3NhZ2UuX3VwZGF0ZUlkKGBydW4tJHtydW5JZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaHVuay5tZXNzYWdlLnJlc3BvbnNlX21ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY2h1bmsuZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jaHVuay5tZXNzYWdlLnJlc3BvbnNlX21ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBjaHVuay5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdlbmVyYXRpb25DaHVuaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbkNodW5rID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uQ2h1bmsgPSBnZW5lcmF0aW9uQ2h1bmsuY29uY2F0KGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzEuaXNBSU1lc3NhZ2VDaHVuaykoY2h1bmsubWVzc2FnZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLm1lc3NhZ2UudXNhZ2VfbWV0YWRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGxtT3V0cHV0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuVXNhZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbXB0VG9rZW5zOiBjaHVuay5tZXNzYWdlLnVzYWdlX21ldGFkYXRhLmlucHV0X3Rva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGlvblRva2VuczogY2h1bmsubWVzc2FnZS51c2FnZV9tZXRhZGF0YS5vdXRwdXRfdG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFRva2VuczogY2h1bmsubWVzc2FnZS51c2FnZV9tZXRhZGF0YS50b3RhbF90b2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoKHJ1bk1hbmFnZXJzID8/IFtdKS5tYXAoKHJ1bk1hbmFnZXIpID0+IHJ1bk1hbmFnZXI/LmhhbmRsZUxMTUVycm9yKGVycikpKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCgocnVuTWFuYWdlcnMgPz8gW10pLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlTExNRW5kKHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgY2FzdCBhZnRlciBmaWd1cmluZyBvdXQgaW5oZXJpdGFuY2VcbiAgICAgICAgICAgICAgICBnZW5lcmF0aW9uczogW1tnZW5lcmF0aW9uQ2h1bmtdXSxcbiAgICAgICAgICAgICAgICBsbG1PdXRwdXQsXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldExzUGFyYW1zKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXJOYW1lID0gdGhpcy5nZXROYW1lKCkuc3RhcnRzV2l0aChcIkNoYXRcIilcbiAgICAgICAgICAgID8gdGhpcy5nZXROYW1lKCkucmVwbGFjZShcIkNoYXRcIiwgXCJcIilcbiAgICAgICAgICAgIDogdGhpcy5nZXROYW1lKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsc19tb2RlbF90eXBlOiBcImNoYXRcIixcbiAgICAgICAgICAgIGxzX3N0b3A6IG9wdGlvbnMuc3RvcCxcbiAgICAgICAgICAgIGxzX3Byb3ZpZGVyOiBwcm92aWRlck5hbWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKiBAaWdub3JlICovXG4gICAgYXN5bmMgX2dlbmVyYXRlVW5jYWNoZWQobWVzc2FnZXMsIHBhcnNlZE9wdGlvbnMsIGhhbmRsZWRPcHRpb25zLCBzdGFydGVkUnVuTWFuYWdlcnMpIHtcbiAgICAgICAgY29uc3QgYmFzZU1lc3NhZ2VzID0gbWVzc2FnZXMubWFwKChtZXNzYWdlTGlzdCkgPT4gbWVzc2FnZUxpc3QubWFwKGluZGV4X2pzXzEuY29lcmNlTWVzc2FnZUxpa2VUb01lc3NhZ2UpKTtcbiAgICAgICAgbGV0IHJ1bk1hbmFnZXJzO1xuICAgICAgICBpZiAoc3RhcnRlZFJ1bk1hbmFnZXJzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHN0YXJ0ZWRSdW5NYW5hZ2Vycy5sZW5ndGggPT09IGJhc2VNZXNzYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJ1bk1hbmFnZXJzID0gc3RhcnRlZFJ1bk1hbmFnZXJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaW5oZXJpdGFibGVNZXRhZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAuLi5oYW5kbGVkT3B0aW9ucy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmdldExzUGFyYW1zKHBhcnNlZE9wdGlvbnMpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBjYWxsYmFjayBtYW5hZ2VyIGFuZCBzdGFydCBydW5cbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCBtYW5hZ2VyX2pzXzEuQ2FsbGJhY2tNYW5hZ2VyLmNvbmZpZ3VyZShoYW5kbGVkT3B0aW9ucy5jYWxsYmFja3MsIHRoaXMuY2FsbGJhY2tzLCBoYW5kbGVkT3B0aW9ucy50YWdzLCB0aGlzLnRhZ3MsIGluaGVyaXRhYmxlTWV0YWRhdGEsIHRoaXMubWV0YWRhdGEsIHsgdmVyYm9zZTogdGhpcy52ZXJib3NlIH0pO1xuICAgICAgICAgICAgY29uc3QgZXh0cmEgPSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uczogcGFyc2VkT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBpbnZvY2F0aW9uX3BhcmFtczogdGhpcz8uaW52b2NhdGlvblBhcmFtcyhwYXJzZWRPcHRpb25zKSxcbiAgICAgICAgICAgICAgICBiYXRjaF9zaXplOiAxLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJ1bk1hbmFnZXJzID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhdE1vZGVsU3RhcnQodGhpcy50b0pTT04oKSwgYmFzZU1lc3NhZ2VzLm1hcChfZm9ybWF0Rm9yVHJhY2luZyksIGhhbmRsZWRPcHRpb25zLnJ1bklkLCB1bmRlZmluZWQsIGV4dHJhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGFuZGxlZE9wdGlvbnMucnVuTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ2VuZXJhdGlvbnMgPSBbXTtcbiAgICAgICAgY29uc3QgbGxtT3V0cHV0cyA9IFtdO1xuICAgICAgICAvLyBFdmVuIGlmIHN0cmVhbSBpcyBub3QgZXhwbGljaXRseSBjYWxsZWQsIGNoZWNrIGlmIG1vZGVsIGlzIGltcGxpY2l0bHlcbiAgICAgICAgLy8gY2FsbGVkIGZyb20gc3RyZWFtRXZlbnRzKCkgb3Igc3RyZWFtTG9nKCkgdG8gZ2V0IGFsbCBzdHJlYW1lZCBldmVudHMuXG4gICAgICAgIC8vIEJhaWwgb3V0IGlmIF9zdHJlYW1SZXNwb25zZUNodW5rcyBub3Qgb3ZlcnJpZGRlblxuICAgICAgICBjb25zdCBoYXNTdHJlYW1pbmdIYW5kbGVyID0gISFydW5NYW5hZ2Vycz8uWzBdLmhhbmRsZXJzLmZpbmQoYmFzZV9qc18zLmNhbGxiYWNrSGFuZGxlclByZWZlcnNTdHJlYW1pbmcpO1xuICAgICAgICBpZiAoaGFzU3RyZWFtaW5nSGFuZGxlciAmJlxuICAgICAgICAgICAgIXRoaXMuZGlzYWJsZVN0cmVhbWluZyAmJlxuICAgICAgICAgICAgYmFzZU1lc3NhZ2VzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgdGhpcy5fc3RyZWFtUmVzcG9uc2VDaHVua3MgIT09XG4gICAgICAgICAgICAgICAgQmFzZUNoYXRNb2RlbC5wcm90b3R5cGUuX3N0cmVhbVJlc3BvbnNlQ2h1bmtzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IHRoaXMuX3N0cmVhbVJlc3BvbnNlQ2h1bmtzKGJhc2VNZXNzYWdlc1swXSwgcGFyc2VkT3B0aW9ucywgcnVuTWFuYWdlcnM/LlswXSk7XG4gICAgICAgICAgICAgICAgbGV0IGFnZ3JlZ2F0ZWQ7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBsZXQgbGxtT3V0cHV0O1xuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVuay5tZXNzYWdlLmlkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ1bklkID0gcnVuTWFuYWdlcnM/LmF0KDApPy5ydW5JZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydW5JZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLm1lc3NhZ2UuX3VwZGF0ZUlkKGBydW4tJHtydW5JZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWdncmVnYXRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2dyZWdhdGVkID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2dyZWdhdGVkID0gKDAsIHN0cmVhbV9qc18xLmNvbmNhdCkoYWdncmVnYXRlZCwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgaW5kZXhfanNfMS5pc0FJTWVzc2FnZUNodW5rKShjaHVuay5tZXNzYWdlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsubWVzc2FnZS51c2FnZV9tZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsbG1PdXRwdXQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5Vc2FnZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9tcHRUb2tlbnM6IGNodW5rLm1lc3NhZ2UudXNhZ2VfbWV0YWRhdGEuaW5wdXRfdG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiBjaHVuay5tZXNzYWdlLnVzYWdlX21ldGFkYXRhLm91dHB1dF90b2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsVG9rZW5zOiBjaHVuay5tZXNzYWdlLnVzYWdlX21ldGFkYXRhLnRvdGFsX3Rva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWdncmVnYXRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlY2VpdmVkIGVtcHR5IHJlc3BvbnNlIGZyb20gY2hhdCBtb2RlbCBjYWxsLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGlvbnMucHVzaChbYWdncmVnYXRlZF0pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXJzPy5bMF0uaGFuZGxlTExNRW5kKHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGxsbU91dHB1dCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcnM/LlswXS5oYW5kbGVMTE1FcnJvcihlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZ2VuZXJhdGUgcmVzdWx0c1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChiYXNlTWVzc2FnZXMubWFwKChtZXNzYWdlTGlzdCwgaSkgPT4gdGhpcy5fZ2VuZXJhdGUobWVzc2FnZUxpc3QsIHsgLi4ucGFyc2VkT3B0aW9ucywgcHJvbXB0SW5kZXg6IGkgfSwgcnVuTWFuYWdlcnM/LltpXSkpKTtcbiAgICAgICAgICAgIC8vIGhhbmRsZSByZXN1bHRzXG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChyZXN1bHRzLm1hcChhc3luYyAocFJlc3VsdCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwUmVzdWx0LnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwUmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGdlbmVyYXRpb24gb2YgcmVzdWx0LmdlbmVyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdGlvbi5tZXNzYWdlLmlkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBydW5JZCA9IHJ1bk1hbmFnZXJzPy5hdCgwKT8ucnVuSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bklkICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb24ubWVzc2FnZS5fdXBkYXRlSWQoYHJ1bi0ke3J1bklkfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbi5tZXNzYWdlLnJlc3BvbnNlX21ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmdlbmVyYXRpb24uZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZ2VuZXJhdGlvbi5tZXNzYWdlLnJlc3BvbnNlX21ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmdlbmVyYXRpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmdlbmVyYXRpb25zWzBdLm1lc3NhZ2UucmVzcG9uc2VfbWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucmVzdWx0LmxsbU91dHB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5yZXN1bHQuZ2VuZXJhdGlvbnNbMF0ubWVzc2FnZS5yZXNwb25zZV9tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbnNbaV0gPSByZXN1bHQuZ2VuZXJhdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGxsbU91dHB1dHNbaV0gPSByZXN1bHQubGxtT3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVuTWFuYWdlcnM/LltpXT8uaGFuZGxlTExNRW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zOiBbcmVzdWx0LmdlbmVyYXRpb25zXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxsbU91dHB1dDogcmVzdWx0LmxsbU91dHB1dCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdGF0dXMgPT09IFwicmVqZWN0ZWRcIlxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2Vycz8uW2ldPy5oYW5kbGVMTE1FcnJvcihwUmVzdWx0LnJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChwUmVzdWx0LnJlYXNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSBjb21iaW5lZCBvdXRwdXRcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgICAgICAgZ2VuZXJhdGlvbnMsXG4gICAgICAgICAgICBsbG1PdXRwdXQ6IGxsbU91dHB1dHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgPyB0aGlzLl9jb21iaW5lTExNT3V0cHV0Py4oLi4ubGxtT3V0cHV0cylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG91dHB1dCwgb3V0cHV0c19qc18xLlJVTl9LRVksIHtcbiAgICAgICAgICAgIHZhbHVlOiBydW5NYW5hZ2Vyc1xuICAgICAgICAgICAgICAgID8geyBydW5JZHM6IHJ1bk1hbmFnZXJzPy5tYXAoKG1hbmFnZXIpID0+IG1hbmFnZXIucnVuSWQpIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGFzeW5jIF9nZW5lcmF0ZUNhY2hlZCh7IG1lc3NhZ2VzLCBjYWNoZSwgbGxtU3RyaW5nS2V5LCBwYXJzZWRPcHRpb25zLCBoYW5kbGVkT3B0aW9ucywgfSkge1xuICAgICAgICBjb25zdCBiYXNlTWVzc2FnZXMgPSBtZXNzYWdlcy5tYXAoKG1lc3NhZ2VMaXN0KSA9PiBtZXNzYWdlTGlzdC5tYXAoaW5kZXhfanNfMS5jb2VyY2VNZXNzYWdlTGlrZVRvTWVzc2FnZSkpO1xuICAgICAgICBjb25zdCBpbmhlcml0YWJsZU1ldGFkYXRhID0ge1xuICAgICAgICAgICAgLi4uaGFuZGxlZE9wdGlvbnMubWV0YWRhdGEsXG4gICAgICAgICAgICAuLi50aGlzLmdldExzUGFyYW1zKHBhcnNlZE9wdGlvbnMpLFxuICAgICAgICB9O1xuICAgICAgICAvLyBjcmVhdGUgY2FsbGJhY2sgbWFuYWdlciBhbmQgc3RhcnQgcnVuXG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCBtYW5hZ2VyX2pzXzEuQ2FsbGJhY2tNYW5hZ2VyLmNvbmZpZ3VyZShoYW5kbGVkT3B0aW9ucy5jYWxsYmFja3MsIHRoaXMuY2FsbGJhY2tzLCBoYW5kbGVkT3B0aW9ucy50YWdzLCB0aGlzLnRhZ3MsIGluaGVyaXRhYmxlTWV0YWRhdGEsIHRoaXMubWV0YWRhdGEsIHsgdmVyYm9zZTogdGhpcy52ZXJib3NlIH0pO1xuICAgICAgICBjb25zdCBleHRyYSA9IHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHBhcnNlZE9wdGlvbnMsXG4gICAgICAgICAgICBpbnZvY2F0aW9uX3BhcmFtczogdGhpcz8uaW52b2NhdGlvblBhcmFtcyhwYXJzZWRPcHRpb25zKSxcbiAgICAgICAgICAgIGJhdGNoX3NpemU6IDEsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXJzID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhdE1vZGVsU3RhcnQodGhpcy50b0pTT04oKSwgYmFzZU1lc3NhZ2VzLm1hcChfZm9ybWF0Rm9yVHJhY2luZyksIGhhbmRsZWRPcHRpb25zLnJ1bklkLCB1bmRlZmluZWQsIGV4dHJhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGFuZGxlZE9wdGlvbnMucnVuTmFtZSk7XG4gICAgICAgIC8vIGdlbmVyYXRlIHJlc3VsdHNcbiAgICAgICAgY29uc3QgbWlzc2luZ1Byb21wdEluZGljZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChiYXNlTWVzc2FnZXMubWFwKGFzeW5jIChiYXNlTWVzc2FnZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIC8vIEpvaW4gYWxsIGNvbnRlbnQgaW50byBvbmUgc3RyaW5nIGZvciB0aGUgcHJvbXB0IGluZGV4XG4gICAgICAgICAgICBjb25zdCBwcm9tcHQgPSBCYXNlQ2hhdE1vZGVsLl9jb252ZXJ0SW5wdXRUb1Byb21wdFZhbHVlKGJhc2VNZXNzYWdlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FjaGUubG9va3VwKHByb21wdCwgbGxtU3RyaW5nS2V5KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1pc3NpbmdQcm9tcHRJbmRpY2VzLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBNYXAgcnVuIG1hbmFnZXJzIHRvIHRoZSByZXN1bHRzIGJlZm9yZSBmaWx0ZXJpbmcgb3V0IG51bGwgcmVzdWx0c1xuICAgICAgICAvLyBOdWxsIHJlc3VsdHMgYXJlIGp1c3QgYWJzZW50IGZyb20gdGhlIGNhY2hlLlxuICAgICAgICBjb25zdCBjYWNoZWRSZXN1bHRzID0gcmVzdWx0c1xuICAgICAgICAgICAgLm1hcCgocmVzdWx0LCBpbmRleCkgPT4gKHsgcmVzdWx0LCBydW5NYW5hZ2VyOiBydW5NYW5hZ2Vycz8uW2luZGV4XSB9KSlcbiAgICAgICAgICAgIC5maWx0ZXIoKHsgcmVzdWx0IH0pID0+IChyZXN1bHQuc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiICYmIHJlc3VsdC52YWx1ZSAhPSBudWxsKSB8fFxuICAgICAgICAgICAgcmVzdWx0LnN0YXR1cyA9PT0gXCJyZWplY3RlZFwiKTtcbiAgICAgICAgLy8gSGFuZGxlIHJlc3VsdHMgYW5kIGNhbGwgcnVuIG1hbmFnZXJzXG4gICAgICAgIGNvbnN0IGdlbmVyYXRpb25zID0gW107XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGNhY2hlZFJlc3VsdHMubWFwKGFzeW5jICh7IHJlc3VsdDogcHJvbWlzZVJlc3VsdCwgcnVuTWFuYWdlciB9LCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZVJlc3VsdC5zdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwcm9taXNlUmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zW2ldID0gcmVzdWx0Lm1hcCgocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcIm1lc3NhZ2VcIiBpbiByZXN1bHQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc18xLmlzQmFzZU1lc3NhZ2UpKHJlc3VsdC5tZXNzYWdlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzEuaXNBSU1lc3NhZ2UpKHJlc3VsdC5tZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubWVzc2FnZS51c2FnZV9tZXRhZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF90b2tlbnM6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0X3Rva2VuczogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbF90b2tlbnM6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuZ2VuZXJhdGlvbkluZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5yZXN1bHQuZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlblVzYWdlOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVMTE1OZXdUb2tlbihyZXN1bHRbMF0udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBydW5NYW5hZ2VyPy5oYW5kbGVMTE1FbmQoe1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uczogW3Jlc3VsdF0sXG4gICAgICAgICAgICAgICAgfSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzdGF0dXMgPT09IFwicmVqZWN0ZWRcIlxuICAgICAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUxMTUVycm9yKHByb21pc2VSZXN1bHQucmVhc29uLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocHJvbWlzZVJlc3VsdC5yZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgICAgICAgIGdlbmVyYXRpb25zLFxuICAgICAgICAgICAgbWlzc2luZ1Byb21wdEluZGljZXMsXG4gICAgICAgICAgICBzdGFydGVkUnVuTWFuYWdlcnM6IHJ1bk1hbmFnZXJzLFxuICAgICAgICB9O1xuICAgICAgICAvLyBUaGlzIGRlZmluZXMgUlVOX0tFWSBhcyBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IG9uIHRoZSBvdXRwdXQgb2JqZWN0XG4gICAgICAgIC8vIHNvIHRoYXQgaXQgaXMgbm90IHNlcmlhbGl6ZWQgd2hlbiB0aGUgb3V0cHV0IGlzIHN0cmluZ2lmaWVkLCBhbmQgc28gdGhhdFxuICAgICAgICAvLyBpdCBpc250IGluY2x1ZGVkIHdoZW4gbGlzdGluZyB0aGUga2V5cyBvZiB0aGUgb3V0cHV0IG9iamVjdC5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG91dHB1dCwgb3V0cHV0c19qc18xLlJVTl9LRVksIHtcbiAgICAgICAgICAgIHZhbHVlOiBydW5NYW5hZ2Vyc1xuICAgICAgICAgICAgICAgID8geyBydW5JZHM6IHJ1bk1hbmFnZXJzPy5tYXAoKG1hbmFnZXIpID0+IG1hbmFnZXIucnVuSWQpIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBjaGF0IGJhc2VkIG9uIHRoZSBpbnB1dCBtZXNzYWdlcy5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZXMgQW4gYXJyYXkgb2YgYXJyYXlzIG9mIEJhc2VNZXNzYWdlIGluc3RhbmNlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgY2FsbCBvcHRpb25zIG9yIGFuIGFycmF5IG9mIHN0b3Agc2VxdWVuY2VzLlxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgVGhlIGNhbGxiYWNrcyBmb3IgdGhlIGxhbmd1YWdlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIExMTVJlc3VsdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZShtZXNzYWdlcywgb3B0aW9ucywgY2FsbGJhY2tzKSB7XG4gICAgICAgIC8vIHBhcnNlIGNhbGwgb3B0aW9uc1xuICAgICAgICBsZXQgcGFyc2VkT3B0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHBhcnNlZE9wdGlvbnMgPSB7IHN0b3A6IG9wdGlvbnMgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlZE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhc2VNZXNzYWdlcyA9IG1lc3NhZ2VzLm1hcCgobWVzc2FnZUxpc3QpID0+IG1lc3NhZ2VMaXN0Lm1hcChpbmRleF9qc18xLmNvZXJjZU1lc3NhZ2VMaWtlVG9NZXNzYWdlKSk7XG4gICAgICAgIGNvbnN0IFtydW5uYWJsZUNvbmZpZywgY2FsbE9wdGlvbnNdID0gdGhpcy5fc2VwYXJhdGVSdW5uYWJsZUNvbmZpZ0Zyb21DYWxsT3B0aW9uc0NvbXBhdChwYXJzZWRPcHRpb25zKTtcbiAgICAgICAgcnVubmFibGVDb25maWcuY2FsbGJhY2tzID0gcnVubmFibGVDb25maWcuY2FsbGJhY2tzID8/IGNhbGxiYWNrcztcbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2VuZXJhdGVVbmNhY2hlZChiYXNlTWVzc2FnZXMsIGNhbGxPcHRpb25zLCBydW5uYWJsZUNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjYWNoZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbGxtU3RyaW5nS2V5ID0gdGhpcy5fZ2V0U2VyaWFsaXplZENhY2hlS2V5UGFyYW1ldGVyc0ZvckNhbGwoY2FsbE9wdGlvbnMpO1xuICAgICAgICBjb25zdCB7IGdlbmVyYXRpb25zLCBtaXNzaW5nUHJvbXB0SW5kaWNlcywgc3RhcnRlZFJ1bk1hbmFnZXJzIH0gPSBhd2FpdCB0aGlzLl9nZW5lcmF0ZUNhY2hlZCh7XG4gICAgICAgICAgICBtZXNzYWdlczogYmFzZU1lc3NhZ2VzLFxuICAgICAgICAgICAgY2FjaGUsXG4gICAgICAgICAgICBsbG1TdHJpbmdLZXksXG4gICAgICAgICAgICBwYXJzZWRPcHRpb25zOiBjYWxsT3B0aW9ucyxcbiAgICAgICAgICAgIGhhbmRsZWRPcHRpb25zOiBydW5uYWJsZUNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBsbG1PdXRwdXQgPSB7fTtcbiAgICAgICAgaWYgKG1pc3NpbmdQcm9tcHRJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLl9nZW5lcmF0ZVVuY2FjaGVkKG1pc3NpbmdQcm9tcHRJbmRpY2VzLm1hcCgoaSkgPT4gYmFzZU1lc3NhZ2VzW2ldKSwgY2FsbE9wdGlvbnMsIHJ1bm5hYmxlQ29uZmlnLCBzdGFydGVkUnVuTWFuYWdlcnMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbWlzc2luZ1Byb21wdEluZGljZXMubWFwKChpKSA9PiBzdGFydGVkUnVuTWFuYWdlcnM/LltpXSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChyZXN1bHRzLmdlbmVyYXRpb25zLm1hcChhc3luYyAoZ2VuZXJhdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9tcHRJbmRleCA9IG1pc3NpbmdQcm9tcHRJbmRpY2VzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBnZW5lcmF0aW9uc1twcm9tcHRJbmRleF0gPSBnZW5lcmF0aW9uO1xuICAgICAgICAgICAgICAgIC8vIEpvaW4gYWxsIGNvbnRlbnQgaW50byBvbmUgc3RyaW5nIGZvciB0aGUgcHJvbXB0IGluZGV4XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbXB0ID0gQmFzZUNoYXRNb2RlbC5fY29udmVydElucHV0VG9Qcm9tcHRWYWx1ZShiYXNlTWVzc2FnZXNbcHJvbXB0SW5kZXhdKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZS51cGRhdGUocHJvbXB0LCBsbG1TdHJpbmdLZXksIGdlbmVyYXRpb24pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgbGxtT3V0cHV0ID0gcmVzdWx0cy5sbG1PdXRwdXQgPz8ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZ2VuZXJhdGlvbnMsIGxsbU91dHB1dCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBhcmFtZXRlcnMgdXNlZCB0byBpbnZva2UgdGhlIG1vZGVsXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBpbnZvY2F0aW9uUGFyYW1zKF9vcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgX21vZGVsVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiYmFzZV9jaGF0X21vZGVsXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogUmV0dXJuIGEganNvbi1saWtlIG9iamVjdCByZXByZXNlbnRpbmcgdGhpcyBMTE0uXG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udGhpcy5pbnZvY2F0aW9uUGFyYW1zKCksXG4gICAgICAgICAgICBfdHlwZTogdGhpcy5fbGxtVHlwZSgpLFxuICAgICAgICAgICAgX21vZGVsOiB0aGlzLl9tb2RlbFR5cGUoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgcHJvbXB0IGJhc2VkIG9uIHRoZSBpbnB1dCBwcm9tcHQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSBwcm9tcHRWYWx1ZXMgQW4gYXJyYXkgb2YgQmFzZVByb21wdFZhbHVlIGluc3RhbmNlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgY2FsbCBvcHRpb25zIG9yIGFuIGFycmF5IG9mIHN0b3Agc2VxdWVuY2VzLlxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgVGhlIGNhbGxiYWNrcyBmb3IgdGhlIGxhbmd1YWdlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIExMTVJlc3VsdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZVByb21wdChwcm9tcHRWYWx1ZXMsIG9wdGlvbnMsIGNhbGxiYWNrcykge1xuICAgICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IHByb21wdFZhbHVlcy5tYXAoKHByb21wdFZhbHVlKSA9PiBwcm9tcHRWYWx1ZS50b0NoYXRNZXNzYWdlcygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGUocHJvbXB0TWVzc2FnZXMsIG9wdGlvbnMsIGNhbGxiYWNrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSAuaW52b2tlKCkgaW5zdGVhZC4gV2lsbCBiZSByZW1vdmVkIGluIDAuMi4wLlxuICAgICAqXG4gICAgICogTWFrZXMgYSBzaW5nbGUgY2FsbCB0byB0aGUgY2hhdCBtb2RlbC5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZXMgQW4gYXJyYXkgb2YgQmFzZU1lc3NhZ2UgaW5zdGFuY2VzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBjYWxsIG9wdGlvbnMgb3IgYW4gYXJyYXkgb2Ygc3RvcCBzZXF1ZW5jZXMuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyBUaGUgY2FsbGJhY2tzIGZvciB0aGUgbGFuZ3VhZ2UgbW9kZWwuXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBCYXNlTWVzc2FnZS5cbiAgICAgKi9cbiAgICBhc3luYyBjYWxsKG1lc3NhZ2VzLCBvcHRpb25zLCBjYWxsYmFja3MpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZW5lcmF0ZShbbWVzc2FnZXMubWFwKGluZGV4X2pzXzEuY29lcmNlTWVzc2FnZUxpa2VUb01lc3NhZ2UpXSwgb3B0aW9ucywgY2FsbGJhY2tzKTtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGlvbnMgPSByZXN1bHQuZ2VuZXJhdGlvbnM7XG4gICAgICAgIHJldHVybiBnZW5lcmF0aW9uc1swXVswXS5tZXNzYWdlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgLmludm9rZSgpIGluc3RlYWQuIFdpbGwgYmUgcmVtb3ZlZCBpbiAwLjIuMC5cbiAgICAgKlxuICAgICAqIE1ha2VzIGEgc2luZ2xlIGNhbGwgdG8gdGhlIGNoYXQgbW9kZWwgd2l0aCBhIHByb21wdCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gcHJvbXB0VmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBwcm9tcHQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGNhbGwgb3B0aW9ucyBvciBhbiBhcnJheSBvZiBzdG9wIHNlcXVlbmNlcy5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tzIFRoZSBjYWxsYmFja3MgZm9yIHRoZSBsYW5ndWFnZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIEJhc2VNZXNzYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIGNhbGxQcm9tcHQocHJvbXB0VmFsdWUsIG9wdGlvbnMsIGNhbGxiYWNrcykge1xuICAgICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IHByb21wdFZhbHVlLnRvQ2hhdE1lc3NhZ2VzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwocHJvbXB0TWVzc2FnZXMsIG9wdGlvbnMsIGNhbGxiYWNrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSAuaW52b2tlKCkgaW5zdGVhZC4gV2lsbCBiZSByZW1vdmVkIGluIDAuMi4wLlxuICAgICAqXG4gICAgICogUHJlZGljdHMgdGhlIG5leHQgbWVzc2FnZSBiYXNlZCBvbiB0aGUgaW5wdXQgbWVzc2FnZXMuXG4gICAgICogQHBhcmFtIG1lc3NhZ2VzIEFuIGFycmF5IG9mIEJhc2VNZXNzYWdlIGluc3RhbmNlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgY2FsbCBvcHRpb25zIG9yIGFuIGFycmF5IG9mIHN0b3Agc2VxdWVuY2VzLlxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgVGhlIGNhbGxiYWNrcyBmb3IgdGhlIGxhbmd1YWdlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgQmFzZU1lc3NhZ2UuXG4gICAgICovXG4gICAgYXN5bmMgcHJlZGljdE1lc3NhZ2VzKG1lc3NhZ2VzLCBvcHRpb25zLCBjYWxsYmFja3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbChtZXNzYWdlcywgb3B0aW9ucywgY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIC5pbnZva2UoKSBpbnN0ZWFkLiBXaWxsIGJlIHJlbW92ZWQgaW4gMC4yLjAuXG4gICAgICpcbiAgICAgKiBQcmVkaWN0cyB0aGUgbmV4dCBtZXNzYWdlIGJhc2VkIG9uIGEgdGV4dCBpbnB1dC5cbiAgICAgKiBAcGFyYW0gdGV4dCBUaGUgdGV4dCBpbnB1dC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgY2FsbCBvcHRpb25zIG9yIGFuIGFycmF5IG9mIHN0b3Agc2VxdWVuY2VzLlxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgVGhlIGNhbGxiYWNrcyBmb3IgdGhlIGxhbmd1YWdlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgc3RyaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIHByZWRpY3QodGV4dCwgb3B0aW9ucywgY2FsbGJhY2tzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgaW5kZXhfanNfMS5IdW1hbk1lc3NhZ2UodGV4dCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY2FsbChbbWVzc2FnZV0sIG9wdGlvbnMsIGNhbGxiYWNrcyk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0LmNvbnRlbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgcHJlZGljdCB3aGVuIG91dHB1dCBpcyBub3QgYSBzdHJpbmcuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuY29udGVudDtcbiAgICB9XG4gICAgd2l0aFN0cnVjdHVyZWRPdXRwdXQob3V0cHV0U2NoZW1hLCBjb25maWcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmJpbmRUb29scyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENoYXQgbW9kZWwgbXVzdCBpbXBsZW1lbnQgXCIuYmluZFRvb2xzKClcIiB0byB1c2Ugd2l0aFN0cnVjdHVyZWRPdXRwdXQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZz8uc3RyaWN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwic3RyaWN0XCIgbW9kZSBpcyBub3Qgc3VwcG9ydGVkIGZvciB0aGlzIG1vZGVsIGJ5IGRlZmF1bHQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gb3V0cHV0U2NoZW1hO1xuICAgICAgICBjb25zdCBuYW1lID0gY29uZmlnPy5uYW1lO1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9ICgwLCB6b2RfanNfMS5nZXRTY2hlbWFEZXNjcmlwdGlvbikoc2NoZW1hKSA/PyBcIkEgZnVuY3Rpb24gYXZhaWxhYmxlIHRvIGNhbGwuXCI7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGNvbmZpZz8ubWV0aG9kO1xuICAgICAgICBjb25zdCBpbmNsdWRlUmF3ID0gY29uZmlnPy5pbmNsdWRlUmF3O1xuICAgICAgICBpZiAobWV0aG9kID09PSBcImpzb25Nb2RlXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmFzZSB3aXRoU3RydWN0dXJlZE91dHB1dCBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIFwiZnVuY3Rpb25DYWxsaW5nXCIgYXMgYSBtZXRob2QuYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZ1bmN0aW9uTmFtZSA9IG5hbWUgPz8gXCJleHRyYWN0XCI7XG4gICAgICAgIGxldCB0b29scztcbiAgICAgICAgaWYgKCgwLCB6b2RfanNfMS5pc0ludGVyb3Bab2RTY2hlbWEpKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHRvb2xzID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiAoMCwganNvbl9zY2hlbWFfanNfMS50b0pzb25TY2hlbWEpKHNjaGVtYSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoXCJuYW1lXCIgaW4gc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lID0gc2NoZW1hLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b29scyA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyczogc2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxsbSA9IHRoaXMuYmluZFRvb2xzKHRvb2xzKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0UGFyc2VyID0gYmFzZV9qc18yLlJ1bm5hYmxlTGFtYmRhLmZyb20oKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlucHV0LnRvb2xfY2FsbHMgfHwgaW5wdXQudG9vbF9jYWxscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB0b29sIGNhbGxzIGZvdW5kIGluIHRoZSByZXNwb25zZS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0b29sQ2FsbCA9IGlucHV0LnRvb2xfY2FsbHMuZmluZCgodGMpID0+IHRjLm5hbWUgPT09IGZ1bmN0aW9uTmFtZSk7XG4gICAgICAgICAgICBpZiAoIXRvb2xDYWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyB0b29sIGNhbGwgZm91bmQgd2l0aCBuYW1lICR7ZnVuY3Rpb25OYW1lfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b29sQ2FsbC5hcmdzO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFpbmNsdWRlUmF3KSB7XG4gICAgICAgICAgICByZXR1cm4gbGxtLnBpcGUob3V0cHV0UGFyc2VyKS53aXRoQ29uZmlnKHtcbiAgICAgICAgICAgICAgICBydW5OYW1lOiBcIlN0cnVjdHVyZWRPdXRwdXRcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlckFzc2lnbiA9IHBhc3N0aHJvdWdoX2pzXzEuUnVubmFibGVQYXNzdGhyb3VnaC5hc3NpZ24oe1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHBhcnNlZDogKGlucHV0LCBjb25maWcpID0+IG91dHB1dFBhcnNlci5pbnZva2UoaW5wdXQucmF3LCBjb25maWcpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGFyc2VyTm9uZSA9IHBhc3N0aHJvdWdoX2pzXzEuUnVubmFibGVQYXNzdGhyb3VnaC5hc3NpZ24oe1xuICAgICAgICAgICAgcGFyc2VkOiAoKSA9PiBudWxsLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGFyc2VkV2l0aEZhbGxiYWNrID0gcGFyc2VyQXNzaWduLndpdGhGYWxsYmFja3Moe1xuICAgICAgICAgICAgZmFsbGJhY2tzOiBbcGFyc2VyTm9uZV0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYmFzZV9qc18yLlJ1bm5hYmxlU2VxdWVuY2UuZnJvbShbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmF3OiBsbG0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyc2VkV2l0aEZhbGxiYWNrLFxuICAgICAgICBdKS53aXRoQ29uZmlnKHtcbiAgICAgICAgICAgIHJ1bk5hbWU6IFwiU3RydWN0dXJlZE91dHB1dFJ1bm5hYmxlXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUNoYXRNb2RlbCA9IEJhc2VDaGF0TW9kZWw7XG4vKipcbiAqIEFuIGFic3RyYWN0IGNsYXNzIHRoYXQgZXh0ZW5kcyBCYXNlQ2hhdE1vZGVsIGFuZCBwcm92aWRlcyBhIHNpbXBsZVxuICogaW1wbGVtZW50YXRpb24gb2YgX2dlbmVyYXRlLlxuICovXG5jbGFzcyBTaW1wbGVDaGF0TW9kZWwgZXh0ZW5kcyBCYXNlQ2hhdE1vZGVsIHtcbiAgICBhc3luYyBfZ2VuZXJhdGUobWVzc2FnZXMsIG9wdGlvbnMsIHJ1bk1hbmFnZXIpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHRoaXMuX2NhbGwobWVzc2FnZXMsIG9wdGlvbnMsIHJ1bk1hbmFnZXIpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gbmV3IGluZGV4X2pzXzEuQUlNZXNzYWdlKHRleHQpO1xuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuY29udGVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdlbmVyYXRlIHdpdGggYSBzaW1wbGUgY2hhdCBtb2RlbCB3aGVuIG91dHB1dCBpcyBub3QgYSBzdHJpbmcuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZW5lcmF0aW9uczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogbWVzc2FnZS5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuU2ltcGxlQ2hhdE1vZGVsID0gU2ltcGxlQ2hhdE1vZGVsO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/language_models/chat_models.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/language_models/llms.cjs":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/language_models/llms.cjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LLM = exports.BaseLLM = void 0;\nconst index_js_1 = __webpack_require__(/*! ../messages/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/index.cjs\");\nconst outputs_js_1 = __webpack_require__(/*! ../outputs.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/outputs.cjs\");\nconst manager_js_1 = __webpack_require__(/*! ../callbacks/manager.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.cjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/language_models/base.cjs\");\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\nconst base_js_2 = __webpack_require__(/*! ../callbacks/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/base.cjs\");\n/**\n * LLM Wrapper. Takes in a prompt (or prompts) and returns a string.\n */\nclass BaseLLM extends base_js_1.BaseLanguageModel {\n    constructor({ concurrency, ...rest }) {\n        super(concurrency ? { maxConcurrency: concurrency, ...rest } : rest);\n        // Only ever instantiated in main LangChain\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"llms\", this._llmType()]\n        });\n    }\n    /**\n     * This method takes an input and options, and returns a string. It\n     * converts the input to a prompt value and generates a result based on\n     * the prompt.\n     * @param input Input for the LLM.\n     * @param options Options for the LLM call.\n     * @returns A string result based on the prompt.\n     */\n    async invoke(input, options) {\n        const promptValue = BaseLLM._convertInputToPromptValue(input);\n        const result = await this.generatePrompt([promptValue], options, options?.callbacks);\n        return result.generations[0][0].text;\n    }\n    // eslint-disable-next-line require-yield\n    async *_streamResponseChunks(_input, _options, _runManager) {\n        throw new Error(\"Not implemented.\");\n    }\n    _separateRunnableConfigFromCallOptionsCompat(options) {\n        // For backwards compat, keep `signal` in both runnableConfig and callOptions\n        const [runnableConfig, callOptions] = super._separateRunnableConfigFromCallOptions(options);\n        callOptions.signal = runnableConfig.signal;\n        return [runnableConfig, callOptions];\n    }\n    async *_streamIterator(input, options) {\n        // Subclass check required to avoid double callbacks with default implementation\n        if (this._streamResponseChunks === BaseLLM.prototype._streamResponseChunks) {\n            yield this.invoke(input, options);\n        }\n        else {\n            const prompt = BaseLLM._convertInputToPromptValue(input);\n            const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(options);\n            const callbackManager_ = await manager_js_1.CallbackManager.configure(runnableConfig.callbacks, this.callbacks, runnableConfig.tags, this.tags, runnableConfig.metadata, this.metadata, { verbose: this.verbose });\n            const extra = {\n                options: callOptions,\n                invocation_params: this?.invocationParams(callOptions),\n                batch_size: 1,\n            };\n            const runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), [prompt.toString()], runnableConfig.runId, undefined, extra, undefined, undefined, runnableConfig.runName);\n            let generation = new outputs_js_1.GenerationChunk({\n                text: \"\",\n            });\n            try {\n                for await (const chunk of this._streamResponseChunks(prompt.toString(), callOptions, runManagers?.[0])) {\n                    if (!generation) {\n                        generation = chunk;\n                    }\n                    else {\n                        generation = generation.concat(chunk);\n                    }\n                    if (typeof chunk.text === \"string\") {\n                        yield chunk.text;\n                    }\n                }\n            }\n            catch (err) {\n                await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));\n                throw err;\n            }\n            await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMEnd({\n                generations: [[generation]],\n            })));\n        }\n    }\n    /**\n     * This method takes prompt values, options, and callbacks, and generates\n     * a result based on the prompts.\n     * @param promptValues Prompt values for the LLM.\n     * @param options Options for the LLM call.\n     * @param callbacks Callbacks for the LLM call.\n     * @returns An LLMResult based on the prompts.\n     */\n    async generatePrompt(promptValues, options, callbacks) {\n        const prompts = promptValues.map((promptValue) => promptValue.toString());\n        return this.generate(prompts, options, callbacks);\n    }\n    /**\n     * Get the parameters used to invoke the model\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    invocationParams(_options) {\n        return {};\n    }\n    _flattenLLMResult(llmResult) {\n        const llmResults = [];\n        for (let i = 0; i < llmResult.generations.length; i += 1) {\n            const genList = llmResult.generations[i];\n            if (i === 0) {\n                llmResults.push({\n                    generations: [genList],\n                    llmOutput: llmResult.llmOutput,\n                });\n            }\n            else {\n                const llmOutput = llmResult.llmOutput\n                    ? { ...llmResult.llmOutput, tokenUsage: {} }\n                    : undefined;\n                llmResults.push({\n                    generations: [genList],\n                    llmOutput,\n                });\n            }\n        }\n        return llmResults;\n    }\n    /** @ignore */\n    async _generateUncached(prompts, parsedOptions, handledOptions, startedRunManagers) {\n        let runManagers;\n        if (startedRunManagers !== undefined &&\n            startedRunManagers.length === prompts.length) {\n            runManagers = startedRunManagers;\n        }\n        else {\n            const callbackManager_ = await manager_js_1.CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, handledOptions.metadata, this.metadata, { verbose: this.verbose });\n            const extra = {\n                options: parsedOptions,\n                invocation_params: this?.invocationParams(parsedOptions),\n                batch_size: prompts.length,\n            };\n            runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), prompts, handledOptions.runId, undefined, extra, undefined, undefined, handledOptions?.runName);\n        }\n        // Even if stream is not explicitly called, check if model is implicitly\n        // called from streamEvents() or streamLog() to get all streamed events.\n        // Bail out if _streamResponseChunks not overridden\n        const hasStreamingHandler = !!runManagers?.[0].handlers.find(base_js_2.callbackHandlerPrefersStreaming);\n        let output;\n        if (hasStreamingHandler &&\n            prompts.length === 1 &&\n            this._streamResponseChunks !== BaseLLM.prototype._streamResponseChunks) {\n            try {\n                const stream = await this._streamResponseChunks(prompts[0], parsedOptions, runManagers?.[0]);\n                let aggregated;\n                for await (const chunk of stream) {\n                    if (aggregated === undefined) {\n                        aggregated = chunk;\n                    }\n                    else {\n                        aggregated = (0, stream_js_1.concat)(aggregated, chunk);\n                    }\n                }\n                if (aggregated === undefined) {\n                    throw new Error(\"Received empty response from chat model call.\");\n                }\n                output = { generations: [[aggregated]], llmOutput: {} };\n                await runManagers?.[0].handleLLMEnd(output);\n            }\n            catch (e) {\n                await runManagers?.[0].handleLLMError(e);\n                throw e;\n            }\n        }\n        else {\n            try {\n                output = await this._generate(prompts, parsedOptions, runManagers?.[0]);\n            }\n            catch (err) {\n                await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));\n                throw err;\n            }\n            const flattenedOutputs = this._flattenLLMResult(output);\n            await Promise.all((runManagers ?? []).map((runManager, i) => runManager?.handleLLMEnd(flattenedOutputs[i])));\n        }\n        const runIds = runManagers?.map((manager) => manager.runId) || undefined;\n        // This defines RUN_KEY as a non-enumerable property on the output object\n        // so that it is not serialized when the output is stringified, and so that\n        // it isnt included when listing the keys of the output object.\n        Object.defineProperty(output, outputs_js_1.RUN_KEY, {\n            value: runIds ? { runIds } : undefined,\n            configurable: true,\n        });\n        return output;\n    }\n    async _generateCached({ prompts, cache, llmStringKey, parsedOptions, handledOptions, runId, }) {\n        const callbackManager_ = await manager_js_1.CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, handledOptions.metadata, this.metadata, { verbose: this.verbose });\n        const extra = {\n            options: parsedOptions,\n            invocation_params: this?.invocationParams(parsedOptions),\n            batch_size: prompts.length,\n        };\n        const runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), prompts, runId, undefined, extra, undefined, undefined, handledOptions?.runName);\n        // generate results\n        const missingPromptIndices = [];\n        const results = await Promise.allSettled(prompts.map(async (prompt, index) => {\n            const result = await cache.lookup(prompt, llmStringKey);\n            if (result == null) {\n                missingPromptIndices.push(index);\n            }\n            return result;\n        }));\n        // Map run managers to the results before filtering out null results\n        // Null results are just absent from the cache.\n        const cachedResults = results\n            .map((result, index) => ({ result, runManager: runManagers?.[index] }))\n            .filter(({ result }) => (result.status === \"fulfilled\" && result.value != null) ||\n            result.status === \"rejected\");\n        // Handle results and call run managers\n        const generations = [];\n        await Promise.all(cachedResults.map(async ({ result: promiseResult, runManager }, i) => {\n            if (promiseResult.status === \"fulfilled\") {\n                const result = promiseResult.value;\n                generations[i] = result.map((result) => {\n                    // eslint-disable-next-line no-param-reassign\n                    result.generationInfo = {\n                        ...result.generationInfo,\n                        tokenUsage: {},\n                    };\n                    return result;\n                });\n                if (result.length) {\n                    await runManager?.handleLLMNewToken(result[0].text);\n                }\n                return runManager?.handleLLMEnd({\n                    generations: [result],\n                }, undefined, undefined, undefined, {\n                    cached: true,\n                });\n            }\n            else {\n                // status === \"rejected\"\n                await runManager?.handleLLMError(promiseResult.reason, undefined, undefined, undefined, {\n                    cached: true,\n                });\n                return Promise.reject(promiseResult.reason);\n            }\n        }));\n        const output = {\n            generations,\n            missingPromptIndices,\n            startedRunManagers: runManagers,\n        };\n        // This defines RUN_KEY as a non-enumerable property on the output object\n        // so that it is not serialized when the output is stringified, and so that\n        // it isnt included when listing the keys of the output object.\n        Object.defineProperty(output, outputs_js_1.RUN_KEY, {\n            value: runManagers\n                ? { runIds: runManagers?.map((manager) => manager.runId) }\n                : undefined,\n            configurable: true,\n        });\n        return output;\n    }\n    /**\n     * Run the LLM on the given prompts and input, handling caching.\n     */\n    async generate(prompts, options, callbacks) {\n        if (!Array.isArray(prompts)) {\n            throw new Error(\"Argument 'prompts' is expected to be a string[]\");\n        }\n        let parsedOptions;\n        if (Array.isArray(options)) {\n            parsedOptions = { stop: options };\n        }\n        else {\n            parsedOptions = options;\n        }\n        const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);\n        runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;\n        if (!this.cache) {\n            return this._generateUncached(prompts, callOptions, runnableConfig);\n        }\n        const { cache } = this;\n        const llmStringKey = this._getSerializedCacheKeyParametersForCall(callOptions);\n        const { generations, missingPromptIndices, startedRunManagers } = await this._generateCached({\n            prompts,\n            cache,\n            llmStringKey,\n            parsedOptions: callOptions,\n            handledOptions: runnableConfig,\n            runId: runnableConfig.runId,\n        });\n        let llmOutput = {};\n        if (missingPromptIndices.length > 0) {\n            const results = await this._generateUncached(missingPromptIndices.map((i) => prompts[i]), callOptions, runnableConfig, startedRunManagers !== undefined\n                ? missingPromptIndices.map((i) => startedRunManagers?.[i])\n                : undefined);\n            await Promise.all(results.generations.map(async (generation, index) => {\n                const promptIndex = missingPromptIndices[index];\n                generations[promptIndex] = generation;\n                return cache.update(prompts[promptIndex], llmStringKey, generation);\n            }));\n            llmOutput = results.llmOutput ?? {};\n        }\n        return { generations, llmOutput };\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     * Convenience wrapper for {@link generate} that takes in a single string prompt and returns a single string output.\n     */\n    async call(prompt, options, callbacks) {\n        const { generations } = await this.generate([prompt], options, callbacks);\n        return generations[0][0].text;\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * This method is similar to `call`, but it's used for making predictions\n     * based on the input text.\n     * @param text Input text for the prediction.\n     * @param options Options for the LLM call.\n     * @param callbacks Callbacks for the LLM call.\n     * @returns A prediction based on the input text.\n     */\n    async predict(text, options, callbacks) {\n        return this.call(text, options, callbacks);\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * This method takes a list of messages, options, and callbacks, and\n     * returns a predicted message.\n     * @param messages A list of messages for the prediction.\n     * @param options Options for the LLM call.\n     * @param callbacks Callbacks for the LLM call.\n     * @returns A predicted message based on the list of messages.\n     */\n    async predictMessages(messages, options, callbacks) {\n        const text = (0, index_js_1.getBufferString)(messages);\n        const prediction = await this.call(text, options, callbacks);\n        return new index_js_1.AIMessage(prediction);\n    }\n    /**\n     * Get the identifying parameters of the LLM.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _identifyingParams() {\n        return {};\n    }\n    /**\n     * @deprecated\n     * Return a json-like object representing this LLM.\n     */\n    serialize() {\n        return {\n            ...this._identifyingParams(),\n            _type: this._llmType(),\n            _model: this._modelType(),\n        };\n    }\n    _modelType() {\n        return \"base_llm\";\n    }\n}\nexports.BaseLLM = BaseLLM;\n/**\n * LLM class that provides a simpler interface to subclass than {@link BaseLLM}.\n *\n * Requires only implementing a simpler {@link _call} method instead of {@link _generate}.\n *\n * @augments BaseLLM\n */\nclass LLM extends BaseLLM {\n    async _generate(prompts, options, runManager) {\n        const generations = await Promise.all(prompts.map((prompt, promptIndex) => this._call(prompt, { ...options, promptIndex }, runManager).then((text) => [{ text }])));\n        return { generations };\n    }\n}\nexports.LLM = LLM;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbGFuZ3VhZ2VfbW9kZWxzL2xsbXMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFdBQVcsR0FBRyxlQUFlO0FBQzdCLG1CQUFtQixtQkFBTyxDQUFDLDJGQUF1QjtBQUNsRCxxQkFBcUIsbUJBQU8sQ0FBQyw2RUFBZ0I7QUFDN0MscUJBQXFCLG1CQUFPLENBQUMsaUdBQTBCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLHNGQUFZO0FBQ3RDLG9CQUFvQixtQkFBTyxDQUFDLHVGQUFxQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQywyRkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDLDhCQUE4Qix1Q0FBdUM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzTUFBc00sdUJBQXVCO0FBQzdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQ0FBa0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc01BQXNNLHVCQUF1QjtBQUM3TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBUztBQUN2QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNEJBQTRCLHFFQUFxRTtBQUNqRyxrTUFBa00sdUJBQXVCO0FBQ3pOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDBDQUEwQztBQUNqRix1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsbUNBQW1DO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLGdCQUFnQix3REFBd0Q7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsaUVBQWlFLGNBQWM7QUFDL0U7QUFDQSx5Q0FBeUMsYUFBYSxtQkFBbUIsZ0JBQWdCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0cseUJBQXlCLGdDQUFnQyxNQUFNO0FBQ3ZLLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsV0FBVyIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2xhbmd1YWdlX21vZGVscy9sbG1zLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTExNID0gZXhwb3J0cy5CYXNlTExNID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9tZXNzYWdlcy9pbmRleC5janNcIik7XG5jb25zdCBvdXRwdXRzX2pzXzEgPSByZXF1aXJlKFwiLi4vb3V0cHV0cy5janNcIik7XG5jb25zdCBtYW5hZ2VyX2pzXzEgPSByZXF1aXJlKFwiLi4vY2FsbGJhY2tzL21hbmFnZXIuY2pzXCIpO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG5jb25zdCBzdHJlYW1fanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9zdHJlYW0uY2pzXCIpO1xuY29uc3QgYmFzZV9qc18yID0gcmVxdWlyZShcIi4uL2NhbGxiYWNrcy9iYXNlLmNqc1wiKTtcbi8qKlxuICogTExNIFdyYXBwZXIuIFRha2VzIGluIGEgcHJvbXB0IChvciBwcm9tcHRzKSBhbmQgcmV0dXJucyBhIHN0cmluZy5cbiAqL1xuY2xhc3MgQmFzZUxMTSBleHRlbmRzIGJhc2VfanNfMS5CYXNlTGFuZ3VhZ2VNb2RlbCB7XG4gICAgY29uc3RydWN0b3IoeyBjb25jdXJyZW5jeSwgLi4ucmVzdCB9KSB7XG4gICAgICAgIHN1cGVyKGNvbmN1cnJlbmN5ID8geyBtYXhDb25jdXJyZW5jeTogY29uY3VycmVuY3ksIC4uLnJlc3QgfSA6IHJlc3QpO1xuICAgICAgICAvLyBPbmx5IGV2ZXIgaW5zdGFudGlhdGVkIGluIG1haW4gTGFuZ0NoYWluXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluXCIsIFwibGxtc1wiLCB0aGlzLl9sbG1UeXBlKCldXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB0YWtlcyBhbiBpbnB1dCBhbmQgb3B0aW9ucywgYW5kIHJldHVybnMgYSBzdHJpbmcuIEl0XG4gICAgICogY29udmVydHMgdGhlIGlucHV0IHRvIGEgcHJvbXB0IHZhbHVlIGFuZCBnZW5lcmF0ZXMgYSByZXN1bHQgYmFzZWQgb25cbiAgICAgKiB0aGUgcHJvbXB0LlxuICAgICAqIEBwYXJhbSBpbnB1dCBJbnB1dCBmb3IgdGhlIExMTS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgTExNIGNhbGwuXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVzdWx0IGJhc2VkIG9uIHRoZSBwcm9tcHQuXG4gICAgICovXG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHByb21wdFZhbHVlID0gQmFzZUxMTS5fY29udmVydElucHV0VG9Qcm9tcHRWYWx1ZShpbnB1dCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVQcm9tcHQoW3Byb21wdFZhbHVlXSwgb3B0aW9ucywgb3B0aW9ucz8uY2FsbGJhY2tzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5nZW5lcmF0aW9uc1swXVswXS50ZXh0O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS15aWVsZFxuICAgIGFzeW5jICpfc3RyZWFtUmVzcG9uc2VDaHVua3MoX2lucHV0LCBfb3B0aW9ucywgX3J1bk1hbmFnZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gICAgX3NlcGFyYXRlUnVubmFibGVDb25maWdGcm9tQ2FsbE9wdGlvbnNDb21wYXQob3B0aW9ucykge1xuICAgICAgICAvLyBGb3IgYmFja3dhcmRzIGNvbXBhdCwga2VlcCBgc2lnbmFsYCBpbiBib3RoIHJ1bm5hYmxlQ29uZmlnIGFuZCBjYWxsT3B0aW9uc1xuICAgICAgICBjb25zdCBbcnVubmFibGVDb25maWcsIGNhbGxPcHRpb25zXSA9IHN1cGVyLl9zZXBhcmF0ZVJ1bm5hYmxlQ29uZmlnRnJvbUNhbGxPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBjYWxsT3B0aW9ucy5zaWduYWwgPSBydW5uYWJsZUNvbmZpZy5zaWduYWw7XG4gICAgICAgIHJldHVybiBbcnVubmFibGVDb25maWcsIGNhbGxPcHRpb25zXTtcbiAgICB9XG4gICAgYXN5bmMgKl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICAvLyBTdWJjbGFzcyBjaGVjayByZXF1aXJlZCB0byBhdm9pZCBkb3VibGUgY2FsbGJhY2tzIHdpdGggZGVmYXVsdCBpbXBsZW1lbnRhdGlvblxuICAgICAgICBpZiAodGhpcy5fc3RyZWFtUmVzcG9uc2VDaHVua3MgPT09IEJhc2VMTE0ucHJvdG90eXBlLl9zdHJlYW1SZXNwb25zZUNodW5rcykge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5pbnZva2UoaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcHJvbXB0ID0gQmFzZUxMTS5fY29udmVydElucHV0VG9Qcm9tcHRWYWx1ZShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBbcnVubmFibGVDb25maWcsIGNhbGxPcHRpb25zXSA9IHRoaXMuX3NlcGFyYXRlUnVubmFibGVDb25maWdGcm9tQ2FsbE9wdGlvbnNDb21wYXQob3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgbWFuYWdlcl9qc18xLkNhbGxiYWNrTWFuYWdlci5jb25maWd1cmUocnVubmFibGVDb25maWcuY2FsbGJhY2tzLCB0aGlzLmNhbGxiYWNrcywgcnVubmFibGVDb25maWcudGFncywgdGhpcy50YWdzLCBydW5uYWJsZUNvbmZpZy5tZXRhZGF0YSwgdGhpcy5tZXRhZGF0YSwgeyB2ZXJib3NlOiB0aGlzLnZlcmJvc2UgfSk7XG4gICAgICAgICAgICBjb25zdCBleHRyYSA9IHtcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBjYWxsT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBpbnZvY2F0aW9uX3BhcmFtczogdGhpcz8uaW52b2NhdGlvblBhcmFtcyhjYWxsT3B0aW9ucyksXG4gICAgICAgICAgICAgICAgYmF0Y2hfc2l6ZTogMSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBydW5NYW5hZ2VycyA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUxMTVN0YXJ0KHRoaXMudG9KU09OKCksIFtwcm9tcHQudG9TdHJpbmcoKV0sIHJ1bm5hYmxlQ29uZmlnLnJ1bklkLCB1bmRlZmluZWQsIGV4dHJhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgcnVubmFibGVDb25maWcucnVuTmFtZSk7XG4gICAgICAgICAgICBsZXQgZ2VuZXJhdGlvbiA9IG5ldyBvdXRwdXRzX2pzXzEuR2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgdGhpcy5fc3RyZWFtUmVzcG9uc2VDaHVua3MocHJvbXB0LnRvU3RyaW5nKCksIGNhbGxPcHRpb25zLCBydW5NYW5hZ2Vycz8uWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdlbmVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb24gPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb24gPSBnZW5lcmF0aW9uLmNvbmNhdChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaHVuay50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBjaHVuay50ZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKChydW5NYW5hZ2VycyA/PyBbXSkubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVMTE1FcnJvcihlcnIpKSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoKHJ1bk1hbmFnZXJzID8/IFtdKS5tYXAoKHJ1bk1hbmFnZXIpID0+IHJ1bk1hbmFnZXI/LmhhbmRsZUxMTUVuZCh7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGlvbnM6IFtbZ2VuZXJhdGlvbl1dLFxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB0YWtlcyBwcm9tcHQgdmFsdWVzLCBvcHRpb25zLCBhbmQgY2FsbGJhY2tzLCBhbmQgZ2VuZXJhdGVzXG4gICAgICogYSByZXN1bHQgYmFzZWQgb24gdGhlIHByb21wdHMuXG4gICAgICogQHBhcmFtIHByb21wdFZhbHVlcyBQcm9tcHQgdmFsdWVzIGZvciB0aGUgTExNLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSBMTE0gY2FsbC5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tzIENhbGxiYWNrcyBmb3IgdGhlIExMTSBjYWxsLlxuICAgICAqIEByZXR1cm5zIEFuIExMTVJlc3VsdCBiYXNlZCBvbiB0aGUgcHJvbXB0cy5cbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZVByb21wdChwcm9tcHRWYWx1ZXMsIG9wdGlvbnMsIGNhbGxiYWNrcykge1xuICAgICAgICBjb25zdCBwcm9tcHRzID0gcHJvbXB0VmFsdWVzLm1hcCgocHJvbXB0VmFsdWUpID0+IHByb21wdFZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZShwcm9tcHRzLCBvcHRpb25zLCBjYWxsYmFja3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBhcmFtZXRlcnMgdXNlZCB0byBpbnZva2UgdGhlIG1vZGVsXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBpbnZvY2F0aW9uUGFyYW1zKF9vcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgX2ZsYXR0ZW5MTE1SZXN1bHQobGxtUmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IGxsbVJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsbG1SZXN1bHQuZ2VuZXJhdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGdlbkxpc3QgPSBsbG1SZXN1bHQuZ2VuZXJhdGlvbnNbaV07XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxsbVJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zOiBbZ2VuTGlzdF0sXG4gICAgICAgICAgICAgICAgICAgIGxsbU91dHB1dDogbGxtUmVzdWx0LmxsbU91dHB1dCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxsbU91dHB1dCA9IGxsbVJlc3VsdC5sbG1PdXRwdXRcbiAgICAgICAgICAgICAgICAgICAgPyB7IC4uLmxsbVJlc3VsdC5sbG1PdXRwdXQsIHRva2VuVXNhZ2U6IHt9IH1cbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbGxtUmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbnM6IFtnZW5MaXN0XSxcbiAgICAgICAgICAgICAgICAgICAgbGxtT3V0cHV0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsbG1SZXN1bHRzO1xuICAgIH1cbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIGFzeW5jIF9nZW5lcmF0ZVVuY2FjaGVkKHByb21wdHMsIHBhcnNlZE9wdGlvbnMsIGhhbmRsZWRPcHRpb25zLCBzdGFydGVkUnVuTWFuYWdlcnMpIHtcbiAgICAgICAgbGV0IHJ1bk1hbmFnZXJzO1xuICAgICAgICBpZiAoc3RhcnRlZFJ1bk1hbmFnZXJzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHN0YXJ0ZWRSdW5NYW5hZ2Vycy5sZW5ndGggPT09IHByb21wdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBydW5NYW5hZ2VycyA9IHN0YXJ0ZWRSdW5NYW5hZ2VycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCBtYW5hZ2VyX2pzXzEuQ2FsbGJhY2tNYW5hZ2VyLmNvbmZpZ3VyZShoYW5kbGVkT3B0aW9ucy5jYWxsYmFja3MsIHRoaXMuY2FsbGJhY2tzLCBoYW5kbGVkT3B0aW9ucy50YWdzLCB0aGlzLnRhZ3MsIGhhbmRsZWRPcHRpb25zLm1ldGFkYXRhLCB0aGlzLm1ldGFkYXRhLCB7IHZlcmJvc2U6IHRoaXMudmVyYm9zZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhID0ge1xuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHBhcnNlZE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgaW52b2NhdGlvbl9wYXJhbXM6IHRoaXM/Lmludm9jYXRpb25QYXJhbXMocGFyc2VkT3B0aW9ucyksXG4gICAgICAgICAgICAgICAgYmF0Y2hfc2l6ZTogcHJvbXB0cy5sZW5ndGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcnVuTWFuYWdlcnMgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVMTE1TdGFydCh0aGlzLnRvSlNPTigpLCBwcm9tcHRzLCBoYW5kbGVkT3B0aW9ucy5ydW5JZCwgdW5kZWZpbmVkLCBleHRyYSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGhhbmRsZWRPcHRpb25zPy5ydW5OYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFdmVuIGlmIHN0cmVhbSBpcyBub3QgZXhwbGljaXRseSBjYWxsZWQsIGNoZWNrIGlmIG1vZGVsIGlzIGltcGxpY2l0bHlcbiAgICAgICAgLy8gY2FsbGVkIGZyb20gc3RyZWFtRXZlbnRzKCkgb3Igc3RyZWFtTG9nKCkgdG8gZ2V0IGFsbCBzdHJlYW1lZCBldmVudHMuXG4gICAgICAgIC8vIEJhaWwgb3V0IGlmIF9zdHJlYW1SZXNwb25zZUNodW5rcyBub3Qgb3ZlcnJpZGRlblxuICAgICAgICBjb25zdCBoYXNTdHJlYW1pbmdIYW5kbGVyID0gISFydW5NYW5hZ2Vycz8uWzBdLmhhbmRsZXJzLmZpbmQoYmFzZV9qc18yLmNhbGxiYWNrSGFuZGxlclByZWZlcnNTdHJlYW1pbmcpO1xuICAgICAgICBsZXQgb3V0cHV0O1xuICAgICAgICBpZiAoaGFzU3RyZWFtaW5nSGFuZGxlciAmJlxuICAgICAgICAgICAgcHJvbXB0cy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgIHRoaXMuX3N0cmVhbVJlc3BvbnNlQ2h1bmtzICE9PSBCYXNlTExNLnByb3RvdHlwZS5fc3RyZWFtUmVzcG9uc2VDaHVua3MpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgdGhpcy5fc3RyZWFtUmVzcG9uc2VDaHVua3MocHJvbXB0c1swXSwgcGFyc2VkT3B0aW9ucywgcnVuTWFuYWdlcnM/LlswXSk7XG4gICAgICAgICAgICAgICAgbGV0IGFnZ3JlZ2F0ZWQ7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFnZ3JlZ2F0ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWdncmVnYXRlZCA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWdncmVnYXRlZCA9ICgwLCBzdHJlYW1fanNfMS5jb25jYXQpKGFnZ3JlZ2F0ZWQsIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWdncmVnYXRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlY2VpdmVkIGVtcHR5IHJlc3BvbnNlIGZyb20gY2hhdCBtb2RlbCBjYWxsLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0geyBnZW5lcmF0aW9uczogW1thZ2dyZWdhdGVkXV0sIGxsbU91dHB1dDoge30gfTtcbiAgICAgICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2Vycz8uWzBdLmhhbmRsZUxMTUVuZChvdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2Vycz8uWzBdLmhhbmRsZUxMTUVycm9yKGUpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IGF3YWl0IHRoaXMuX2dlbmVyYXRlKHByb21wdHMsIHBhcnNlZE9wdGlvbnMsIHJ1bk1hbmFnZXJzPy5bMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKChydW5NYW5hZ2VycyA/PyBbXSkubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVMTE1FcnJvcihlcnIpKSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmxhdHRlbmVkT3V0cHV0cyA9IHRoaXMuX2ZsYXR0ZW5MTE1SZXN1bHQob3V0cHV0KTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKChydW5NYW5hZ2VycyA/PyBbXSkubWFwKChydW5NYW5hZ2VyLCBpKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVMTE1FbmQoZmxhdHRlbmVkT3V0cHV0c1tpXSkpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW5JZHMgPSBydW5NYW5hZ2Vycz8ubWFwKChtYW5hZ2VyKSA9PiBtYW5hZ2VyLnJ1bklkKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFRoaXMgZGVmaW5lcyBSVU5fS0VZIGFzIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgb24gdGhlIG91dHB1dCBvYmplY3RcbiAgICAgICAgLy8gc28gdGhhdCBpdCBpcyBub3Qgc2VyaWFsaXplZCB3aGVuIHRoZSBvdXRwdXQgaXMgc3RyaW5naWZpZWQsIGFuZCBzbyB0aGF0XG4gICAgICAgIC8vIGl0IGlzbnQgaW5jbHVkZWQgd2hlbiBsaXN0aW5nIHRoZSBrZXlzIG9mIHRoZSBvdXRwdXQgb2JqZWN0LlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3V0cHV0LCBvdXRwdXRzX2pzXzEuUlVOX0tFWSwge1xuICAgICAgICAgICAgdmFsdWU6IHJ1bklkcyA/IHsgcnVuSWRzIH0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBhc3luYyBfZ2VuZXJhdGVDYWNoZWQoeyBwcm9tcHRzLCBjYWNoZSwgbGxtU3RyaW5nS2V5LCBwYXJzZWRPcHRpb25zLCBoYW5kbGVkT3B0aW9ucywgcnVuSWQsIH0pIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0IG1hbmFnZXJfanNfMS5DYWxsYmFja01hbmFnZXIuY29uZmlndXJlKGhhbmRsZWRPcHRpb25zLmNhbGxiYWNrcywgdGhpcy5jYWxsYmFja3MsIGhhbmRsZWRPcHRpb25zLnRhZ3MsIHRoaXMudGFncywgaGFuZGxlZE9wdGlvbnMubWV0YWRhdGEsIHRoaXMubWV0YWRhdGEsIHsgdmVyYm9zZTogdGhpcy52ZXJib3NlIH0pO1xuICAgICAgICBjb25zdCBleHRyYSA9IHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHBhcnNlZE9wdGlvbnMsXG4gICAgICAgICAgICBpbnZvY2F0aW9uX3BhcmFtczogdGhpcz8uaW52b2NhdGlvblBhcmFtcyhwYXJzZWRPcHRpb25zKSxcbiAgICAgICAgICAgIGJhdGNoX3NpemU6IHByb21wdHMubGVuZ3RoLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VycyA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUxMTVN0YXJ0KHRoaXMudG9KU09OKCksIHByb21wdHMsIHJ1bklkLCB1bmRlZmluZWQsIGV4dHJhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGFuZGxlZE9wdGlvbnM/LnJ1bk5hbWUpO1xuICAgICAgICAvLyBnZW5lcmF0ZSByZXN1bHRzXG4gICAgICAgIGNvbnN0IG1pc3NpbmdQcm9tcHRJbmRpY2VzID0gW107XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQocHJvbXB0cy5tYXAoYXN5bmMgKHByb21wdCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhY2hlLmxvb2t1cChwcm9tcHQsIGxsbVN0cmluZ0tleSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nUHJvbXB0SW5kaWNlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gTWFwIHJ1biBtYW5hZ2VycyB0byB0aGUgcmVzdWx0cyBiZWZvcmUgZmlsdGVyaW5nIG91dCBudWxsIHJlc3VsdHNcbiAgICAgICAgLy8gTnVsbCByZXN1bHRzIGFyZSBqdXN0IGFic2VudCBmcm9tIHRoZSBjYWNoZS5cbiAgICAgICAgY29uc3QgY2FjaGVkUmVzdWx0cyA9IHJlc3VsdHNcbiAgICAgICAgICAgIC5tYXAoKHJlc3VsdCwgaW5kZXgpID0+ICh7IHJlc3VsdCwgcnVuTWFuYWdlcjogcnVuTWFuYWdlcnM/LltpbmRleF0gfSkpXG4gICAgICAgICAgICAuZmlsdGVyKCh7IHJlc3VsdCB9KSA9PiAocmVzdWx0LnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIiAmJiByZXN1bHQudmFsdWUgIT0gbnVsbCkgfHxcbiAgICAgICAgICAgIHJlc3VsdC5zdGF0dXMgPT09IFwicmVqZWN0ZWRcIik7XG4gICAgICAgIC8vIEhhbmRsZSByZXN1bHRzIGFuZCBjYWxsIHJ1biBtYW5hZ2Vyc1xuICAgICAgICBjb25zdCBnZW5lcmF0aW9ucyA9IFtdO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChjYWNoZWRSZXN1bHRzLm1hcChhc3luYyAoeyByZXN1bHQ6IHByb21pc2VSZXN1bHQsIHJ1bk1hbmFnZXIgfSwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKHByb21pc2VSZXN1bHQuc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcHJvbWlzZVJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBnZW5lcmF0aW9uc1tpXSA9IHJlc3VsdC5tYXAoKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmdlbmVyYXRpb25JbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucmVzdWx0LmdlbmVyYXRpb25JbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5Vc2FnZToge30sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlTExNTmV3VG9rZW4ocmVzdWx0WzBdLnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcnVuTWFuYWdlcj8uaGFuZGxlTExNRW5kKHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbnM6IFtyZXN1bHRdLFxuICAgICAgICAgICAgICAgIH0sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhdHVzID09PSBcInJlamVjdGVkXCJcbiAgICAgICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVMTE1FcnJvcihwcm9taXNlUmVzdWx0LnJlYXNvbiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHByb21pc2VSZXN1bHQucmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICAgICAgICBnZW5lcmF0aW9ucyxcbiAgICAgICAgICAgIG1pc3NpbmdQcm9tcHRJbmRpY2VzLFxuICAgICAgICAgICAgc3RhcnRlZFJ1bk1hbmFnZXJzOiBydW5NYW5hZ2VycyxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVGhpcyBkZWZpbmVzIFJVTl9LRVkgYXMgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBvbiB0aGUgb3V0cHV0IG9iamVjdFxuICAgICAgICAvLyBzbyB0aGF0IGl0IGlzIG5vdCBzZXJpYWxpemVkIHdoZW4gdGhlIG91dHB1dCBpcyBzdHJpbmdpZmllZCwgYW5kIHNvIHRoYXRcbiAgICAgICAgLy8gaXQgaXNudCBpbmNsdWRlZCB3aGVuIGxpc3RpbmcgdGhlIGtleXMgb2YgdGhlIG91dHB1dCBvYmplY3QuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvdXRwdXQsIG91dHB1dHNfanNfMS5SVU5fS0VZLCB7XG4gICAgICAgICAgICB2YWx1ZTogcnVuTWFuYWdlcnNcbiAgICAgICAgICAgICAgICA/IHsgcnVuSWRzOiBydW5NYW5hZ2Vycz8ubWFwKChtYW5hZ2VyKSA9PiBtYW5hZ2VyLnJ1bklkKSB9XG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW4gdGhlIExMTSBvbiB0aGUgZ2l2ZW4gcHJvbXB0cyBhbmQgaW5wdXQsIGhhbmRsaW5nIGNhY2hpbmcuXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGUocHJvbXB0cywgb3B0aW9ucywgY2FsbGJhY2tzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9tcHRzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgJ3Byb21wdHMnIGlzIGV4cGVjdGVkIHRvIGJlIGEgc3RyaW5nW11cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcnNlZE9wdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBwYXJzZWRPcHRpb25zID0geyBzdG9wOiBvcHRpb25zIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJzZWRPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbcnVubmFibGVDb25maWcsIGNhbGxPcHRpb25zXSA9IHRoaXMuX3NlcGFyYXRlUnVubmFibGVDb25maWdGcm9tQ2FsbE9wdGlvbnNDb21wYXQocGFyc2VkT3B0aW9ucyk7XG4gICAgICAgIHJ1bm5hYmxlQ29uZmlnLmNhbGxiYWNrcyA9IHJ1bm5hYmxlQ29uZmlnLmNhbGxiYWNrcyA/PyBjYWxsYmFja3M7XG4gICAgICAgIGlmICghdGhpcy5jYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dlbmVyYXRlVW5jYWNoZWQocHJvbXB0cywgY2FsbE9wdGlvbnMsIHJ1bm5hYmxlQ29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNhY2hlIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBsbG1TdHJpbmdLZXkgPSB0aGlzLl9nZXRTZXJpYWxpemVkQ2FjaGVLZXlQYXJhbWV0ZXJzRm9yQ2FsbChjYWxsT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHsgZ2VuZXJhdGlvbnMsIG1pc3NpbmdQcm9tcHRJbmRpY2VzLCBzdGFydGVkUnVuTWFuYWdlcnMgfSA9IGF3YWl0IHRoaXMuX2dlbmVyYXRlQ2FjaGVkKHtcbiAgICAgICAgICAgIHByb21wdHMsXG4gICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgIGxsbVN0cmluZ0tleSxcbiAgICAgICAgICAgIHBhcnNlZE9wdGlvbnM6IGNhbGxPcHRpb25zLFxuICAgICAgICAgICAgaGFuZGxlZE9wdGlvbnM6IHJ1bm5hYmxlQ29uZmlnLFxuICAgICAgICAgICAgcnVuSWQ6IHJ1bm5hYmxlQ29uZmlnLnJ1bklkLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGxsbU91dHB1dCA9IHt9O1xuICAgICAgICBpZiAobWlzc2luZ1Byb21wdEluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuX2dlbmVyYXRlVW5jYWNoZWQobWlzc2luZ1Byb21wdEluZGljZXMubWFwKChpKSA9PiBwcm9tcHRzW2ldKSwgY2FsbE9wdGlvbnMsIHJ1bm5hYmxlQ29uZmlnLCBzdGFydGVkUnVuTWFuYWdlcnMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbWlzc2luZ1Byb21wdEluZGljZXMubWFwKChpKSA9PiBzdGFydGVkUnVuTWFuYWdlcnM/LltpXSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChyZXN1bHRzLmdlbmVyYXRpb25zLm1hcChhc3luYyAoZ2VuZXJhdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9tcHRJbmRleCA9IG1pc3NpbmdQcm9tcHRJbmRpY2VzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBnZW5lcmF0aW9uc1twcm9tcHRJbmRleF0gPSBnZW5lcmF0aW9uO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZS51cGRhdGUocHJvbXB0c1twcm9tcHRJbmRleF0sIGxsbVN0cmluZ0tleSwgZ2VuZXJhdGlvbik7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBsbG1PdXRwdXQgPSByZXN1bHRzLmxsbU91dHB1dCA/PyB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBnZW5lcmF0aW9ucywgbGxtT3V0cHV0IH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSAuaW52b2tlKCkgaW5zdGVhZC4gV2lsbCBiZSByZW1vdmVkIGluIDAuMi4wLlxuICAgICAqIENvbnZlbmllbmNlIHdyYXBwZXIgZm9yIHtAbGluayBnZW5lcmF0ZX0gdGhhdCB0YWtlcyBpbiBhIHNpbmdsZSBzdHJpbmcgcHJvbXB0IGFuZCByZXR1cm5zIGEgc2luZ2xlIHN0cmluZyBvdXRwdXQuXG4gICAgICovXG4gICAgYXN5bmMgY2FsbChwcm9tcHQsIG9wdGlvbnMsIGNhbGxiYWNrcykge1xuICAgICAgICBjb25zdCB7IGdlbmVyYXRpb25zIH0gPSBhd2FpdCB0aGlzLmdlbmVyYXRlKFtwcm9tcHRdLCBvcHRpb25zLCBjYWxsYmFja3MpO1xuICAgICAgICByZXR1cm4gZ2VuZXJhdGlvbnNbMF1bMF0udGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIC5pbnZva2UoKSBpbnN0ZWFkLiBXaWxsIGJlIHJlbW92ZWQgaW4gMC4yLjAuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBzaW1pbGFyIHRvIGBjYWxsYCwgYnV0IGl0J3MgdXNlZCBmb3IgbWFraW5nIHByZWRpY3Rpb25zXG4gICAgICogYmFzZWQgb24gdGhlIGlucHV0IHRleHQuXG4gICAgICogQHBhcmFtIHRleHQgSW5wdXQgdGV4dCBmb3IgdGhlIHByZWRpY3Rpb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIExMTSBjYWxsLlxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgQ2FsbGJhY2tzIGZvciB0aGUgTExNIGNhbGwuXG4gICAgICogQHJldHVybnMgQSBwcmVkaWN0aW9uIGJhc2VkIG9uIHRoZSBpbnB1dCB0ZXh0LlxuICAgICAqL1xuICAgIGFzeW5jIHByZWRpY3QodGV4dCwgb3B0aW9ucywgY2FsbGJhY2tzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwodGV4dCwgb3B0aW9ucywgY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIC5pbnZva2UoKSBpbnN0ZWFkLiBXaWxsIGJlIHJlbW92ZWQgaW4gMC4yLjAuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCB0YWtlcyBhIGxpc3Qgb2YgbWVzc2FnZXMsIG9wdGlvbnMsIGFuZCBjYWxsYmFja3MsIGFuZFxuICAgICAqIHJldHVybnMgYSBwcmVkaWN0ZWQgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZXMgQSBsaXN0IG9mIG1lc3NhZ2VzIGZvciB0aGUgcHJlZGljdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgTExNIGNhbGwuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyBDYWxsYmFja3MgZm9yIHRoZSBMTE0gY2FsbC5cbiAgICAgKiBAcmV0dXJucyBBIHByZWRpY3RlZCBtZXNzYWdlIGJhc2VkIG9uIHRoZSBsaXN0IG9mIG1lc3NhZ2VzLlxuICAgICAqL1xuICAgIGFzeW5jIHByZWRpY3RNZXNzYWdlcyhtZXNzYWdlcywgb3B0aW9ucywgY2FsbGJhY2tzKSB7XG4gICAgICAgIGNvbnN0IHRleHQgPSAoMCwgaW5kZXhfanNfMS5nZXRCdWZmZXJTdHJpbmcpKG1lc3NhZ2VzKTtcbiAgICAgICAgY29uc3QgcHJlZGljdGlvbiA9IGF3YWl0IHRoaXMuY2FsbCh0ZXh0LCBvcHRpb25zLCBjYWxsYmFja3MpO1xuICAgICAgICByZXR1cm4gbmV3IGluZGV4X2pzXzEuQUlNZXNzYWdlKHByZWRpY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlkZW50aWZ5aW5nIHBhcmFtZXRlcnMgb2YgdGhlIExMTS5cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIF9pZGVudGlmeWluZ1BhcmFtcygpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIFJldHVybiBhIGpzb24tbGlrZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoaXMgTExNLlxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2lkZW50aWZ5aW5nUGFyYW1zKCksXG4gICAgICAgICAgICBfdHlwZTogdGhpcy5fbGxtVHlwZSgpLFxuICAgICAgICAgICAgX21vZGVsOiB0aGlzLl9tb2RlbFR5cGUoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX21vZGVsVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiYmFzZV9sbG1cIjtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VMTE0gPSBCYXNlTExNO1xuLyoqXG4gKiBMTE0gY2xhc3MgdGhhdCBwcm92aWRlcyBhIHNpbXBsZXIgaW50ZXJmYWNlIHRvIHN1YmNsYXNzIHRoYW4ge0BsaW5rIEJhc2VMTE19LlxuICpcbiAqIFJlcXVpcmVzIG9ubHkgaW1wbGVtZW50aW5nIGEgc2ltcGxlciB7QGxpbmsgX2NhbGx9IG1ldGhvZCBpbnN0ZWFkIG9mIHtAbGluayBfZ2VuZXJhdGV9LlxuICpcbiAqIEBhdWdtZW50cyBCYXNlTExNXG4gKi9cbmNsYXNzIExMTSBleHRlbmRzIEJhc2VMTE0ge1xuICAgIGFzeW5jIF9nZW5lcmF0ZShwcm9tcHRzLCBvcHRpb25zLCBydW5NYW5hZ2VyKSB7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRpb25zID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbXB0cy5tYXAoKHByb21wdCwgcHJvbXB0SW5kZXgpID0+IHRoaXMuX2NhbGwocHJvbXB0LCB7IC4uLm9wdGlvbnMsIHByb21wdEluZGV4IH0sIHJ1bk1hbmFnZXIpLnRoZW4oKHRleHQpID0+IFt7IHRleHQgfV0pKSk7XG4gICAgICAgIHJldHVybiB7IGdlbmVyYXRpb25zIH07XG4gICAgfVxufVxuZXhwb3J0cy5MTE0gPSBMTE07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/language_models/llms.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/load/map_keys.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/load/map_keys.cjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.keyToJson = keyToJson;\nexports.keyFromJson = keyFromJson;\nexports.mapKeys = mapKeys;\nconst decamelize_1 = __importDefault(__webpack_require__(/*! decamelize */ \"(rsc)/./node_modules/decamelize/index.js\"));\nconst camelcase_1 = __importDefault(__webpack_require__(/*! camelcase */ \"(rsc)/./node_modules/camelcase/index.js\"));\nfunction keyToJson(key, map) {\n    return map?.[key] || (0, decamelize_1.default)(key);\n}\nfunction keyFromJson(key, map) {\n    return map?.[key] || (0, camelcase_1.default)(key);\n}\nfunction mapKeys(fields, mapper, map) {\n    const mapped = {};\n    for (const key in fields) {\n        if (Object.hasOwn(fields, key)) {\n            mapped[mapper(key, map)] = fields[key];\n        }\n    }\n    return mapped;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbG9hZC9tYXBfa2V5cy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsbUJBQW1CO0FBQ25CLGVBQWU7QUFDZixxQ0FBcUMsbUJBQU8sQ0FBQyw0REFBWTtBQUN6RCxvQ0FBb0MsbUJBQU8sQ0FBQywwREFBVztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9sb2FkL21hcF9rZXlzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMua2V5VG9Kc29uID0ga2V5VG9Kc29uO1xuZXhwb3J0cy5rZXlGcm9tSnNvbiA9IGtleUZyb21Kc29uO1xuZXhwb3J0cy5tYXBLZXlzID0gbWFwS2V5cztcbmNvbnN0IGRlY2FtZWxpemVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVjYW1lbGl6ZVwiKSk7XG5jb25zdCBjYW1lbGNhc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY2FtZWxjYXNlXCIpKTtcbmZ1bmN0aW9uIGtleVRvSnNvbihrZXksIG1hcCkge1xuICAgIHJldHVybiBtYXA/LltrZXldIHx8ICgwLCBkZWNhbWVsaXplXzEuZGVmYXVsdCkoa2V5KTtcbn1cbmZ1bmN0aW9uIGtleUZyb21Kc29uKGtleSwgbWFwKSB7XG4gICAgcmV0dXJuIG1hcD8uW2tleV0gfHwgKDAsIGNhbWVsY2FzZV8xLmRlZmF1bHQpKGtleSk7XG59XG5mdW5jdGlvbiBtYXBLZXlzKGZpZWxkcywgbWFwcGVyLCBtYXApIHtcbiAgICBjb25zdCBtYXBwZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmaWVsZHMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oZmllbGRzLCBrZXkpKSB7XG4gICAgICAgICAgICBtYXBwZWRbbWFwcGVyKGtleSwgbWFwKV0gPSBmaWVsZHNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwcGVkO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/load/map_keys.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/load/serializable.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/load/serializable.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Serializable = void 0;\nexports.get_lc_unique_name = get_lc_unique_name;\nconst map_keys_js_1 = __webpack_require__(/*! ./map_keys.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/load/map_keys.cjs\");\nfunction shallowCopy(obj) {\n    return Array.isArray(obj) ? [...obj] : { ...obj };\n}\nfunction replaceSecrets(root, secretsMap) {\n    const result = shallowCopy(root);\n    for (const [path, secretId] of Object.entries(secretsMap)) {\n        const [last, ...partsReverse] = path.split(\".\").reverse();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let current = result;\n        for (const part of partsReverse.reverse()) {\n            if (current[part] === undefined) {\n                break;\n            }\n            current[part] = shallowCopy(current[part]);\n            current = current[part];\n        }\n        if (current[last] !== undefined) {\n            current[last] = {\n                lc: 1,\n                type: \"secret\",\n                id: [secretId],\n            };\n        }\n    }\n    return result;\n}\n/**\n * Get a unique name for the module, rather than parent class implementations.\n * Should not be subclassed, subclass lc_name above instead.\n */\nfunction get_lc_unique_name(\n// eslint-disable-next-line @typescript-eslint/no-use-before-define\nserializableClass) {\n    // \"super\" here would refer to the parent class of Serializable,\n    // when we want the parent class of the module actually calling this method.\n    const parentClass = Object.getPrototypeOf(serializableClass);\n    const lcNameIsSubclassed = typeof serializableClass.lc_name === \"function\" &&\n        (typeof parentClass.lc_name !== \"function\" ||\n            serializableClass.lc_name() !== parentClass.lc_name());\n    if (lcNameIsSubclassed) {\n        return serializableClass.lc_name();\n    }\n    else {\n        return serializableClass.name;\n    }\n}\nclass Serializable {\n    /**\n     * The name of the serializable. Override to provide an alias or\n     * to preserve the serialized module name in minified environments.\n     *\n     * Implemented as a static method to support loading logic.\n     */\n    static lc_name() {\n        return this.name;\n    }\n    /**\n     * The final serialized identifier for the module.\n     */\n    get lc_id() {\n        return [\n            ...this.lc_namespace,\n            get_lc_unique_name(this.constructor),\n        ];\n    }\n    /**\n     * A map of secrets, which will be omitted from serialization.\n     * Keys are paths to the secret in constructor args, e.g. \"foo.bar.baz\".\n     * Values are the secret ids, which will be used when deserializing.\n     */\n    get lc_secrets() {\n        return undefined;\n    }\n    /**\n     * A map of additional attributes to merge with constructor args.\n     * Keys are the attribute names, e.g. \"foo\".\n     * Values are the attribute values, which will be serialized.\n     * These attributes need to be accepted by the constructor as arguments.\n     */\n    get lc_attributes() {\n        return undefined;\n    }\n    /**\n     * A map of aliases for constructor args.\n     * Keys are the attribute names, e.g. \"foo\".\n     * Values are the alias that will replace the key in serialization.\n     * This is used to eg. make argument names match Python.\n     */\n    get lc_aliases() {\n        return undefined;\n    }\n    /**\n     * A manual list of keys that should be serialized.\n     * If not overridden, all fields passed into the constructor will be serialized.\n     */\n    get lc_serializable_keys() {\n        return undefined;\n    }\n    constructor(kwargs, ..._args) {\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (this.lc_serializable_keys !== undefined) {\n            this.lc_kwargs = Object.fromEntries(Object.entries(kwargs || {}).filter(([key]) => this.lc_serializable_keys?.includes(key)));\n        }\n        else {\n            this.lc_kwargs = kwargs ?? {};\n        }\n    }\n    toJSON() {\n        if (!this.lc_serializable) {\n            return this.toJSONNotImplemented();\n        }\n        if (\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        this.lc_kwargs instanceof Serializable ||\n            typeof this.lc_kwargs !== \"object\" ||\n            Array.isArray(this.lc_kwargs)) {\n            // We do not support serialization of classes with arg not a POJO\n            // I'm aware the check above isn't as strict as it could be\n            return this.toJSONNotImplemented();\n        }\n        const aliases = {};\n        const secrets = {};\n        const kwargs = Object.keys(this.lc_kwargs).reduce((acc, key) => {\n            acc[key] = key in this ? this[key] : this.lc_kwargs[key];\n            return acc;\n        }, {});\n        // get secrets, attributes and aliases from all superclasses\n        for (\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let current = Object.getPrototypeOf(this); current; current = Object.getPrototypeOf(current)) {\n            Object.assign(aliases, Reflect.get(current, \"lc_aliases\", this));\n            Object.assign(secrets, Reflect.get(current, \"lc_secrets\", this));\n            Object.assign(kwargs, Reflect.get(current, \"lc_attributes\", this));\n        }\n        // include all secrets used, even if not in kwargs,\n        // will be replaced with sentinel value in replaceSecrets\n        Object.keys(secrets).forEach((keyPath) => {\n            // eslint-disable-next-line @typescript-eslint/no-this-alias, @typescript-eslint/no-explicit-any\n            let read = this;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            let write = kwargs;\n            const [last, ...partsReverse] = keyPath.split(\".\").reverse();\n            for (const key of partsReverse.reverse()) {\n                if (!(key in read) || read[key] === undefined)\n                    return;\n                if (!(key in write) || write[key] === undefined) {\n                    if (typeof read[key] === \"object\" && read[key] != null) {\n                        write[key] = {};\n                    }\n                    else if (Array.isArray(read[key])) {\n                        write[key] = [];\n                    }\n                }\n                read = read[key];\n                write = write[key];\n            }\n            if (last in read && read[last] !== undefined) {\n                write[last] = write[last] || read[last];\n            }\n        });\n        return {\n            lc: 1,\n            type: \"constructor\",\n            id: this.lc_id,\n            kwargs: (0, map_keys_js_1.mapKeys)(Object.keys(secrets).length ? replaceSecrets(kwargs, secrets) : kwargs, map_keys_js_1.keyToJson, aliases),\n        };\n    }\n    toJSONNotImplemented() {\n        return {\n            lc: 1,\n            type: \"not_implemented\",\n            id: this.lc_id,\n        };\n    }\n}\nexports.Serializable = Serializable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbG9hZC9zZXJpYWxpemFibGUuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQiwwQkFBMEI7QUFDMUIsc0JBQXNCLG1CQUFPLENBQUMsbUZBQWdCO0FBQzlDO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2xvYWQvc2VyaWFsaXphYmxlLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2VyaWFsaXphYmxlID0gdm9pZCAwO1xuZXhwb3J0cy5nZXRfbGNfdW5pcXVlX25hbWUgPSBnZXRfbGNfdW5pcXVlX25hbWU7XG5jb25zdCBtYXBfa2V5c19qc18xID0gcmVxdWlyZShcIi4vbWFwX2tleXMuY2pzXCIpO1xuZnVuY3Rpb24gc2hhbGxvd0NvcHkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKSA/IFsuLi5vYmpdIDogeyAuLi5vYmogfTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VTZWNyZXRzKHJvb3QsIHNlY3JldHNNYXApIHtcbiAgICBjb25zdCByZXN1bHQgPSBzaGFsbG93Q29weShyb290KTtcbiAgICBmb3IgKGNvbnN0IFtwYXRoLCBzZWNyZXRJZF0gb2YgT2JqZWN0LmVudHJpZXMoc2VjcmV0c01hcCkpIHtcbiAgICAgICAgY29uc3QgW2xhc3QsIC4uLnBhcnRzUmV2ZXJzZV0gPSBwYXRoLnNwbGl0KFwiLlwiKS5yZXZlcnNlKCk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGxldCBjdXJyZW50ID0gcmVzdWx0O1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHNSZXZlcnNlLnJldmVyc2UoKSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRbcGFydF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFtwYXJ0XSA9IHNoYWxsb3dDb3B5KGN1cnJlbnRbcGFydF0pO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbcGFydF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRbbGFzdF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY3VycmVudFtsYXN0XSA9IHtcbiAgICAgICAgICAgICAgICBsYzogMSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNlY3JldFwiLFxuICAgICAgICAgICAgICAgIGlkOiBbc2VjcmV0SWRdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBHZXQgYSB1bmlxdWUgbmFtZSBmb3IgdGhlIG1vZHVsZSwgcmF0aGVyIHRoYW4gcGFyZW50IGNsYXNzIGltcGxlbWVudGF0aW9ucy5cbiAqIFNob3VsZCBub3QgYmUgc3ViY2xhc3NlZCwgc3ViY2xhc3MgbGNfbmFtZSBhYm92ZSBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiBnZXRfbGNfdW5pcXVlX25hbWUoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG5zZXJpYWxpemFibGVDbGFzcykge1xuICAgIC8vIFwic3VwZXJcIiBoZXJlIHdvdWxkIHJlZmVyIHRvIHRoZSBwYXJlbnQgY2xhc3Mgb2YgU2VyaWFsaXphYmxlLFxuICAgIC8vIHdoZW4gd2Ugd2FudCB0aGUgcGFyZW50IGNsYXNzIG9mIHRoZSBtb2R1bGUgYWN0dWFsbHkgY2FsbGluZyB0aGlzIG1ldGhvZC5cbiAgICBjb25zdCBwYXJlbnRDbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihzZXJpYWxpemFibGVDbGFzcyk7XG4gICAgY29uc3QgbGNOYW1lSXNTdWJjbGFzc2VkID0gdHlwZW9mIHNlcmlhbGl6YWJsZUNsYXNzLmxjX25hbWUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAodHlwZW9mIHBhcmVudENsYXNzLmxjX25hbWUgIT09IFwiZnVuY3Rpb25cIiB8fFxuICAgICAgICAgICAgc2VyaWFsaXphYmxlQ2xhc3MubGNfbmFtZSgpICE9PSBwYXJlbnRDbGFzcy5sY19uYW1lKCkpO1xuICAgIGlmIChsY05hbWVJc1N1YmNsYXNzZWQpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6YWJsZUNsYXNzLmxjX25hbWUoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemFibGVDbGFzcy5uYW1lO1xuICAgIH1cbn1cbmNsYXNzIFNlcmlhbGl6YWJsZSB7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHNlcmlhbGl6YWJsZS4gT3ZlcnJpZGUgdG8gcHJvdmlkZSBhbiBhbGlhcyBvclxuICAgICAqIHRvIHByZXNlcnZlIHRoZSBzZXJpYWxpemVkIG1vZHVsZSBuYW1lIGluIG1pbmlmaWVkIGVudmlyb25tZW50cy5cbiAgICAgKlxuICAgICAqIEltcGxlbWVudGVkIGFzIGEgc3RhdGljIG1ldGhvZCB0byBzdXBwb3J0IGxvYWRpbmcgbG9naWMuXG4gICAgICovXG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmaW5hbCBzZXJpYWxpemVkIGlkZW50aWZpZXIgZm9yIHRoZSBtb2R1bGUuXG4gICAgICovXG4gICAgZ2V0IGxjX2lkKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLi4udGhpcy5sY19uYW1lc3BhY2UsXG4gICAgICAgICAgICBnZXRfbGNfdW5pcXVlX25hbWUodGhpcy5jb25zdHJ1Y3RvciksXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbWFwIG9mIHNlY3JldHMsIHdoaWNoIHdpbGwgYmUgb21pdHRlZCBmcm9tIHNlcmlhbGl6YXRpb24uXG4gICAgICogS2V5cyBhcmUgcGF0aHMgdG8gdGhlIHNlY3JldCBpbiBjb25zdHJ1Y3RvciBhcmdzLCBlLmcuIFwiZm9vLmJhci5iYXpcIi5cbiAgICAgKiBWYWx1ZXMgYXJlIHRoZSBzZWNyZXQgaWRzLCB3aGljaCB3aWxsIGJlIHVzZWQgd2hlbiBkZXNlcmlhbGl6aW5nLlxuICAgICAqL1xuICAgIGdldCBsY19zZWNyZXRzKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIG1hcCBvZiBhZGRpdGlvbmFsIGF0dHJpYnV0ZXMgdG8gbWVyZ2Ugd2l0aCBjb25zdHJ1Y3RvciBhcmdzLlxuICAgICAqIEtleXMgYXJlIHRoZSBhdHRyaWJ1dGUgbmFtZXMsIGUuZy4gXCJmb29cIi5cbiAgICAgKiBWYWx1ZXMgYXJlIHRoZSBhdHRyaWJ1dGUgdmFsdWVzLCB3aGljaCB3aWxsIGJlIHNlcmlhbGl6ZWQuXG4gICAgICogVGhlc2UgYXR0cmlidXRlcyBuZWVkIHRvIGJlIGFjY2VwdGVkIGJ5IHRoZSBjb25zdHJ1Y3RvciBhcyBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZ2V0IGxjX2F0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbWFwIG9mIGFsaWFzZXMgZm9yIGNvbnN0cnVjdG9yIGFyZ3MuXG4gICAgICogS2V5cyBhcmUgdGhlIGF0dHJpYnV0ZSBuYW1lcywgZS5nLiBcImZvb1wiLlxuICAgICAqIFZhbHVlcyBhcmUgdGhlIGFsaWFzIHRoYXQgd2lsbCByZXBsYWNlIHRoZSBrZXkgaW4gc2VyaWFsaXphdGlvbi5cbiAgICAgKiBUaGlzIGlzIHVzZWQgdG8gZWcuIG1ha2UgYXJndW1lbnQgbmFtZXMgbWF0Y2ggUHl0aG9uLlxuICAgICAqL1xuICAgIGdldCBsY19hbGlhc2VzKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIG1hbnVhbCBsaXN0IG9mIGtleXMgdGhhdCBzaG91bGQgYmUgc2VyaWFsaXplZC5cbiAgICAgKiBJZiBub3Qgb3ZlcnJpZGRlbiwgYWxsIGZpZWxkcyBwYXNzZWQgaW50byB0aGUgY29uc3RydWN0b3Igd2lsbCBiZSBzZXJpYWxpemVkLlxuICAgICAqL1xuICAgIGdldCBsY19zZXJpYWxpemFibGVfa2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioa3dhcmdzLCAuLi5fYXJncykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19rd2FyZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMubGNfc2VyaWFsaXphYmxlX2tleXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5sY19rd2FyZ3MgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoa3dhcmdzIHx8IHt9KS5maWx0ZXIoKFtrZXldKSA9PiB0aGlzLmxjX3NlcmlhbGl6YWJsZV9rZXlzPy5pbmNsdWRlcyhrZXkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxjX2t3YXJncyA9IGt3YXJncyA/PyB7fTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGlmICghdGhpcy5sY19zZXJpYWxpemFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvSlNPTk5vdEltcGxlbWVudGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgIHRoaXMubGNfa3dhcmdzIGluc3RhbmNlb2YgU2VyaWFsaXphYmxlIHx8XG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5sY19rd2FyZ3MgIT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodGhpcy5sY19rd2FyZ3MpKSB7XG4gICAgICAgICAgICAvLyBXZSBkbyBub3Qgc3VwcG9ydCBzZXJpYWxpemF0aW9uIG9mIGNsYXNzZXMgd2l0aCBhcmcgbm90IGEgUE9KT1xuICAgICAgICAgICAgLy8gSSdtIGF3YXJlIHRoZSBjaGVjayBhYm92ZSBpc24ndCBhcyBzdHJpY3QgYXMgaXQgY291bGQgYmVcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvSlNPTk5vdEltcGxlbWVudGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxpYXNlcyA9IHt9O1xuICAgICAgICBjb25zdCBzZWNyZXRzID0ge307XG4gICAgICAgIGNvbnN0IGt3YXJncyA9IE9iamVjdC5rZXlzKHRoaXMubGNfa3dhcmdzKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IGtleSBpbiB0aGlzID8gdGhpc1trZXldIDogdGhpcy5sY19rd2FyZ3Nba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgLy8gZ2V0IHNlY3JldHMsIGF0dHJpYnV0ZXMgYW5kIGFsaWFzZXMgZnJvbSBhbGwgc3VwZXJjbGFzc2VzXG4gICAgICAgIGZvciAoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICBsZXQgY3VycmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKTsgY3VycmVudDsgY3VycmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjdXJyZW50KSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihhbGlhc2VzLCBSZWZsZWN0LmdldChjdXJyZW50LCBcImxjX2FsaWFzZXNcIiwgdGhpcykpO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzZWNyZXRzLCBSZWZsZWN0LmdldChjdXJyZW50LCBcImxjX3NlY3JldHNcIiwgdGhpcykpO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihrd2FyZ3MsIFJlZmxlY3QuZ2V0KGN1cnJlbnQsIFwibGNfYXR0cmlidXRlc1wiLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW5jbHVkZSBhbGwgc2VjcmV0cyB1c2VkLCBldmVuIGlmIG5vdCBpbiBrd2FyZ3MsXG4gICAgICAgIC8vIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBzZW50aW5lbCB2YWx1ZSBpbiByZXBsYWNlU2VjcmV0c1xuICAgICAgICBPYmplY3Qua2V5cyhzZWNyZXRzKS5mb3JFYWNoKChrZXlQYXRoKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXMsIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGxldCByZWFkID0gdGhpcztcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBsZXQgd3JpdGUgPSBrd2FyZ3M7XG4gICAgICAgICAgICBjb25zdCBbbGFzdCwgLi4ucGFydHNSZXZlcnNlXSA9IGtleVBhdGguc3BsaXQoXCIuXCIpLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHBhcnRzUmV2ZXJzZS5yZXZlcnNlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gcmVhZCkgfHwgcmVhZFtrZXldID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gd3JpdGUpIHx8IHdyaXRlW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlYWRba2V5XSA9PT0gXCJvYmplY3RcIiAmJiByZWFkW2tleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVhZFtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVba2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlYWQgPSByZWFkW2tleV07XG4gICAgICAgICAgICAgICAgd3JpdGUgPSB3cml0ZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3QgaW4gcmVhZCAmJiByZWFkW2xhc3RdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB3cml0ZVtsYXN0XSA9IHdyaXRlW2xhc3RdIHx8IHJlYWRbbGFzdF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGM6IDEsXG4gICAgICAgICAgICB0eXBlOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICBpZDogdGhpcy5sY19pZCxcbiAgICAgICAgICAgIGt3YXJnczogKDAsIG1hcF9rZXlzX2pzXzEubWFwS2V5cykoT2JqZWN0LmtleXMoc2VjcmV0cykubGVuZ3RoID8gcmVwbGFjZVNlY3JldHMoa3dhcmdzLCBzZWNyZXRzKSA6IGt3YXJncywgbWFwX2tleXNfanNfMS5rZXlUb0pzb24sIGFsaWFzZXMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0b0pTT05Ob3RJbXBsZW1lbnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxjOiAxLFxuICAgICAgICAgICAgdHlwZTogXCJub3RfaW1wbGVtZW50ZWRcIixcbiAgICAgICAgICAgIGlkOiB0aGlzLmxjX2lkLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuU2VyaWFsaXphYmxlID0gU2VyaWFsaXphYmxlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/load/serializable.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/ai.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/ai.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AIMessageChunk = exports.AIMessage = void 0;\nexports.isAIMessage = isAIMessage;\nexports.isAIMessageChunk = isAIMessageChunk;\nconst json_js_1 = __webpack_require__(/*! ../utils/json.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json.cjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\nconst tool_js_1 = __webpack_require__(/*! ./tool.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/tool.cjs\");\n/**\n * Represents an AI message in a conversation.\n */\nclass AIMessage extends base_js_1.BaseMessage {\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return {\n            ...super.lc_aliases,\n            tool_calls: \"tool_calls\",\n            invalid_tool_calls: \"invalid_tool_calls\",\n        };\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        let initParams;\n        if (typeof fields === \"string\") {\n            initParams = {\n                content: fields,\n                tool_calls: [],\n                invalid_tool_calls: [],\n                additional_kwargs: kwargs ?? {},\n            };\n        }\n        else {\n            initParams = fields;\n            const rawToolCalls = initParams.additional_kwargs?.tool_calls;\n            const toolCalls = initParams.tool_calls;\n            if (!(rawToolCalls == null) &&\n                rawToolCalls.length > 0 &&\n                (toolCalls === undefined || toolCalls.length === 0)) {\n                console.warn([\n                    \"New LangChain packages are available that more efficiently handle\",\n                    \"tool calling.\\n\\nPlease upgrade your packages to versions that set\",\n                    \"message tool calls. e.g., `yarn add @langchain/anthropic`,\",\n                    \"yarn add @langchain/openai`, etc.\",\n                ].join(\" \"));\n            }\n            try {\n                if (!(rawToolCalls == null) && toolCalls === undefined) {\n                    const [toolCalls, invalidToolCalls] = (0, tool_js_1.defaultToolCallParser)(rawToolCalls);\n                    initParams.tool_calls = toolCalls ?? [];\n                    initParams.invalid_tool_calls = invalidToolCalls ?? [];\n                }\n                else {\n                    initParams.tool_calls = initParams.tool_calls ?? [];\n                    initParams.invalid_tool_calls = initParams.invalid_tool_calls ?? [];\n                }\n            }\n            catch (e) {\n                // Do nothing if parsing fails\n                initParams.tool_calls = [];\n                initParams.invalid_tool_calls = [];\n            }\n        }\n        // Sadly, TypeScript only allows super() calls at root if the class has\n        // properties with initializers, so we have to check types twice.\n        super(initParams);\n        // These are typed as optional to avoid breaking changes and allow for casting\n        // from BaseMessage.\n        Object.defineProperty(this, \"tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"invalid_tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        /**\n         * If provided, token usage information associated with the message.\n         */\n        Object.defineProperty(this, \"usage_metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (typeof initParams !== \"string\") {\n            this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n            this.invalid_tool_calls =\n                initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n        }\n        this.usage_metadata = initParams.usage_metadata;\n    }\n    static lc_name() {\n        return \"AIMessage\";\n    }\n    _getType() {\n        return \"ai\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            tool_calls: this.tool_calls,\n            invalid_tool_calls: this.invalid_tool_calls,\n            usage_metadata: this.usage_metadata,\n        };\n    }\n}\nexports.AIMessage = AIMessage;\nfunction isAIMessage(x) {\n    return x._getType() === \"ai\";\n}\nfunction isAIMessageChunk(x) {\n    return x._getType() === \"ai\";\n}\n/**\n * Represents a chunk of an AI message, which can be concatenated with\n * other AI message chunks.\n */\nclass AIMessageChunk extends base_js_1.BaseMessageChunk {\n    constructor(fields) {\n        let initParams;\n        if (typeof fields === \"string\") {\n            initParams = {\n                content: fields,\n                tool_calls: [],\n                invalid_tool_calls: [],\n                tool_call_chunks: [],\n            };\n        }\n        else if (fields.tool_call_chunks === undefined) {\n            initParams = {\n                ...fields,\n                tool_calls: fields.tool_calls ?? [],\n                invalid_tool_calls: [],\n                tool_call_chunks: [],\n                usage_metadata: fields.usage_metadata !== undefined\n                    ? fields.usage_metadata\n                    : undefined,\n            };\n        }\n        else {\n            const groupedToolCallChunks = fields.tool_call_chunks.reduce((acc, chunk) => {\n                const matchedChunkIndex = acc.findIndex(([match]) => {\n                    // If chunk has an id and index, match if both are present\n                    if (\"id\" in chunk &&\n                        chunk.id &&\n                        \"index\" in chunk &&\n                        chunk.index !== undefined) {\n                        return chunk.id === match.id && chunk.index === match.index;\n                    }\n                    // If chunk has an id, we match on id\n                    if (\"id\" in chunk && chunk.id) {\n                        return chunk.id === match.id;\n                    }\n                    // If chunk has an index, we match on index\n                    if (\"index\" in chunk && chunk.index !== undefined) {\n                        return chunk.index === match.index;\n                    }\n                    return false;\n                });\n                if (matchedChunkIndex !== -1) {\n                    acc[matchedChunkIndex].push(chunk);\n                }\n                else {\n                    acc.push([chunk]);\n                }\n                return acc;\n            }, []);\n            const toolCalls = [];\n            const invalidToolCalls = [];\n            for (const chunks of groupedToolCallChunks) {\n                let parsedArgs = {};\n                const name = chunks[0]?.name ?? \"\";\n                const joinedArgs = chunks.map((c) => c.args || \"\").join(\"\");\n                const argsStr = joinedArgs.length ? joinedArgs : \"{}\";\n                const id = chunks[0]?.id;\n                try {\n                    parsedArgs = (0, json_js_1.parsePartialJson)(argsStr);\n                    if (!id ||\n                        parsedArgs === null ||\n                        typeof parsedArgs !== \"object\" ||\n                        Array.isArray(parsedArgs)) {\n                        throw new Error(\"Malformed tool call chunk args.\");\n                    }\n                    toolCalls.push({\n                        name,\n                        args: parsedArgs,\n                        id,\n                        type: \"tool_call\",\n                    });\n                }\n                catch (e) {\n                    invalidToolCalls.push({\n                        name,\n                        args: argsStr,\n                        id,\n                        error: \"Malformed args.\",\n                        type: \"invalid_tool_call\",\n                    });\n                }\n            }\n            initParams = {\n                ...fields,\n                tool_calls: toolCalls,\n                invalid_tool_calls: invalidToolCalls,\n                usage_metadata: fields.usage_metadata !== undefined\n                    ? fields.usage_metadata\n                    : undefined,\n            };\n        }\n        // Sadly, TypeScript only allows super() calls at root if the class has\n        // properties with initializers, so we have to check types twice.\n        super(initParams);\n        // Must redeclare tool call fields since there is no multiple inheritance in JS.\n        // These are typed as optional to avoid breaking changes and allow for casting\n        // from BaseMessage.\n        Object.defineProperty(this, \"tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"invalid_tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"tool_call_chunks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        /**\n         * If provided, token usage information associated with the message.\n         */\n        Object.defineProperty(this, \"usage_metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tool_call_chunks =\n            initParams.tool_call_chunks ?? this.tool_call_chunks;\n        this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n        this.invalid_tool_calls =\n            initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n        this.usage_metadata = initParams.usage_metadata;\n    }\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return {\n            ...super.lc_aliases,\n            tool_calls: \"tool_calls\",\n            invalid_tool_calls: \"invalid_tool_calls\",\n            tool_call_chunks: \"tool_call_chunks\",\n        };\n    }\n    static lc_name() {\n        return \"AIMessageChunk\";\n    }\n    _getType() {\n        return \"ai\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            tool_calls: this.tool_calls,\n            tool_call_chunks: this.tool_call_chunks,\n            invalid_tool_calls: this.invalid_tool_calls,\n            usage_metadata: this.usage_metadata,\n        };\n    }\n    concat(chunk) {\n        const combinedFields = {\n            content: (0, base_js_1.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0, base_js_1._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0, base_js_1._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            tool_call_chunks: [],\n            id: this.id ?? chunk.id,\n        };\n        if (this.tool_call_chunks !== undefined ||\n            chunk.tool_call_chunks !== undefined) {\n            const rawToolCalls = (0, base_js_1._mergeLists)(this.tool_call_chunks, chunk.tool_call_chunks);\n            if (rawToolCalls !== undefined && rawToolCalls.length > 0) {\n                combinedFields.tool_call_chunks = rawToolCalls;\n            }\n        }\n        if (this.usage_metadata !== undefined ||\n            chunk.usage_metadata !== undefined) {\n            const inputTokenDetails = {\n                ...((this.usage_metadata?.input_token_details?.audio !== undefined ||\n                    chunk.usage_metadata?.input_token_details?.audio !== undefined) && {\n                    audio: (this.usage_metadata?.input_token_details?.audio ?? 0) +\n                        (chunk.usage_metadata?.input_token_details?.audio ?? 0),\n                }),\n                ...((this.usage_metadata?.input_token_details?.cache_read !==\n                    undefined ||\n                    chunk.usage_metadata?.input_token_details?.cache_read !==\n                        undefined) && {\n                    cache_read: (this.usage_metadata?.input_token_details?.cache_read ?? 0) +\n                        (chunk.usage_metadata?.input_token_details?.cache_read ?? 0),\n                }),\n                ...((this.usage_metadata?.input_token_details?.cache_creation !==\n                    undefined ||\n                    chunk.usage_metadata?.input_token_details?.cache_creation !==\n                        undefined) && {\n                    cache_creation: (this.usage_metadata?.input_token_details?.cache_creation ?? 0) +\n                        (chunk.usage_metadata?.input_token_details?.cache_creation ?? 0),\n                }),\n            };\n            const outputTokenDetails = {\n                ...((this.usage_metadata?.output_token_details?.audio !== undefined ||\n                    chunk.usage_metadata?.output_token_details?.audio !== undefined) && {\n                    audio: (this.usage_metadata?.output_token_details?.audio ?? 0) +\n                        (chunk.usage_metadata?.output_token_details?.audio ?? 0),\n                }),\n                ...((this.usage_metadata?.output_token_details?.reasoning !==\n                    undefined ||\n                    chunk.usage_metadata?.output_token_details?.reasoning !==\n                        undefined) && {\n                    reasoning: (this.usage_metadata?.output_token_details?.reasoning ?? 0) +\n                        (chunk.usage_metadata?.output_token_details?.reasoning ?? 0),\n                }),\n            };\n            const left = this.usage_metadata ?? {\n                input_tokens: 0,\n                output_tokens: 0,\n                total_tokens: 0,\n            };\n            const right = chunk.usage_metadata ?? {\n                input_tokens: 0,\n                output_tokens: 0,\n                total_tokens: 0,\n            };\n            const usage_metadata = {\n                input_tokens: left.input_tokens + right.input_tokens,\n                output_tokens: left.output_tokens + right.output_tokens,\n                total_tokens: left.total_tokens + right.total_tokens,\n                // Do not include `input_token_details` / `output_token_details` keys in combined fields\n                // unless their values are defined.\n                ...(Object.keys(inputTokenDetails).length > 0 && {\n                    input_token_details: inputTokenDetails,\n                }),\n                ...(Object.keys(outputTokenDetails).length > 0 && {\n                    output_token_details: outputTokenDetails,\n                }),\n            };\n            combinedFields.usage_metadata = usage_metadata;\n        }\n        return new AIMessageChunk(combinedFields);\n    }\n}\nexports.AIMessageChunk = AIMessageChunk;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvYWkuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLGlCQUFpQjtBQUMxQyxtQkFBbUI7QUFDbkIsd0JBQXdCO0FBQ3hCLGtCQUFrQixtQkFBTyxDQUFDLG1GQUFtQjtBQUM3QyxrQkFBa0IsbUJBQU8sQ0FBQywrRUFBWTtBQUN0QyxrQkFBa0IsbUJBQU8sQ0FBQywrRUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvYWkuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BSU1lc3NhZ2VDaHVuayA9IGV4cG9ydHMuQUlNZXNzYWdlID0gdm9pZCAwO1xuZXhwb3J0cy5pc0FJTWVzc2FnZSA9IGlzQUlNZXNzYWdlO1xuZXhwb3J0cy5pc0FJTWVzc2FnZUNodW5rID0gaXNBSU1lc3NhZ2VDaHVuaztcbmNvbnN0IGpzb25fanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9qc29uLmNqc1wiKTtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2UuY2pzXCIpO1xuY29uc3QgdG9vbF9qc18xID0gcmVxdWlyZShcIi4vdG9vbC5janNcIik7XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gQUkgbWVzc2FnZSBpbiBhIGNvbnZlcnNhdGlvbi5cbiAqL1xuY2xhc3MgQUlNZXNzYWdlIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VNZXNzYWdlIHtcbiAgICBnZXQgbGNfYWxpYXNlcygpIHtcbiAgICAgICAgLy8gZXhjbHVkZSBzbmFrZSBjYXNlIGNvbnZlcnNpb24gdG8gcGFzY2FsIGNhc2VcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLmxjX2FsaWFzZXMsXG4gICAgICAgICAgICB0b29sX2NhbGxzOiBcInRvb2xfY2FsbHNcIixcbiAgICAgICAgICAgIGludmFsaWRfdG9vbF9jYWxsczogXCJpbnZhbGlkX3Rvb2xfY2FsbHNcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCBcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBrd2FyZ3MpIHtcbiAgICAgICAgbGV0IGluaXRQYXJhbXM7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpbml0UGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGZpZWxkcyxcbiAgICAgICAgICAgICAgICB0b29sX2NhbGxzOiBbXSxcbiAgICAgICAgICAgICAgICBpbnZhbGlkX3Rvb2xfY2FsbHM6IFtdLFxuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiBrd2FyZ3MgPz8ge30sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5pdFBhcmFtcyA9IGZpZWxkcztcbiAgICAgICAgICAgIGNvbnN0IHJhd1Rvb2xDYWxscyA9IGluaXRQYXJhbXMuYWRkaXRpb25hbF9rd2FyZ3M/LnRvb2xfY2FsbHM7XG4gICAgICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBpbml0UGFyYW1zLnRvb2xfY2FsbHM7XG4gICAgICAgICAgICBpZiAoIShyYXdUb29sQ2FsbHMgPT0gbnVsbCkgJiZcbiAgICAgICAgICAgICAgICByYXdUb29sQ2FsbHMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICh0b29sQ2FsbHMgPT09IHVuZGVmaW5lZCB8fCB0b29sQ2FsbHMubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihbXG4gICAgICAgICAgICAgICAgICAgIFwiTmV3IExhbmdDaGFpbiBwYWNrYWdlcyBhcmUgYXZhaWxhYmxlIHRoYXQgbW9yZSBlZmZpY2llbnRseSBoYW5kbGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ0b29sIGNhbGxpbmcuXFxuXFxuUGxlYXNlIHVwZ3JhZGUgeW91ciBwYWNrYWdlcyB0byB2ZXJzaW9ucyB0aGF0IHNldFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm1lc3NhZ2UgdG9vbCBjYWxscy4gZS5nLiwgYHlhcm4gYWRkIEBsYW5nY2hhaW4vYW50aHJvcGljYCxcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ5YXJuIGFkZCBAbGFuZ2NoYWluL29wZW5haWAsIGV0Yy5cIixcbiAgICAgICAgICAgICAgICBdLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocmF3VG9vbENhbGxzID09IG51bGwpICYmIHRvb2xDYWxscyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFt0b29sQ2FsbHMsIGludmFsaWRUb29sQ2FsbHNdID0gKDAsIHRvb2xfanNfMS5kZWZhdWx0VG9vbENhbGxQYXJzZXIpKHJhd1Rvb2xDYWxscyk7XG4gICAgICAgICAgICAgICAgICAgIGluaXRQYXJhbXMudG9vbF9jYWxscyA9IHRvb2xDYWxscyA/PyBbXTtcbiAgICAgICAgICAgICAgICAgICAgaW5pdFBhcmFtcy5pbnZhbGlkX3Rvb2xfY2FsbHMgPSBpbnZhbGlkVG9vbENhbGxzID8/IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdFBhcmFtcy50b29sX2NhbGxzID0gaW5pdFBhcmFtcy50b29sX2NhbGxzID8/IFtdO1xuICAgICAgICAgICAgICAgICAgICBpbml0UGFyYW1zLmludmFsaWRfdG9vbF9jYWxscyA9IGluaXRQYXJhbXMuaW52YWxpZF90b29sX2NhbGxzID8/IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiBwYXJzaW5nIGZhaWxzXG4gICAgICAgICAgICAgICAgaW5pdFBhcmFtcy50b29sX2NhbGxzID0gW107XG4gICAgICAgICAgICAgICAgaW5pdFBhcmFtcy5pbnZhbGlkX3Rvb2xfY2FsbHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTYWRseSwgVHlwZVNjcmlwdCBvbmx5IGFsbG93cyBzdXBlcigpIGNhbGxzIGF0IHJvb3QgaWYgdGhlIGNsYXNzIGhhc1xuICAgICAgICAvLyBwcm9wZXJ0aWVzIHdpdGggaW5pdGlhbGl6ZXJzLCBzbyB3ZSBoYXZlIHRvIGNoZWNrIHR5cGVzIHR3aWNlLlxuICAgICAgICBzdXBlcihpbml0UGFyYW1zKTtcbiAgICAgICAgLy8gVGhlc2UgYXJlIHR5cGVkIGFzIG9wdGlvbmFsIHRvIGF2b2lkIGJyZWFraW5nIGNoYW5nZXMgYW5kIGFsbG93IGZvciBjYXN0aW5nXG4gICAgICAgIC8vIGZyb20gQmFzZU1lc3NhZ2UuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvb2xfY2FsbHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnZhbGlkX3Rvb2xfY2FsbHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgcHJvdmlkZWQsIHRva2VuIHVzYWdlIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgbWVzc2FnZS5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVzYWdlX21ldGFkYXRhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2YgaW5pdFBhcmFtcyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy50b29sX2NhbGxzID0gaW5pdFBhcmFtcy50b29sX2NhbGxzID8/IHRoaXMudG9vbF9jYWxscztcbiAgICAgICAgICAgIHRoaXMuaW52YWxpZF90b29sX2NhbGxzID1cbiAgICAgICAgICAgICAgICBpbml0UGFyYW1zLmludmFsaWRfdG9vbF9jYWxscyA/PyB0aGlzLmludmFsaWRfdG9vbF9jYWxscztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVzYWdlX21ldGFkYXRhID0gaW5pdFBhcmFtcy51c2FnZV9tZXRhZGF0YTtcbiAgICB9XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkFJTWVzc2FnZVwiO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiYWlcIjtcbiAgICB9XG4gICAgZ2V0IF9wcmludGFibGVGaWVsZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci5fcHJpbnRhYmxlRmllbGRzLFxuICAgICAgICAgICAgdG9vbF9jYWxsczogdGhpcy50b29sX2NhbGxzLFxuICAgICAgICAgICAgaW52YWxpZF90b29sX2NhbGxzOiB0aGlzLmludmFsaWRfdG9vbF9jYWxscyxcbiAgICAgICAgICAgIHVzYWdlX21ldGFkYXRhOiB0aGlzLnVzYWdlX21ldGFkYXRhLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQUlNZXNzYWdlID0gQUlNZXNzYWdlO1xuZnVuY3Rpb24gaXNBSU1lc3NhZ2UoeCkge1xuICAgIHJldHVybiB4Ll9nZXRUeXBlKCkgPT09IFwiYWlcIjtcbn1cbmZ1bmN0aW9uIGlzQUlNZXNzYWdlQ2h1bmsoeCkge1xuICAgIHJldHVybiB4Ll9nZXRUeXBlKCkgPT09IFwiYWlcIjtcbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIGNodW5rIG9mIGFuIEFJIG1lc3NhZ2UsIHdoaWNoIGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aFxuICogb3RoZXIgQUkgbWVzc2FnZSBjaHVua3MuXG4gKi9cbmNsYXNzIEFJTWVzc2FnZUNodW5rIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VNZXNzYWdlQ2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBsZXQgaW5pdFBhcmFtcztcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGluaXRQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY29udGVudDogZmllbGRzLFxuICAgICAgICAgICAgICAgIHRvb2xfY2FsbHM6IFtdLFxuICAgICAgICAgICAgICAgIGludmFsaWRfdG9vbF9jYWxsczogW10sXG4gICAgICAgICAgICAgICAgdG9vbF9jYWxsX2NodW5rczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpZWxkcy50b29sX2NhbGxfY2h1bmtzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluaXRQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgICAgICAgIHRvb2xfY2FsbHM6IGZpZWxkcy50b29sX2NhbGxzID8/IFtdLFxuICAgICAgICAgICAgICAgIGludmFsaWRfdG9vbF9jYWxsczogW10sXG4gICAgICAgICAgICAgICAgdG9vbF9jYWxsX2NodW5rczogW10sXG4gICAgICAgICAgICAgICAgdXNhZ2VfbWV0YWRhdGE6IGZpZWxkcy51c2FnZV9tZXRhZGF0YSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gZmllbGRzLnVzYWdlX21ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwZWRUb29sQ2FsbENodW5rcyA9IGZpZWxkcy50b29sX2NhbGxfY2h1bmtzLnJlZHVjZSgoYWNjLCBjaHVuaykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZWRDaHVua0luZGV4ID0gYWNjLmZpbmRJbmRleCgoW21hdGNoXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBjaHVuayBoYXMgYW4gaWQgYW5kIGluZGV4LCBtYXRjaCBpZiBib3RoIGFyZSBwcmVzZW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImlkXCIgaW4gY2h1bmsgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLmlkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBcImluZGV4XCIgaW4gY2h1bmsgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLmluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaHVuay5pZCA9PT0gbWF0Y2guaWQgJiYgY2h1bmsuaW5kZXggPT09IG1hdGNoLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGNodW5rIGhhcyBhbiBpZCwgd2UgbWF0Y2ggb24gaWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiaWRcIiBpbiBjaHVuayAmJiBjaHVuay5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNodW5rLmlkID09PSBtYXRjaC5pZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBjaHVuayBoYXMgYW4gaW5kZXgsIHdlIG1hdGNoIG9uIGluZGV4XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImluZGV4XCIgaW4gY2h1bmsgJiYgY2h1bmsuaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNodW5rLmluZGV4ID09PSBtYXRjaC5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZWRDaHVua0luZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBhY2NbbWF0Y2hlZENodW5rSW5kZXhdLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjLnB1c2goW2NodW5rXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGludmFsaWRUb29sQ2FsbHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2h1bmtzIG9mIGdyb3VwZWRUb29sQ2FsbENodW5rcykge1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZWRBcmdzID0ge307XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNodW5rc1swXT8ubmFtZSA/PyBcIlwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IGpvaW5lZEFyZ3MgPSBjaHVua3MubWFwKChjKSA9PiBjLmFyZ3MgfHwgXCJcIikuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzU3RyID0gam9pbmVkQXJncy5sZW5ndGggPyBqb2luZWRBcmdzIDogXCJ7fVwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gY2h1bmtzWzBdPy5pZDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRBcmdzID0gKDAsIGpzb25fanNfMS5wYXJzZVBhcnRpYWxKc29uKShhcmdzU3RyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkQXJncyA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHBhcnNlZEFyZ3MgIT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocGFyc2VkQXJncykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCB0b29sIGNhbGwgY2h1bmsgYXJncy5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IHBhcnNlZEFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbF9jYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkVG9vbENhbGxzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NTdHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBcIk1hbGZvcm1lZCBhcmdzLlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkX3Rvb2xfY2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbml0UGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAgICAgICB0b29sX2NhbGxzOiB0b29sQ2FsbHMsXG4gICAgICAgICAgICAgICAgaW52YWxpZF90b29sX2NhbGxzOiBpbnZhbGlkVG9vbENhbGxzLFxuICAgICAgICAgICAgICAgIHVzYWdlX21ldGFkYXRhOiBmaWVsZHMudXNhZ2VfbWV0YWRhdGEgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IGZpZWxkcy51c2FnZV9tZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2FkbHksIFR5cGVTY3JpcHQgb25seSBhbGxvd3Mgc3VwZXIoKSBjYWxscyBhdCByb290IGlmIHRoZSBjbGFzcyBoYXNcbiAgICAgICAgLy8gcHJvcGVydGllcyB3aXRoIGluaXRpYWxpemVycywgc28gd2UgaGF2ZSB0byBjaGVjayB0eXBlcyB0d2ljZS5cbiAgICAgICAgc3VwZXIoaW5pdFBhcmFtcyk7XG4gICAgICAgIC8vIE11c3QgcmVkZWNsYXJlIHRvb2wgY2FsbCBmaWVsZHMgc2luY2UgdGhlcmUgaXMgbm8gbXVsdGlwbGUgaW5oZXJpdGFuY2UgaW4gSlMuXG4gICAgICAgIC8vIFRoZXNlIGFyZSB0eXBlZCBhcyBvcHRpb25hbCB0byBhdm9pZCBicmVha2luZyBjaGFuZ2VzIGFuZCBhbGxvdyBmb3IgY2FzdGluZ1xuICAgICAgICAvLyBmcm9tIEJhc2VNZXNzYWdlLlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b29sX2NhbGxzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW52YWxpZF90b29sX2NhbGxzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9vbF9jYWxsX2NodW5rc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBwcm92aWRlZCwgdG9rZW4gdXNhZ2UgaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBtZXNzYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidXNhZ2VfbWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b29sX2NhbGxfY2h1bmtzID1cbiAgICAgICAgICAgIGluaXRQYXJhbXMudG9vbF9jYWxsX2NodW5rcyA/PyB0aGlzLnRvb2xfY2FsbF9jaHVua3M7XG4gICAgICAgIHRoaXMudG9vbF9jYWxscyA9IGluaXRQYXJhbXMudG9vbF9jYWxscyA/PyB0aGlzLnRvb2xfY2FsbHM7XG4gICAgICAgIHRoaXMuaW52YWxpZF90b29sX2NhbGxzID1cbiAgICAgICAgICAgIGluaXRQYXJhbXMuaW52YWxpZF90b29sX2NhbGxzID8/IHRoaXMuaW52YWxpZF90b29sX2NhbGxzO1xuICAgICAgICB0aGlzLnVzYWdlX21ldGFkYXRhID0gaW5pdFBhcmFtcy51c2FnZV9tZXRhZGF0YTtcbiAgICB9XG4gICAgZ2V0IGxjX2FsaWFzZXMoKSB7XG4gICAgICAgIC8vIGV4Y2x1ZGUgc25ha2UgY2FzZSBjb252ZXJzaW9uIHRvIHBhc2NhbCBjYXNlXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci5sY19hbGlhc2VzLFxuICAgICAgICAgICAgdG9vbF9jYWxsczogXCJ0b29sX2NhbGxzXCIsXG4gICAgICAgICAgICBpbnZhbGlkX3Rvb2xfY2FsbHM6IFwiaW52YWxpZF90b29sX2NhbGxzXCIsXG4gICAgICAgICAgICB0b29sX2NhbGxfY2h1bmtzOiBcInRvb2xfY2FsbF9jaHVua3NcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkFJTWVzc2FnZUNodW5rXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJhaVwiO1xuICAgIH1cbiAgICBnZXQgX3ByaW50YWJsZUZpZWxkcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLl9wcmludGFibGVGaWVsZHMsXG4gICAgICAgICAgICB0b29sX2NhbGxzOiB0aGlzLnRvb2xfY2FsbHMsXG4gICAgICAgICAgICB0b29sX2NhbGxfY2h1bmtzOiB0aGlzLnRvb2xfY2FsbF9jaHVua3MsXG4gICAgICAgICAgICBpbnZhbGlkX3Rvb2xfY2FsbHM6IHRoaXMuaW52YWxpZF90b29sX2NhbGxzLFxuICAgICAgICAgICAgdXNhZ2VfbWV0YWRhdGE6IHRoaXMudXNhZ2VfbWV0YWRhdGEsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbmNhdChjaHVuaykge1xuICAgICAgICBjb25zdCBjb21iaW5lZEZpZWxkcyA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6ICgwLCBiYXNlX2pzXzEubWVyZ2VDb250ZW50KSh0aGlzLmNvbnRlbnQsIGNodW5rLmNvbnRlbnQpLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6ICgwLCBiYXNlX2pzXzEuX21lcmdlRGljdHMpKHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MsIGNodW5rLmFkZGl0aW9uYWxfa3dhcmdzKSxcbiAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiAoMCwgYmFzZV9qc18xLl9tZXJnZURpY3RzKSh0aGlzLnJlc3BvbnNlX21ldGFkYXRhLCBjaHVuay5yZXNwb25zZV9tZXRhZGF0YSksXG4gICAgICAgICAgICB0b29sX2NhbGxfY2h1bmtzOiBbXSxcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkID8/IGNodW5rLmlkLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy50b29sX2NhbGxfY2h1bmtzICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGNodW5rLnRvb2xfY2FsbF9jaHVua3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcmF3VG9vbENhbGxzID0gKDAsIGJhc2VfanNfMS5fbWVyZ2VMaXN0cykodGhpcy50b29sX2NhbGxfY2h1bmtzLCBjaHVuay50b29sX2NhbGxfY2h1bmtzKTtcbiAgICAgICAgICAgIGlmIChyYXdUb29sQ2FsbHMgIT09IHVuZGVmaW5lZCAmJiByYXdUb29sQ2FsbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbWJpbmVkRmllbGRzLnRvb2xfY2FsbF9jaHVua3MgPSByYXdUb29sQ2FsbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudXNhZ2VfbWV0YWRhdGEgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgY2h1bmsudXNhZ2VfbWV0YWRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgaW5wdXRUb2tlbkRldGFpbHMgPSB7XG4gICAgICAgICAgICAgICAgLi4uKCh0aGlzLnVzYWdlX21ldGFkYXRhPy5pbnB1dF90b2tlbl9kZXRhaWxzPy5hdWRpbyAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIGNodW5rLnVzYWdlX21ldGFkYXRhPy5pbnB1dF90b2tlbl9kZXRhaWxzPy5hdWRpbyAhPT0gdW5kZWZpbmVkKSAmJiB7XG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvOiAodGhpcy51c2FnZV9tZXRhZGF0YT8uaW5wdXRfdG9rZW5fZGV0YWlscz8uYXVkaW8gPz8gMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGNodW5rLnVzYWdlX21ldGFkYXRhPy5pbnB1dF90b2tlbl9kZXRhaWxzPy5hdWRpbyA/PyAwKSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi4oKHRoaXMudXNhZ2VfbWV0YWRhdGE/LmlucHV0X3Rva2VuX2RldGFpbHM/LmNhY2hlX3JlYWQgIT09XG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICBjaHVuay51c2FnZV9tZXRhZGF0YT8uaW5wdXRfdG9rZW5fZGV0YWlscz8uY2FjaGVfcmVhZCAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCkgJiYge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZV9yZWFkOiAodGhpcy51c2FnZV9tZXRhZGF0YT8uaW5wdXRfdG9rZW5fZGV0YWlscz8uY2FjaGVfcmVhZCA/PyAwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2h1bmsudXNhZ2VfbWV0YWRhdGE/LmlucHV0X3Rva2VuX2RldGFpbHM/LmNhY2hlX3JlYWQgPz8gMCksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uKCh0aGlzLnVzYWdlX21ldGFkYXRhPy5pbnB1dF90b2tlbl9kZXRhaWxzPy5jYWNoZV9jcmVhdGlvbiAhPT1cbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIGNodW5rLnVzYWdlX21ldGFkYXRhPy5pbnB1dF90b2tlbl9kZXRhaWxzPy5jYWNoZV9jcmVhdGlvbiAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCkgJiYge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZV9jcmVhdGlvbjogKHRoaXMudXNhZ2VfbWV0YWRhdGE/LmlucHV0X3Rva2VuX2RldGFpbHM/LmNhY2hlX2NyZWF0aW9uID8/IDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChjaHVuay51c2FnZV9tZXRhZGF0YT8uaW5wdXRfdG9rZW5fZGV0YWlscz8uY2FjaGVfY3JlYXRpb24gPz8gMCksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0VG9rZW5EZXRhaWxzID0ge1xuICAgICAgICAgICAgICAgIC4uLigodGhpcy51c2FnZV9tZXRhZGF0YT8ub3V0cHV0X3Rva2VuX2RldGFpbHM/LmF1ZGlvICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsudXNhZ2VfbWV0YWRhdGE/Lm91dHB1dF90b2tlbl9kZXRhaWxzPy5hdWRpbyAhPT0gdW5kZWZpbmVkKSAmJiB7XG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvOiAodGhpcy51c2FnZV9tZXRhZGF0YT8ub3V0cHV0X3Rva2VuX2RldGFpbHM/LmF1ZGlvID8/IDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChjaHVuay51c2FnZV9tZXRhZGF0YT8ub3V0cHV0X3Rva2VuX2RldGFpbHM/LmF1ZGlvID8/IDApLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLigodGhpcy51c2FnZV9tZXRhZGF0YT8ub3V0cHV0X3Rva2VuX2RldGFpbHM/LnJlYXNvbmluZyAhPT1cbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIGNodW5rLnVzYWdlX21ldGFkYXRhPy5vdXRwdXRfdG9rZW5fZGV0YWlscz8ucmVhc29uaW5nICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkKSAmJiB7XG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbmluZzogKHRoaXMudXNhZ2VfbWV0YWRhdGE/Lm91dHB1dF90b2tlbl9kZXRhaWxzPy5yZWFzb25pbmcgPz8gMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGNodW5rLnVzYWdlX21ldGFkYXRhPy5vdXRwdXRfdG9rZW5fZGV0YWlscz8ucmVhc29uaW5nID8/IDApLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLnVzYWdlX21ldGFkYXRhID8/IHtcbiAgICAgICAgICAgICAgICBpbnB1dF90b2tlbnM6IDAsXG4gICAgICAgICAgICAgICAgb3V0cHV0X3Rva2VuczogMCxcbiAgICAgICAgICAgICAgICB0b3RhbF90b2tlbnM6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBjaHVuay51c2FnZV9tZXRhZGF0YSA/PyB7XG4gICAgICAgICAgICAgICAgaW5wdXRfdG9rZW5zOiAwLFxuICAgICAgICAgICAgICAgIG91dHB1dF90b2tlbnM6IDAsXG4gICAgICAgICAgICAgICAgdG90YWxfdG9rZW5zOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHVzYWdlX21ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgIGlucHV0X3Rva2VuczogbGVmdC5pbnB1dF90b2tlbnMgKyByaWdodC5pbnB1dF90b2tlbnMsXG4gICAgICAgICAgICAgICAgb3V0cHV0X3Rva2VuczogbGVmdC5vdXRwdXRfdG9rZW5zICsgcmlnaHQub3V0cHV0X3Rva2VucyxcbiAgICAgICAgICAgICAgICB0b3RhbF90b2tlbnM6IGxlZnQudG90YWxfdG9rZW5zICsgcmlnaHQudG90YWxfdG9rZW5zLFxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBpbmNsdWRlIGBpbnB1dF90b2tlbl9kZXRhaWxzYCAvIGBvdXRwdXRfdG9rZW5fZGV0YWlsc2Aga2V5cyBpbiBjb21iaW5lZCBmaWVsZHNcbiAgICAgICAgICAgICAgICAvLyB1bmxlc3MgdGhlaXIgdmFsdWVzIGFyZSBkZWZpbmVkLlxuICAgICAgICAgICAgICAgIC4uLihPYmplY3Qua2V5cyhpbnB1dFRva2VuRGV0YWlscykubGVuZ3RoID4gMCAmJiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0X3Rva2VuX2RldGFpbHM6IGlucHV0VG9rZW5EZXRhaWxzLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLihPYmplY3Qua2V5cyhvdXRwdXRUb2tlbkRldGFpbHMpLmxlbmd0aCA+IDAgJiYge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRfdG9rZW5fZGV0YWlsczogb3V0cHV0VG9rZW5EZXRhaWxzLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbWJpbmVkRmllbGRzLnVzYWdlX21ldGFkYXRhID0gdXNhZ2VfbWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBSU1lc3NhZ2VDaHVuayhjb21iaW5lZEZpZWxkcyk7XG4gICAgfVxufVxuZXhwb3J0cy5BSU1lc3NhZ2VDaHVuayA9IEFJTWVzc2FnZUNodW5rO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/ai.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/base.cjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseMessageChunk = exports.BaseMessage = void 0;\nexports.mergeContent = mergeContent;\nexports._mergeStatus = _mergeStatus;\nexports.isOpenAIToolCallArray = isOpenAIToolCallArray;\nexports._mergeDicts = _mergeDicts;\nexports._mergeLists = _mergeLists;\nexports._mergeObj = _mergeObj;\nexports._isMessageFieldWithRole = _isMessageFieldWithRole;\nexports.isBaseMessage = isBaseMessage;\nexports.isBaseMessageChunk = isBaseMessageChunk;\nconst serializable_js_1 = __webpack_require__(/*! ../load/serializable.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.cjs\");\nconst content_blocks_js_1 = __webpack_require__(/*! ./content_blocks.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/content_blocks.cjs\");\nfunction mergeContent(firstContent, secondContent) {\n    // If first content is a string\n    if (typeof firstContent === \"string\") {\n        if (firstContent === \"\") {\n            return secondContent;\n        }\n        if (typeof secondContent === \"string\") {\n            return firstContent + secondContent;\n        }\n        else if (Array.isArray(secondContent) &&\n            secondContent.some((c) => (0, content_blocks_js_1.isDataContentBlock)(c))) {\n            return [\n                {\n                    type: \"text\",\n                    source_type: \"text\",\n                    text: firstContent,\n                },\n                ...secondContent,\n            ];\n        }\n        else {\n            return [{ type: \"text\", text: firstContent }, ...secondContent];\n        }\n        // If both are arrays\n    }\n    else if (Array.isArray(secondContent)) {\n        return (_mergeLists(firstContent, secondContent) ?? [\n            ...firstContent,\n            ...secondContent,\n        ]);\n    }\n    else {\n        if (secondContent === \"\") {\n            return firstContent;\n        }\n        else if (Array.isArray(firstContent) &&\n            firstContent.some((c) => (0, content_blocks_js_1.isDataContentBlock)(c))) {\n            return [\n                ...firstContent,\n                {\n                    type: \"file\",\n                    source_type: \"text\",\n                    text: secondContent,\n                },\n            ];\n        }\n        else {\n            return [...firstContent, { type: \"text\", text: secondContent }];\n        }\n    }\n}\n/**\n * 'Merge' two statuses. If either value passed is 'error', it will return 'error'. Else\n * it will return 'success'.\n *\n * @param {\"success\" | \"error\" | undefined} left The existing value to 'merge' with the new value.\n * @param {\"success\" | \"error\" | undefined} right The new value to 'merge' with the existing value\n * @returns {\"success\" | \"error\"} The 'merged' value.\n */\nfunction _mergeStatus(left, right) {\n    if (left === \"error\" || right === \"error\") {\n        return \"error\";\n    }\n    return \"success\";\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction stringifyWithDepthLimit(obj, depthLimit) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function helper(obj, currentDepth) {\n        if (typeof obj !== \"object\" || obj === null || obj === undefined) {\n            return obj;\n        }\n        if (currentDepth >= depthLimit) {\n            if (Array.isArray(obj)) {\n                return \"[Array]\";\n            }\n            return \"[Object]\";\n        }\n        if (Array.isArray(obj)) {\n            return obj.map((item) => helper(item, currentDepth + 1));\n        }\n        const result = {};\n        for (const key of Object.keys(obj)) {\n            result[key] = helper(obj[key], currentDepth + 1);\n        }\n        return result;\n    }\n    return JSON.stringify(helper(obj, 0), null, 2);\n}\n/**\n * Base class for all types of messages in a conversation. It includes\n * properties like `content`, `name`, and `additional_kwargs`. It also\n * includes methods like `toDict()` and `_getType()`.\n */\nclass BaseMessage extends serializable_js_1.Serializable {\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return {\n            additional_kwargs: \"additional_kwargs\",\n            response_metadata: \"response_metadata\",\n        };\n    }\n    /**\n     * Get text content of the message.\n     */\n    get text() {\n        if (typeof this.content === \"string\") {\n            return this.content;\n        }\n        if (!Array.isArray(this.content))\n            return \"\";\n        return this.content\n            .map((c) => {\n            if (typeof c === \"string\")\n                return c;\n            if (c.type === \"text\")\n                return c.text;\n            return \"\";\n        })\n            .join(\"\");\n    }\n    /** The type of the message. */\n    getType() {\n        return this._getType();\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign\n            fields = {\n                content: fields,\n                additional_kwargs: kwargs,\n                response_metadata: {},\n            };\n        }\n        // Make sure the default value for additional_kwargs is passed into super() for serialization\n        if (!fields.additional_kwargs) {\n            // eslint-disable-next-line no-param-reassign\n            fields.additional_kwargs = {};\n        }\n        if (!fields.response_metadata) {\n            // eslint-disable-next-line no-param-reassign\n            fields.response_metadata = {};\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"messages\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        /** The content of the message. */\n        Object.defineProperty(this, \"content\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** The name of the message sender in a multi-user chat. */\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Additional keyword arguments */\n        Object.defineProperty(this, \"additional_kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Response metadata. For example: response headers, logprobs, token counts, model name. */\n        Object.defineProperty(this, \"response_metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * An optional unique identifier for the message. This should ideally be\n         * provided by the provider/model which created the message.\n         */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.content = fields.content;\n        this.additional_kwargs = fields.additional_kwargs;\n        this.response_metadata = fields.response_metadata;\n        this.id = fields.id;\n    }\n    toDict() {\n        return {\n            type: this._getType(),\n            data: this.toJSON()\n                .kwargs,\n        };\n    }\n    static lc_name() {\n        return \"BaseMessage\";\n    }\n    // Can't be protected for silly reasons\n    get _printableFields() {\n        return {\n            id: this.id,\n            content: this.content,\n            name: this.name,\n            additional_kwargs: this.additional_kwargs,\n            response_metadata: this.response_metadata,\n        };\n    }\n    // this private method is used to update the ID for the runtime\n    // value as well as in lc_kwargs for serialisation\n    _updateId(value) {\n        this.id = value;\n        // lc_attributes wouldn't work here, because jest compares the\n        // whole object\n        this.lc_kwargs.id = value;\n    }\n    get [Symbol.toStringTag]() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return this.constructor.lc_name();\n    }\n    // Override the default behavior of console.log\n    [Symbol.for(\"nodejs.util.inspect.custom\")](depth) {\n        if (depth === null) {\n            return this;\n        }\n        const printable = stringifyWithDepthLimit(this._printableFields, Math.max(4, depth));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return `${this.constructor.lc_name()} ${printable}`;\n    }\n}\nexports.BaseMessage = BaseMessage;\nfunction isOpenAIToolCallArray(value) {\n    return (Array.isArray(value) &&\n        value.every((v) => typeof v.index === \"number\"));\n}\nfunction _mergeDicts(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nleft, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nright\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    const merged = { ...left };\n    for (const [key, value] of Object.entries(right)) {\n        if (merged[key] == null) {\n            merged[key] = value;\n        }\n        else if (value == null) {\n            continue;\n        }\n        else if (typeof merged[key] !== typeof value ||\n            Array.isArray(merged[key]) !== Array.isArray(value)) {\n            throw new Error(`field[${key}] already exists in the message chunk, but with a different type.`);\n        }\n        else if (typeof merged[key] === \"string\") {\n            if (key === \"type\") {\n                // Do not merge 'type' fields\n                continue;\n            }\n            else if ([\"id\", \"name\", \"output_version\", \"model_provider\"].includes(key)) {\n                // Keep the incoming value for these fields\n                merged[key] = value;\n            }\n            else {\n                merged[key] += value;\n            }\n        }\n        else if (typeof merged[key] === \"object\" && !Array.isArray(merged[key])) {\n            merged[key] = _mergeDicts(merged[key], value);\n        }\n        else if (Array.isArray(merged[key])) {\n            merged[key] = _mergeLists(merged[key], value);\n        }\n        else if (merged[key] === value) {\n            continue;\n        }\n        else {\n            console.warn(`field[${key}] already exists in this message chunk and value has unsupported type.`);\n        }\n    }\n    return merged;\n}\nfunction _mergeLists(left, right) {\n    if (left === undefined && right === undefined) {\n        return undefined;\n    }\n    else if (left === undefined || right === undefined) {\n        return left || right;\n    }\n    else {\n        const merged = [...left];\n        for (const item of right) {\n            if (typeof item === \"object\" &&\n                item !== null &&\n                \"index\" in item &&\n                typeof item.index === \"number\") {\n                const toMerge = merged.findIndex((leftItem) => {\n                    const isObject = typeof leftItem === \"object\";\n                    const indiciesMatch = \"index\" in leftItem && leftItem.index === item.index;\n                    const idsMatch = \"id\" in leftItem && \"id\" in item && leftItem?.id === item?.id;\n                    const eitherItemMissingID = !(\"id\" in leftItem) ||\n                        !leftItem?.id ||\n                        !(\"id\" in item) ||\n                        !item?.id;\n                    return isObject && indiciesMatch && (idsMatch || eitherItemMissingID);\n                });\n                if (toMerge !== -1 &&\n                    typeof merged[toMerge] === \"object\" &&\n                    merged[toMerge] !== null) {\n                    merged[toMerge] = _mergeDicts(merged[toMerge], item);\n                }\n                else {\n                    merged.push(item);\n                }\n            }\n            else if (typeof item === \"object\" &&\n                item !== null &&\n                \"text\" in item &&\n                item.text === \"\") {\n                // No-op - skip empty text blocks\n                continue;\n            }\n            else {\n                merged.push(item);\n            }\n        }\n        return merged;\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _mergeObj(left, right) {\n    if (!left && !right) {\n        throw new Error(\"Cannot merge two undefined objects.\");\n    }\n    if (!left || !right) {\n        return left || right;\n    }\n    else if (typeof left !== typeof right) {\n        throw new Error(`Cannot merge objects of different types.\\nLeft ${typeof left}\\nRight ${typeof right}`);\n    }\n    else if (typeof left === \"string\" && typeof right === \"string\") {\n        return (left + right);\n    }\n    else if (Array.isArray(left) && Array.isArray(right)) {\n        return _mergeLists(left, right);\n    }\n    else if (typeof left === \"object\" && typeof right === \"object\") {\n        return _mergeDicts(left, right);\n    }\n    else if (left === right) {\n        return left;\n    }\n    else {\n        throw new Error(`Can not merge objects of different types.\\nLeft ${left}\\nRight ${right}`);\n    }\n}\n/**\n * Represents a chunk of a message, which can be concatenated with other\n * message chunks. It includes a method `_merge_kwargs_dict()` for merging\n * additional keyword arguments from another `BaseMessageChunk` into this\n * one. It also overrides the `__add__()` method to support concatenation\n * of `BaseMessageChunk` instances.\n */\nclass BaseMessageChunk extends BaseMessage {\n}\nexports.BaseMessageChunk = BaseMessageChunk;\nfunction _isMessageFieldWithRole(x) {\n    return typeof x.role === \"string\";\n}\nfunction isBaseMessage(messageLike) {\n    return typeof messageLike?._getType === \"function\";\n}\nfunction isBaseMessageChunk(messageLike) {\n    return (isBaseMessage(messageLike) &&\n        typeof messageLike.concat === \"function\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvYmFzZS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsbUJBQW1CO0FBQzlDLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsNkJBQTZCO0FBQzdCLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCLCtCQUErQjtBQUMvQixxQkFBcUI7QUFDckIsMEJBQTBCO0FBQzFCLDBCQUEwQixtQkFBTyxDQUFDLGlHQUEwQjtBQUM1RCw0QkFBNEIsbUJBQU8sQ0FBQyxtR0FBc0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0NBQWtDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsbUNBQW1DO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUMsV0FBVyxpQ0FBaUM7QUFDNUMsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRCQUE0QixFQUFFLFVBQVU7QUFDMUQ7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxJQUFJO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLFlBQVksVUFBVSxhQUFhO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsS0FBSyxVQUFVLE1BQU07QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L21lc3NhZ2VzL2Jhc2UuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlTWVzc2FnZUNodW5rID0gZXhwb3J0cy5CYXNlTWVzc2FnZSA9IHZvaWQgMDtcbmV4cG9ydHMubWVyZ2VDb250ZW50ID0gbWVyZ2VDb250ZW50O1xuZXhwb3J0cy5fbWVyZ2VTdGF0dXMgPSBfbWVyZ2VTdGF0dXM7XG5leHBvcnRzLmlzT3BlbkFJVG9vbENhbGxBcnJheSA9IGlzT3BlbkFJVG9vbENhbGxBcnJheTtcbmV4cG9ydHMuX21lcmdlRGljdHMgPSBfbWVyZ2VEaWN0cztcbmV4cG9ydHMuX21lcmdlTGlzdHMgPSBfbWVyZ2VMaXN0cztcbmV4cG9ydHMuX21lcmdlT2JqID0gX21lcmdlT2JqO1xuZXhwb3J0cy5faXNNZXNzYWdlRmllbGRXaXRoUm9sZSA9IF9pc01lc3NhZ2VGaWVsZFdpdGhSb2xlO1xuZXhwb3J0cy5pc0Jhc2VNZXNzYWdlID0gaXNCYXNlTWVzc2FnZTtcbmV4cG9ydHMuaXNCYXNlTWVzc2FnZUNodW5rID0gaXNCYXNlTWVzc2FnZUNodW5rO1xuY29uc3Qgc2VyaWFsaXphYmxlX2pzXzEgPSByZXF1aXJlKFwiLi4vbG9hZC9zZXJpYWxpemFibGUuY2pzXCIpO1xuY29uc3QgY29udGVudF9ibG9ja3NfanNfMSA9IHJlcXVpcmUoXCIuL2NvbnRlbnRfYmxvY2tzLmNqc1wiKTtcbmZ1bmN0aW9uIG1lcmdlQ29udGVudChmaXJzdENvbnRlbnQsIHNlY29uZENvbnRlbnQpIHtcbiAgICAvLyBJZiBmaXJzdCBjb250ZW50IGlzIGEgc3RyaW5nXG4gICAgaWYgKHR5cGVvZiBmaXJzdENvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGZpcnN0Q29udGVudCA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHNlY29uZENvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNvbmRDb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3RDb250ZW50ICsgc2Vjb25kQ29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNlY29uZENvbnRlbnQpICYmXG4gICAgICAgICAgICBzZWNvbmRDb250ZW50LnNvbWUoKGMpID0+ICgwLCBjb250ZW50X2Jsb2Nrc19qc18xLmlzRGF0YUNvbnRlbnRCbG9jaykoYykpKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZV90eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogZmlyc3RDb250ZW50LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLi4uc2Vjb25kQ29udGVudCxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IGZpcnN0Q29udGVudCB9LCAuLi5zZWNvbmRDb250ZW50XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBib3RoIGFyZSBhcnJheXNcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzZWNvbmRDb250ZW50KSkge1xuICAgICAgICByZXR1cm4gKF9tZXJnZUxpc3RzKGZpcnN0Q29udGVudCwgc2Vjb25kQ29udGVudCkgPz8gW1xuICAgICAgICAgICAgLi4uZmlyc3RDb250ZW50LFxuICAgICAgICAgICAgLi4uc2Vjb25kQ29udGVudCxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoc2Vjb25kQ29udGVudCA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0Q29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGZpcnN0Q29udGVudCkgJiZcbiAgICAgICAgICAgIGZpcnN0Q29udGVudC5zb21lKChjKSA9PiAoMCwgY29udGVudF9ibG9ja3NfanNfMS5pc0RhdGFDb250ZW50QmxvY2spKGMpKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAuLi5maXJzdENvbnRlbnQsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgICAgICAgICAgc291cmNlX3R5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBzZWNvbmRDb250ZW50LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5maXJzdENvbnRlbnQsIHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IHNlY29uZENvbnRlbnQgfV07XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqICdNZXJnZScgdHdvIHN0YXR1c2VzLiBJZiBlaXRoZXIgdmFsdWUgcGFzc2VkIGlzICdlcnJvcicsIGl0IHdpbGwgcmV0dXJuICdlcnJvcicuIEVsc2VcbiAqIGl0IHdpbGwgcmV0dXJuICdzdWNjZXNzJy5cbiAqXG4gKiBAcGFyYW0ge1wic3VjY2Vzc1wiIHwgXCJlcnJvclwiIHwgdW5kZWZpbmVkfSBsZWZ0IFRoZSBleGlzdGluZyB2YWx1ZSB0byAnbWVyZ2UnIHdpdGggdGhlIG5ldyB2YWx1ZS5cbiAqIEBwYXJhbSB7XCJzdWNjZXNzXCIgfCBcImVycm9yXCIgfCB1bmRlZmluZWR9IHJpZ2h0IFRoZSBuZXcgdmFsdWUgdG8gJ21lcmdlJyB3aXRoIHRoZSBleGlzdGluZyB2YWx1ZVxuICogQHJldHVybnMge1wic3VjY2Vzc1wiIHwgXCJlcnJvclwifSBUaGUgJ21lcmdlZCcgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIF9tZXJnZVN0YXR1cyhsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0ID09PSBcImVycm9yXCIgfHwgcmlnaHQgPT09IFwiZXJyb3JcIikge1xuICAgICAgICByZXR1cm4gXCJlcnJvclwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJzdWNjZXNzXCI7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gc3RyaW5naWZ5V2l0aERlcHRoTGltaXQob2JqLCBkZXB0aExpbWl0KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBmdW5jdGlvbiBoZWxwZXIob2JqLCBjdXJyZW50RGVwdGgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgfHwgb2JqID09PSBudWxsIHx8IG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50RGVwdGggPj0gZGVwdGhMaW1pdCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIltBcnJheV1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcIltPYmplY3RdXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5tYXAoKGl0ZW0pID0+IGhlbHBlcihpdGVtLCBjdXJyZW50RGVwdGggKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gaGVscGVyKG9ialtrZXldLCBjdXJyZW50RGVwdGggKyAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaGVscGVyKG9iaiwgMCksIG51bGwsIDIpO1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgdHlwZXMgb2YgbWVzc2FnZXMgaW4gYSBjb252ZXJzYXRpb24uIEl0IGluY2x1ZGVzXG4gKiBwcm9wZXJ0aWVzIGxpa2UgYGNvbnRlbnRgLCBgbmFtZWAsIGFuZCBgYWRkaXRpb25hbF9rd2FyZ3NgLiBJdCBhbHNvXG4gKiBpbmNsdWRlcyBtZXRob2RzIGxpa2UgYHRvRGljdCgpYCBhbmQgYF9nZXRUeXBlKClgLlxuICovXG5jbGFzcyBCYXNlTWVzc2FnZSBleHRlbmRzIHNlcmlhbGl6YWJsZV9qc18xLlNlcmlhbGl6YWJsZSB7XG4gICAgZ2V0IGxjX2FsaWFzZXMoKSB7XG4gICAgICAgIC8vIGV4Y2x1ZGUgc25ha2UgY2FzZSBjb252ZXJzaW9uIHRvIHBhc2NhbCBjYXNlXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRpdGlvbmFsX2t3YXJnczogXCJhZGRpdGlvbmFsX2t3YXJnc1wiLFxuICAgICAgICAgICAgcmVzcG9uc2VfbWV0YWRhdGE6IFwicmVzcG9uc2VfbWV0YWRhdGFcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRleHQgY29udGVudCBvZiB0aGUgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMuY29udGVudCkpXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFxuICAgICAgICAgICAgLm1hcCgoYykgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgaWYgKGMudHlwZSA9PT0gXCJ0ZXh0XCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGMudGV4dDtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oXCJcIik7XG4gICAgfVxuICAgIC8qKiBUaGUgdHlwZSBvZiB0aGUgbWVzc2FnZS4gKi9cbiAgICBnZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VHlwZSgpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIFxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIGt3YXJncykge1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBmaWVsZHMgPSB7XG4gICAgICAgICAgICAgICAgY29udGVudDogZmllbGRzLFxuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiBrd2FyZ3MsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VfbWV0YWRhdGE6IHt9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIGFkZGl0aW9uYWxfa3dhcmdzIGlzIHBhc3NlZCBpbnRvIHN1cGVyKCkgZm9yIHNlcmlhbGl6YXRpb25cbiAgICAgICAgaWYgKCFmaWVsZHMuYWRkaXRpb25hbF9rd2FyZ3MpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgZmllbGRzLmFkZGl0aW9uYWxfa3dhcmdzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmaWVsZHMucmVzcG9uc2VfbWV0YWRhdGEpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgZmllbGRzLnJlc3BvbnNlX21ldGFkYXRhID0ge307XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcIm1lc3NhZ2VzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBUaGUgY29udGVudCBvZiB0aGUgbWVzc2FnZS4gKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udGVudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogVGhlIG5hbWUgb2YgdGhlIG1lc3NhZ2Ugc2VuZGVyIGluIGEgbXVsdGktdXNlciBjaGF0LiAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBBZGRpdGlvbmFsIGtleXdvcmQgYXJndW1lbnRzICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFkZGl0aW9uYWxfa3dhcmdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBSZXNwb25zZSBtZXRhZGF0YS4gRm9yIGV4YW1wbGU6IHJlc3BvbnNlIGhlYWRlcnMsIGxvZ3Byb2JzLCB0b2tlbiBjb3VudHMsIG1vZGVsIG5hbWUuICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc3BvbnNlX21ldGFkYXRhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBvcHRpb25hbCB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIG1lc3NhZ2UuIFRoaXMgc2hvdWxkIGlkZWFsbHkgYmVcbiAgICAgICAgICogcHJvdmlkZWQgYnkgdGhlIHByb3ZpZGVyL21vZGVsIHdoaWNoIGNyZWF0ZWQgdGhlIG1lc3NhZ2UuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSBmaWVsZHMubmFtZTtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gZmllbGRzLmNvbnRlbnQ7XG4gICAgICAgIHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MgPSBmaWVsZHMuYWRkaXRpb25hbF9rd2FyZ3M7XG4gICAgICAgIHRoaXMucmVzcG9uc2VfbWV0YWRhdGEgPSBmaWVsZHMucmVzcG9uc2VfbWV0YWRhdGE7XG4gICAgICAgIHRoaXMuaWQgPSBmaWVsZHMuaWQ7XG4gICAgfVxuICAgIHRvRGljdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuX2dldFR5cGUoKSxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMudG9KU09OKClcbiAgICAgICAgICAgICAgICAua3dhcmdzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQmFzZU1lc3NhZ2VcIjtcbiAgICB9XG4gICAgLy8gQ2FuJ3QgYmUgcHJvdGVjdGVkIGZvciBzaWxseSByZWFzb25zXG4gICAgZ2V0IF9wcmludGFibGVGaWVsZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuY29udGVudCxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiB0aGlzLmFkZGl0aW9uYWxfa3dhcmdzLFxuICAgICAgICAgICAgcmVzcG9uc2VfbWV0YWRhdGE6IHRoaXMucmVzcG9uc2VfbWV0YWRhdGEsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIHRoaXMgcHJpdmF0ZSBtZXRob2QgaXMgdXNlZCB0byB1cGRhdGUgdGhlIElEIGZvciB0aGUgcnVudGltZVxuICAgIC8vIHZhbHVlIGFzIHdlbGwgYXMgaW4gbGNfa3dhcmdzIGZvciBzZXJpYWxpc2F0aW9uXG4gICAgX3VwZGF0ZUlkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaWQgPSB2YWx1ZTtcbiAgICAgICAgLy8gbGNfYXR0cmlidXRlcyB3b3VsZG4ndCB3b3JrIGhlcmUsIGJlY2F1c2UgamVzdCBjb21wYXJlcyB0aGVcbiAgICAgICAgLy8gd2hvbGUgb2JqZWN0XG4gICAgICAgIHRoaXMubGNfa3dhcmdzLmlkID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubGNfbmFtZSgpO1xuICAgIH1cbiAgICAvLyBPdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBjb25zb2xlLmxvZ1xuICAgIFtTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIildKGRlcHRoKSB7XG4gICAgICAgIGlmIChkZXB0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJpbnRhYmxlID0gc3RyaW5naWZ5V2l0aERlcHRoTGltaXQodGhpcy5fcHJpbnRhYmxlRmllbGRzLCBNYXRoLm1heCg0LCBkZXB0aCkpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb25zdHJ1Y3Rvci5sY19uYW1lKCl9ICR7cHJpbnRhYmxlfWA7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlTWVzc2FnZSA9IEJhc2VNZXNzYWdlO1xuZnVuY3Rpb24gaXNPcGVuQUlUb29sQ2FsbEFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJlxuICAgICAgICB2YWx1ZS5ldmVyeSgodikgPT4gdHlwZW9mIHYuaW5kZXggPT09IFwibnVtYmVyXCIpKTtcbn1cbmZ1bmN0aW9uIF9tZXJnZURpY3RzKFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmxlZnQsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnJpZ2h0XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuKSB7XG4gICAgY29uc3QgbWVyZ2VkID0geyAuLi5sZWZ0IH07XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmlnaHQpKSB7XG4gICAgICAgIGlmIChtZXJnZWRba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXJnZWRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtZXJnZWRba2V5XSAhPT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KG1lcmdlZFtrZXldKSAhPT0gQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZmllbGRbJHtrZXl9XSBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgbWVzc2FnZSBjaHVuaywgYnV0IHdpdGggYSBkaWZmZXJlbnQgdHlwZS5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWVyZ2VkW2tleV0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwidHlwZVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IG1lcmdlICd0eXBlJyBmaWVsZHNcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFtcImlkXCIsIFwibmFtZVwiLCBcIm91dHB1dF92ZXJzaW9uXCIsIFwibW9kZWxfcHJvdmlkZXJcIl0uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIC8vIEtlZXAgdGhlIGluY29taW5nIHZhbHVlIGZvciB0aGVzZSBmaWVsZHNcbiAgICAgICAgICAgICAgICBtZXJnZWRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkW2tleV0gKz0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1lcmdlZFtrZXldID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KG1lcmdlZFtrZXldKSkge1xuICAgICAgICAgICAgbWVyZ2VkW2tleV0gPSBfbWVyZ2VEaWN0cyhtZXJnZWRba2V5XSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobWVyZ2VkW2tleV0pKSB7XG4gICAgICAgICAgICBtZXJnZWRba2V5XSA9IF9tZXJnZUxpc3RzKG1lcmdlZFtrZXldLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWVyZ2VkW2tleV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgZmllbGRbJHtrZXl9XSBhbHJlYWR5IGV4aXN0cyBpbiB0aGlzIG1lc3NhZ2UgY2h1bmsgYW5kIHZhbHVlIGhhcyB1bnN1cHBvcnRlZCB0eXBlLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWQ7XG59XG5mdW5jdGlvbiBfbWVyZ2VMaXN0cyhsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0ID09PSB1bmRlZmluZWQgJiYgcmlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZWZ0ID09PSB1bmRlZmluZWQgfHwgcmlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVmdCB8fCByaWdodDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IFsuLi5sZWZ0XTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHJpZ2h0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICBpdGVtICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgXCJpbmRleFwiIGluIGl0ZW0gJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgaXRlbS5pbmRleCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvTWVyZ2UgPSBtZXJnZWQuZmluZEluZGV4KChsZWZ0SXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc09iamVjdCA9IHR5cGVvZiBsZWZ0SXRlbSA9PT0gXCJvYmplY3RcIjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kaWNpZXNNYXRjaCA9IFwiaW5kZXhcIiBpbiBsZWZ0SXRlbSAmJiBsZWZ0SXRlbS5pbmRleCA9PT0gaXRlbS5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWRzTWF0Y2ggPSBcImlkXCIgaW4gbGVmdEl0ZW0gJiYgXCJpZFwiIGluIGl0ZW0gJiYgbGVmdEl0ZW0/LmlkID09PSBpdGVtPy5pZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWl0aGVySXRlbU1pc3NpbmdJRCA9ICEoXCJpZFwiIGluIGxlZnRJdGVtKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIWxlZnRJdGVtPy5pZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIShcImlkXCIgaW4gaXRlbSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFpdGVtPy5pZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzT2JqZWN0ICYmIGluZGljaWVzTWF0Y2ggJiYgKGlkc01hdGNoIHx8IGVpdGhlckl0ZW1NaXNzaW5nSUQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0b01lcmdlICE9PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgbWVyZ2VkW3RvTWVyZ2VdID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZFt0b01lcmdlXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRbdG9NZXJnZV0gPSBfbWVyZ2VEaWN0cyhtZXJnZWRbdG9NZXJnZV0sIGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICBpdGVtICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgXCJ0ZXh0XCIgaW4gaXRlbSAmJlxuICAgICAgICAgICAgICAgIGl0ZW0udGV4dCA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIC8vIE5vLW9wIC0gc2tpcCBlbXB0eSB0ZXh0IGJsb2Nrc1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gX21lcmdlT2JqKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKCFsZWZ0ICYmICFyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbWVyZ2UgdHdvIHVuZGVmaW5lZCBvYmplY3RzLlwiKTtcbiAgICB9XG4gICAgaWYgKCFsZWZ0IHx8ICFyaWdodCkge1xuICAgICAgICByZXR1cm4gbGVmdCB8fCByaWdodDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGxlZnQgIT09IHR5cGVvZiByaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBtZXJnZSBvYmplY3RzIG9mIGRpZmZlcmVudCB0eXBlcy5cXG5MZWZ0ICR7dHlwZW9mIGxlZnR9XFxuUmlnaHQgJHt0eXBlb2YgcmlnaHR9YCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBsZWZ0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiByaWdodCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gKGxlZnQgKyByaWdodCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobGVmdCkgJiYgQXJyYXkuaXNBcnJheShyaWdodCkpIHtcbiAgICAgICAgcmV0dXJuIF9tZXJnZUxpc3RzKGxlZnQsIHJpZ2h0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGxlZnQgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJpZ2h0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBfbWVyZ2VEaWN0cyhsZWZ0LCByaWdodCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlZnQgPT09IHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBsZWZ0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4gbm90IG1lcmdlIG9iamVjdHMgb2YgZGlmZmVyZW50IHR5cGVzLlxcbkxlZnQgJHtsZWZ0fVxcblJpZ2h0ICR7cmlnaHR9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2h1bmsgb2YgYSBtZXNzYWdlLCB3aGljaCBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbiAqIG1lc3NhZ2UgY2h1bmtzLiBJdCBpbmNsdWRlcyBhIG1ldGhvZCBgX21lcmdlX2t3YXJnc19kaWN0KClgIGZvciBtZXJnaW5nXG4gKiBhZGRpdGlvbmFsIGtleXdvcmQgYXJndW1lbnRzIGZyb20gYW5vdGhlciBgQmFzZU1lc3NhZ2VDaHVua2AgaW50byB0aGlzXG4gKiBvbmUuIEl0IGFsc28gb3ZlcnJpZGVzIHRoZSBgX19hZGRfXygpYCBtZXRob2QgdG8gc3VwcG9ydCBjb25jYXRlbmF0aW9uXG4gKiBvZiBgQmFzZU1lc3NhZ2VDaHVua2AgaW5zdGFuY2VzLlxuICovXG5jbGFzcyBCYXNlTWVzc2FnZUNodW5rIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xufVxuZXhwb3J0cy5CYXNlTWVzc2FnZUNodW5rID0gQmFzZU1lc3NhZ2VDaHVuaztcbmZ1bmN0aW9uIF9pc01lc3NhZ2VGaWVsZFdpdGhSb2xlKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHgucm9sZSA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzQmFzZU1lc3NhZ2UobWVzc2FnZUxpa2UpIHtcbiAgICByZXR1cm4gdHlwZW9mIG1lc3NhZ2VMaWtlPy5fZ2V0VHlwZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gaXNCYXNlTWVzc2FnZUNodW5rKG1lc3NhZ2VMaWtlKSB7XG4gICAgcmV0dXJuIChpc0Jhc2VNZXNzYWdlKG1lc3NhZ2VMaWtlKSAmJlxuICAgICAgICB0eXBlb2YgbWVzc2FnZUxpa2UuY29uY2F0ID09PSBcImZ1bmN0aW9uXCIpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/chat.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/chat.cjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChatMessageChunk = exports.ChatMessage = void 0;\nexports.isChatMessage = isChatMessage;\nexports.isChatMessageChunk = isChatMessageChunk;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\n/**\n * Represents a chat message in a conversation.\n */\nclass ChatMessage extends base_js_1.BaseMessage {\n    static lc_name() {\n        return \"ChatMessage\";\n    }\n    static _chatMessageClass() {\n        return ChatMessage;\n    }\n    constructor(fields, role) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, role: role };\n        }\n        super(fields);\n        Object.defineProperty(this, \"role\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.role = fields.role;\n    }\n    _getType() {\n        return \"generic\";\n    }\n    static isInstance(message) {\n        return message._getType() === \"generic\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            role: this.role,\n        };\n    }\n}\nexports.ChatMessage = ChatMessage;\n/**\n * Represents a chunk of a chat message, which can be concatenated with\n * other chat message chunks.\n */\nclass ChatMessageChunk extends base_js_1.BaseMessageChunk {\n    static lc_name() {\n        return \"ChatMessageChunk\";\n    }\n    constructor(fields, role) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, role: role };\n        }\n        super(fields);\n        Object.defineProperty(this, \"role\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.role = fields.role;\n    }\n    _getType() {\n        return \"generic\";\n    }\n    concat(chunk) {\n        return new ChatMessageChunk({\n            content: (0, base_js_1.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0, base_js_1._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0, base_js_1._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            role: this.role,\n            id: this.id ?? chunk.id,\n        });\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            role: this.role,\n        };\n    }\n}\nexports.ChatMessageChunk = ChatMessageChunk;\nfunction isChatMessage(x) {\n    return x._getType() === \"generic\";\n}\nfunction isChatMessageChunk(x) {\n    return x._getType() === \"generic\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvY2hhdC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsbUJBQW1CO0FBQzlDLHFCQUFxQjtBQUNyQiwwQkFBMEI7QUFDMUIsa0JBQWtCLG1CQUFPLENBQUMsK0VBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvY2hhdC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoYXRNZXNzYWdlQ2h1bmsgPSBleHBvcnRzLkNoYXRNZXNzYWdlID0gdm9pZCAwO1xuZXhwb3J0cy5pc0NoYXRNZXNzYWdlID0gaXNDaGF0TWVzc2FnZTtcbmV4cG9ydHMuaXNDaGF0TWVzc2FnZUNodW5rID0gaXNDaGF0TWVzc2FnZUNodW5rO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBjaGF0IG1lc3NhZ2UgaW4gYSBjb252ZXJzYXRpb24uXG4gKi9cbmNsYXNzIENoYXRNZXNzYWdlIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VNZXNzYWdlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2hhdE1lc3NhZ2VcIjtcbiAgICB9XG4gICAgc3RhdGljIF9jaGF0TWVzc2FnZUNsYXNzKCkge1xuICAgICAgICByZXR1cm4gQ2hhdE1lc3NhZ2U7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgcm9sZSkge1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBmaWVsZHMgPSB7IGNvbnRlbnQ6IGZpZWxkcywgcm9sZTogcm9sZSB9O1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJvbGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yb2xlID0gZmllbGRzLnJvbGU7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJnZW5lcmljXCI7XG4gICAgfVxuICAgIHN0YXRpYyBpc0luc3RhbmNlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2UuX2dldFR5cGUoKSA9PT0gXCJnZW5lcmljXCI7XG4gICAgfVxuICAgIGdldCBfcHJpbnRhYmxlRmllbGRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIuX3ByaW50YWJsZUZpZWxkcyxcbiAgICAgICAgICAgIHJvbGU6IHRoaXMucm9sZSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkNoYXRNZXNzYWdlID0gQ2hhdE1lc3NhZ2U7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBjaHVuayBvZiBhIGNoYXQgbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoXG4gKiBvdGhlciBjaGF0IG1lc3NhZ2UgY2h1bmtzLlxuICovXG5jbGFzcyBDaGF0TWVzc2FnZUNodW5rIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VNZXNzYWdlQ2h1bmsge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJDaGF0TWVzc2FnZUNodW5rXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgcm9sZSkge1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBmaWVsZHMgPSB7IGNvbnRlbnQ6IGZpZWxkcywgcm9sZTogcm9sZSB9O1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJvbGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yb2xlID0gZmllbGRzLnJvbGU7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJnZW5lcmljXCI7XG4gICAgfVxuICAgIGNvbmNhdChjaHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IENoYXRNZXNzYWdlQ2h1bmsoe1xuICAgICAgICAgICAgY29udGVudDogKDAsIGJhc2VfanNfMS5tZXJnZUNvbnRlbnQpKHRoaXMuY29udGVudCwgY2h1bmsuY29udGVudCksXG4gICAgICAgICAgICBhZGRpdGlvbmFsX2t3YXJnczogKDAsIGJhc2VfanNfMS5fbWVyZ2VEaWN0cykodGhpcy5hZGRpdGlvbmFsX2t3YXJncywgY2h1bmsuYWRkaXRpb25hbF9rd2FyZ3MpLFxuICAgICAgICAgICAgcmVzcG9uc2VfbWV0YWRhdGE6ICgwLCBiYXNlX2pzXzEuX21lcmdlRGljdHMpKHRoaXMucmVzcG9uc2VfbWV0YWRhdGEsIGNodW5rLnJlc3BvbnNlX21ldGFkYXRhKSxcbiAgICAgICAgICAgIHJvbGU6IHRoaXMucm9sZSxcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkID8/IGNodW5rLmlkLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IF9wcmludGFibGVGaWVsZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci5fcHJpbnRhYmxlRmllbGRzLFxuICAgICAgICAgICAgcm9sZTogdGhpcy5yb2xlLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhdE1lc3NhZ2VDaHVuayA9IENoYXRNZXNzYWdlQ2h1bms7XG5mdW5jdGlvbiBpc0NoYXRNZXNzYWdlKHgpIHtcbiAgICByZXR1cm4geC5fZ2V0VHlwZSgpID09PSBcImdlbmVyaWNcIjtcbn1cbmZ1bmN0aW9uIGlzQ2hhdE1lc3NhZ2VDaHVuayh4KSB7XG4gICAgcmV0dXJuIHguX2dldFR5cGUoKSA9PT0gXCJnZW5lcmljXCI7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/chat.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/content_blocks.cjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/content_blocks.cjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isDataContentBlock = isDataContentBlock;\nexports.isURLContentBlock = isURLContentBlock;\nexports.isBase64ContentBlock = isBase64ContentBlock;\nexports.isPlainTextContentBlock = isPlainTextContentBlock;\nexports.isIDContentBlock = isIDContentBlock;\nexports.convertToOpenAIImageBlock = convertToOpenAIImageBlock;\nexports.parseMimeType = parseMimeType;\nexports.parseBase64DataUrl = parseBase64DataUrl;\nexports.convertToProviderContentBlock = convertToProviderContentBlock;\nfunction isDataContentBlock(content_block) {\n    return (typeof content_block === \"object\" &&\n        content_block !== null &&\n        \"type\" in content_block &&\n        typeof content_block.type === \"string\" &&\n        \"source_type\" in content_block &&\n        (content_block.source_type === \"url\" ||\n            content_block.source_type === \"base64\" ||\n            content_block.source_type === \"text\" ||\n            content_block.source_type === \"id\"));\n}\nfunction isURLContentBlock(content_block) {\n    return (isDataContentBlock(content_block) &&\n        content_block.source_type === \"url\" &&\n        \"url\" in content_block &&\n        typeof content_block.url === \"string\");\n}\nfunction isBase64ContentBlock(content_block) {\n    return (isDataContentBlock(content_block) &&\n        content_block.source_type === \"base64\" &&\n        \"data\" in content_block &&\n        typeof content_block.data === \"string\");\n}\nfunction isPlainTextContentBlock(content_block) {\n    return (isDataContentBlock(content_block) &&\n        content_block.source_type === \"text\" &&\n        \"text\" in content_block &&\n        typeof content_block.text === \"string\");\n}\nfunction isIDContentBlock(content_block) {\n    return (isDataContentBlock(content_block) &&\n        content_block.source_type === \"id\" &&\n        \"id\" in content_block &&\n        typeof content_block.id === \"string\");\n}\nfunction convertToOpenAIImageBlock(content_block) {\n    if (isDataContentBlock(content_block)) {\n        if (content_block.source_type === \"url\") {\n            return {\n                type: \"image_url\",\n                image_url: {\n                    url: content_block.url,\n                },\n            };\n        }\n        if (content_block.source_type === \"base64\") {\n            if (!content_block.mime_type) {\n                throw new Error(\"mime_type key is required for base64 data.\");\n            }\n            const mime_type = content_block.mime_type;\n            return {\n                type: \"image_url\",\n                image_url: {\n                    url: `data:${mime_type};base64,${content_block.data}`,\n                },\n            };\n        }\n    }\n    throw new Error(\"Unsupported source type. Only 'url' and 'base64' are supported.\");\n}\n/**\n * Utility function for ChatModelProviders. Parses a mime type into a type, subtype, and parameters.\n *\n * @param mime_type - The mime type to parse.\n * @returns An object containing the type, subtype, and parameters.\n */\nfunction parseMimeType(mime_type) {\n    const parts = mime_type.split(\";\")[0].split(\"/\");\n    if (parts.length !== 2) {\n        throw new Error(`Invalid mime type: \"${mime_type}\" - does not match type/subtype format.`);\n    }\n    const type = parts[0].trim();\n    const subtype = parts[1].trim();\n    if (type === \"\" || subtype === \"\") {\n        throw new Error(`Invalid mime type: \"${mime_type}\" - type or subtype is empty.`);\n    }\n    const parameters = {};\n    for (const parameterKvp of mime_type.split(\";\").slice(1)) {\n        const parameterParts = parameterKvp.split(\"=\");\n        if (parameterParts.length !== 2) {\n            throw new Error(`Invalid parameter syntax in mime type: \"${mime_type}\".`);\n        }\n        const key = parameterParts[0].trim();\n        const value = parameterParts[1].trim();\n        if (key === \"\") {\n            throw new Error(`Invalid parameter syntax in mime type: \"${mime_type}\".`);\n        }\n        parameters[key] = value;\n    }\n    return {\n        type,\n        subtype,\n        parameters,\n    };\n}\n/**\n * Utility function for ChatModelProviders. Parses a base64 data URL into a typed array or string.\n *\n * @param dataUrl - The base64 data URL to parse.\n * @param asTypedArray - Whether to return the data as a typed array.\n * @returns The parsed data and mime type, or undefined if the data URL is invalid.\n */\nfunction parseBase64DataUrl({ dataUrl: data_url, asTypedArray = false, }) {\n    const formatMatch = data_url.match(/^data:(\\w+\\/\\w+);base64,([A-Za-z0-9+/]+=*)$/);\n    let mime_type;\n    if (formatMatch) {\n        mime_type = formatMatch[1].toLowerCase();\n        const data = asTypedArray\n            ? Uint8Array.from(atob(formatMatch[2]), (c) => c.charCodeAt(0))\n            : formatMatch[2];\n        return {\n            mime_type,\n            data,\n        };\n    }\n    return undefined;\n}\n/**\n * Convert from a standard data content block to a provider's proprietary data content block format.\n *\n * Don't override this method. Instead, override the more specific conversion methods and use this\n * method unmodified.\n *\n * @param block - The standard data content block to convert.\n * @returns The provider data content block.\n * @throws An error if the standard data content block type is not supported.\n */\nfunction convertToProviderContentBlock(block, converter) {\n    if (block.type === \"text\") {\n        if (!converter.fromStandardTextBlock) {\n            throw new Error(`Converter for ${converter.providerName} does not implement \\`fromStandardTextBlock\\` method.`);\n        }\n        return converter.fromStandardTextBlock(block);\n    }\n    if (block.type === \"image\") {\n        if (!converter.fromStandardImageBlock) {\n            throw new Error(`Converter for ${converter.providerName} does not implement \\`fromStandardImageBlock\\` method.`);\n        }\n        return converter.fromStandardImageBlock(block);\n    }\n    if (block.type === \"audio\") {\n        if (!converter.fromStandardAudioBlock) {\n            throw new Error(`Converter for ${converter.providerName} does not implement \\`fromStandardAudioBlock\\` method.`);\n        }\n        return converter.fromStandardAudioBlock(block);\n    }\n    if (block.type === \"file\") {\n        if (!converter.fromStandardFileBlock) {\n            throw new Error(`Converter for ${converter.providerName} does not implement \\`fromStandardFileBlock\\` method.`);\n        }\n        return converter.fromStandardFileBlock(block);\n    }\n    throw new Error(`Unable to convert content block type '${block.type}' to provider-specific format: not recognized.`);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvY29udGVudF9ibG9ja3MuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQix5QkFBeUI7QUFDekIsNEJBQTRCO0FBQzVCLCtCQUErQjtBQUMvQix3QkFBd0I7QUFDeEIsaUNBQWlDO0FBQ2pDLHFCQUFxQjtBQUNyQiwwQkFBMEI7QUFDMUIscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxXQUFXLFNBQVMsbUJBQW1CO0FBQ3hFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVO0FBQ3pEO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLHVFQUF1RSxVQUFVO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLFVBQVU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMENBQTBDO0FBQ3hFLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHdCQUF3QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHdCQUF3QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHdCQUF3QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHdCQUF3QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsV0FBVztBQUN4RSIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L21lc3NhZ2VzL2NvbnRlbnRfYmxvY2tzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNEYXRhQ29udGVudEJsb2NrID0gaXNEYXRhQ29udGVudEJsb2NrO1xuZXhwb3J0cy5pc1VSTENvbnRlbnRCbG9jayA9IGlzVVJMQ29udGVudEJsb2NrO1xuZXhwb3J0cy5pc0Jhc2U2NENvbnRlbnRCbG9jayA9IGlzQmFzZTY0Q29udGVudEJsb2NrO1xuZXhwb3J0cy5pc1BsYWluVGV4dENvbnRlbnRCbG9jayA9IGlzUGxhaW5UZXh0Q29udGVudEJsb2NrO1xuZXhwb3J0cy5pc0lEQ29udGVudEJsb2NrID0gaXNJRENvbnRlbnRCbG9jaztcbmV4cG9ydHMuY29udmVydFRvT3BlbkFJSW1hZ2VCbG9jayA9IGNvbnZlcnRUb09wZW5BSUltYWdlQmxvY2s7XG5leHBvcnRzLnBhcnNlTWltZVR5cGUgPSBwYXJzZU1pbWVUeXBlO1xuZXhwb3J0cy5wYXJzZUJhc2U2NERhdGFVcmwgPSBwYXJzZUJhc2U2NERhdGFVcmw7XG5leHBvcnRzLmNvbnZlcnRUb1Byb3ZpZGVyQ29udGVudEJsb2NrID0gY29udmVydFRvUHJvdmlkZXJDb250ZW50QmxvY2s7XG5mdW5jdGlvbiBpc0RhdGFDb250ZW50QmxvY2soY29udGVudF9ibG9jaykge1xuICAgIHJldHVybiAodHlwZW9mIGNvbnRlbnRfYmxvY2sgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgY29udGVudF9ibG9jayAhPT0gbnVsbCAmJlxuICAgICAgICBcInR5cGVcIiBpbiBjb250ZW50X2Jsb2NrICYmXG4gICAgICAgIHR5cGVvZiBjb250ZW50X2Jsb2NrLnR5cGUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgXCJzb3VyY2VfdHlwZVwiIGluIGNvbnRlbnRfYmxvY2sgJiZcbiAgICAgICAgKGNvbnRlbnRfYmxvY2suc291cmNlX3R5cGUgPT09IFwidXJsXCIgfHxcbiAgICAgICAgICAgIGNvbnRlbnRfYmxvY2suc291cmNlX3R5cGUgPT09IFwiYmFzZTY0XCIgfHxcbiAgICAgICAgICAgIGNvbnRlbnRfYmxvY2suc291cmNlX3R5cGUgPT09IFwidGV4dFwiIHx8XG4gICAgICAgICAgICBjb250ZW50X2Jsb2NrLnNvdXJjZV90eXBlID09PSBcImlkXCIpKTtcbn1cbmZ1bmN0aW9uIGlzVVJMQ29udGVudEJsb2NrKGNvbnRlbnRfYmxvY2spIHtcbiAgICByZXR1cm4gKGlzRGF0YUNvbnRlbnRCbG9jayhjb250ZW50X2Jsb2NrKSAmJlxuICAgICAgICBjb250ZW50X2Jsb2NrLnNvdXJjZV90eXBlID09PSBcInVybFwiICYmXG4gICAgICAgIFwidXJsXCIgaW4gY29udGVudF9ibG9jayAmJlxuICAgICAgICB0eXBlb2YgY29udGVudF9ibG9jay51cmwgPT09IFwic3RyaW5nXCIpO1xufVxuZnVuY3Rpb24gaXNCYXNlNjRDb250ZW50QmxvY2soY29udGVudF9ibG9jaykge1xuICAgIHJldHVybiAoaXNEYXRhQ29udGVudEJsb2NrKGNvbnRlbnRfYmxvY2spICYmXG4gICAgICAgIGNvbnRlbnRfYmxvY2suc291cmNlX3R5cGUgPT09IFwiYmFzZTY0XCIgJiZcbiAgICAgICAgXCJkYXRhXCIgaW4gY29udGVudF9ibG9jayAmJlxuICAgICAgICB0eXBlb2YgY29udGVudF9ibG9jay5kYXRhID09PSBcInN0cmluZ1wiKTtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5UZXh0Q29udGVudEJsb2NrKGNvbnRlbnRfYmxvY2spIHtcbiAgICByZXR1cm4gKGlzRGF0YUNvbnRlbnRCbG9jayhjb250ZW50X2Jsb2NrKSAmJlxuICAgICAgICBjb250ZW50X2Jsb2NrLnNvdXJjZV90eXBlID09PSBcInRleHRcIiAmJlxuICAgICAgICBcInRleHRcIiBpbiBjb250ZW50X2Jsb2NrICYmXG4gICAgICAgIHR5cGVvZiBjb250ZW50X2Jsb2NrLnRleHQgPT09IFwic3RyaW5nXCIpO1xufVxuZnVuY3Rpb24gaXNJRENvbnRlbnRCbG9jayhjb250ZW50X2Jsb2NrKSB7XG4gICAgcmV0dXJuIChpc0RhdGFDb250ZW50QmxvY2soY29udGVudF9ibG9jaykgJiZcbiAgICAgICAgY29udGVudF9ibG9jay5zb3VyY2VfdHlwZSA9PT0gXCJpZFwiICYmXG4gICAgICAgIFwiaWRcIiBpbiBjb250ZW50X2Jsb2NrICYmXG4gICAgICAgIHR5cGVvZiBjb250ZW50X2Jsb2NrLmlkID09PSBcInN0cmluZ1wiKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb09wZW5BSUltYWdlQmxvY2soY29udGVudF9ibG9jaykge1xuICAgIGlmIChpc0RhdGFDb250ZW50QmxvY2soY29udGVudF9ibG9jaykpIHtcbiAgICAgICAgaWYgKGNvbnRlbnRfYmxvY2suc291cmNlX3R5cGUgPT09IFwidXJsXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbWFnZV91cmxcIixcbiAgICAgICAgICAgICAgICBpbWFnZV91cmw6IHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBjb250ZW50X2Jsb2NrLnVybCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudF9ibG9jay5zb3VyY2VfdHlwZSA9PT0gXCJiYXNlNjRcIikge1xuICAgICAgICAgICAgaWYgKCFjb250ZW50X2Jsb2NrLm1pbWVfdHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pbWVfdHlwZSBrZXkgaXMgcmVxdWlyZWQgZm9yIGJhc2U2NCBkYXRhLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1pbWVfdHlwZSA9IGNvbnRlbnRfYmxvY2subWltZV90eXBlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImltYWdlX3VybFwiLFxuICAgICAgICAgICAgICAgIGltYWdlX3VybDoge1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGBkYXRhOiR7bWltZV90eXBlfTtiYXNlNjQsJHtjb250ZW50X2Jsb2NrLmRhdGF9YCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBzb3VyY2UgdHlwZS4gT25seSAndXJsJyBhbmQgJ2Jhc2U2NCcgYXJlIHN1cHBvcnRlZC5cIik7XG59XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIENoYXRNb2RlbFByb3ZpZGVycy4gUGFyc2VzIGEgbWltZSB0eXBlIGludG8gYSB0eXBlLCBzdWJ0eXBlLCBhbmQgcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0gbWltZV90eXBlIC0gVGhlIG1pbWUgdHlwZSB0byBwYXJzZS5cbiAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSB0eXBlLCBzdWJ0eXBlLCBhbmQgcGFyYW1ldGVycy5cbiAqL1xuZnVuY3Rpb24gcGFyc2VNaW1lVHlwZShtaW1lX3R5cGUpIHtcbiAgICBjb25zdCBwYXJ0cyA9IG1pbWVfdHlwZS5zcGxpdChcIjtcIilbMF0uc3BsaXQoXCIvXCIpO1xuICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1pbWUgdHlwZTogXCIke21pbWVfdHlwZX1cIiAtIGRvZXMgbm90IG1hdGNoIHR5cGUvc3VidHlwZSBmb3JtYXQuYCk7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBwYXJ0c1swXS50cmltKCk7XG4gICAgY29uc3Qgc3VidHlwZSA9IHBhcnRzWzFdLnRyaW0oKTtcbiAgICBpZiAodHlwZSA9PT0gXCJcIiB8fCBzdWJ0eXBlID09PSBcIlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtaW1lIHR5cGU6IFwiJHttaW1lX3R5cGV9XCIgLSB0eXBlIG9yIHN1YnR5cGUgaXMgZW1wdHkuYCk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHBhcmFtZXRlckt2cCBvZiBtaW1lX3R5cGUuc3BsaXQoXCI7XCIpLnNsaWNlKDEpKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlclBhcnRzID0gcGFyYW1ldGVyS3ZwLnNwbGl0KFwiPVwiKTtcbiAgICAgICAgaWYgKHBhcmFtZXRlclBhcnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhcmFtZXRlciBzeW50YXggaW4gbWltZSB0eXBlOiBcIiR7bWltZV90eXBlfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleSA9IHBhcmFtZXRlclBhcnRzWzBdLnRyaW0oKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbWV0ZXJQYXJ0c1sxXS50cmltKCk7XG4gICAgICAgIGlmIChrZXkgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXJhbWV0ZXIgc3ludGF4IGluIG1pbWUgdHlwZTogXCIke21pbWVfdHlwZX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbWV0ZXJzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgc3VidHlwZSxcbiAgICAgICAgcGFyYW1ldGVycyxcbiAgICB9O1xufVxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciBDaGF0TW9kZWxQcm92aWRlcnMuIFBhcnNlcyBhIGJhc2U2NCBkYXRhIFVSTCBpbnRvIGEgdHlwZWQgYXJyYXkgb3Igc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBkYXRhVXJsIC0gVGhlIGJhc2U2NCBkYXRhIFVSTCB0byBwYXJzZS5cbiAqIEBwYXJhbSBhc1R5cGVkQXJyYXkgLSBXaGV0aGVyIHRvIHJldHVybiB0aGUgZGF0YSBhcyBhIHR5cGVkIGFycmF5LlxuICogQHJldHVybnMgVGhlIHBhcnNlZCBkYXRhIGFuZCBtaW1lIHR5cGUsIG9yIHVuZGVmaW5lZCBpZiB0aGUgZGF0YSBVUkwgaXMgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VCYXNlNjREYXRhVXJsKHsgZGF0YVVybDogZGF0YV91cmwsIGFzVHlwZWRBcnJheSA9IGZhbHNlLCB9KSB7XG4gICAgY29uc3QgZm9ybWF0TWF0Y2ggPSBkYXRhX3VybC5tYXRjaCgvXmRhdGE6KFxcdytcXC9cXHcrKTtiYXNlNjQsKFtBLVphLXowLTkrL10rPSopJC8pO1xuICAgIGxldCBtaW1lX3R5cGU7XG4gICAgaWYgKGZvcm1hdE1hdGNoKSB7XG4gICAgICAgIG1pbWVfdHlwZSA9IGZvcm1hdE1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhc1R5cGVkQXJyYXlcbiAgICAgICAgICAgID8gVWludDhBcnJheS5mcm9tKGF0b2IoZm9ybWF0TWF0Y2hbMl0pLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKVxuICAgICAgICAgICAgOiBmb3JtYXRNYXRjaFsyXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1pbWVfdHlwZSxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIENvbnZlcnQgZnJvbSBhIHN0YW5kYXJkIGRhdGEgY29udGVudCBibG9jayB0byBhIHByb3ZpZGVyJ3MgcHJvcHJpZXRhcnkgZGF0YSBjb250ZW50IGJsb2NrIGZvcm1hdC5cbiAqXG4gKiBEb24ndCBvdmVycmlkZSB0aGlzIG1ldGhvZC4gSW5zdGVhZCwgb3ZlcnJpZGUgdGhlIG1vcmUgc3BlY2lmaWMgY29udmVyc2lvbiBtZXRob2RzIGFuZCB1c2UgdGhpc1xuICogbWV0aG9kIHVubW9kaWZpZWQuXG4gKlxuICogQHBhcmFtIGJsb2NrIC0gVGhlIHN0YW5kYXJkIGRhdGEgY29udGVudCBibG9jayB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIHByb3ZpZGVyIGRhdGEgY29udGVudCBibG9jay5cbiAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIHN0YW5kYXJkIGRhdGEgY29udGVudCBibG9jayB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRUb1Byb3ZpZGVyQ29udGVudEJsb2NrKGJsb2NrLCBjb252ZXJ0ZXIpIHtcbiAgICBpZiAoYmxvY2sudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgaWYgKCFjb252ZXJ0ZXIuZnJvbVN0YW5kYXJkVGV4dEJsb2NrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnZlcnRlciBmb3IgJHtjb252ZXJ0ZXIucHJvdmlkZXJOYW1lfSBkb2VzIG5vdCBpbXBsZW1lbnQgXFxgZnJvbVN0YW5kYXJkVGV4dEJsb2NrXFxgIG1ldGhvZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udmVydGVyLmZyb21TdGFuZGFyZFRleHRCbG9jayhibG9jayk7XG4gICAgfVxuICAgIGlmIChibG9jay50eXBlID09PSBcImltYWdlXCIpIHtcbiAgICAgICAgaWYgKCFjb252ZXJ0ZXIuZnJvbVN0YW5kYXJkSW1hZ2VCbG9jaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb252ZXJ0ZXIgZm9yICR7Y29udmVydGVyLnByb3ZpZGVyTmFtZX0gZG9lcyBub3QgaW1wbGVtZW50IFxcYGZyb21TdGFuZGFyZEltYWdlQmxvY2tcXGAgbWV0aG9kLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb252ZXJ0ZXIuZnJvbVN0YW5kYXJkSW1hZ2VCbG9jayhibG9jayk7XG4gICAgfVxuICAgIGlmIChibG9jay50eXBlID09PSBcImF1ZGlvXCIpIHtcbiAgICAgICAgaWYgKCFjb252ZXJ0ZXIuZnJvbVN0YW5kYXJkQXVkaW9CbG9jaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb252ZXJ0ZXIgZm9yICR7Y29udmVydGVyLnByb3ZpZGVyTmFtZX0gZG9lcyBub3QgaW1wbGVtZW50IFxcYGZyb21TdGFuZGFyZEF1ZGlvQmxvY2tcXGAgbWV0aG9kLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb252ZXJ0ZXIuZnJvbVN0YW5kYXJkQXVkaW9CbG9jayhibG9jayk7XG4gICAgfVxuICAgIGlmIChibG9jay50eXBlID09PSBcImZpbGVcIikge1xuICAgICAgICBpZiAoIWNvbnZlcnRlci5mcm9tU3RhbmRhcmRGaWxlQmxvY2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udmVydGVyIGZvciAke2NvbnZlcnRlci5wcm92aWRlck5hbWV9IGRvZXMgbm90IGltcGxlbWVudCBcXGBmcm9tU3RhbmRhcmRGaWxlQmxvY2tcXGAgbWV0aG9kLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb252ZXJ0ZXIuZnJvbVN0YW5kYXJkRmlsZUJsb2NrKGJsb2NrKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gY29udmVydCBjb250ZW50IGJsb2NrIHR5cGUgJyR7YmxvY2sudHlwZX0nIHRvIHByb3ZpZGVyLXNwZWNpZmljIGZvcm1hdDogbm90IHJlY29nbml6ZWQuYCk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/content_blocks.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/function.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/function.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FunctionMessageChunk = exports.FunctionMessage = void 0;\nexports.isFunctionMessage = isFunctionMessage;\nexports.isFunctionMessageChunk = isFunctionMessageChunk;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\n/**\n * Represents a function message in a conversation.\n */\nclass FunctionMessage extends base_js_1.BaseMessage {\n    static lc_name() {\n        return \"FunctionMessage\";\n    }\n    constructor(fields, \n    /** @deprecated */\n    name) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, name: name };\n        }\n        super(fields);\n    }\n    _getType() {\n        return \"function\";\n    }\n}\nexports.FunctionMessage = FunctionMessage;\n/**\n * Represents a chunk of a function message, which can be concatenated\n * with other function message chunks.\n */\nclass FunctionMessageChunk extends base_js_1.BaseMessageChunk {\n    static lc_name() {\n        return \"FunctionMessageChunk\";\n    }\n    _getType() {\n        return \"function\";\n    }\n    concat(chunk) {\n        return new FunctionMessageChunk({\n            content: (0, base_js_1.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0, base_js_1._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0, base_js_1._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            name: this.name ?? \"\",\n            id: this.id ?? chunk.id,\n        });\n    }\n}\nexports.FunctionMessageChunk = FunctionMessageChunk;\nfunction isFunctionMessage(x) {\n    return x._getType() === \"function\";\n}\nfunction isFunctionMessageChunk(x) {\n    return x._getType() === \"function\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvZnVuY3Rpb24uY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLHVCQUF1QjtBQUN0RCx5QkFBeUI7QUFDekIsOEJBQThCO0FBQzlCLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9tZXNzYWdlcy9mdW5jdGlvbi5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZ1bmN0aW9uTWVzc2FnZUNodW5rID0gZXhwb3J0cy5GdW5jdGlvbk1lc3NhZ2UgPSB2b2lkIDA7XG5leHBvcnRzLmlzRnVuY3Rpb25NZXNzYWdlID0gaXNGdW5jdGlvbk1lc3NhZ2U7XG5leHBvcnRzLmlzRnVuY3Rpb25NZXNzYWdlQ2h1bmsgPSBpc0Z1bmN0aW9uTWVzc2FnZUNodW5rO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBmdW5jdGlvbiBtZXNzYWdlIGluIGEgY29udmVyc2F0aW9uLlxuICovXG5jbGFzcyBGdW5jdGlvbk1lc3NhZ2UgZXh0ZW5kcyBiYXNlX2pzXzEuQmFzZU1lc3NhZ2Uge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJGdW5jdGlvbk1lc3NhZ2VcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCBcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGZpZWxkcyA9IHsgY29udGVudDogZmllbGRzLCBuYW1lOiBuYW1lIH07XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImZ1bmN0aW9uXCI7XG4gICAgfVxufVxuZXhwb3J0cy5GdW5jdGlvbk1lc3NhZ2UgPSBGdW5jdGlvbk1lc3NhZ2U7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBjaHVuayBvZiBhIGZ1bmN0aW9uIG1lc3NhZ2UsIHdoaWNoIGNhbiBiZSBjb25jYXRlbmF0ZWRcbiAqIHdpdGggb3RoZXIgZnVuY3Rpb24gbWVzc2FnZSBjaHVua3MuXG4gKi9cbmNsYXNzIEZ1bmN0aW9uTWVzc2FnZUNodW5rIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VNZXNzYWdlQ2h1bmsge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJGdW5jdGlvbk1lc3NhZ2VDaHVua1wiO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIjtcbiAgICB9XG4gICAgY29uY2F0KGNodW5rKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25NZXNzYWdlQ2h1bmsoe1xuICAgICAgICAgICAgY29udGVudDogKDAsIGJhc2VfanNfMS5tZXJnZUNvbnRlbnQpKHRoaXMuY29udGVudCwgY2h1bmsuY29udGVudCksXG4gICAgICAgICAgICBhZGRpdGlvbmFsX2t3YXJnczogKDAsIGJhc2VfanNfMS5fbWVyZ2VEaWN0cykodGhpcy5hZGRpdGlvbmFsX2t3YXJncywgY2h1bmsuYWRkaXRpb25hbF9rd2FyZ3MpLFxuICAgICAgICAgICAgcmVzcG9uc2VfbWV0YWRhdGE6ICgwLCBiYXNlX2pzXzEuX21lcmdlRGljdHMpKHRoaXMucmVzcG9uc2VfbWV0YWRhdGEsIGNodW5rLnJlc3BvbnNlX21ldGFkYXRhKSxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSA/PyBcIlwiLFxuICAgICAgICAgICAgaWQ6IHRoaXMuaWQgPz8gY2h1bmsuaWQsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuRnVuY3Rpb25NZXNzYWdlQ2h1bmsgPSBGdW5jdGlvbk1lc3NhZ2VDaHVuaztcbmZ1bmN0aW9uIGlzRnVuY3Rpb25NZXNzYWdlKHgpIHtcbiAgICByZXR1cm4geC5fZ2V0VHlwZSgpID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uTWVzc2FnZUNodW5rKHgpIHtcbiAgICByZXR1cm4geC5fZ2V0VHlwZSgpID09PSBcImZ1bmN0aW9uXCI7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/function.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/human.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/human.cjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HumanMessageChunk = exports.HumanMessage = void 0;\nexports.isHumanMessage = isHumanMessage;\nexports.isHumanMessageChunk = isHumanMessageChunk;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\n/**\n * Represents a human message in a conversation.\n */\nclass HumanMessage extends base_js_1.BaseMessage {\n    static lc_name() {\n        return \"HumanMessage\";\n    }\n    _getType() {\n        return \"human\";\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        super(fields, kwargs);\n    }\n}\nexports.HumanMessage = HumanMessage;\n/**\n * Represents a chunk of a human message, which can be concatenated with\n * other human message chunks.\n */\nclass HumanMessageChunk extends base_js_1.BaseMessageChunk {\n    static lc_name() {\n        return \"HumanMessageChunk\";\n    }\n    _getType() {\n        return \"human\";\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        super(fields, kwargs);\n    }\n    concat(chunk) {\n        return new HumanMessageChunk({\n            content: (0, base_js_1.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0, base_js_1._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0, base_js_1._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            id: this.id ?? chunk.id,\n        });\n    }\n}\nexports.HumanMessageChunk = HumanMessageChunk;\nfunction isHumanMessage(x) {\n    return x.getType() === \"human\";\n}\nfunction isHumanMessageChunk(x) {\n    return x.getType() === \"human\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvaHVtYW4uY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLG9CQUFvQjtBQUNoRCxzQkFBc0I7QUFDdEIsMkJBQTJCO0FBQzNCLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvaHVtYW4uY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IdW1hbk1lc3NhZ2VDaHVuayA9IGV4cG9ydHMuSHVtYW5NZXNzYWdlID0gdm9pZCAwO1xuZXhwb3J0cy5pc0h1bWFuTWVzc2FnZSA9IGlzSHVtYW5NZXNzYWdlO1xuZXhwb3J0cy5pc0h1bWFuTWVzc2FnZUNodW5rID0gaXNIdW1hbk1lc3NhZ2VDaHVuaztcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2UuY2pzXCIpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgaHVtYW4gbWVzc2FnZSBpbiBhIGNvbnZlcnNhdGlvbi5cbiAqL1xuY2xhc3MgSHVtYW5NZXNzYWdlIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VNZXNzYWdlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiSHVtYW5NZXNzYWdlXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJodW1hblwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIFxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIGt3YXJncykge1xuICAgICAgICBzdXBlcihmaWVsZHMsIGt3YXJncyk7XG4gICAgfVxufVxuZXhwb3J0cy5IdW1hbk1lc3NhZ2UgPSBIdW1hbk1lc3NhZ2U7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBjaHVuayBvZiBhIGh1bWFuIG1lc3NhZ2UsIHdoaWNoIGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aFxuICogb3RoZXIgaHVtYW4gbWVzc2FnZSBjaHVua3MuXG4gKi9cbmNsYXNzIEh1bWFuTWVzc2FnZUNodW5rIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VNZXNzYWdlQ2h1bmsge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJIdW1hbk1lc3NhZ2VDaHVua1wiO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiaHVtYW5cIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCBcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBrd2FyZ3MpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzLCBrd2FyZ3MpO1xuICAgIH1cbiAgICBjb25jYXQoY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIdW1hbk1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICBjb250ZW50OiAoMCwgYmFzZV9qc18xLm1lcmdlQ29udGVudCkodGhpcy5jb250ZW50LCBjaHVuay5jb250ZW50KSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiAoMCwgYmFzZV9qc18xLl9tZXJnZURpY3RzKSh0aGlzLmFkZGl0aW9uYWxfa3dhcmdzLCBjaHVuay5hZGRpdGlvbmFsX2t3YXJncyksXG4gICAgICAgICAgICByZXNwb25zZV9tZXRhZGF0YTogKDAsIGJhc2VfanNfMS5fbWVyZ2VEaWN0cykodGhpcy5yZXNwb25zZV9tZXRhZGF0YSwgY2h1bmsucmVzcG9uc2VfbWV0YWRhdGEpLFxuICAgICAgICAgICAgaWQ6IHRoaXMuaWQgPz8gY2h1bmsuaWQsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSHVtYW5NZXNzYWdlQ2h1bmsgPSBIdW1hbk1lc3NhZ2VDaHVuaztcbmZ1bmN0aW9uIGlzSHVtYW5NZXNzYWdlKHgpIHtcbiAgICByZXR1cm4geC5nZXRUeXBlKCkgPT09IFwiaHVtYW5cIjtcbn1cbmZ1bmN0aW9uIGlzSHVtYW5NZXNzYWdlQ2h1bmsoeCkge1xuICAgIHJldHVybiB4LmdldFR5cGUoKSA9PT0gXCJodW1hblwiO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/human.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/index.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/index.cjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isToolMessageChunk = exports.isToolMessage = exports.ToolMessageChunk = exports.ToolMessage = void 0;\n__exportStar(__webpack_require__(/*! ./ai.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/ai.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./chat.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/chat.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./function.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/function.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./human.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/human.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./system.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/system.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./transformers.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/transformers.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./modifier.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/modifier.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./content_blocks.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/content_blocks.cjs\"), exports);\n// TODO: Use a star export when we deprecate the\n// existing \"ToolCall\" type in \"base.js\".\nvar tool_js_1 = __webpack_require__(/*! ./tool.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/tool.cjs\");\nObject.defineProperty(exports, \"ToolMessage\", ({ enumerable: true, get: function () { return tool_js_1.ToolMessage; } }));\nObject.defineProperty(exports, \"ToolMessageChunk\", ({ enumerable: true, get: function () { return tool_js_1.ToolMessageChunk; } }));\nObject.defineProperty(exports, \"isToolMessage\", ({ enumerable: true, get: function () { return tool_js_1.isToolMessage; } }));\nObject.defineProperty(exports, \"isToolMessageChunk\", ({ enumerable: true, get: function () { return tool_js_1.isToolMessageChunk; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQixHQUFHLHFCQUFxQixHQUFHLHdCQUF3QixHQUFHLG1CQUFtQjtBQUNuRyxhQUFhLG1CQUFPLENBQUMsMkVBQVU7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLCtFQUFZO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQywrRUFBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsdUZBQWdCO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyxpRkFBYTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsbUZBQWM7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLGlGQUFhO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQywrRkFBb0I7QUFDekMsYUFBYSxtQkFBTyxDQUFDLHVGQUFnQjtBQUNyQyxhQUFhLG1CQUFPLENBQUMsbUdBQXNCO0FBQzNDO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQywrRUFBWTtBQUNwQywrQ0FBOEMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDdkgsb0RBQW1ELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQ2pJLGlEQUFnRCxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUMzSCxzREFBcUQsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9tZXNzYWdlcy9pbmRleC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNUb29sTWVzc2FnZUNodW5rID0gZXhwb3J0cy5pc1Rvb2xNZXNzYWdlID0gZXhwb3J0cy5Ub29sTWVzc2FnZUNodW5rID0gZXhwb3J0cy5Ub29sTWVzc2FnZSA9IHZvaWQgMDtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9haS5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2UuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jaGF0LmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZnVuY3Rpb24uY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9odW1hbi5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3N5c3RlbS5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHJhbnNmb3JtZXJzLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9kaWZpZXIuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb250ZW50X2Jsb2Nrcy5janNcIiksIGV4cG9ydHMpO1xuLy8gVE9ETzogVXNlIGEgc3RhciBleHBvcnQgd2hlbiB3ZSBkZXByZWNhdGUgdGhlXG4vLyBleGlzdGluZyBcIlRvb2xDYWxsXCIgdHlwZSBpbiBcImJhc2UuanNcIi5cbnZhciB0b29sX2pzXzEgPSByZXF1aXJlKFwiLi90b29sLmNqc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRvb2xNZXNzYWdlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0b29sX2pzXzEuVG9vbE1lc3NhZ2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUb29sTWVzc2FnZUNodW5rXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0b29sX2pzXzEuVG9vbE1lc3NhZ2VDaHVuazsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzVG9vbE1lc3NhZ2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRvb2xfanNfMS5pc1Rvb2xNZXNzYWdlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNUb29sTWVzc2FnZUNodW5rXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0b29sX2pzXzEuaXNUb29sTWVzc2FnZUNodW5rOyB9IH0pO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/modifier.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/modifier.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RemoveMessage = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\n/**\n * Message responsible for deleting other messages.\n */\nclass RemoveMessage extends base_js_1.BaseMessage {\n    constructor(fields) {\n        super({\n            ...fields,\n            content: \"\",\n        });\n        /**\n         * The ID of the message to remove.\n         */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.id = fields.id;\n    }\n    _getType() {\n        return \"remove\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            id: this.id,\n        };\n    }\n}\nexports.RemoveMessage = RemoveMessage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvbW9kaWZpZXIuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixrQkFBa0IsbUJBQU8sQ0FBQywrRUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvbW9kaWZpZXIuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZW1vdmVNZXNzYWdlID0gdm9pZCAwO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG4vKipcbiAqIE1lc3NhZ2UgcmVzcG9uc2libGUgZm9yIGRlbGV0aW5nIG90aGVyIG1lc3NhZ2VzLlxuICovXG5jbGFzcyBSZW1vdmVNZXNzYWdlIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSUQgb2YgdGhlIG1lc3NhZ2UgdG8gcmVtb3ZlLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pZCA9IGZpZWxkcy5pZDtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcInJlbW92ZVwiO1xuICAgIH1cbiAgICBnZXQgX3ByaW50YWJsZUZpZWxkcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLl9wcmludGFibGVGaWVsZHMsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlJlbW92ZU1lc3NhZ2UgPSBSZW1vdmVNZXNzYWdlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/modifier.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/system.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/system.cjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SystemMessageChunk = exports.SystemMessage = void 0;\nexports.isSystemMessage = isSystemMessage;\nexports.isSystemMessageChunk = isSystemMessageChunk;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\n/**\n * Represents a system message in a conversation.\n */\nclass SystemMessage extends base_js_1.BaseMessage {\n    static lc_name() {\n        return \"SystemMessage\";\n    }\n    _getType() {\n        return \"system\";\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        super(fields, kwargs);\n    }\n}\nexports.SystemMessage = SystemMessage;\n/**\n * Represents a chunk of a system message, which can be concatenated with\n * other system message chunks.\n */\nclass SystemMessageChunk extends base_js_1.BaseMessageChunk {\n    static lc_name() {\n        return \"SystemMessageChunk\";\n    }\n    _getType() {\n        return \"system\";\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        super(fields, kwargs);\n    }\n    concat(chunk) {\n        return new SystemMessageChunk({\n            content: (0, base_js_1.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0, base_js_1._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0, base_js_1._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            id: this.id ?? chunk.id,\n        });\n    }\n}\nexports.SystemMessageChunk = SystemMessageChunk;\nfunction isSystemMessage(x) {\n    return x._getType() === \"system\";\n}\nfunction isSystemMessageChunk(x) {\n    return x._getType() === \"system\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvc3lzdGVtLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRyxxQkFBcUI7QUFDbEQsdUJBQXVCO0FBQ3ZCLDRCQUE0QjtBQUM1QixrQkFBa0IsbUJBQU8sQ0FBQywrRUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L21lc3NhZ2VzL3N5c3RlbS5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN5c3RlbU1lc3NhZ2VDaHVuayA9IGV4cG9ydHMuU3lzdGVtTWVzc2FnZSA9IHZvaWQgMDtcbmV4cG9ydHMuaXNTeXN0ZW1NZXNzYWdlID0gaXNTeXN0ZW1NZXNzYWdlO1xuZXhwb3J0cy5pc1N5c3RlbU1lc3NhZ2VDaHVuayA9IGlzU3lzdGVtTWVzc2FnZUNodW5rO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBzeXN0ZW0gbWVzc2FnZSBpbiBhIGNvbnZlcnNhdGlvbi5cbiAqL1xuY2xhc3MgU3lzdGVtTWVzc2FnZSBleHRlbmRzIGJhc2VfanNfMS5CYXNlTWVzc2FnZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlN5c3RlbU1lc3NhZ2VcIjtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcInN5c3RlbVwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIFxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIGt3YXJncykge1xuICAgICAgICBzdXBlcihmaWVsZHMsIGt3YXJncyk7XG4gICAgfVxufVxuZXhwb3J0cy5TeXN0ZW1NZXNzYWdlID0gU3lzdGVtTWVzc2FnZTtcbi8qKlxuICogUmVwcmVzZW50cyBhIGNodW5rIG9mIGEgc3lzdGVtIG1lc3NhZ2UsIHdoaWNoIGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aFxuICogb3RoZXIgc3lzdGVtIG1lc3NhZ2UgY2h1bmtzLlxuICovXG5jbGFzcyBTeXN0ZW1NZXNzYWdlQ2h1bmsgZXh0ZW5kcyBiYXNlX2pzXzEuQmFzZU1lc3NhZ2VDaHVuayB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlN5c3RlbU1lc3NhZ2VDaHVua1wiO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwic3lzdGVtXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgXG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAga3dhcmdzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcywga3dhcmdzKTtcbiAgICB9XG4gICAgY29uY2F0KGNodW5rKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3lzdGVtTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6ICgwLCBiYXNlX2pzXzEubWVyZ2VDb250ZW50KSh0aGlzLmNvbnRlbnQsIGNodW5rLmNvbnRlbnQpLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6ICgwLCBiYXNlX2pzXzEuX21lcmdlRGljdHMpKHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MsIGNodW5rLmFkZGl0aW9uYWxfa3dhcmdzKSxcbiAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiAoMCwgYmFzZV9qc18xLl9tZXJnZURpY3RzKSh0aGlzLnJlc3BvbnNlX21ldGFkYXRhLCBjaHVuay5yZXNwb25zZV9tZXRhZGF0YSksXG4gICAgICAgICAgICBpZDogdGhpcy5pZCA/PyBjaHVuay5pZCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TeXN0ZW1NZXNzYWdlQ2h1bmsgPSBTeXN0ZW1NZXNzYWdlQ2h1bms7XG5mdW5jdGlvbiBpc1N5c3RlbU1lc3NhZ2UoeCkge1xuICAgIHJldHVybiB4Ll9nZXRUeXBlKCkgPT09IFwic3lzdGVtXCI7XG59XG5mdW5jdGlvbiBpc1N5c3RlbU1lc3NhZ2VDaHVuayh4KSB7XG4gICAgcmV0dXJuIHguX2dldFR5cGUoKSA9PT0gXCJzeXN0ZW1cIjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/system.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/tool.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/tool.cjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ToolMessageChunk = exports.ToolMessage = void 0;\nexports.isDirectToolOutput = isDirectToolOutput;\nexports.defaultToolCallParser = defaultToolCallParser;\nexports.isToolMessage = isToolMessage;\nexports.isToolMessageChunk = isToolMessageChunk;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\nfunction isDirectToolOutput(x) {\n    return (x != null &&\n        typeof x === \"object\" &&\n        \"lc_direct_tool_output\" in x &&\n        x.lc_direct_tool_output === true);\n}\n/**\n * Represents a tool message in a conversation.\n */\nclass ToolMessage extends base_js_1.BaseMessage {\n    static lc_name() {\n        return \"ToolMessage\";\n    }\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return { tool_call_id: \"tool_call_id\" };\n    }\n    constructor(fields, tool_call_id, name) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, name, tool_call_id: tool_call_id };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_direct_tool_output\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        /**\n         * Status of the tool invocation.\n         * @version 0.2.19\n         */\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tool_call_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Artifact of the Tool execution which is not meant to be sent to the model.\n         *\n         * Should only be specified if it is different from the message content, e.g. if only\n         * a subset of the full tool output is being passed as message content but the full\n         * output is needed in other parts of the code.\n         */\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"artifact\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tool_call_id = fields.tool_call_id;\n        this.artifact = fields.artifact;\n        this.status = fields.status;\n        this.metadata = fields.metadata;\n    }\n    _getType() {\n        return \"tool\";\n    }\n    static isInstance(message) {\n        return message._getType() === \"tool\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            tool_call_id: this.tool_call_id,\n            artifact: this.artifact,\n        };\n    }\n}\nexports.ToolMessage = ToolMessage;\n/**\n * Represents a chunk of a tool message, which can be concatenated\n * with other tool message chunks.\n */\nclass ToolMessageChunk extends base_js_1.BaseMessageChunk {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"tool_call_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Status of the tool invocation.\n         * @version 0.2.19\n         */\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Artifact of the Tool execution which is not meant to be sent to the model.\n         *\n         * Should only be specified if it is different from the message content, e.g. if only\n         * a subset of the full tool output is being passed as message content but the full\n         * output is needed in other parts of the code.\n         */\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"artifact\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tool_call_id = fields.tool_call_id;\n        this.artifact = fields.artifact;\n        this.status = fields.status;\n    }\n    static lc_name() {\n        return \"ToolMessageChunk\";\n    }\n    _getType() {\n        return \"tool\";\n    }\n    concat(chunk) {\n        return new ToolMessageChunk({\n            content: (0, base_js_1.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0, base_js_1._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0, base_js_1._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            artifact: (0, base_js_1._mergeObj)(this.artifact, chunk.artifact),\n            tool_call_id: this.tool_call_id,\n            id: this.id ?? chunk.id,\n            status: (0, base_js_1._mergeStatus)(this.status, chunk.status),\n        });\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            tool_call_id: this.tool_call_id,\n            artifact: this.artifact,\n        };\n    }\n}\nexports.ToolMessageChunk = ToolMessageChunk;\nfunction defaultToolCallParser(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nrawToolCalls) {\n    const toolCalls = [];\n    const invalidToolCalls = [];\n    for (const toolCall of rawToolCalls) {\n        if (!toolCall.function) {\n            continue;\n        }\n        else {\n            const functionName = toolCall.function.name;\n            try {\n                const functionArgs = JSON.parse(toolCall.function.arguments);\n                const parsed = {\n                    name: functionName || \"\",\n                    args: functionArgs || {},\n                    id: toolCall.id,\n                };\n                toolCalls.push(parsed);\n            }\n            catch (error) {\n                invalidToolCalls.push({\n                    name: functionName,\n                    args: toolCall.function.arguments,\n                    id: toolCall.id,\n                    error: \"Malformed args.\",\n                });\n            }\n        }\n    }\n    return [toolCalls, invalidToolCalls];\n}\nfunction isToolMessage(x) {\n    return x._getType() === \"tool\";\n}\nfunction isToolMessageChunk(x) {\n    return x._getType() === \"tool\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvdG9vbC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsbUJBQW1CO0FBQzlDLDBCQUEwQjtBQUMxQiw2QkFBNkI7QUFDN0IscUJBQXFCO0FBQ3JCLDBCQUEwQjtBQUMxQixrQkFBa0IsbUJBQU8sQ0FBQywrRUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L21lc3NhZ2VzL3Rvb2wuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ub29sTWVzc2FnZUNodW5rID0gZXhwb3J0cy5Ub29sTWVzc2FnZSA9IHZvaWQgMDtcbmV4cG9ydHMuaXNEaXJlY3RUb29sT3V0cHV0ID0gaXNEaXJlY3RUb29sT3V0cHV0O1xuZXhwb3J0cy5kZWZhdWx0VG9vbENhbGxQYXJzZXIgPSBkZWZhdWx0VG9vbENhbGxQYXJzZXI7XG5leHBvcnRzLmlzVG9vbE1lc3NhZ2UgPSBpc1Rvb2xNZXNzYWdlO1xuZXhwb3J0cy5pc1Rvb2xNZXNzYWdlQ2h1bmsgPSBpc1Rvb2xNZXNzYWdlQ2h1bms7XG5jb25zdCBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlLmNqc1wiKTtcbmZ1bmN0aW9uIGlzRGlyZWN0VG9vbE91dHB1dCh4KSB7XG4gICAgcmV0dXJuICh4ICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgXCJsY19kaXJlY3RfdG9vbF9vdXRwdXRcIiBpbiB4ICYmXG4gICAgICAgIHgubGNfZGlyZWN0X3Rvb2xfb3V0cHV0ID09PSB0cnVlKTtcbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIHRvb2wgbWVzc2FnZSBpbiBhIGNvbnZlcnNhdGlvbi5cbiAqL1xuY2xhc3MgVG9vbE1lc3NhZ2UgZXh0ZW5kcyBiYXNlX2pzXzEuQmFzZU1lc3NhZ2Uge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJUb29sTWVzc2FnZVwiO1xuICAgIH1cbiAgICBnZXQgbGNfYWxpYXNlcygpIHtcbiAgICAgICAgLy8gZXhjbHVkZSBzbmFrZSBjYXNlIGNvbnZlcnNpb24gdG8gcGFzY2FsIGNhc2VcbiAgICAgICAgcmV0dXJuIHsgdG9vbF9jYWxsX2lkOiBcInRvb2xfY2FsbF9pZFwiIH07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgdG9vbF9jYWxsX2lkLCBuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGZpZWxkcyA9IHsgY29udGVudDogZmllbGRzLCBuYW1lLCB0b29sX2NhbGxfaWQ6IHRvb2xfY2FsbF9pZCB9O1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX2RpcmVjdF90b29sX291dHB1dFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXR1cyBvZiB0aGUgdG9vbCBpbnZvY2F0aW9uLlxuICAgICAgICAgKiBAdmVyc2lvbiAwLjIuMTlcbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXR1c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b29sX2NhbGxfaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFydGlmYWN0IG9mIHRoZSBUb29sIGV4ZWN1dGlvbiB3aGljaCBpcyBub3QgbWVhbnQgdG8gYmUgc2VudCB0byB0aGUgbW9kZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNob3VsZCBvbmx5IGJlIHNwZWNpZmllZCBpZiBpdCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgbWVzc2FnZSBjb250ZW50LCBlLmcuIGlmIG9ubHlcbiAgICAgICAgICogYSBzdWJzZXQgb2YgdGhlIGZ1bGwgdG9vbCBvdXRwdXQgaXMgYmVpbmcgcGFzc2VkIGFzIG1lc3NhZ2UgY29udGVudCBidXQgdGhlIGZ1bGxcbiAgICAgICAgICogb3V0cHV0IGlzIG5lZWRlZCBpbiBvdGhlciBwYXJ0cyBvZiB0aGUgY29kZS5cbiAgICAgICAgICovXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFydGlmYWN0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9vbF9jYWxsX2lkID0gZmllbGRzLnRvb2xfY2FsbF9pZDtcbiAgICAgICAgdGhpcy5hcnRpZmFjdCA9IGZpZWxkcy5hcnRpZmFjdDtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBmaWVsZHMuc3RhdHVzO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gZmllbGRzLm1ldGFkYXRhO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwidG9vbFwiO1xuICAgIH1cbiAgICBzdGF0aWMgaXNJbnN0YW5jZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlLl9nZXRUeXBlKCkgPT09IFwidG9vbFwiO1xuICAgIH1cbiAgICBnZXQgX3ByaW50YWJsZUZpZWxkcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLl9wcmludGFibGVGaWVsZHMsXG4gICAgICAgICAgICB0b29sX2NhbGxfaWQ6IHRoaXMudG9vbF9jYWxsX2lkLFxuICAgICAgICAgICAgYXJ0aWZhY3Q6IHRoaXMuYXJ0aWZhY3QsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5Ub29sTWVzc2FnZSA9IFRvb2xNZXNzYWdlO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2h1bmsgb2YgYSB0b29sIG1lc3NhZ2UsIHdoaWNoIGNhbiBiZSBjb25jYXRlbmF0ZWRcbiAqIHdpdGggb3RoZXIgdG9vbCBtZXNzYWdlIGNodW5rcy5cbiAqL1xuY2xhc3MgVG9vbE1lc3NhZ2VDaHVuayBleHRlbmRzIGJhc2VfanNfMS5CYXNlTWVzc2FnZUNodW5rIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9vbF9jYWxsX2lkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGF0dXMgb2YgdGhlIHRvb2wgaW52b2NhdGlvbi5cbiAgICAgICAgICogQHZlcnNpb24gMC4yLjE5XG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0dXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFydGlmYWN0IG9mIHRoZSBUb29sIGV4ZWN1dGlvbiB3aGljaCBpcyBub3QgbWVhbnQgdG8gYmUgc2VudCB0byB0aGUgbW9kZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNob3VsZCBvbmx5IGJlIHNwZWNpZmllZCBpZiBpdCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgbWVzc2FnZSBjb250ZW50LCBlLmcuIGlmIG9ubHlcbiAgICAgICAgICogYSBzdWJzZXQgb2YgdGhlIGZ1bGwgdG9vbCBvdXRwdXQgaXMgYmVpbmcgcGFzc2VkIGFzIG1lc3NhZ2UgY29udGVudCBidXQgdGhlIGZ1bGxcbiAgICAgICAgICogb3V0cHV0IGlzIG5lZWRlZCBpbiBvdGhlciBwYXJ0cyBvZiB0aGUgY29kZS5cbiAgICAgICAgICovXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFydGlmYWN0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9vbF9jYWxsX2lkID0gZmllbGRzLnRvb2xfY2FsbF9pZDtcbiAgICAgICAgdGhpcy5hcnRpZmFjdCA9IGZpZWxkcy5hcnRpZmFjdDtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBmaWVsZHMuc3RhdHVzO1xuICAgIH1cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiVG9vbE1lc3NhZ2VDaHVua1wiO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwidG9vbFwiO1xuICAgIH1cbiAgICBjb25jYXQoY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUb29sTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6ICgwLCBiYXNlX2pzXzEubWVyZ2VDb250ZW50KSh0aGlzLmNvbnRlbnQsIGNodW5rLmNvbnRlbnQpLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6ICgwLCBiYXNlX2pzXzEuX21lcmdlRGljdHMpKHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MsIGNodW5rLmFkZGl0aW9uYWxfa3dhcmdzKSxcbiAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiAoMCwgYmFzZV9qc18xLl9tZXJnZURpY3RzKSh0aGlzLnJlc3BvbnNlX21ldGFkYXRhLCBjaHVuay5yZXNwb25zZV9tZXRhZGF0YSksXG4gICAgICAgICAgICBhcnRpZmFjdDogKDAsIGJhc2VfanNfMS5fbWVyZ2VPYmopKHRoaXMuYXJ0aWZhY3QsIGNodW5rLmFydGlmYWN0KSxcbiAgICAgICAgICAgIHRvb2xfY2FsbF9pZDogdGhpcy50b29sX2NhbGxfaWQsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCA/PyBjaHVuay5pZCxcbiAgICAgICAgICAgIHN0YXR1czogKDAsIGJhc2VfanNfMS5fbWVyZ2VTdGF0dXMpKHRoaXMuc3RhdHVzLCBjaHVuay5zdGF0dXMpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IF9wcmludGFibGVGaWVsZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci5fcHJpbnRhYmxlRmllbGRzLFxuICAgICAgICAgICAgdG9vbF9jYWxsX2lkOiB0aGlzLnRvb2xfY2FsbF9pZCxcbiAgICAgICAgICAgIGFydGlmYWN0OiB0aGlzLmFydGlmYWN0LFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuVG9vbE1lc3NhZ2VDaHVuayA9IFRvb2xNZXNzYWdlQ2h1bms7XG5mdW5jdGlvbiBkZWZhdWx0VG9vbENhbGxQYXJzZXIoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxucmF3VG9vbENhbGxzKSB7XG4gICAgY29uc3QgdG9vbENhbGxzID0gW107XG4gICAgY29uc3QgaW52YWxpZFRvb2xDYWxscyA9IFtdO1xuICAgIGZvciAoY29uc3QgdG9vbENhbGwgb2YgcmF3VG9vbENhbGxzKSB7XG4gICAgICAgIGlmICghdG9vbENhbGwuZnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25OYW1lID0gdG9vbENhbGwuZnVuY3Rpb24ubmFtZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25BcmdzID0gSlNPTi5wYXJzZSh0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25OYW1lIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IGZ1bmN0aW9uQXJncyB8fCB7fSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRvb2xDYWxsLmlkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdG9vbENhbGxzLnB1c2gocGFyc2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGludmFsaWRUb29sQ2FsbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogdG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwuaWQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBcIk1hbGZvcm1lZCBhcmdzLlwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbdG9vbENhbGxzLCBpbnZhbGlkVG9vbENhbGxzXTtcbn1cbmZ1bmN0aW9uIGlzVG9vbE1lc3NhZ2UoeCkge1xuICAgIHJldHVybiB4Ll9nZXRUeXBlKCkgPT09IFwidG9vbFwiO1xufVxuZnVuY3Rpb24gaXNUb29sTWVzc2FnZUNodW5rKHgpIHtcbiAgICByZXR1cm4geC5fZ2V0VHlwZSgpID09PSBcInRvb2xcIjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/tool.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/transformers.cjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/transformers.cjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.filterMessages = filterMessages;\nexports.mergeMessageRuns = mergeMessageRuns;\nexports.trimMessages = trimMessages;\nexports.defaultTextSplitter = defaultTextSplitter;\nconst base_js_1 = __webpack_require__(/*! ../runnables/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nconst ai_js_1 = __webpack_require__(/*! ./ai.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/ai.cjs\");\nconst base_js_2 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\nconst chat_js_1 = __webpack_require__(/*! ./chat.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/chat.cjs\");\nconst function_js_1 = __webpack_require__(/*! ./function.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/function.cjs\");\nconst human_js_1 = __webpack_require__(/*! ./human.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/human.cjs\");\nconst modifier_js_1 = __webpack_require__(/*! ./modifier.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/modifier.cjs\");\nconst system_js_1 = __webpack_require__(/*! ./system.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/system.cjs\");\nconst tool_js_1 = __webpack_require__(/*! ./tool.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/tool.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs\");\nconst _isMessageType = (msg, types) => {\n    const typesAsStrings = [\n        ...new Set(types?.map((t) => {\n            if (typeof t === \"string\") {\n                return t;\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const instantiatedMsgClass = new t({});\n            if (!(\"getType\" in instantiatedMsgClass) ||\n                typeof instantiatedMsgClass.getType !== \"function\") {\n                throw new Error(\"Invalid type provided.\");\n            }\n            return instantiatedMsgClass.getType();\n        })),\n    ];\n    const msgType = msg.getType();\n    return typesAsStrings.some((t) => t === msgType);\n};\nfunction filterMessages(messagesOrOptions, options) {\n    if (Array.isArray(messagesOrOptions)) {\n        return _filterMessages(messagesOrOptions, options);\n    }\n    return base_js_1.RunnableLambda.from((input) => {\n        return _filterMessages(input, messagesOrOptions);\n    });\n}\nfunction _filterMessages(messages, options = {}) {\n    const { includeNames, excludeNames, includeTypes, excludeTypes, includeIds, excludeIds, } = options;\n    const filtered = [];\n    for (const msg of messages) {\n        if (excludeNames && msg.name && excludeNames.includes(msg.name)) {\n            continue;\n        }\n        else if (excludeTypes && _isMessageType(msg, excludeTypes)) {\n            continue;\n        }\n        else if (excludeIds && msg.id && excludeIds.includes(msg.id)) {\n            continue;\n        }\n        // default to inclusion when no inclusion criteria given.\n        if (!(includeTypes || includeIds || includeNames)) {\n            filtered.push(msg);\n        }\n        else if (includeNames &&\n            msg.name &&\n            includeNames.some((iName) => iName === msg.name)) {\n            filtered.push(msg);\n        }\n        else if (includeTypes && _isMessageType(msg, includeTypes)) {\n            filtered.push(msg);\n        }\n        else if (includeIds && msg.id && includeIds.some((id) => id === msg.id)) {\n            filtered.push(msg);\n        }\n    }\n    return filtered;\n}\nfunction mergeMessageRuns(messages) {\n    if (Array.isArray(messages)) {\n        return _mergeMessageRuns(messages);\n    }\n    return base_js_1.RunnableLambda.from(_mergeMessageRuns);\n}\nfunction _mergeMessageRuns(messages) {\n    if (!messages.length) {\n        return [];\n    }\n    const merged = [];\n    for (const msg of messages) {\n        const curr = msg;\n        const last = merged.pop();\n        if (!last) {\n            merged.push(curr);\n        }\n        else if (curr.getType() === \"tool\" ||\n            !(curr.getType() === last.getType())) {\n            merged.push(last, curr);\n        }\n        else {\n            const lastChunk = (0, utils_js_1.convertToChunk)(last);\n            const currChunk = (0, utils_js_1.convertToChunk)(curr);\n            const mergedChunks = lastChunk.concat(currChunk);\n            if (typeof lastChunk.content === \"string\" &&\n                typeof currChunk.content === \"string\") {\n                mergedChunks.content = `${lastChunk.content}\\n${currChunk.content}`;\n            }\n            merged.push(_chunkToMsg(mergedChunks));\n        }\n    }\n    return merged;\n}\nfunction trimMessages(messagesOrOptions, options) {\n    if (Array.isArray(messagesOrOptions)) {\n        const messages = messagesOrOptions;\n        if (!options) {\n            throw new Error(\"Options parameter is required when providing messages.\");\n        }\n        return _trimMessagesHelper(messages, options);\n    }\n    else {\n        const trimmerOptions = messagesOrOptions;\n        return base_js_1.RunnableLambda.from((input) => _trimMessagesHelper(input, trimmerOptions)).withConfig({\n            runName: \"trim_messages\",\n        });\n    }\n}\nasync function _trimMessagesHelper(messages, options) {\n    const { maxTokens, tokenCounter, strategy = \"last\", allowPartial = false, endOn, startOn, includeSystem = false, textSplitter, } = options;\n    if (startOn && strategy === \"first\") {\n        throw new Error(\"`startOn` should only be specified if `strategy` is 'last'.\");\n    }\n    if (includeSystem && strategy === \"first\") {\n        throw new Error(\"`includeSystem` should only be specified if `strategy` is 'last'.\");\n    }\n    let listTokenCounter;\n    if (\"getNumTokens\" in tokenCounter) {\n        listTokenCounter = async (msgs) => {\n            const tokenCounts = await Promise.all(msgs.map((msg) => tokenCounter.getNumTokens(msg.content)));\n            return tokenCounts.reduce((sum, count) => sum + count, 0);\n        };\n    }\n    else {\n        listTokenCounter = async (msgs) => tokenCounter(msgs);\n    }\n    let textSplitterFunc = defaultTextSplitter;\n    if (textSplitter) {\n        if (\"splitText\" in textSplitter) {\n            textSplitterFunc = textSplitter.splitText;\n        }\n        else {\n            textSplitterFunc = async (text) => textSplitter(text);\n        }\n    }\n    if (strategy === \"first\") {\n        return _firstMaxTokens(messages, {\n            maxTokens,\n            tokenCounter: listTokenCounter,\n            textSplitter: textSplitterFunc,\n            partialStrategy: allowPartial ? \"first\" : undefined,\n            endOn,\n        });\n    }\n    else if (strategy === \"last\") {\n        return _lastMaxTokens(messages, {\n            maxTokens,\n            tokenCounter: listTokenCounter,\n            textSplitter: textSplitterFunc,\n            allowPartial,\n            includeSystem,\n            startOn,\n            endOn,\n        });\n    }\n    else {\n        throw new Error(`Unrecognized strategy: '${strategy}'. Must be one of 'first' or 'last'.`);\n    }\n}\nasync function _firstMaxTokens(messages, options) {\n    const { maxTokens, tokenCounter, textSplitter, partialStrategy, endOn } = options;\n    let messagesCopy = [...messages];\n    let idx = 0;\n    for (let i = 0; i < messagesCopy.length; i += 1) {\n        const remainingMessages = i > 0 ? messagesCopy.slice(0, -i) : messagesCopy;\n        if ((await tokenCounter(remainingMessages)) <= maxTokens) {\n            idx = messagesCopy.length - i;\n            break;\n        }\n    }\n    if (idx < messagesCopy.length && partialStrategy) {\n        let includedPartial = false;\n        if (Array.isArray(messagesCopy[idx].content)) {\n            const excluded = messagesCopy[idx];\n            if (typeof excluded.content === \"string\") {\n                throw new Error(\"Expected content to be an array.\");\n            }\n            const numBlock = excluded.content.length;\n            const reversedContent = partialStrategy === \"last\"\n                ? [...excluded.content].reverse()\n                : excluded.content;\n            for (let i = 1; i <= numBlock; i += 1) {\n                const partialContent = partialStrategy === \"first\"\n                    ? reversedContent.slice(0, i)\n                    : reversedContent.slice(-i);\n                const fields = Object.fromEntries(Object.entries(excluded).filter(([k]) => k !== \"type\" && !k.startsWith(\"lc_\")));\n                const updatedMessage = _switchTypeToMessage(excluded.getType(), {\n                    ...fields,\n                    content: partialContent,\n                });\n                const slicedMessages = [...messagesCopy.slice(0, idx), updatedMessage];\n                if ((await tokenCounter(slicedMessages)) <= maxTokens) {\n                    messagesCopy = slicedMessages;\n                    idx += 1;\n                    includedPartial = true;\n                }\n                else {\n                    break;\n                }\n            }\n            if (includedPartial && partialStrategy === \"last\") {\n                excluded.content = [...reversedContent].reverse();\n            }\n        }\n        if (!includedPartial) {\n            const excluded = messagesCopy[idx];\n            let text;\n            if (Array.isArray(excluded.content) &&\n                excluded.content.some((block) => typeof block === \"string\" || block.type === \"text\")) {\n                const textBlock = excluded.content.find((block) => block.type === \"text\" && block.text);\n                text = textBlock?.text;\n            }\n            else if (typeof excluded.content === \"string\") {\n                text = excluded.content;\n            }\n            if (text) {\n                const splitTexts = await textSplitter(text);\n                const numSplits = splitTexts.length;\n                if (partialStrategy === \"last\") {\n                    splitTexts.reverse();\n                }\n                for (let _ = 0; _ < numSplits - 1; _ += 1) {\n                    splitTexts.pop();\n                    excluded.content = splitTexts.join(\"\");\n                    if ((await tokenCounter([...messagesCopy.slice(0, idx), excluded])) <=\n                        maxTokens) {\n                        if (partialStrategy === \"last\") {\n                            excluded.content = [...splitTexts].reverse().join(\"\");\n                        }\n                        messagesCopy = [...messagesCopy.slice(0, idx), excluded];\n                        idx += 1;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    if (endOn) {\n        const endOnArr = Array.isArray(endOn) ? endOn : [endOn];\n        while (idx > 0 && !_isMessageType(messagesCopy[idx - 1], endOnArr)) {\n            idx -= 1;\n        }\n    }\n    return messagesCopy.slice(0, idx);\n}\nasync function _lastMaxTokens(messages, options) {\n    const { allowPartial = false, includeSystem = false, endOn, startOn, ...rest } = options;\n    // Create a copy of messages to avoid mutation\n    let messagesCopy = messages.map((message) => {\n        const fields = Object.fromEntries(Object.entries(message).filter(([k]) => k !== \"type\" && !k.startsWith(\"lc_\")));\n        return _switchTypeToMessage(message.getType(), fields, (0, base_js_2.isBaseMessageChunk)(message));\n    });\n    if (endOn) {\n        const endOnArr = Array.isArray(endOn) ? endOn : [endOn];\n        while (messagesCopy.length > 0 &&\n            !_isMessageType(messagesCopy[messagesCopy.length - 1], endOnArr)) {\n            messagesCopy = messagesCopy.slice(0, -1);\n        }\n    }\n    const swappedSystem = includeSystem && messagesCopy[0]?.getType() === \"system\";\n    let reversed_ = swappedSystem\n        ? messagesCopy.slice(0, 1).concat(messagesCopy.slice(1).reverse())\n        : messagesCopy.reverse();\n    reversed_ = await _firstMaxTokens(reversed_, {\n        ...rest,\n        partialStrategy: allowPartial ? \"last\" : undefined,\n        endOn: startOn,\n    });\n    if (swappedSystem) {\n        return [reversed_[0], ...reversed_.slice(1).reverse()];\n    }\n    else {\n        return reversed_.reverse();\n    }\n}\nconst _MSG_CHUNK_MAP = {\n    human: {\n        message: human_js_1.HumanMessage,\n        messageChunk: human_js_1.HumanMessageChunk,\n    },\n    ai: {\n        message: ai_js_1.AIMessage,\n        messageChunk: ai_js_1.AIMessageChunk,\n    },\n    system: {\n        message: system_js_1.SystemMessage,\n        messageChunk: system_js_1.SystemMessageChunk,\n    },\n    developer: {\n        message: system_js_1.SystemMessage,\n        messageChunk: system_js_1.SystemMessageChunk,\n    },\n    tool: {\n        message: tool_js_1.ToolMessage,\n        messageChunk: tool_js_1.ToolMessageChunk,\n    },\n    function: {\n        message: function_js_1.FunctionMessage,\n        messageChunk: function_js_1.FunctionMessageChunk,\n    },\n    generic: {\n        message: chat_js_1.ChatMessage,\n        messageChunk: chat_js_1.ChatMessageChunk,\n    },\n    remove: {\n        message: modifier_js_1.RemoveMessage,\n        messageChunk: modifier_js_1.RemoveMessage, // RemoveMessage does not have a chunk class.\n    },\n};\nfunction _switchTypeToMessage(messageType, fields, returnChunk) {\n    let chunk;\n    let msg;\n    switch (messageType) {\n        case \"human\":\n            if (returnChunk) {\n                chunk = new human_js_1.HumanMessageChunk(fields);\n            }\n            else {\n                msg = new human_js_1.HumanMessage(fields);\n            }\n            break;\n        case \"ai\":\n            if (returnChunk) {\n                let aiChunkFields = {\n                    ...fields,\n                };\n                if (\"tool_calls\" in aiChunkFields) {\n                    aiChunkFields = {\n                        ...aiChunkFields,\n                        tool_call_chunks: aiChunkFields.tool_calls?.map((tc) => ({\n                            ...tc,\n                            type: \"tool_call_chunk\",\n                            index: undefined,\n                            args: JSON.stringify(tc.args),\n                        })),\n                    };\n                }\n                chunk = new ai_js_1.AIMessageChunk(aiChunkFields);\n            }\n            else {\n                msg = new ai_js_1.AIMessage(fields);\n            }\n            break;\n        case \"system\":\n            if (returnChunk) {\n                chunk = new system_js_1.SystemMessageChunk(fields);\n            }\n            else {\n                msg = new system_js_1.SystemMessage(fields);\n            }\n            break;\n        case \"developer\":\n            if (returnChunk) {\n                chunk = new system_js_1.SystemMessageChunk({\n                    ...fields,\n                    additional_kwargs: {\n                        ...fields.additional_kwargs,\n                        __openai_role__: \"developer\",\n                    },\n                });\n            }\n            else {\n                msg = new system_js_1.SystemMessage({\n                    ...fields,\n                    additional_kwargs: {\n                        ...fields.additional_kwargs,\n                        __openai_role__: \"developer\",\n                    },\n                });\n            }\n            break;\n        case \"tool\":\n            if (\"tool_call_id\" in fields) {\n                if (returnChunk) {\n                    chunk = new tool_js_1.ToolMessageChunk(fields);\n                }\n                else {\n                    msg = new tool_js_1.ToolMessage(fields);\n                }\n            }\n            else {\n                throw new Error(\"Can not convert ToolMessage to ToolMessageChunk if 'tool_call_id' field is not defined.\");\n            }\n            break;\n        case \"function\":\n            if (returnChunk) {\n                chunk = new function_js_1.FunctionMessageChunk(fields);\n            }\n            else {\n                if (!fields.name) {\n                    throw new Error(\"FunctionMessage must have a 'name' field\");\n                }\n                msg = new function_js_1.FunctionMessage(fields);\n            }\n            break;\n        case \"generic\":\n            if (\"role\" in fields) {\n                if (returnChunk) {\n                    chunk = new chat_js_1.ChatMessageChunk(fields);\n                }\n                else {\n                    msg = new chat_js_1.ChatMessage(fields);\n                }\n            }\n            else {\n                throw new Error(\"Can not convert ChatMessage to ChatMessageChunk if 'role' field is not defined.\");\n            }\n            break;\n        default:\n            throw new Error(`Unrecognized message type ${messageType}`);\n    }\n    if (returnChunk && chunk) {\n        return chunk;\n    }\n    if (msg) {\n        return msg;\n    }\n    throw new Error(`Unrecognized message type ${messageType}`);\n}\nfunction _chunkToMsg(chunk) {\n    const chunkType = chunk.getType();\n    let msg;\n    const fields = Object.fromEntries(Object.entries(chunk).filter(([k]) => ![\"type\", \"tool_call_chunks\"].includes(k) && !k.startsWith(\"lc_\")));\n    if (chunkType in _MSG_CHUNK_MAP) {\n        msg = _switchTypeToMessage(chunkType, fields);\n    }\n    if (!msg) {\n        throw new Error(`Unrecognized message chunk class ${chunkType}. Supported classes are ${Object.keys(_MSG_CHUNK_MAP)}`);\n    }\n    return msg;\n}\n/**\n * The default text splitter function that splits text by newlines.\n *\n * @param {string} text\n * @returns A promise that resolves to an array of strings split by newlines.\n */\nfunction defaultTextSplitter(text) {\n    const splits = text.split(\"\\n\");\n    return Promise.resolve([\n        ...splits.slice(0, -1).map((s) => `${s}\\n`),\n        splits[splits.length - 1],\n    ]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvdHJhbnNmb3JtZXJzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsd0JBQXdCO0FBQ3hCLG9CQUFvQjtBQUNwQiwyQkFBMkI7QUFDM0Isa0JBQWtCLG1CQUFPLENBQUMsMkZBQXVCO0FBQ2pELGdCQUFnQixtQkFBTyxDQUFDLDJFQUFVO0FBQ2xDLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3RDLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3RDLHNCQUFzQixtQkFBTyxDQUFDLHVGQUFnQjtBQUM5QyxtQkFBbUIsbUJBQU8sQ0FBQyxpRkFBYTtBQUN4QyxzQkFBc0IsbUJBQU8sQ0FBQyx1RkFBZ0I7QUFDOUMsb0JBQW9CLG1CQUFPLENBQUMsbUZBQWM7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMsK0VBQVk7QUFDdEMsbUJBQW1CLG1CQUFPLENBQUMsaUZBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLCtDQUErQztBQUMvQyxZQUFZLGtGQUFrRjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtCQUFrQixJQUFJLGtCQUFrQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5SEFBeUg7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRUFBZ0U7QUFDNUU7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1CQUFtQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVFQUF1RTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsWUFBWTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxVQUFVLDBCQUEwQiw0QkFBNEI7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsRUFBRTtBQUMvQztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9tZXNzYWdlcy90cmFuc2Zvcm1lcnMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5maWx0ZXJNZXNzYWdlcyA9IGZpbHRlck1lc3NhZ2VzO1xuZXhwb3J0cy5tZXJnZU1lc3NhZ2VSdW5zID0gbWVyZ2VNZXNzYWdlUnVucztcbmV4cG9ydHMudHJpbU1lc3NhZ2VzID0gdHJpbU1lc3NhZ2VzO1xuZXhwb3J0cy5kZWZhdWx0VGV4dFNwbGl0dGVyID0gZGVmYXVsdFRleHRTcGxpdHRlcjtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuLi9ydW5uYWJsZXMvYmFzZS5janNcIik7XG5jb25zdCBhaV9qc18xID0gcmVxdWlyZShcIi4vYWkuY2pzXCIpO1xuY29uc3QgYmFzZV9qc18yID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG5jb25zdCBjaGF0X2pzXzEgPSByZXF1aXJlKFwiLi9jaGF0LmNqc1wiKTtcbmNvbnN0IGZ1bmN0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi9mdW5jdGlvbi5janNcIik7XG5jb25zdCBodW1hbl9qc18xID0gcmVxdWlyZShcIi4vaHVtYW4uY2pzXCIpO1xuY29uc3QgbW9kaWZpZXJfanNfMSA9IHJlcXVpcmUoXCIuL21vZGlmaWVyLmNqc1wiKTtcbmNvbnN0IHN5c3RlbV9qc18xID0gcmVxdWlyZShcIi4vc3lzdGVtLmNqc1wiKTtcbmNvbnN0IHRvb2xfanNfMSA9IHJlcXVpcmUoXCIuL3Rvb2wuY2pzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmNqc1wiKTtcbmNvbnN0IF9pc01lc3NhZ2VUeXBlID0gKG1zZywgdHlwZXMpID0+IHtcbiAgICBjb25zdCB0eXBlc0FzU3RyaW5ncyA9IFtcbiAgICAgICAgLi4ubmV3IFNldCh0eXBlcz8ubWFwKCh0KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBjb25zdCBpbnN0YW50aWF0ZWRNc2dDbGFzcyA9IG5ldyB0KHt9KTtcbiAgICAgICAgICAgIGlmICghKFwiZ2V0VHlwZVwiIGluIGluc3RhbnRpYXRlZE1zZ0NsYXNzKSB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiBpbnN0YW50aWF0ZWRNc2dDbGFzcy5nZXRUeXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHR5cGUgcHJvdmlkZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluc3RhbnRpYXRlZE1zZ0NsYXNzLmdldFR5cGUoKTtcbiAgICAgICAgfSkpLFxuICAgIF07XG4gICAgY29uc3QgbXNnVHlwZSA9IG1zZy5nZXRUeXBlKCk7XG4gICAgcmV0dXJuIHR5cGVzQXNTdHJpbmdzLnNvbWUoKHQpID0+IHQgPT09IG1zZ1R5cGUpO1xufTtcbmZ1bmN0aW9uIGZpbHRlck1lc3NhZ2VzKG1lc3NhZ2VzT3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZXNPck9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBfZmlsdGVyTWVzc2FnZXMobWVzc2FnZXNPck9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZV9qc18xLlJ1bm5hYmxlTGFtYmRhLmZyb20oKGlucHV0KSA9PiB7XG4gICAgICAgIHJldHVybiBfZmlsdGVyTWVzc2FnZXMoaW5wdXQsIG1lc3NhZ2VzT3JPcHRpb25zKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIF9maWx0ZXJNZXNzYWdlcyhtZXNzYWdlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBpbmNsdWRlTmFtZXMsIGV4Y2x1ZGVOYW1lcywgaW5jbHVkZVR5cGVzLCBleGNsdWRlVHlwZXMsIGluY2x1ZGVJZHMsIGV4Y2x1ZGVJZHMsIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGZpbHRlcmVkID0gW107XG4gICAgZm9yIChjb25zdCBtc2cgb2YgbWVzc2FnZXMpIHtcbiAgICAgICAgaWYgKGV4Y2x1ZGVOYW1lcyAmJiBtc2cubmFtZSAmJiBleGNsdWRlTmFtZXMuaW5jbHVkZXMobXNnLm5hbWUpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleGNsdWRlVHlwZXMgJiYgX2lzTWVzc2FnZVR5cGUobXNnLCBleGNsdWRlVHlwZXMpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleGNsdWRlSWRzICYmIG1zZy5pZCAmJiBleGNsdWRlSWRzLmluY2x1ZGVzKG1zZy5pZCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRlZmF1bHQgdG8gaW5jbHVzaW9uIHdoZW4gbm8gaW5jbHVzaW9uIGNyaXRlcmlhIGdpdmVuLlxuICAgICAgICBpZiAoIShpbmNsdWRlVHlwZXMgfHwgaW5jbHVkZUlkcyB8fCBpbmNsdWRlTmFtZXMpKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZC5wdXNoKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5jbHVkZU5hbWVzICYmXG4gICAgICAgICAgICBtc2cubmFtZSAmJlxuICAgICAgICAgICAgaW5jbHVkZU5hbWVzLnNvbWUoKGlOYW1lKSA9PiBpTmFtZSA9PT0gbXNnLm5hbWUpKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZC5wdXNoKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5jbHVkZVR5cGVzICYmIF9pc01lc3NhZ2VUeXBlKG1zZywgaW5jbHVkZVR5cGVzKSkge1xuICAgICAgICAgICAgZmlsdGVyZWQucHVzaChtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluY2x1ZGVJZHMgJiYgbXNnLmlkICYmIGluY2x1ZGVJZHMuc29tZSgoaWQpID0+IGlkID09PSBtc2cuaWQpKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZC5wdXNoKG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcmVkO1xufVxuZnVuY3Rpb24gbWVyZ2VNZXNzYWdlUnVucyhtZXNzYWdlcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1lc3NhZ2VzKSkge1xuICAgICAgICByZXR1cm4gX21lcmdlTWVzc2FnZVJ1bnMobWVzc2FnZXMpO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZV9qc18xLlJ1bm5hYmxlTGFtYmRhLmZyb20oX21lcmdlTWVzc2FnZVJ1bnMpO1xufVxuZnVuY3Rpb24gX21lcmdlTWVzc2FnZVJ1bnMobWVzc2FnZXMpIHtcbiAgICBpZiAoIW1lc3NhZ2VzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IG1lcmdlZCA9IFtdO1xuICAgIGZvciAoY29uc3QgbXNnIG9mIG1lc3NhZ2VzKSB7XG4gICAgICAgIGNvbnN0IGN1cnIgPSBtc2c7XG4gICAgICAgIGNvbnN0IGxhc3QgPSBtZXJnZWQucG9wKCk7XG4gICAgICAgIGlmICghbGFzdCkge1xuICAgICAgICAgICAgbWVyZ2VkLnB1c2goY3Vycik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3Vyci5nZXRUeXBlKCkgPT09IFwidG9vbFwiIHx8XG4gICAgICAgICAgICAhKGN1cnIuZ2V0VHlwZSgpID09PSBsYXN0LmdldFR5cGUoKSkpIHtcbiAgICAgICAgICAgIG1lcmdlZC5wdXNoKGxhc3QsIGN1cnIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbGFzdENodW5rID0gKDAsIHV0aWxzX2pzXzEuY29udmVydFRvQ2h1bmspKGxhc3QpO1xuICAgICAgICAgICAgY29uc3QgY3VyckNodW5rID0gKDAsIHV0aWxzX2pzXzEuY29udmVydFRvQ2h1bmspKGN1cnIpO1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkQ2h1bmtzID0gbGFzdENodW5rLmNvbmNhdChjdXJyQ2h1bmspO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsYXN0Q2h1bmsuY29udGVudCA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjdXJyQ2h1bmsuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIG1lcmdlZENodW5rcy5jb250ZW50ID0gYCR7bGFzdENodW5rLmNvbnRlbnR9XFxuJHtjdXJyQ2h1bmsuY29udGVudH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVyZ2VkLnB1c2goX2NodW5rVG9Nc2cobWVyZ2VkQ2h1bmtzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmZ1bmN0aW9uIHRyaW1NZXNzYWdlcyhtZXNzYWdlc09yT3B0aW9ucywgb3B0aW9ucykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1lc3NhZ2VzT3JPcHRpb25zKSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlcyA9IG1lc3NhZ2VzT3JPcHRpb25zO1xuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9wdGlvbnMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIHdoZW4gcHJvdmlkaW5nIG1lc3NhZ2VzLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RyaW1NZXNzYWdlc0hlbHBlcihtZXNzYWdlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB0cmltbWVyT3B0aW9ucyA9IG1lc3NhZ2VzT3JPcHRpb25zO1xuICAgICAgICByZXR1cm4gYmFzZV9qc18xLlJ1bm5hYmxlTGFtYmRhLmZyb20oKGlucHV0KSA9PiBfdHJpbU1lc3NhZ2VzSGVscGVyKGlucHV0LCB0cmltbWVyT3B0aW9ucykpLndpdGhDb25maWcoe1xuICAgICAgICAgICAgcnVuTmFtZTogXCJ0cmltX21lc3NhZ2VzXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIF90cmltTWVzc2FnZXNIZWxwZXIobWVzc2FnZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IG1heFRva2VucywgdG9rZW5Db3VudGVyLCBzdHJhdGVneSA9IFwibGFzdFwiLCBhbGxvd1BhcnRpYWwgPSBmYWxzZSwgZW5kT24sIHN0YXJ0T24sIGluY2x1ZGVTeXN0ZW0gPSBmYWxzZSwgdGV4dFNwbGl0dGVyLCB9ID0gb3B0aW9ucztcbiAgICBpZiAoc3RhcnRPbiAmJiBzdHJhdGVneSA9PT0gXCJmaXJzdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImBzdGFydE9uYCBzaG91bGQgb25seSBiZSBzcGVjaWZpZWQgaWYgYHN0cmF0ZWd5YCBpcyAnbGFzdCcuXCIpO1xuICAgIH1cbiAgICBpZiAoaW5jbHVkZVN5c3RlbSAmJiBzdHJhdGVneSA9PT0gXCJmaXJzdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImBpbmNsdWRlU3lzdGVtYCBzaG91bGQgb25seSBiZSBzcGVjaWZpZWQgaWYgYHN0cmF0ZWd5YCBpcyAnbGFzdCcuXCIpO1xuICAgIH1cbiAgICBsZXQgbGlzdFRva2VuQ291bnRlcjtcbiAgICBpZiAoXCJnZXROdW1Ub2tlbnNcIiBpbiB0b2tlbkNvdW50ZXIpIHtcbiAgICAgICAgbGlzdFRva2VuQ291bnRlciA9IGFzeW5jIChtc2dzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbkNvdW50cyA9IGF3YWl0IFByb21pc2UuYWxsKG1zZ3MubWFwKChtc2cpID0+IHRva2VuQ291bnRlci5nZXROdW1Ub2tlbnMobXNnLmNvbnRlbnQpKSk7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5Db3VudHMucmVkdWNlKChzdW0sIGNvdW50KSA9PiBzdW0gKyBjb3VudCwgMCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsaXN0VG9rZW5Db3VudGVyID0gYXN5bmMgKG1zZ3MpID0+IHRva2VuQ291bnRlcihtc2dzKTtcbiAgICB9XG4gICAgbGV0IHRleHRTcGxpdHRlckZ1bmMgPSBkZWZhdWx0VGV4dFNwbGl0dGVyO1xuICAgIGlmICh0ZXh0U3BsaXR0ZXIpIHtcbiAgICAgICAgaWYgKFwic3BsaXRUZXh0XCIgaW4gdGV4dFNwbGl0dGVyKSB7XG4gICAgICAgICAgICB0ZXh0U3BsaXR0ZXJGdW5jID0gdGV4dFNwbGl0dGVyLnNwbGl0VGV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRleHRTcGxpdHRlckZ1bmMgPSBhc3luYyAodGV4dCkgPT4gdGV4dFNwbGl0dGVyKHRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdHJhdGVneSA9PT0gXCJmaXJzdFwiKSB7XG4gICAgICAgIHJldHVybiBfZmlyc3RNYXhUb2tlbnMobWVzc2FnZXMsIHtcbiAgICAgICAgICAgIG1heFRva2VucyxcbiAgICAgICAgICAgIHRva2VuQ291bnRlcjogbGlzdFRva2VuQ291bnRlcixcbiAgICAgICAgICAgIHRleHRTcGxpdHRlcjogdGV4dFNwbGl0dGVyRnVuYyxcbiAgICAgICAgICAgIHBhcnRpYWxTdHJhdGVneTogYWxsb3dQYXJ0aWFsID8gXCJmaXJzdFwiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZW5kT24sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdHJhdGVneSA9PT0gXCJsYXN0XCIpIHtcbiAgICAgICAgcmV0dXJuIF9sYXN0TWF4VG9rZW5zKG1lc3NhZ2VzLCB7XG4gICAgICAgICAgICBtYXhUb2tlbnMsXG4gICAgICAgICAgICB0b2tlbkNvdW50ZXI6IGxpc3RUb2tlbkNvdW50ZXIsXG4gICAgICAgICAgICB0ZXh0U3BsaXR0ZXI6IHRleHRTcGxpdHRlckZ1bmMsXG4gICAgICAgICAgICBhbGxvd1BhcnRpYWwsXG4gICAgICAgICAgICBpbmNsdWRlU3lzdGVtLFxuICAgICAgICAgICAgc3RhcnRPbixcbiAgICAgICAgICAgIGVuZE9uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIHN0cmF0ZWd5OiAnJHtzdHJhdGVneX0nLiBNdXN0IGJlIG9uZSBvZiAnZmlyc3QnIG9yICdsYXN0Jy5gKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBfZmlyc3RNYXhUb2tlbnMobWVzc2FnZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IG1heFRva2VucywgdG9rZW5Db3VudGVyLCB0ZXh0U3BsaXR0ZXIsIHBhcnRpYWxTdHJhdGVneSwgZW5kT24gfSA9IG9wdGlvbnM7XG4gICAgbGV0IG1lc3NhZ2VzQ29weSA9IFsuLi5tZXNzYWdlc107XG4gICAgbGV0IGlkeCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlc0NvcHkubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgcmVtYWluaW5nTWVzc2FnZXMgPSBpID4gMCA/IG1lc3NhZ2VzQ29weS5zbGljZSgwLCAtaSkgOiBtZXNzYWdlc0NvcHk7XG4gICAgICAgIGlmICgoYXdhaXQgdG9rZW5Db3VudGVyKHJlbWFpbmluZ01lc3NhZ2VzKSkgPD0gbWF4VG9rZW5zKSB7XG4gICAgICAgICAgICBpZHggPSBtZXNzYWdlc0NvcHkubGVuZ3RoIC0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpZHggPCBtZXNzYWdlc0NvcHkubGVuZ3RoICYmIHBhcnRpYWxTdHJhdGVneSkge1xuICAgICAgICBsZXQgaW5jbHVkZWRQYXJ0aWFsID0gZmFsc2U7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1lc3NhZ2VzQ29weVtpZHhdLmNvbnRlbnQpKSB7XG4gICAgICAgICAgICBjb25zdCBleGNsdWRlZCA9IG1lc3NhZ2VzQ29weVtpZHhdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBleGNsdWRlZC5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgY29udGVudCB0byBiZSBhbiBhcnJheS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBudW1CbG9jayA9IGV4Y2x1ZGVkLmNvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgcmV2ZXJzZWRDb250ZW50ID0gcGFydGlhbFN0cmF0ZWd5ID09PSBcImxhc3RcIlxuICAgICAgICAgICAgICAgID8gWy4uLmV4Y2x1ZGVkLmNvbnRlbnRdLnJldmVyc2UoKVxuICAgICAgICAgICAgICAgIDogZXhjbHVkZWQuY29udGVudDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IG51bUJsb2NrOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsQ29udGVudCA9IHBhcnRpYWxTdHJhdGVneSA9PT0gXCJmaXJzdFwiXG4gICAgICAgICAgICAgICAgICAgID8gcmV2ZXJzZWRDb250ZW50LnNsaWNlKDAsIGkpXG4gICAgICAgICAgICAgICAgICAgIDogcmV2ZXJzZWRDb250ZW50LnNsaWNlKC1pKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZHMgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoZXhjbHVkZWQpLmZpbHRlcigoW2tdKSA9PiBrICE9PSBcInR5cGVcIiAmJiAhay5zdGFydHNXaXRoKFwibGNfXCIpKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZE1lc3NhZ2UgPSBfc3dpdGNoVHlwZVRvTWVzc2FnZShleGNsdWRlZC5nZXRUeXBlKCksIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBwYXJ0aWFsQ29udGVudCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzbGljZWRNZXNzYWdlcyA9IFsuLi5tZXNzYWdlc0NvcHkuc2xpY2UoMCwgaWR4KSwgdXBkYXRlZE1lc3NhZ2VdO1xuICAgICAgICAgICAgICAgIGlmICgoYXdhaXQgdG9rZW5Db3VudGVyKHNsaWNlZE1lc3NhZ2VzKSkgPD0gbWF4VG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzQ29weSA9IHNsaWNlZE1lc3NhZ2VzO1xuICAgICAgICAgICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZWRQYXJ0aWFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmNsdWRlZFBhcnRpYWwgJiYgcGFydGlhbFN0cmF0ZWd5ID09PSBcImxhc3RcIikge1xuICAgICAgICAgICAgICAgIGV4Y2x1ZGVkLmNvbnRlbnQgPSBbLi4ucmV2ZXJzZWRDb250ZW50XS5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbmNsdWRlZFBhcnRpYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4Y2x1ZGVkID0gbWVzc2FnZXNDb3B5W2lkeF07XG4gICAgICAgICAgICBsZXQgdGV4dDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV4Y2x1ZGVkLmNvbnRlbnQpICYmXG4gICAgICAgICAgICAgICAgZXhjbHVkZWQuY29udGVudC5zb21lKChibG9jaykgPT4gdHlwZW9mIGJsb2NrID09PSBcInN0cmluZ1wiIHx8IGJsb2NrLnR5cGUgPT09IFwidGV4dFwiKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHRCbG9jayA9IGV4Y2x1ZGVkLmNvbnRlbnQuZmluZCgoYmxvY2spID0+IGJsb2NrLnR5cGUgPT09IFwidGV4dFwiICYmIGJsb2NrLnRleHQpO1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0QmxvY2s/LnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZXhjbHVkZWQuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRleHQgPSBleGNsdWRlZC5jb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzcGxpdFRleHRzID0gYXdhaXQgdGV4dFNwbGl0dGVyKHRleHQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bVNwbGl0cyA9IHNwbGl0VGV4dHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0aWFsU3RyYXRlZ3kgPT09IFwibGFzdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0VGV4dHMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBfID0gMDsgXyA8IG51bVNwbGl0cyAtIDE7IF8gKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBzcGxpdFRleHRzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBleGNsdWRlZC5jb250ZW50ID0gc3BsaXRUZXh0cy5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGF3YWl0IHRva2VuQ291bnRlcihbLi4ubWVzc2FnZXNDb3B5LnNsaWNlKDAsIGlkeCksIGV4Y2x1ZGVkXSkpIDw9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0aWFsU3RyYXRlZ3kgPT09IFwibGFzdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhjbHVkZWQuY29udGVudCA9IFsuLi5zcGxpdFRleHRzXS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzQ29weSA9IFsuLi5tZXNzYWdlc0NvcHkuc2xpY2UoMCwgaWR4KSwgZXhjbHVkZWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5kT24pIHtcbiAgICAgICAgY29uc3QgZW5kT25BcnIgPSBBcnJheS5pc0FycmF5KGVuZE9uKSA/IGVuZE9uIDogW2VuZE9uXTtcbiAgICAgICAgd2hpbGUgKGlkeCA+IDAgJiYgIV9pc01lc3NhZ2VUeXBlKG1lc3NhZ2VzQ29weVtpZHggLSAxXSwgZW5kT25BcnIpKSB7XG4gICAgICAgICAgICBpZHggLT0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZXNDb3B5LnNsaWNlKDAsIGlkeCk7XG59XG5hc3luYyBmdW5jdGlvbiBfbGFzdE1heFRva2VucyhtZXNzYWdlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgYWxsb3dQYXJ0aWFsID0gZmFsc2UsIGluY2x1ZGVTeXN0ZW0gPSBmYWxzZSwgZW5kT24sIHN0YXJ0T24sIC4uLnJlc3QgfSA9IG9wdGlvbnM7XG4gICAgLy8gQ3JlYXRlIGEgY29weSBvZiBtZXNzYWdlcyB0byBhdm9pZCBtdXRhdGlvblxuICAgIGxldCBtZXNzYWdlc0NvcHkgPSBtZXNzYWdlcy5tYXAoKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29uc3QgZmllbGRzID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKG1lc3NhZ2UpLmZpbHRlcigoW2tdKSA9PiBrICE9PSBcInR5cGVcIiAmJiAhay5zdGFydHNXaXRoKFwibGNfXCIpKSk7XG4gICAgICAgIHJldHVybiBfc3dpdGNoVHlwZVRvTWVzc2FnZShtZXNzYWdlLmdldFR5cGUoKSwgZmllbGRzLCAoMCwgYmFzZV9qc18yLmlzQmFzZU1lc3NhZ2VDaHVuaykobWVzc2FnZSkpO1xuICAgIH0pO1xuICAgIGlmIChlbmRPbikge1xuICAgICAgICBjb25zdCBlbmRPbkFyciA9IEFycmF5LmlzQXJyYXkoZW5kT24pID8gZW5kT24gOiBbZW5kT25dO1xuICAgICAgICB3aGlsZSAobWVzc2FnZXNDb3B5Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICFfaXNNZXNzYWdlVHlwZShtZXNzYWdlc0NvcHlbbWVzc2FnZXNDb3B5Lmxlbmd0aCAtIDFdLCBlbmRPbkFycikpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzQ29weSA9IG1lc3NhZ2VzQ29weS5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc3dhcHBlZFN5c3RlbSA9IGluY2x1ZGVTeXN0ZW0gJiYgbWVzc2FnZXNDb3B5WzBdPy5nZXRUeXBlKCkgPT09IFwic3lzdGVtXCI7XG4gICAgbGV0IHJldmVyc2VkXyA9IHN3YXBwZWRTeXN0ZW1cbiAgICAgICAgPyBtZXNzYWdlc0NvcHkuc2xpY2UoMCwgMSkuY29uY2F0KG1lc3NhZ2VzQ29weS5zbGljZSgxKS5yZXZlcnNlKCkpXG4gICAgICAgIDogbWVzc2FnZXNDb3B5LnJldmVyc2UoKTtcbiAgICByZXZlcnNlZF8gPSBhd2FpdCBfZmlyc3RNYXhUb2tlbnMocmV2ZXJzZWRfLCB7XG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIHBhcnRpYWxTdHJhdGVneTogYWxsb3dQYXJ0aWFsID8gXCJsYXN0XCIgOiB1bmRlZmluZWQsXG4gICAgICAgIGVuZE9uOiBzdGFydE9uLFxuICAgIH0pO1xuICAgIGlmIChzd2FwcGVkU3lzdGVtKSB7XG4gICAgICAgIHJldHVybiBbcmV2ZXJzZWRfWzBdLCAuLi5yZXZlcnNlZF8uc2xpY2UoMSkucmV2ZXJzZSgpXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZXZlcnNlZF8ucmV2ZXJzZSgpO1xuICAgIH1cbn1cbmNvbnN0IF9NU0dfQ0hVTktfTUFQID0ge1xuICAgIGh1bWFuOiB7XG4gICAgICAgIG1lc3NhZ2U6IGh1bWFuX2pzXzEuSHVtYW5NZXNzYWdlLFxuICAgICAgICBtZXNzYWdlQ2h1bms6IGh1bWFuX2pzXzEuSHVtYW5NZXNzYWdlQ2h1bmssXG4gICAgfSxcbiAgICBhaToge1xuICAgICAgICBtZXNzYWdlOiBhaV9qc18xLkFJTWVzc2FnZSxcbiAgICAgICAgbWVzc2FnZUNodW5rOiBhaV9qc18xLkFJTWVzc2FnZUNodW5rLFxuICAgIH0sXG4gICAgc3lzdGVtOiB7XG4gICAgICAgIG1lc3NhZ2U6IHN5c3RlbV9qc18xLlN5c3RlbU1lc3NhZ2UsXG4gICAgICAgIG1lc3NhZ2VDaHVuazogc3lzdGVtX2pzXzEuU3lzdGVtTWVzc2FnZUNodW5rLFxuICAgIH0sXG4gICAgZGV2ZWxvcGVyOiB7XG4gICAgICAgIG1lc3NhZ2U6IHN5c3RlbV9qc18xLlN5c3RlbU1lc3NhZ2UsXG4gICAgICAgIG1lc3NhZ2VDaHVuazogc3lzdGVtX2pzXzEuU3lzdGVtTWVzc2FnZUNodW5rLFxuICAgIH0sXG4gICAgdG9vbDoge1xuICAgICAgICBtZXNzYWdlOiB0b29sX2pzXzEuVG9vbE1lc3NhZ2UsXG4gICAgICAgIG1lc3NhZ2VDaHVuazogdG9vbF9qc18xLlRvb2xNZXNzYWdlQ2h1bmssXG4gICAgfSxcbiAgICBmdW5jdGlvbjoge1xuICAgICAgICBtZXNzYWdlOiBmdW5jdGlvbl9qc18xLkZ1bmN0aW9uTWVzc2FnZSxcbiAgICAgICAgbWVzc2FnZUNodW5rOiBmdW5jdGlvbl9qc18xLkZ1bmN0aW9uTWVzc2FnZUNodW5rLFxuICAgIH0sXG4gICAgZ2VuZXJpYzoge1xuICAgICAgICBtZXNzYWdlOiBjaGF0X2pzXzEuQ2hhdE1lc3NhZ2UsXG4gICAgICAgIG1lc3NhZ2VDaHVuazogY2hhdF9qc18xLkNoYXRNZXNzYWdlQ2h1bmssXG4gICAgfSxcbiAgICByZW1vdmU6IHtcbiAgICAgICAgbWVzc2FnZTogbW9kaWZpZXJfanNfMS5SZW1vdmVNZXNzYWdlLFxuICAgICAgICBtZXNzYWdlQ2h1bms6IG1vZGlmaWVyX2pzXzEuUmVtb3ZlTWVzc2FnZSwgLy8gUmVtb3ZlTWVzc2FnZSBkb2VzIG5vdCBoYXZlIGEgY2h1bmsgY2xhc3MuXG4gICAgfSxcbn07XG5mdW5jdGlvbiBfc3dpdGNoVHlwZVRvTWVzc2FnZShtZXNzYWdlVHlwZSwgZmllbGRzLCByZXR1cm5DaHVuaykge1xuICAgIGxldCBjaHVuaztcbiAgICBsZXQgbXNnO1xuICAgIHN3aXRjaCAobWVzc2FnZVR5cGUpIHtcbiAgICAgICAgY2FzZSBcImh1bWFuXCI6XG4gICAgICAgICAgICBpZiAocmV0dXJuQ2h1bmspIHtcbiAgICAgICAgICAgICAgICBjaHVuayA9IG5ldyBodW1hbl9qc18xLkh1bWFuTWVzc2FnZUNodW5rKGZpZWxkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtc2cgPSBuZXcgaHVtYW5fanNfMS5IdW1hbk1lc3NhZ2UoZmllbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYWlcIjpcbiAgICAgICAgICAgIGlmIChyZXR1cm5DaHVuaykge1xuICAgICAgICAgICAgICAgIGxldCBhaUNodW5rRmllbGRzID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoXCJ0b29sX2NhbGxzXCIgaW4gYWlDaHVua0ZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICBhaUNodW5rRmllbGRzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYWlDaHVua0ZpZWxkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xfY2FsbF9jaHVua3M6IGFpQ2h1bmtGaWVsZHMudG9vbF9jYWxscz8ubWFwKCh0YykgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi50YyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2xfY2FsbF9jaHVua1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogSlNPTi5zdHJpbmdpZnkodGMuYXJncyksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNodW5rID0gbmV3IGFpX2pzXzEuQUlNZXNzYWdlQ2h1bmsoYWlDaHVua0ZpZWxkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtc2cgPSBuZXcgYWlfanNfMS5BSU1lc3NhZ2UoZmllbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3lzdGVtXCI6XG4gICAgICAgICAgICBpZiAocmV0dXJuQ2h1bmspIHtcbiAgICAgICAgICAgICAgICBjaHVuayA9IG5ldyBzeXN0ZW1fanNfMS5TeXN0ZW1NZXNzYWdlQ2h1bmsoZmllbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1zZyA9IG5ldyBzeXN0ZW1fanNfMS5TeXN0ZW1NZXNzYWdlKGZpZWxkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRldmVsb3BlclwiOlxuICAgICAgICAgICAgaWYgKHJldHVybkNodW5rKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBuZXcgc3lzdGVtX2pzXzEuU3lzdGVtTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsX2t3YXJnczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZmllbGRzLmFkZGl0aW9uYWxfa3dhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgX19vcGVuYWlfcm9sZV9fOiBcImRldmVsb3BlclwiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbXNnID0gbmV3IHN5c3RlbV9qc18xLlN5c3RlbU1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5maWVsZHMuYWRkaXRpb25hbF9rd2FyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBfX29wZW5haV9yb2xlX186IFwiZGV2ZWxvcGVyXCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRvb2xcIjpcbiAgICAgICAgICAgIGlmIChcInRvb2xfY2FsbF9pZFwiIGluIGZpZWxkcykge1xuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5DaHVuaykge1xuICAgICAgICAgICAgICAgICAgICBjaHVuayA9IG5ldyB0b29sX2pzXzEuVG9vbE1lc3NhZ2VDaHVuayhmaWVsZHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbXNnID0gbmV3IHRvb2xfanNfMS5Ub29sTWVzc2FnZShmaWVsZHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgY29udmVydCBUb29sTWVzc2FnZSB0byBUb29sTWVzc2FnZUNodW5rIGlmICd0b29sX2NhbGxfaWQnIGZpZWxkIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgIGlmIChyZXR1cm5DaHVuaykge1xuICAgICAgICAgICAgICAgIGNodW5rID0gbmV3IGZ1bmN0aW9uX2pzXzEuRnVuY3Rpb25NZXNzYWdlQ2h1bmsoZmllbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghZmllbGRzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb25NZXNzYWdlIG11c3QgaGF2ZSBhICduYW1lJyBmaWVsZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbXNnID0gbmV3IGZ1bmN0aW9uX2pzXzEuRnVuY3Rpb25NZXNzYWdlKGZpZWxkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImdlbmVyaWNcIjpcbiAgICAgICAgICAgIGlmIChcInJvbGVcIiBpbiBmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuQ2h1bmspIHtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsgPSBuZXcgY2hhdF9qc18xLkNoYXRNZXNzYWdlQ2h1bmsoZmllbGRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1zZyA9IG5ldyBjaGF0X2pzXzEuQ2hhdE1lc3NhZ2UoZmllbGRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGNvbnZlcnQgQ2hhdE1lc3NhZ2UgdG8gQ2hhdE1lc3NhZ2VDaHVuayBpZiAncm9sZScgZmllbGQgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBtZXNzYWdlIHR5cGUgJHttZXNzYWdlVHlwZX1gKTtcbiAgICB9XG4gICAgaWYgKHJldHVybkNodW5rICYmIGNodW5rKSB7XG4gICAgICAgIHJldHVybiBjaHVuaztcbiAgICB9XG4gICAgaWYgKG1zZykge1xuICAgICAgICByZXR1cm4gbXNnO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBtZXNzYWdlIHR5cGUgJHttZXNzYWdlVHlwZX1gKTtcbn1cbmZ1bmN0aW9uIF9jaHVua1RvTXNnKGNodW5rKSB7XG4gICAgY29uc3QgY2h1bmtUeXBlID0gY2h1bmsuZ2V0VHlwZSgpO1xuICAgIGxldCBtc2c7XG4gICAgY29uc3QgZmllbGRzID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGNodW5rKS5maWx0ZXIoKFtrXSkgPT4gIVtcInR5cGVcIiwgXCJ0b29sX2NhbGxfY2h1bmtzXCJdLmluY2x1ZGVzKGspICYmICFrLnN0YXJ0c1dpdGgoXCJsY19cIikpKTtcbiAgICBpZiAoY2h1bmtUeXBlIGluIF9NU0dfQ0hVTktfTUFQKSB7XG4gICAgICAgIG1zZyA9IF9zd2l0Y2hUeXBlVG9NZXNzYWdlKGNodW5rVHlwZSwgZmllbGRzKTtcbiAgICB9XG4gICAgaWYgKCFtc2cpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgbWVzc2FnZSBjaHVuayBjbGFzcyAke2NodW5rVHlwZX0uIFN1cHBvcnRlZCBjbGFzc2VzIGFyZSAke09iamVjdC5rZXlzKF9NU0dfQ0hVTktfTUFQKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG1zZztcbn1cbi8qKlxuICogVGhlIGRlZmF1bHQgdGV4dCBzcGxpdHRlciBmdW5jdGlvbiB0aGF0IHNwbGl0cyB0ZXh0IGJ5IG5ld2xpbmVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhcnJheSBvZiBzdHJpbmdzIHNwbGl0IGJ5IG5ld2xpbmVzLlxuICovXG5mdW5jdGlvbiBkZWZhdWx0VGV4dFNwbGl0dGVyKHRleHQpIHtcbiAgICBjb25zdCBzcGxpdHMgPSB0ZXh0LnNwbGl0KFwiXFxuXCIpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW1xuICAgICAgICAuLi5zcGxpdHMuc2xpY2UoMCwgLTEpLm1hcCgocykgPT4gYCR7c31cXG5gKSxcbiAgICAgICAgc3BsaXRzW3NwbGl0cy5sZW5ndGggLSAxXSxcbiAgICBdKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/transformers.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/utils.cjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.coerceMessageLikeToMessage = coerceMessageLikeToMessage;\nexports.getBufferString = getBufferString;\nexports.mapStoredMessageToChatMessage = mapStoredMessageToChatMessage;\nexports.mapStoredMessagesToChatMessages = mapStoredMessagesToChatMessages;\nexports.mapChatMessagesToStoredMessages = mapChatMessagesToStoredMessages;\nexports.convertToChunk = convertToChunk;\nconst index_js_1 = __webpack_require__(/*! ../errors/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/errors/index.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ../tools/utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tools/utils.cjs\");\nconst ai_js_1 = __webpack_require__(/*! ./ai.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/ai.cjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\nconst chat_js_1 = __webpack_require__(/*! ./chat.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/chat.cjs\");\nconst function_js_1 = __webpack_require__(/*! ./function.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/function.cjs\");\nconst human_js_1 = __webpack_require__(/*! ./human.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/human.cjs\");\nconst modifier_js_1 = __webpack_require__(/*! ./modifier.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/modifier.cjs\");\nconst system_js_1 = __webpack_require__(/*! ./system.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/system.cjs\");\nconst tool_js_1 = __webpack_require__(/*! ./tool.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/tool.cjs\");\nfunction _coerceToolCall(toolCall) {\n    if ((0, utils_js_1._isToolCall)(toolCall)) {\n        return toolCall;\n    }\n    else if (typeof toolCall.id === \"string\" &&\n        toolCall.type === \"function\" &&\n        typeof toolCall.function === \"object\" &&\n        toolCall.function !== null &&\n        \"arguments\" in toolCall.function &&\n        typeof toolCall.function.arguments === \"string\" &&\n        \"name\" in toolCall.function &&\n        typeof toolCall.function.name === \"string\") {\n        // Handle OpenAI tool call format\n        return {\n            id: toolCall.id,\n            args: JSON.parse(toolCall.function.arguments),\n            name: toolCall.function.name,\n            type: \"tool_call\",\n        };\n    }\n    else {\n        // TODO: Throw an error?\n        return toolCall;\n    }\n}\nfunction isSerializedConstructor(x) {\n    return (typeof x === \"object\" &&\n        x != null &&\n        x.lc === 1 &&\n        Array.isArray(x.id) &&\n        x.kwargs != null &&\n        typeof x.kwargs === \"object\");\n}\nfunction _constructMessageFromParams(params) {\n    let type;\n    let rest;\n    // Support serialized messages\n    if (isSerializedConstructor(params)) {\n        const className = params.id.at(-1);\n        if (className === \"HumanMessage\" || className === \"HumanMessageChunk\") {\n            type = \"user\";\n        }\n        else if (className === \"AIMessage\" || className === \"AIMessageChunk\") {\n            type = \"assistant\";\n        }\n        else if (className === \"SystemMessage\" ||\n            className === \"SystemMessageChunk\") {\n            type = \"system\";\n        }\n        else if (className === \"FunctionMessage\" ||\n            className === \"FunctionMessageChunk\") {\n            type = \"function\";\n        }\n        else if (className === \"ToolMessage\" ||\n            className === \"ToolMessageChunk\") {\n            type = \"tool\";\n        }\n        else {\n            type = \"unknown\";\n        }\n        rest = params.kwargs;\n    }\n    else {\n        const { type: extractedType, ...otherParams } = params;\n        type = extractedType;\n        rest = otherParams;\n    }\n    if (type === \"human\" || type === \"user\") {\n        return new human_js_1.HumanMessage(rest);\n    }\n    else if (type === \"ai\" || type === \"assistant\") {\n        const { tool_calls: rawToolCalls, ...other } = rest;\n        if (!Array.isArray(rawToolCalls)) {\n            return new ai_js_1.AIMessage(rest);\n        }\n        const tool_calls = rawToolCalls.map(_coerceToolCall);\n        return new ai_js_1.AIMessage({ ...other, tool_calls });\n    }\n    else if (type === \"system\") {\n        return new system_js_1.SystemMessage(rest);\n    }\n    else if (type === \"developer\") {\n        return new system_js_1.SystemMessage({\n            ...rest,\n            additional_kwargs: {\n                ...rest.additional_kwargs,\n                __openai_role__: \"developer\",\n            },\n        });\n    }\n    else if (type === \"tool\" && \"tool_call_id\" in rest) {\n        return new tool_js_1.ToolMessage({\n            ...rest,\n            content: rest.content,\n            tool_call_id: rest.tool_call_id,\n            name: rest.name,\n        });\n    }\n    else if (type === \"remove\" && \"id\" in rest && typeof rest.id === \"string\") {\n        return new modifier_js_1.RemoveMessage({ ...rest, id: rest.id });\n    }\n    else {\n        const error = (0, index_js_1.addLangChainErrorFields)(new Error(`Unable to coerce message from array: only human, AI, system, developer, or tool message coercion is currently supported.\\n\\nReceived: ${JSON.stringify(params, null, 2)}`), \"MESSAGE_COERCION_FAILURE\");\n        throw error;\n    }\n}\nfunction coerceMessageLikeToMessage(messageLike) {\n    if (typeof messageLike === \"string\") {\n        return new human_js_1.HumanMessage(messageLike);\n    }\n    else if ((0, base_js_1.isBaseMessage)(messageLike)) {\n        return messageLike;\n    }\n    if (Array.isArray(messageLike)) {\n        const [type, content] = messageLike;\n        return _constructMessageFromParams({ type, content });\n    }\n    else if ((0, base_js_1._isMessageFieldWithRole)(messageLike)) {\n        const { role: type, ...rest } = messageLike;\n        return _constructMessageFromParams({ ...rest, type });\n    }\n    else {\n        return _constructMessageFromParams(messageLike);\n    }\n}\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n */\nfunction getBufferString(messages, humanPrefix = \"Human\", aiPrefix = \"AI\") {\n    const string_messages = [];\n    for (const m of messages) {\n        let role;\n        if (m._getType() === \"human\") {\n            role = humanPrefix;\n        }\n        else if (m._getType() === \"ai\") {\n            role = aiPrefix;\n        }\n        else if (m._getType() === \"system\") {\n            role = \"System\";\n        }\n        else if (m._getType() === \"function\") {\n            role = \"Function\";\n        }\n        else if (m._getType() === \"tool\") {\n            role = \"Tool\";\n        }\n        else if (m._getType() === \"generic\") {\n            role = m.role;\n        }\n        else {\n            throw new Error(`Got unsupported message type: ${m._getType()}`);\n        }\n        const nameStr = m.name ? `${m.name}, ` : \"\";\n        const readableContent = typeof m.content === \"string\"\n            ? m.content\n            : JSON.stringify(m.content, null, 2);\n        string_messages.push(`${role}: ${nameStr}${readableContent}`);\n    }\n    return string_messages.join(\"\\n\");\n}\n/**\n * Maps messages from an older format (V1) to the current `StoredMessage`\n * format. If the message is already in the `StoredMessage` format, it is\n * returned as is. Otherwise, it transforms the V1 message into a\n * `StoredMessage`. This function is important for maintaining\n * compatibility with older message formats.\n */\nfunction mapV1MessageToStoredMessage(message) {\n    // TODO: Remove this mapper when we deprecate the old message format.\n    if (message.data !== undefined) {\n        return message;\n    }\n    else {\n        const v1Message = message;\n        return {\n            type: v1Message.type,\n            data: {\n                content: v1Message.text,\n                role: v1Message.role,\n                name: undefined,\n                tool_call_id: undefined,\n            },\n        };\n    }\n}\nfunction mapStoredMessageToChatMessage(message) {\n    const storedMessage = mapV1MessageToStoredMessage(message);\n    switch (storedMessage.type) {\n        case \"human\":\n            return new human_js_1.HumanMessage(storedMessage.data);\n        case \"ai\":\n            return new ai_js_1.AIMessage(storedMessage.data);\n        case \"system\":\n            return new system_js_1.SystemMessage(storedMessage.data);\n        case \"function\":\n            if (storedMessage.data.name === undefined) {\n                throw new Error(\"Name must be defined for function messages\");\n            }\n            return new function_js_1.FunctionMessage(storedMessage.data);\n        case \"tool\":\n            if (storedMessage.data.tool_call_id === undefined) {\n                throw new Error(\"Tool call ID must be defined for tool messages\");\n            }\n            return new tool_js_1.ToolMessage(storedMessage.data);\n        case \"generic\": {\n            if (storedMessage.data.role === undefined) {\n                throw new Error(\"Role must be defined for chat messages\");\n            }\n            return new chat_js_1.ChatMessage(storedMessage.data);\n        }\n        default:\n            throw new Error(`Got unexpected type: ${storedMessage.type}`);\n    }\n}\n/**\n * Transforms an array of `StoredMessage` instances into an array of\n * `BaseMessage` instances. It uses the `mapV1MessageToStoredMessage`\n * function to ensure all messages are in the `StoredMessage` format, then\n * creates new instances of the appropriate `BaseMessage` subclass based\n * on the type of each message. This function is used to prepare stored\n * messages for use in a chat context.\n */\nfunction mapStoredMessagesToChatMessages(messages) {\n    return messages.map(mapStoredMessageToChatMessage);\n}\n/**\n * Transforms an array of `BaseMessage` instances into an array of\n * `StoredMessage` instances. It does this by calling the `toDict` method\n * on each `BaseMessage`, which returns a `StoredMessage`. This function\n * is used to prepare chat messages for storage.\n */\nfunction mapChatMessagesToStoredMessages(messages) {\n    return messages.map((message) => message.toDict());\n}\nfunction convertToChunk(message) {\n    const type = message._getType();\n    if (type === \"human\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new human_js_1.HumanMessageChunk({ ...message });\n    }\n    else if (type === \"ai\") {\n        let aiChunkFields = {\n            ...message,\n        };\n        if (\"tool_calls\" in aiChunkFields) {\n            aiChunkFields = {\n                ...aiChunkFields,\n                tool_call_chunks: aiChunkFields.tool_calls?.map((tc) => ({\n                    ...tc,\n                    type: \"tool_call_chunk\",\n                    index: undefined,\n                    args: JSON.stringify(tc.args),\n                })),\n            };\n        }\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new ai_js_1.AIMessageChunk({ ...aiChunkFields });\n    }\n    else if (type === \"system\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new system_js_1.SystemMessageChunk({ ...message });\n    }\n    else if (type === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new function_js_1.FunctionMessageChunk({ ...message });\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    }\n    else if (chat_js_1.ChatMessage.isInstance(message)) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new chat_js_1.ChatMessageChunk({ ...message });\n    }\n    else {\n        throw new Error(\"Unknown message type.\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvdXRpbHMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtDQUFrQztBQUNsQyx1QkFBdUI7QUFDdkIscUNBQXFDO0FBQ3JDLHVDQUF1QztBQUN2Qyx1Q0FBdUM7QUFDdkMsc0JBQXNCO0FBQ3RCLG1CQUFtQixtQkFBTyxDQUFDLHVGQUFxQjtBQUNoRCxtQkFBbUIsbUJBQU8sQ0FBQyxxRkFBb0I7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsMkVBQVU7QUFDbEMsa0JBQWtCLG1CQUFPLENBQUMsK0VBQVk7QUFDdEMsa0JBQWtCLG1CQUFPLENBQUMsK0VBQVk7QUFDdEMsc0JBQXNCLG1CQUFPLENBQUMsdUZBQWdCO0FBQzlDLG1CQUFtQixtQkFBTyxDQUFDLGlGQUFhO0FBQ3hDLHNCQUFzQixtQkFBTyxDQUFDLHVGQUFnQjtBQUM5QyxvQkFBb0IsbUJBQU8sQ0FBQyxtRkFBYztBQUMxQyxrQkFBa0IsbUJBQU8sQ0FBQywrRUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0NBQXNDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFDQUFxQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxzQkFBc0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxpREFBaUQsc0JBQXNCO0FBQ3ZFO0FBQ0E7QUFDQSxpTkFBaU4sZ0NBQWdDO0FBQ2pQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxlQUFlO0FBQzVEO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDLDZDQUE2QyxlQUFlO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsYUFBYTtBQUMxRTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxLQUFLLElBQUksUUFBUSxFQUFFLGdCQUFnQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxtQkFBbUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxZQUFZO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxrQkFBa0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFlBQVk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvdXRpbHMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb2VyY2VNZXNzYWdlTGlrZVRvTWVzc2FnZSA9IGNvZXJjZU1lc3NhZ2VMaWtlVG9NZXNzYWdlO1xuZXhwb3J0cy5nZXRCdWZmZXJTdHJpbmcgPSBnZXRCdWZmZXJTdHJpbmc7XG5leHBvcnRzLm1hcFN0b3JlZE1lc3NhZ2VUb0NoYXRNZXNzYWdlID0gbWFwU3RvcmVkTWVzc2FnZVRvQ2hhdE1lc3NhZ2U7XG5leHBvcnRzLm1hcFN0b3JlZE1lc3NhZ2VzVG9DaGF0TWVzc2FnZXMgPSBtYXBTdG9yZWRNZXNzYWdlc1RvQ2hhdE1lc3NhZ2VzO1xuZXhwb3J0cy5tYXBDaGF0TWVzc2FnZXNUb1N0b3JlZE1lc3NhZ2VzID0gbWFwQ2hhdE1lc3NhZ2VzVG9TdG9yZWRNZXNzYWdlcztcbmV4cG9ydHMuY29udmVydFRvQ2h1bmsgPSBjb252ZXJ0VG9DaHVuaztcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzL2luZGV4LmNqc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi4vdG9vbHMvdXRpbHMuY2pzXCIpO1xuY29uc3QgYWlfanNfMSA9IHJlcXVpcmUoXCIuL2FpLmNqc1wiKTtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2UuY2pzXCIpO1xuY29uc3QgY2hhdF9qc18xID0gcmVxdWlyZShcIi4vY2hhdC5janNcIik7XG5jb25zdCBmdW5jdGlvbl9qc18xID0gcmVxdWlyZShcIi4vZnVuY3Rpb24uY2pzXCIpO1xuY29uc3QgaHVtYW5fanNfMSA9IHJlcXVpcmUoXCIuL2h1bWFuLmNqc1wiKTtcbmNvbnN0IG1vZGlmaWVyX2pzXzEgPSByZXF1aXJlKFwiLi9tb2RpZmllci5janNcIik7XG5jb25zdCBzeXN0ZW1fanNfMSA9IHJlcXVpcmUoXCIuL3N5c3RlbS5janNcIik7XG5jb25zdCB0b29sX2pzXzEgPSByZXF1aXJlKFwiLi90b29sLmNqc1wiKTtcbmZ1bmN0aW9uIF9jb2VyY2VUb29sQ2FsbCh0b29sQ2FsbCkge1xuICAgIGlmICgoMCwgdXRpbHNfanNfMS5faXNUb29sQ2FsbCkodG9vbENhbGwpKSB7XG4gICAgICAgIHJldHVybiB0b29sQ2FsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHRvb2xDYWxsLmlkID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgIHRvb2xDYWxsLnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgdG9vbENhbGwuZnVuY3Rpb24gPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgdG9vbENhbGwuZnVuY3Rpb24gIT09IG51bGwgJiZcbiAgICAgICAgXCJhcmd1bWVudHNcIiBpbiB0b29sQ2FsbC5mdW5jdGlvbiAmJlxuICAgICAgICB0eXBlb2YgdG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgIFwibmFtZVwiIGluIHRvb2xDYWxsLmZ1bmN0aW9uICYmXG4gICAgICAgIHR5cGVvZiB0b29sQ2FsbC5mdW5jdGlvbi5uYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIEhhbmRsZSBPcGVuQUkgdG9vbCBjYWxsIGZvcm1hdFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHRvb2xDYWxsLmlkLFxuICAgICAgICAgICAgYXJnczogSlNPTi5wYXJzZSh0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMpLFxuICAgICAgICAgICAgbmFtZTogdG9vbENhbGwuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgIHR5cGU6IFwidG9vbF9jYWxsXCIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBUaHJvdyBhbiBlcnJvcj9cbiAgICAgICAgcmV0dXJuIHRvb2xDYWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU2VyaWFsaXplZENvbnN0cnVjdG9yKHgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB4ID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHggIT0gbnVsbCAmJlxuICAgICAgICB4LmxjID09PSAxICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkoeC5pZCkgJiZcbiAgICAgICAgeC5rd2FyZ3MgIT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgeC5rd2FyZ3MgPT09IFwib2JqZWN0XCIpO1xufVxuZnVuY3Rpb24gX2NvbnN0cnVjdE1lc3NhZ2VGcm9tUGFyYW1zKHBhcmFtcykge1xuICAgIGxldCB0eXBlO1xuICAgIGxldCByZXN0O1xuICAgIC8vIFN1cHBvcnQgc2VyaWFsaXplZCBtZXNzYWdlc1xuICAgIGlmIChpc1NlcmlhbGl6ZWRDb25zdHJ1Y3RvcihwYXJhbXMpKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IHBhcmFtcy5pZC5hdCgtMSk7XG4gICAgICAgIGlmIChjbGFzc05hbWUgPT09IFwiSHVtYW5NZXNzYWdlXCIgfHwgY2xhc3NOYW1lID09PSBcIkh1bWFuTWVzc2FnZUNodW5rXCIpIHtcbiAgICAgICAgICAgIHR5cGUgPSBcInVzZXJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbGFzc05hbWUgPT09IFwiQUlNZXNzYWdlXCIgfHwgY2xhc3NOYW1lID09PSBcIkFJTWVzc2FnZUNodW5rXCIpIHtcbiAgICAgICAgICAgIHR5cGUgPSBcImFzc2lzdGFudFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsYXNzTmFtZSA9PT0gXCJTeXN0ZW1NZXNzYWdlXCIgfHxcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9PT0gXCJTeXN0ZW1NZXNzYWdlQ2h1bmtcIikge1xuICAgICAgICAgICAgdHlwZSA9IFwic3lzdGVtXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xhc3NOYW1lID09PSBcIkZ1bmN0aW9uTWVzc2FnZVwiIHx8XG4gICAgICAgICAgICBjbGFzc05hbWUgPT09IFwiRnVuY3Rpb25NZXNzYWdlQ2h1bmtcIikge1xuICAgICAgICAgICAgdHlwZSA9IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbGFzc05hbWUgPT09IFwiVG9vbE1lc3NhZ2VcIiB8fFxuICAgICAgICAgICAgY2xhc3NOYW1lID09PSBcIlRvb2xNZXNzYWdlQ2h1bmtcIikge1xuICAgICAgICAgICAgdHlwZSA9IFwidG9vbFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHlwZSA9IFwidW5rbm93blwiO1xuICAgICAgICB9XG4gICAgICAgIHJlc3QgPSBwYXJhbXMua3dhcmdzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgeyB0eXBlOiBleHRyYWN0ZWRUeXBlLCAuLi5vdGhlclBhcmFtcyB9ID0gcGFyYW1zO1xuICAgICAgICB0eXBlID0gZXh0cmFjdGVkVHlwZTtcbiAgICAgICAgcmVzdCA9IG90aGVyUGFyYW1zO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJodW1hblwiIHx8IHR5cGUgPT09IFwidXNlclwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgaHVtYW5fanNfMS5IdW1hbk1lc3NhZ2UocmVzdCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiYWlcIiB8fCB0eXBlID09PSBcImFzc2lzdGFudFwiKSB7XG4gICAgICAgIGNvbnN0IHsgdG9vbF9jYWxsczogcmF3VG9vbENhbGxzLCAuLi5vdGhlciB9ID0gcmVzdDtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJhd1Rvb2xDYWxscykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgYWlfanNfMS5BSU1lc3NhZ2UocmVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9vbF9jYWxscyA9IHJhd1Rvb2xDYWxscy5tYXAoX2NvZXJjZVRvb2xDYWxsKTtcbiAgICAgICAgcmV0dXJuIG5ldyBhaV9qc18xLkFJTWVzc2FnZSh7IC4uLm90aGVyLCB0b29sX2NhbGxzIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcInN5c3RlbVwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgc3lzdGVtX2pzXzEuU3lzdGVtTWVzc2FnZShyZXN0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJkZXZlbG9wZXJcIikge1xuICAgICAgICByZXR1cm4gbmV3IHN5c3RlbV9qc18xLlN5c3RlbU1lc3NhZ2Uoe1xuICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiB7XG4gICAgICAgICAgICAgICAgLi4ucmVzdC5hZGRpdGlvbmFsX2t3YXJncyxcbiAgICAgICAgICAgICAgICBfX29wZW5haV9yb2xlX186IFwiZGV2ZWxvcGVyXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJ0b29sXCIgJiYgXCJ0b29sX2NhbGxfaWRcIiBpbiByZXN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgdG9vbF9qc18xLlRvb2xNZXNzYWdlKHtcbiAgICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgICBjb250ZW50OiByZXN0LmNvbnRlbnQsXG4gICAgICAgICAgICB0b29sX2NhbGxfaWQ6IHJlc3QudG9vbF9jYWxsX2lkLFxuICAgICAgICAgICAgbmFtZTogcmVzdC5uYW1lLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJyZW1vdmVcIiAmJiBcImlkXCIgaW4gcmVzdCAmJiB0eXBlb2YgcmVzdC5pZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gbmV3IG1vZGlmaWVyX2pzXzEuUmVtb3ZlTWVzc2FnZSh7IC4uLnJlc3QsIGlkOiByZXN0LmlkIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSAoMCwgaW5kZXhfanNfMS5hZGRMYW5nQ2hhaW5FcnJvckZpZWxkcykobmV3IEVycm9yKGBVbmFibGUgdG8gY29lcmNlIG1lc3NhZ2UgZnJvbSBhcnJheTogb25seSBodW1hbiwgQUksIHN5c3RlbSwgZGV2ZWxvcGVyLCBvciB0b29sIG1lc3NhZ2UgY29lcmNpb24gaXMgY3VycmVudGx5IHN1cHBvcnRlZC5cXG5cXG5SZWNlaXZlZDogJHtKU09OLnN0cmluZ2lmeShwYXJhbXMsIG51bGwsIDIpfWApLCBcIk1FU1NBR0VfQ09FUkNJT05fRkFJTFVSRVwiKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZnVuY3Rpb24gY29lcmNlTWVzc2FnZUxpa2VUb01lc3NhZ2UobWVzc2FnZUxpa2UpIHtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2VMaWtlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBuZXcgaHVtYW5fanNfMS5IdW1hbk1lc3NhZ2UobWVzc2FnZUxpa2UpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgYmFzZV9qc18xLmlzQmFzZU1lc3NhZ2UpKG1lc3NhZ2VMaWtlKSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZUxpa2U7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG1lc3NhZ2VMaWtlKSkge1xuICAgICAgICBjb25zdCBbdHlwZSwgY29udGVudF0gPSBtZXNzYWdlTGlrZTtcbiAgICAgICAgcmV0dXJuIF9jb25zdHJ1Y3RNZXNzYWdlRnJvbVBhcmFtcyh7IHR5cGUsIGNvbnRlbnQgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCBiYXNlX2pzXzEuX2lzTWVzc2FnZUZpZWxkV2l0aFJvbGUpKG1lc3NhZ2VMaWtlKSkge1xuICAgICAgICBjb25zdCB7IHJvbGU6IHR5cGUsIC4uLnJlc3QgfSA9IG1lc3NhZ2VMaWtlO1xuICAgICAgICByZXR1cm4gX2NvbnN0cnVjdE1lc3NhZ2VGcm9tUGFyYW1zKHsgLi4ucmVzdCwgdHlwZSB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBfY29uc3RydWN0TWVzc2FnZUZyb21QYXJhbXMobWVzc2FnZUxpa2UpO1xuICAgIH1cbn1cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJ5IG1lbW9yeSBjbGFzc2VzIHRvIGdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvblxuICogb2YgdGhlIGNoYXQgbWVzc2FnZSBoaXN0b3J5LCBiYXNlZCBvbiB0aGUgbWVzc2FnZSBjb250ZW50IGFuZCByb2xlLlxuICovXG5mdW5jdGlvbiBnZXRCdWZmZXJTdHJpbmcobWVzc2FnZXMsIGh1bWFuUHJlZml4ID0gXCJIdW1hblwiLCBhaVByZWZpeCA9IFwiQUlcIikge1xuICAgIGNvbnN0IHN0cmluZ19tZXNzYWdlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgbSBvZiBtZXNzYWdlcykge1xuICAgICAgICBsZXQgcm9sZTtcbiAgICAgICAgaWYgKG0uX2dldFR5cGUoKSA9PT0gXCJodW1hblwiKSB7XG4gICAgICAgICAgICByb2xlID0gaHVtYW5QcmVmaXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobS5fZ2V0VHlwZSgpID09PSBcImFpXCIpIHtcbiAgICAgICAgICAgIHJvbGUgPSBhaVByZWZpeDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtLl9nZXRUeXBlKCkgPT09IFwic3lzdGVtXCIpIHtcbiAgICAgICAgICAgIHJvbGUgPSBcIlN5c3RlbVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG0uX2dldFR5cGUoKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByb2xlID0gXCJGdW5jdGlvblwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG0uX2dldFR5cGUoKSA9PT0gXCJ0b29sXCIpIHtcbiAgICAgICAgICAgIHJvbGUgPSBcIlRvb2xcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtLl9nZXRUeXBlKCkgPT09IFwiZ2VuZXJpY1wiKSB7XG4gICAgICAgICAgICByb2xlID0gbS5yb2xlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHb3QgdW5zdXBwb3J0ZWQgbWVzc2FnZSB0eXBlOiAke20uX2dldFR5cGUoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lU3RyID0gbS5uYW1lID8gYCR7bS5uYW1lfSwgYCA6IFwiXCI7XG4gICAgICAgIGNvbnN0IHJlYWRhYmxlQ29udGVudCA9IHR5cGVvZiBtLmNvbnRlbnQgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8gbS5jb250ZW50XG4gICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KG0uY29udGVudCwgbnVsbCwgMik7XG4gICAgICAgIHN0cmluZ19tZXNzYWdlcy5wdXNoKGAke3JvbGV9OiAke25hbWVTdHJ9JHtyZWFkYWJsZUNvbnRlbnR9YCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmdfbWVzc2FnZXMuam9pbihcIlxcblwiKTtcbn1cbi8qKlxuICogTWFwcyBtZXNzYWdlcyBmcm9tIGFuIG9sZGVyIGZvcm1hdCAoVjEpIHRvIHRoZSBjdXJyZW50IGBTdG9yZWRNZXNzYWdlYFxuICogZm9ybWF0LiBJZiB0aGUgbWVzc2FnZSBpcyBhbHJlYWR5IGluIHRoZSBgU3RvcmVkTWVzc2FnZWAgZm9ybWF0LCBpdCBpc1xuICogcmV0dXJuZWQgYXMgaXMuIE90aGVyd2lzZSwgaXQgdHJhbnNmb3JtcyB0aGUgVjEgbWVzc2FnZSBpbnRvIGFcbiAqIGBTdG9yZWRNZXNzYWdlYC4gVGhpcyBmdW5jdGlvbiBpcyBpbXBvcnRhbnQgZm9yIG1haW50YWluaW5nXG4gKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkZXIgbWVzc2FnZSBmb3JtYXRzLlxuICovXG5mdW5jdGlvbiBtYXBWMU1lc3NhZ2VUb1N0b3JlZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIG1hcHBlciB3aGVuIHdlIGRlcHJlY2F0ZSB0aGUgb2xkIG1lc3NhZ2UgZm9ybWF0LlxuICAgIGlmIChtZXNzYWdlLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHYxTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB2MU1lc3NhZ2UudHlwZSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiB2MU1lc3NhZ2UudGV4dCxcbiAgICAgICAgICAgICAgICByb2xlOiB2MU1lc3NhZ2Uucm9sZSxcbiAgICAgICAgICAgICAgICBuYW1lOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdG9vbF9jYWxsX2lkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcFN0b3JlZE1lc3NhZ2VUb0NoYXRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBzdG9yZWRNZXNzYWdlID0gbWFwVjFNZXNzYWdlVG9TdG9yZWRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIHN3aXRjaCAoc3RvcmVkTWVzc2FnZS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJodW1hblwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBodW1hbl9qc18xLkh1bWFuTWVzc2FnZShzdG9yZWRNZXNzYWdlLmRhdGEpO1xuICAgICAgICBjYXNlIFwiYWlcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgYWlfanNfMS5BSU1lc3NhZ2Uoc3RvcmVkTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgY2FzZSBcInN5c3RlbVwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBzeXN0ZW1fanNfMS5TeXN0ZW1NZXNzYWdlKHN0b3JlZE1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgaWYgKHN0b3JlZE1lc3NhZ2UuZGF0YS5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOYW1lIG11c3QgYmUgZGVmaW5lZCBmb3IgZnVuY3Rpb24gbWVzc2FnZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IGZ1bmN0aW9uX2pzXzEuRnVuY3Rpb25NZXNzYWdlKHN0b3JlZE1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIGNhc2UgXCJ0b29sXCI6XG4gICAgICAgICAgICBpZiAoc3RvcmVkTWVzc2FnZS5kYXRhLnRvb2xfY2FsbF9pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG9vbCBjYWxsIElEIG11c3QgYmUgZGVmaW5lZCBmb3IgdG9vbCBtZXNzYWdlc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgdG9vbF9qc18xLlRvb2xNZXNzYWdlKHN0b3JlZE1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIGNhc2UgXCJnZW5lcmljXCI6IHtcbiAgICAgICAgICAgIGlmIChzdG9yZWRNZXNzYWdlLmRhdGEucm9sZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9sZSBtdXN0IGJlIGRlZmluZWQgZm9yIGNoYXQgbWVzc2FnZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNoYXRfanNfMS5DaGF0TWVzc2FnZShzdG9yZWRNZXNzYWdlLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCB1bmV4cGVjdGVkIHR5cGU6ICR7c3RvcmVkTWVzc2FnZS50eXBlfWApO1xuICAgIH1cbn1cbi8qKlxuICogVHJhbnNmb3JtcyBhbiBhcnJheSBvZiBgU3RvcmVkTWVzc2FnZWAgaW5zdGFuY2VzIGludG8gYW4gYXJyYXkgb2ZcbiAqIGBCYXNlTWVzc2FnZWAgaW5zdGFuY2VzLiBJdCB1c2VzIHRoZSBgbWFwVjFNZXNzYWdlVG9TdG9yZWRNZXNzYWdlYFxuICogZnVuY3Rpb24gdG8gZW5zdXJlIGFsbCBtZXNzYWdlcyBhcmUgaW4gdGhlIGBTdG9yZWRNZXNzYWdlYCBmb3JtYXQsIHRoZW5cbiAqIGNyZWF0ZXMgbmV3IGluc3RhbmNlcyBvZiB0aGUgYXBwcm9wcmlhdGUgYEJhc2VNZXNzYWdlYCBzdWJjbGFzcyBiYXNlZFxuICogb24gdGhlIHR5cGUgb2YgZWFjaCBtZXNzYWdlLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcHJlcGFyZSBzdG9yZWRcbiAqIG1lc3NhZ2VzIGZvciB1c2UgaW4gYSBjaGF0IGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIG1hcFN0b3JlZE1lc3NhZ2VzVG9DaGF0TWVzc2FnZXMobWVzc2FnZXMpIHtcbiAgICByZXR1cm4gbWVzc2FnZXMubWFwKG1hcFN0b3JlZE1lc3NhZ2VUb0NoYXRNZXNzYWdlKTtcbn1cbi8qKlxuICogVHJhbnNmb3JtcyBhbiBhcnJheSBvZiBgQmFzZU1lc3NhZ2VgIGluc3RhbmNlcyBpbnRvIGFuIGFycmF5IG9mXG4gKiBgU3RvcmVkTWVzc2FnZWAgaW5zdGFuY2VzLiBJdCBkb2VzIHRoaXMgYnkgY2FsbGluZyB0aGUgYHRvRGljdGAgbWV0aG9kXG4gKiBvbiBlYWNoIGBCYXNlTWVzc2FnZWAsIHdoaWNoIHJldHVybnMgYSBgU3RvcmVkTWVzc2FnZWAuIFRoaXMgZnVuY3Rpb25cbiAqIGlzIHVzZWQgdG8gcHJlcGFyZSBjaGF0IG1lc3NhZ2VzIGZvciBzdG9yYWdlLlxuICovXG5mdW5jdGlvbiBtYXBDaGF0TWVzc2FnZXNUb1N0b3JlZE1lc3NhZ2VzKG1lc3NhZ2VzKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2VzLm1hcCgobWVzc2FnZSkgPT4gbWVzc2FnZS50b0RpY3QoKSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9DaHVuayhtZXNzYWdlKSB7XG4gICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UuX2dldFR5cGUoKTtcbiAgICBpZiAodHlwZSA9PT0gXCJodW1hblwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBodW1hbl9qc18xLkh1bWFuTWVzc2FnZUNodW5rKHsgLi4ubWVzc2FnZSB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJhaVwiKSB7XG4gICAgICAgIGxldCBhaUNodW5rRmllbGRzID0ge1xuICAgICAgICAgICAgLi4ubWVzc2FnZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKFwidG9vbF9jYWxsc1wiIGluIGFpQ2h1bmtGaWVsZHMpIHtcbiAgICAgICAgICAgIGFpQ2h1bmtGaWVsZHMgPSB7XG4gICAgICAgICAgICAgICAgLi4uYWlDaHVua0ZpZWxkcyxcbiAgICAgICAgICAgICAgICB0b29sX2NhbGxfY2h1bmtzOiBhaUNodW5rRmllbGRzLnRvb2xfY2FsbHM/Lm1hcCgodGMpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRjLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2xfY2FsbF9jaHVua1wiLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBKU09OLnN0cmluZ2lmeSh0Yy5hcmdzKSxcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBhaV9qc18xLkFJTWVzc2FnZUNodW5rKHsgLi4uYWlDaHVua0ZpZWxkcyB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJzeXN0ZW1cIikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgc3lzdGVtX2pzXzEuU3lzdGVtTWVzc2FnZUNodW5rKHsgLi4ubWVzc2FnZSB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBmdW5jdGlvbl9qc18xLkZ1bmN0aW9uTWVzc2FnZUNodW5rKHsgLi4ubWVzc2FnZSB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgIH1cbiAgICBlbHNlIGlmIChjaGF0X2pzXzEuQ2hhdE1lc3NhZ2UuaXNJbnN0YW5jZShtZXNzYWdlKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgY2hhdF9qc18xLkNoYXRNZXNzYWdlQ2h1bmsoeyAuLi5tZXNzYWdlIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBtZXNzYWdlIHR5cGUuXCIpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/base.cjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/base.cjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OutputParserException = exports.BaseOutputParser = exports.BaseLLMOutputParser = void 0;\nconst index_js_1 = __webpack_require__(/*! ../runnables/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/index.cjs\");\nconst index_js_2 = __webpack_require__(/*! ../errors/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/errors/index.cjs\");\n/**\n * Abstract base class for parsing the output of a Large Language Model\n * (LLM) call. It provides methods for parsing the result of an LLM call\n * and invoking the parser with a given input.\n */\nclass BaseLLMOutputParser extends index_js_1.Runnable {\n    /**\n     * Parses the result of an LLM call with a given prompt. By default, it\n     * simply calls `parseResult`.\n     * @param generations The generations from an LLM call.\n     * @param _prompt The prompt used in the LLM call.\n     * @param callbacks Optional callbacks.\n     * @returns A promise of the parsed output.\n     */\n    parseResultWithPrompt(generations, _prompt, callbacks) {\n        return this.parseResult(generations, callbacks);\n    }\n    _baseMessageToString(message) {\n        return typeof message.content === \"string\"\n            ? message.content\n            : this._baseMessageContentToString(message.content);\n    }\n    _baseMessageContentToString(content) {\n        return JSON.stringify(content);\n    }\n    /**\n     * Calls the parser with a given input and optional configuration options.\n     * If the input is a string, it creates a generation with the input as\n     * text and calls `parseResult`. If the input is a `BaseMessage`, it\n     * creates a generation with the input as a message and the content of the\n     * input as text, and then calls `parseResult`.\n     * @param input The input to the parser, which can be a string or a `BaseMessage`.\n     * @param options Optional configuration options.\n     * @returns A promise of the parsed output.\n     */\n    async invoke(input, options) {\n        if (typeof input === \"string\") {\n            return this._callWithConfig(async (input, options) => this.parseResult([{ text: input }], options?.callbacks), input, { ...options, runType: \"parser\" });\n        }\n        else {\n            return this._callWithConfig(async (input, options) => this.parseResult([\n                {\n                    message: input,\n                    text: this._baseMessageToString(input),\n                },\n            ], options?.callbacks), input, { ...options, runType: \"parser\" });\n        }\n    }\n}\nexports.BaseLLMOutputParser = BaseLLMOutputParser;\n/**\n * Class to parse the output of an LLM call.\n */\nclass BaseOutputParser extends BaseLLMOutputParser {\n    parseResult(generations, callbacks) {\n        return this.parse(generations[0].text, callbacks);\n    }\n    async parseWithPrompt(text, _prompt, callbacks) {\n        return this.parse(text, callbacks);\n    }\n    /**\n     * Return the string type key uniquely identifying this class of parser\n     */\n    _type() {\n        throw new Error(\"_type not implemented\");\n    }\n}\nexports.BaseOutputParser = BaseOutputParser;\n/**\n * Exception that output parsers should raise to signify a parsing error.\n *\n * This exists to differentiate parsing errors from other code or execution errors\n * that also may arise inside the output parser. OutputParserExceptions will be\n * available to catch and handle in ways to fix the parsing error, while other\n * errors will be raised.\n *\n * @param message - The error that's being re-raised or an error message.\n * @param llmOutput - String model output which is error-ing.\n * @param observation - String explanation of error which can be passed to a\n *     model to try and remediate the issue.\n * @param sendToLLM - Whether to send the observation and llm_output back to an Agent\n *     after an OutputParserException has been raised. This gives the underlying\n *     model driving the agent the context that the previous output was improperly\n *     structured, in the hopes that it will update the output to the correct\n *     format.\n */\nclass OutputParserException extends Error {\n    constructor(message, llmOutput, observation, sendToLLM = false) {\n        super(message);\n        Object.defineProperty(this, \"llmOutput\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"observation\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"sendToLLM\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.llmOutput = llmOutput;\n        this.observation = observation;\n        this.sendToLLM = sendToLLM;\n        if (sendToLLM) {\n            if (observation === undefined || llmOutput === undefined) {\n                throw new Error(\"Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true\");\n            }\n        }\n        (0, index_js_2.addLangChainErrorFields)(this, \"OUTPUT_PARSING_FAILURE\");\n    }\n}\nexports.OutputParserException = OutputParserException;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvYmFzZS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcsd0JBQXdCLEdBQUcsMkJBQTJCO0FBQ3RGLG1CQUFtQixtQkFBTyxDQUFDLDZGQUF3QjtBQUNuRCxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsYUFBYSxpQ0FBaUMsK0JBQStCO0FBQ25LO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiw2Q0FBNkMsK0JBQStCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9vdXRwdXRfcGFyc2Vycy9iYXNlLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT3V0cHV0UGFyc2VyRXhjZXB0aW9uID0gZXhwb3J0cy5CYXNlT3V0cHV0UGFyc2VyID0gZXhwb3J0cy5CYXNlTExNT3V0cHV0UGFyc2VyID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9ydW5uYWJsZXMvaW5kZXguY2pzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi9lcnJvcnMvaW5kZXguY2pzXCIpO1xuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBwYXJzaW5nIHRoZSBvdXRwdXQgb2YgYSBMYXJnZSBMYW5ndWFnZSBNb2RlbFxuICogKExMTSkgY2FsbC4gSXQgcHJvdmlkZXMgbWV0aG9kcyBmb3IgcGFyc2luZyB0aGUgcmVzdWx0IG9mIGFuIExMTSBjYWxsXG4gKiBhbmQgaW52b2tpbmcgdGhlIHBhcnNlciB3aXRoIGEgZ2l2ZW4gaW5wdXQuXG4gKi9cbmNsYXNzIEJhc2VMTE1PdXRwdXRQYXJzZXIgZXh0ZW5kcyBpbmRleF9qc18xLlJ1bm5hYmxlIHtcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIHJlc3VsdCBvZiBhbiBMTE0gY2FsbCB3aXRoIGEgZ2l2ZW4gcHJvbXB0LiBCeSBkZWZhdWx0LCBpdFxuICAgICAqIHNpbXBseSBjYWxscyBgcGFyc2VSZXN1bHRgLlxuICAgICAqIEBwYXJhbSBnZW5lcmF0aW9ucyBUaGUgZ2VuZXJhdGlvbnMgZnJvbSBhbiBMTE0gY2FsbC5cbiAgICAgKiBAcGFyYW0gX3Byb21wdCBUaGUgcHJvbXB0IHVzZWQgaW4gdGhlIExMTSBjYWxsLlxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgT3B0aW9uYWwgY2FsbGJhY2tzLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSBvZiB0aGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBwYXJzZVJlc3VsdFdpdGhQcm9tcHQoZ2VuZXJhdGlvbnMsIF9wcm9tcHQsIGNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVJlc3VsdChnZW5lcmF0aW9ucywgY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgX2Jhc2VNZXNzYWdlVG9TdHJpbmcobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgPyBtZXNzYWdlLmNvbnRlbnRcbiAgICAgICAgICAgIDogdGhpcy5fYmFzZU1lc3NhZ2VDb250ZW50VG9TdHJpbmcobWVzc2FnZS5jb250ZW50KTtcbiAgICB9XG4gICAgX2Jhc2VNZXNzYWdlQ29udGVudFRvU3RyaW5nKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgcGFyc2VyIHdpdGggYSBnaXZlbiBpbnB1dCBhbmQgb3B0aW9uYWwgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAqIElmIHRoZSBpbnB1dCBpcyBhIHN0cmluZywgaXQgY3JlYXRlcyBhIGdlbmVyYXRpb24gd2l0aCB0aGUgaW5wdXQgYXNcbiAgICAgKiB0ZXh0IGFuZCBjYWxscyBgcGFyc2VSZXN1bHRgLiBJZiB0aGUgaW5wdXQgaXMgYSBgQmFzZU1lc3NhZ2VgLCBpdFxuICAgICAqIGNyZWF0ZXMgYSBnZW5lcmF0aW9uIHdpdGggdGhlIGlucHV0IGFzIGEgbWVzc2FnZSBhbmQgdGhlIGNvbnRlbnQgb2YgdGhlXG4gICAgICogaW5wdXQgYXMgdGV4dCwgYW5kIHRoZW4gY2FsbHMgYHBhcnNlUmVzdWx0YC5cbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIHRoZSBwYXJzZXIsIHdoaWNoIGNhbiBiZSBhIHN0cmluZyBvciBhIGBCYXNlTWVzc2FnZWAuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSBvZiB0aGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxXaXRoQ29uZmlnKGFzeW5jIChpbnB1dCwgb3B0aW9ucykgPT4gdGhpcy5wYXJzZVJlc3VsdChbeyB0ZXh0OiBpbnB1dCB9XSwgb3B0aW9ucz8uY2FsbGJhY2tzKSwgaW5wdXQsIHsgLi4ub3B0aW9ucywgcnVuVHlwZTogXCJwYXJzZXJcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxsV2l0aENvbmZpZyhhc3luYyAoaW5wdXQsIG9wdGlvbnMpID0+IHRoaXMucGFyc2VSZXN1bHQoW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuX2Jhc2VNZXNzYWdlVG9TdHJpbmcoaW5wdXQpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLCBvcHRpb25zPy5jYWxsYmFja3MpLCBpbnB1dCwgeyAuLi5vcHRpb25zLCBydW5UeXBlOiBcInBhcnNlclwiIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlTExNT3V0cHV0UGFyc2VyID0gQmFzZUxMTU91dHB1dFBhcnNlcjtcbi8qKlxuICogQ2xhc3MgdG8gcGFyc2UgdGhlIG91dHB1dCBvZiBhbiBMTE0gY2FsbC5cbiAqL1xuY2xhc3MgQmFzZU91dHB1dFBhcnNlciBleHRlbmRzIEJhc2VMTE1PdXRwdXRQYXJzZXIge1xuICAgIHBhcnNlUmVzdWx0KGdlbmVyYXRpb25zLCBjYWxsYmFja3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2UoZ2VuZXJhdGlvbnNbMF0udGV4dCwgY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2VXaXRoUHJvbXB0KHRleHQsIF9wcm9tcHQsIGNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZSh0ZXh0LCBjYWxsYmFja3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHN0cmluZyB0eXBlIGtleSB1bmlxdWVseSBpZGVudGlmeWluZyB0aGlzIGNsYXNzIG9mIHBhcnNlclxuICAgICAqL1xuICAgIF90eXBlKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfdHlwZSBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlT3V0cHV0UGFyc2VyID0gQmFzZU91dHB1dFBhcnNlcjtcbi8qKlxuICogRXhjZXB0aW9uIHRoYXQgb3V0cHV0IHBhcnNlcnMgc2hvdWxkIHJhaXNlIHRvIHNpZ25pZnkgYSBwYXJzaW5nIGVycm9yLlxuICpcbiAqIFRoaXMgZXhpc3RzIHRvIGRpZmZlcmVudGlhdGUgcGFyc2luZyBlcnJvcnMgZnJvbSBvdGhlciBjb2RlIG9yIGV4ZWN1dGlvbiBlcnJvcnNcbiAqIHRoYXQgYWxzbyBtYXkgYXJpc2UgaW5zaWRlIHRoZSBvdXRwdXQgcGFyc2VyLiBPdXRwdXRQYXJzZXJFeGNlcHRpb25zIHdpbGwgYmVcbiAqIGF2YWlsYWJsZSB0byBjYXRjaCBhbmQgaGFuZGxlIGluIHdheXMgdG8gZml4IHRoZSBwYXJzaW5nIGVycm9yLCB3aGlsZSBvdGhlclxuICogZXJyb3JzIHdpbGwgYmUgcmFpc2VkLlxuICpcbiAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIGVycm9yIHRoYXQncyBiZWluZyByZS1yYWlzZWQgb3IgYW4gZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSBsbG1PdXRwdXQgLSBTdHJpbmcgbW9kZWwgb3V0cHV0IHdoaWNoIGlzIGVycm9yLWluZy5cbiAqIEBwYXJhbSBvYnNlcnZhdGlvbiAtIFN0cmluZyBleHBsYW5hdGlvbiBvZiBlcnJvciB3aGljaCBjYW4gYmUgcGFzc2VkIHRvIGFcbiAqICAgICBtb2RlbCB0byB0cnkgYW5kIHJlbWVkaWF0ZSB0aGUgaXNzdWUuXG4gKiBAcGFyYW0gc2VuZFRvTExNIC0gV2hldGhlciB0byBzZW5kIHRoZSBvYnNlcnZhdGlvbiBhbmQgbGxtX291dHB1dCBiYWNrIHRvIGFuIEFnZW50XG4gKiAgICAgYWZ0ZXIgYW4gT3V0cHV0UGFyc2VyRXhjZXB0aW9uIGhhcyBiZWVuIHJhaXNlZC4gVGhpcyBnaXZlcyB0aGUgdW5kZXJseWluZ1xuICogICAgIG1vZGVsIGRyaXZpbmcgdGhlIGFnZW50IHRoZSBjb250ZXh0IHRoYXQgdGhlIHByZXZpb3VzIG91dHB1dCB3YXMgaW1wcm9wZXJseVxuICogICAgIHN0cnVjdHVyZWQsIGluIHRoZSBob3BlcyB0aGF0IGl0IHdpbGwgdXBkYXRlIHRoZSBvdXRwdXQgdG8gdGhlIGNvcnJlY3RcbiAqICAgICBmb3JtYXQuXG4gKi9cbmNsYXNzIE91dHB1dFBhcnNlckV4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBsbG1PdXRwdXQsIG9ic2VydmF0aW9uLCBzZW5kVG9MTE0gPSBmYWxzZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGxtT3V0cHV0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9ic2VydmF0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlbmRUb0xMTVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxsbU91dHB1dCA9IGxsbU91dHB1dDtcbiAgICAgICAgdGhpcy5vYnNlcnZhdGlvbiA9IG9ic2VydmF0aW9uO1xuICAgICAgICB0aGlzLnNlbmRUb0xMTSA9IHNlbmRUb0xMTTtcbiAgICAgICAgaWYgKHNlbmRUb0xMTSkge1xuICAgICAgICAgICAgaWYgKG9ic2VydmF0aW9uID09PSB1bmRlZmluZWQgfHwgbGxtT3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudHMgJ29ic2VydmF0aW9uJyAmICdsbG1PdXRwdXQnIGFyZSByZXF1aXJlZCBpZiAnc2VuZFRvTGxtJyBpcyB0cnVlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18yLmFkZExhbmdDaGFpbkVycm9yRmllbGRzKSh0aGlzLCBcIk9VVFBVVF9QQVJTSU5HX0ZBSUxVUkVcIik7XG4gICAgfVxufVxuZXhwb3J0cy5PdXRwdXRQYXJzZXJFeGNlcHRpb24gPSBPdXRwdXRQYXJzZXJFeGNlcHRpb247XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/base.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/bytes.cjs":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/bytes.cjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BytesOutputParser = void 0;\nconst transform_js_1 = __webpack_require__(/*! ./transform.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.cjs\");\n/**\n * OutputParser that parses LLMResult into the top likely string and\n * encodes it into bytes.\n */\nclass BytesOutputParser extends transform_js_1.BaseTransformOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\", \"bytes\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"textEncoder\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new TextEncoder()\n        });\n    }\n    static lc_name() {\n        return \"BytesOutputParser\";\n    }\n    parse(text) {\n        return Promise.resolve(this.textEncoder.encode(text));\n    }\n    getFormatInstructions() {\n        return \"\";\n    }\n}\nexports.BytesOutputParser = BytesOutputParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvYnl0ZXMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6Qix1QkFBdUIsbUJBQU8sQ0FBQywrRkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvYnl0ZXMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CeXRlc091dHB1dFBhcnNlciA9IHZvaWQgMDtcbmNvbnN0IHRyYW5zZm9ybV9qc18xID0gcmVxdWlyZShcIi4vdHJhbnNmb3JtLmNqc1wiKTtcbi8qKlxuICogT3V0cHV0UGFyc2VyIHRoYXQgcGFyc2VzIExMTVJlc3VsdCBpbnRvIHRoZSB0b3AgbGlrZWx5IHN0cmluZyBhbmRcbiAqIGVuY29kZXMgaXQgaW50byBieXRlcy5cbiAqL1xuY2xhc3MgQnl0ZXNPdXRwdXRQYXJzZXIgZXh0ZW5kcyB0cmFuc2Zvcm1fanNfMS5CYXNlVHJhbnNmb3JtT3V0cHV0UGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcIm91dHB1dF9wYXJzZXJzXCIsIFwiYnl0ZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGV4dEVuY29kZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBUZXh0RW5jb2RlcigpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQnl0ZXNPdXRwdXRQYXJzZXJcIjtcbiAgICB9XG4gICAgcGFyc2UodGV4dCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMudGV4dEVuY29kZXIuZW5jb2RlKHRleHQpKTtcbiAgICB9XG4gICAgZ2V0Rm9ybWF0SW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG59XG5leHBvcnRzLkJ5dGVzT3V0cHV0UGFyc2VyID0gQnl0ZXNPdXRwdXRQYXJzZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/bytes.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/index.cjs":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/index.cjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/base.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./bytes.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/bytes.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./list.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/list.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./string.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/string.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./structured.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/structured.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./transform.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./json.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/json.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./xml.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/xml.cjs\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyxxRkFBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsdUZBQWE7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLHFGQUFZO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyx5RkFBYztBQUNuQyxhQUFhLG1CQUFPLENBQUMsaUdBQWtCO0FBQ3ZDLGFBQWEsbUJBQU8sQ0FBQywrRkFBaUI7QUFDdEMsYUFBYSxtQkFBTyxDQUFDLHFGQUFZO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxtRkFBVyIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L291dHB1dF9wYXJzZXJzL2luZGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2UuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ieXRlcy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xpc3QuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zdHJpbmcuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zdHJ1Y3R1cmVkLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHJhbnNmb3JtLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vanNvbi5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3htbC5janNcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/json.cjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/json.cjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseJsonMarkdown = exports.parsePartialJson = exports.JsonOutputParser = void 0;\nconst transform_js_1 = __webpack_require__(/*! ./transform.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.cjs\");\nconst json_patch_js_1 = __webpack_require__(/*! ../utils/json_patch.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_patch.cjs\");\nconst json_js_1 = __webpack_require__(/*! ../utils/json.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json.cjs\");\nObject.defineProperty(exports, \"parseJsonMarkdown\", ({ enumerable: true, get: function () { return json_js_1.parseJsonMarkdown; } }));\nObject.defineProperty(exports, \"parsePartialJson\", ({ enumerable: true, get: function () { return json_js_1.parsePartialJson; } }));\n/**\n * Class for parsing the output of an LLM into a JSON object.\n */\nclass JsonOutputParser extends transform_js_1.BaseCumulativeTransformOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    static lc_name() {\n        return \"JsonOutputParser\";\n    }\n    /** @internal */\n    _concatOutputChunks(first, second) {\n        if (this.diff) {\n            return super._concatOutputChunks(first, second);\n        }\n        return second;\n    }\n    _diff(prev, next) {\n        if (!next) {\n            return undefined;\n        }\n        if (!prev) {\n            return [{ op: \"replace\", path: \"\", value: next }];\n        }\n        return (0, json_patch_js_1.compare)(prev, next);\n    }\n    // This should actually return Partial<T>, but there's no way\n    // to specify emitted chunks as instances separate from the main output type.\n    async parsePartialResult(generations) {\n        return (0, json_js_1.parseJsonMarkdown)(generations[0].text);\n    }\n    async parse(text) {\n        return (0, json_js_1.parseJsonMarkdown)(text, JSON.parse);\n    }\n    getFormatInstructions() {\n        return \"\";\n    }\n}\nexports.JsonOutputParser = JsonOutputParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvanNvbi5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCLEdBQUcsd0JBQXdCLEdBQUcsd0JBQXdCO0FBQy9FLHVCQUF1QixtQkFBTyxDQUFDLCtGQUFpQjtBQUNoRCx3QkFBd0IsbUJBQU8sQ0FBQywrRkFBeUI7QUFDekQsa0JBQWtCLG1CQUFPLENBQUMsbUZBQW1CO0FBQzdDLHFEQUFvRCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUNuSSxvREFBbUQsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNDQUFzQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9vdXRwdXRfcGFyc2Vycy9qc29uLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VKc29uTWFya2Rvd24gPSBleHBvcnRzLnBhcnNlUGFydGlhbEpzb24gPSBleHBvcnRzLkpzb25PdXRwdXRQYXJzZXIgPSB2b2lkIDA7XG5jb25zdCB0cmFuc2Zvcm1fanNfMSA9IHJlcXVpcmUoXCIuL3RyYW5zZm9ybS5janNcIik7XG5jb25zdCBqc29uX3BhdGNoX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvanNvbl9wYXRjaC5janNcIik7XG5jb25zdCBqc29uX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvanNvbi5janNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZUpzb25NYXJrZG93blwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ganNvbl9qc18xLnBhcnNlSnNvbk1hcmtkb3duOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VQYXJ0aWFsSnNvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ganNvbl9qc18xLnBhcnNlUGFydGlhbEpzb247IH0gfSk7XG4vKipcbiAqIENsYXNzIGZvciBwYXJzaW5nIHRoZSBvdXRwdXQgb2YgYW4gTExNIGludG8gYSBKU09OIG9iamVjdC5cbiAqL1xuY2xhc3MgSnNvbk91dHB1dFBhcnNlciBleHRlbmRzIHRyYW5zZm9ybV9qc18xLkJhc2VDdW11bGF0aXZlVHJhbnNmb3JtT3V0cHV0UGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcIm91dHB1dF9wYXJzZXJzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJKc29uT3V0cHV0UGFyc2VyXCI7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfY29uY2F0T3V0cHV0Q2h1bmtzKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlmZikge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLl9jb25jYXRPdXRwdXRDaHVua3MoZmlyc3QsIHNlY29uZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlY29uZDtcbiAgICB9XG4gICAgX2RpZmYocHJldiwgbmV4dCkge1xuICAgICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcmV2KSB7XG4gICAgICAgICAgICByZXR1cm4gW3sgb3A6IFwicmVwbGFjZVwiLCBwYXRoOiBcIlwiLCB2YWx1ZTogbmV4dCB9XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGpzb25fcGF0Y2hfanNfMS5jb21wYXJlKShwcmV2LCBuZXh0KTtcbiAgICB9XG4gICAgLy8gVGhpcyBzaG91bGQgYWN0dWFsbHkgcmV0dXJuIFBhcnRpYWw8VD4sIGJ1dCB0aGVyZSdzIG5vIHdheVxuICAgIC8vIHRvIHNwZWNpZnkgZW1pdHRlZCBjaHVua3MgYXMgaW5zdGFuY2VzIHNlcGFyYXRlIGZyb20gdGhlIG1haW4gb3V0cHV0IHR5cGUuXG4gICAgYXN5bmMgcGFyc2VQYXJ0aWFsUmVzdWx0KGdlbmVyYXRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwganNvbl9qc18xLnBhcnNlSnNvbk1hcmtkb3duKShnZW5lcmF0aW9uc1swXS50ZXh0KTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2UodGV4dCkge1xuICAgICAgICByZXR1cm4gKDAsIGpzb25fanNfMS5wYXJzZUpzb25NYXJrZG93bikodGV4dCwgSlNPTi5wYXJzZSk7XG4gICAgfVxuICAgIGdldEZvcm1hdEluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxufVxuZXhwb3J0cy5Kc29uT3V0cHV0UGFyc2VyID0gSnNvbk91dHB1dFBhcnNlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/json.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/list.cjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/list.cjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MarkdownListOutputParser = exports.NumberedListOutputParser = exports.CustomListOutputParser = exports.CommaSeparatedListOutputParser = exports.ListOutputParser = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/base.cjs\");\nconst transform_js_1 = __webpack_require__(/*! ./transform.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.cjs\");\n/**\n * Class to parse the output of an LLM call to a list.\n * @augments BaseOutputParser\n */\nclass ListOutputParser extends transform_js_1.BaseTransformOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"re\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    async *_transform(inputGenerator) {\n        let buffer = \"\";\n        for await (const input of inputGenerator) {\n            if (typeof input === \"string\") {\n                // add current chunk to buffer\n                buffer += input;\n            }\n            else {\n                // extract message content and add to buffer\n                buffer += input.content;\n            }\n            // get parts in buffer\n            if (!this.re) {\n                const parts = await this.parse(buffer);\n                if (parts.length > 1) {\n                    // if there are multiple parts, yield all but the last one\n                    for (const part of parts.slice(0, -1)) {\n                        yield [part];\n                    }\n                    // keep the last part in the buffer\n                    buffer = parts[parts.length - 1];\n                }\n            }\n            else {\n                // if there is a regex, get all matches\n                const matches = [...buffer.matchAll(this.re)];\n                if (matches.length > 1) {\n                    let doneIdx = 0;\n                    // if there are multiple matches, yield all but the last one\n                    for (const match of matches.slice(0, -1)) {\n                        yield [match[1]];\n                        doneIdx += (match.index ?? 0) + match[0].length;\n                    }\n                    // keep the last match in the buffer\n                    buffer = buffer.slice(doneIdx);\n                }\n            }\n        }\n        // yield the last part\n        for (const part of await this.parse(buffer)) {\n            yield [part];\n        }\n    }\n}\nexports.ListOutputParser = ListOutputParser;\n/**\n * Class to parse the output of an LLM call as a comma-separated list.\n * @augments ListOutputParser\n */\nclass CommaSeparatedListOutputParser extends ListOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\", \"list\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    static lc_name() {\n        return \"CommaSeparatedListOutputParser\";\n    }\n    /**\n     * Parses the given text into an array of strings, using a comma as the\n     * separator. If the parsing fails, throws an OutputParserException.\n     * @param text The text to parse.\n     * @returns An array of strings obtained by splitting the input text at each comma.\n     */\n    async parse(text) {\n        try {\n            return text\n                .trim()\n                .split(\",\")\n                .map((s) => s.trim());\n        }\n        catch (e) {\n            throw new base_js_1.OutputParserException(`Could not parse output: ${text}`, text);\n        }\n    }\n    /**\n     * Provides instructions on the expected format of the response for the\n     * CommaSeparatedListOutputParser.\n     * @returns A string containing instructions on the expected format of the response.\n     */\n    getFormatInstructions() {\n        return `Your response should be a list of comma separated values, eg: \\`foo, bar, baz\\``;\n    }\n}\nexports.CommaSeparatedListOutputParser = CommaSeparatedListOutputParser;\n/**\n * Class to parse the output of an LLM call to a list with a specific length and separator.\n * @augments ListOutputParser\n */\nclass CustomListOutputParser extends ListOutputParser {\n    constructor({ length, separator }) {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\", \"list\"]\n        });\n        Object.defineProperty(this, \"length\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"separator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.length = length;\n        this.separator = separator || \",\";\n    }\n    /**\n     * Parses the given text into an array of strings, using the specified\n     * separator. If the parsing fails or the number of items in the list\n     * doesn't match the expected length, throws an OutputParserException.\n     * @param text The text to parse.\n     * @returns An array of strings obtained by splitting the input text at each occurrence of the specified separator.\n     */\n    async parse(text) {\n        try {\n            const items = text\n                .trim()\n                .split(this.separator)\n                .map((s) => s.trim());\n            if (this.length !== undefined && items.length !== this.length) {\n                throw new base_js_1.OutputParserException(`Incorrect number of items. Expected ${this.length}, got ${items.length}.`);\n            }\n            return items;\n        }\n        catch (e) {\n            if (Object.getPrototypeOf(e) === base_js_1.OutputParserException.prototype) {\n                throw e;\n            }\n            throw new base_js_1.OutputParserException(`Could not parse output: ${text}`);\n        }\n    }\n    /**\n     * Provides instructions on the expected format of the response for the\n     * CustomListOutputParser, including the number of items and the\n     * separator.\n     * @returns A string containing instructions on the expected format of the response.\n     */\n    getFormatInstructions() {\n        return `Your response should be a list of ${this.length === undefined ? \"\" : `${this.length} `}items separated by \"${this.separator}\" (eg: \\`foo${this.separator} bar${this.separator} baz\\`)`;\n    }\n}\nexports.CustomListOutputParser = CustomListOutputParser;\nclass NumberedListOutputParser extends ListOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\", \"list\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"re\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: /\\d+\\.\\s([^\\n]+)/g\n        });\n    }\n    static lc_name() {\n        return \"NumberedListOutputParser\";\n    }\n    getFormatInstructions() {\n        return `Your response should be a numbered list with each item on a new line. For example: \\n\\n1. foo\\n\\n2. bar\\n\\n3. baz`;\n    }\n    async parse(text) {\n        return [...(text.matchAll(this.re) ?? [])].map((m) => m[1]);\n    }\n}\nexports.NumberedListOutputParser = NumberedListOutputParser;\nclass MarkdownListOutputParser extends ListOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\", \"list\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"re\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: /^\\s*[-*]\\s([^\\n]+)$/gm\n        });\n    }\n    static lc_name() {\n        return \"NumberedListOutputParser\";\n    }\n    getFormatInstructions() {\n        return `Your response should be a numbered list with each item on a new line. For example: \\n\\n1. foo\\n\\n2. bar\\n\\n3. baz`;\n    }\n    async parse(text) {\n        return [...(text.matchAll(this.re) ?? [])].map((m) => m[1]);\n    }\n}\nexports.MarkdownListOutputParser = MarkdownListOutputParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvbGlzdC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDLEdBQUcsZ0NBQWdDLEdBQUcsOEJBQThCLEdBQUcsc0NBQXNDLEdBQUcsd0JBQXdCO0FBQ3hLLGtCQUFrQixtQkFBTyxDQUFDLHFGQUFZO0FBQ3RDLHVCQUF1QixtQkFBTyxDQUFDLCtGQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixLQUFLO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLFlBQVksUUFBUSxhQUFhO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLEtBQUs7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELG9DQUFvQyxhQUFhLEVBQUUsc0JBQXNCLGVBQWUsY0FBYyxnQkFBZ0IsS0FBSyxnQkFBZ0I7QUFDL0w7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9vdXRwdXRfcGFyc2Vycy9saXN0LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFya2Rvd25MaXN0T3V0cHV0UGFyc2VyID0gZXhwb3J0cy5OdW1iZXJlZExpc3RPdXRwdXRQYXJzZXIgPSBleHBvcnRzLkN1c3RvbUxpc3RPdXRwdXRQYXJzZXIgPSBleHBvcnRzLkNvbW1hU2VwYXJhdGVkTGlzdE91dHB1dFBhcnNlciA9IGV4cG9ydHMuTGlzdE91dHB1dFBhcnNlciA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2UuY2pzXCIpO1xuY29uc3QgdHJhbnNmb3JtX2pzXzEgPSByZXF1aXJlKFwiLi90cmFuc2Zvcm0uY2pzXCIpO1xuLyoqXG4gKiBDbGFzcyB0byBwYXJzZSB0aGUgb3V0cHV0IG9mIGFuIExMTSBjYWxsIHRvIGEgbGlzdC5cbiAqIEBhdWdtZW50cyBCYXNlT3V0cHV0UGFyc2VyXG4gKi9cbmNsYXNzIExpc3RPdXRwdXRQYXJzZXIgZXh0ZW5kcyB0cmFuc2Zvcm1fanNfMS5CYXNlVHJhbnNmb3JtT3V0cHV0UGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgKl90cmFuc2Zvcm0oaW5wdXRHZW5lcmF0b3IpIHtcbiAgICAgICAgbGV0IGJ1ZmZlciA9IFwiXCI7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgaW5wdXQgb2YgaW5wdXRHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBhZGQgY3VycmVudCBjaHVuayB0byBidWZmZXJcbiAgICAgICAgICAgICAgICBidWZmZXIgKz0gaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBleHRyYWN0IG1lc3NhZ2UgY29udGVudCBhbmQgYWRkIHRvIGJ1ZmZlclxuICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBpbnB1dC5jb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZ2V0IHBhcnRzIGluIGJ1ZmZlclxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBhd2FpdCB0aGlzLnBhcnNlKGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG11bHRpcGxlIHBhcnRzLCB5aWVsZCBhbGwgYnV0IHRoZSBsYXN0IG9uZVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMuc2xpY2UoMCwgLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBbcGFydF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCB0aGUgbGFzdCBwYXJ0IGluIHRoZSBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSByZWdleCwgZ2V0IGFsbCBtYXRjaGVzXG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IFsuLi5idWZmZXIubWF0Y2hBbGwodGhpcy5yZSldO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRvbmVJZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgbWF0Y2hlcywgeWllbGQgYWxsIGJ1dCB0aGUgbGFzdCBvbmVcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBtYXRjaCBvZiBtYXRjaGVzLnNsaWNlKDAsIC0xKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgW21hdGNoWzFdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmVJZHggKz0gKG1hdGNoLmluZGV4ID8/IDApICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgdGhlIGxhc3QgbWF0Y2ggaW4gdGhlIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoZG9uZUlkeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHlpZWxkIHRoZSBsYXN0IHBhcnRcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIGF3YWl0IHRoaXMucGFyc2UoYnVmZmVyKSkge1xuICAgICAgICAgICAgeWllbGQgW3BhcnRdO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MaXN0T3V0cHV0UGFyc2VyID0gTGlzdE91dHB1dFBhcnNlcjtcbi8qKlxuICogQ2xhc3MgdG8gcGFyc2UgdGhlIG91dHB1dCBvZiBhbiBMTE0gY2FsbCBhcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0LlxuICogQGF1Z21lbnRzIExpc3RPdXRwdXRQYXJzZXJcbiAqL1xuY2xhc3MgQ29tbWFTZXBhcmF0ZWRMaXN0T3V0cHV0UGFyc2VyIGV4dGVuZHMgTGlzdE91dHB1dFBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJvdXRwdXRfcGFyc2Vyc1wiLCBcImxpc3RcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkNvbW1hU2VwYXJhdGVkTGlzdE91dHB1dFBhcnNlclwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIGdpdmVuIHRleHQgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzLCB1c2luZyBhIGNvbW1hIGFzIHRoZVxuICAgICAqIHNlcGFyYXRvci4gSWYgdGhlIHBhcnNpbmcgZmFpbHMsIHRocm93cyBhbiBPdXRwdXRQYXJzZXJFeGNlcHRpb24uXG4gICAgICogQHBhcmFtIHRleHQgVGhlIHRleHQgdG8gcGFyc2UuXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2Ygc3RyaW5ncyBvYnRhaW5lZCBieSBzcGxpdHRpbmcgdGhlIGlucHV0IHRleHQgYXQgZWFjaCBjb21tYS5cbiAgICAgKi9cbiAgICBhc3luYyBwYXJzZSh0ZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dFxuICAgICAgICAgICAgICAgIC50cmltKClcbiAgICAgICAgICAgICAgICAuc3BsaXQoXCIsXCIpXG4gICAgICAgICAgICAgICAgLm1hcCgocykgPT4gcy50cmltKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgYmFzZV9qc18xLk91dHB1dFBhcnNlckV4Y2VwdGlvbihgQ291bGQgbm90IHBhcnNlIG91dHB1dDogJHt0ZXh0fWAsIHRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGluc3RydWN0aW9ucyBvbiB0aGUgZXhwZWN0ZWQgZm9ybWF0IG9mIHRoZSByZXNwb25zZSBmb3IgdGhlXG4gICAgICogQ29tbWFTZXBhcmF0ZWRMaXN0T3V0cHV0UGFyc2VyLlxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIGNvbnRhaW5pbmcgaW5zdHJ1Y3Rpb25zIG9uIHRoZSBleHBlY3RlZCBmb3JtYXQgb2YgdGhlIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIGdldEZvcm1hdEluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIGBZb3VyIHJlc3BvbnNlIHNob3VsZCBiZSBhIGxpc3Qgb2YgY29tbWEgc2VwYXJhdGVkIHZhbHVlcywgZWc6IFxcYGZvbywgYmFyLCBiYXpcXGBgO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29tbWFTZXBhcmF0ZWRMaXN0T3V0cHV0UGFyc2VyID0gQ29tbWFTZXBhcmF0ZWRMaXN0T3V0cHV0UGFyc2VyO1xuLyoqXG4gKiBDbGFzcyB0byBwYXJzZSB0aGUgb3V0cHV0IG9mIGFuIExMTSBjYWxsIHRvIGEgbGlzdCB3aXRoIGEgc3BlY2lmaWMgbGVuZ3RoIGFuZCBzZXBhcmF0b3IuXG4gKiBAYXVnbWVudHMgTGlzdE91dHB1dFBhcnNlclxuICovXG5jbGFzcyBDdXN0b21MaXN0T3V0cHV0UGFyc2VyIGV4dGVuZHMgTGlzdE91dHB1dFBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoeyBsZW5ndGgsIHNlcGFyYXRvciB9KSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJvdXRwdXRfcGFyc2Vyc1wiLCBcImxpc3RcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxlbmd0aFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXBhcmF0b3JcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuc2VwYXJhdG9yID0gc2VwYXJhdG9yIHx8IFwiLFwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIGdpdmVuIHRleHQgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzLCB1c2luZyB0aGUgc3BlY2lmaWVkXG4gICAgICogc2VwYXJhdG9yLiBJZiB0aGUgcGFyc2luZyBmYWlscyBvciB0aGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBsaXN0XG4gICAgICogZG9lc24ndCBtYXRjaCB0aGUgZXhwZWN0ZWQgbGVuZ3RoLCB0aHJvd3MgYW4gT3V0cHV0UGFyc2VyRXhjZXB0aW9uLlxuICAgICAqIEBwYXJhbSB0ZXh0IFRoZSB0ZXh0IHRvIHBhcnNlLlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHN0cmluZ3Mgb2J0YWluZWQgYnkgc3BsaXR0aW5nIHRoZSBpbnB1dCB0ZXh0IGF0IGVhY2ggb2NjdXJyZW5jZSBvZiB0aGUgc3BlY2lmaWVkIHNlcGFyYXRvci5cbiAgICAgKi9cbiAgICBhc3luYyBwYXJzZSh0ZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IHRleHRcbiAgICAgICAgICAgICAgICAudHJpbSgpXG4gICAgICAgICAgICAgICAgLnNwbGl0KHRoaXMuc2VwYXJhdG9yKVxuICAgICAgICAgICAgICAgIC5tYXAoKHMpID0+IHMudHJpbSgpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIGl0ZW1zLmxlbmd0aCAhPT0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYmFzZV9qc18xLk91dHB1dFBhcnNlckV4Y2VwdGlvbihgSW5jb3JyZWN0IG51bWJlciBvZiBpdGVtcy4gRXhwZWN0ZWQgJHt0aGlzLmxlbmd0aH0sIGdvdCAke2l0ZW1zLmxlbmd0aH0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkgPT09IGJhc2VfanNfMS5PdXRwdXRQYXJzZXJFeGNlcHRpb24ucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBiYXNlX2pzXzEuT3V0cHV0UGFyc2VyRXhjZXB0aW9uKGBDb3VsZCBub3QgcGFyc2Ugb3V0cHV0OiAke3RleHR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgaW5zdHJ1Y3Rpb25zIG9uIHRoZSBleHBlY3RlZCBmb3JtYXQgb2YgdGhlIHJlc3BvbnNlIGZvciB0aGVcbiAgICAgKiBDdXN0b21MaXN0T3V0cHV0UGFyc2VyLCBpbmNsdWRpbmcgdGhlIG51bWJlciBvZiBpdGVtcyBhbmQgdGhlXG4gICAgICogc2VwYXJhdG9yLlxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIGNvbnRhaW5pbmcgaW5zdHJ1Y3Rpb25zIG9uIHRoZSBleHBlY3RlZCBmb3JtYXQgb2YgdGhlIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIGdldEZvcm1hdEluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIGBZb3VyIHJlc3BvbnNlIHNob3VsZCBiZSBhIGxpc3Qgb2YgJHt0aGlzLmxlbmd0aCA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IGAke3RoaXMubGVuZ3RofSBgfWl0ZW1zIHNlcGFyYXRlZCBieSBcIiR7dGhpcy5zZXBhcmF0b3J9XCIgKGVnOiBcXGBmb28ke3RoaXMuc2VwYXJhdG9yfSBiYXIke3RoaXMuc2VwYXJhdG9yfSBiYXpcXGApYDtcbiAgICB9XG59XG5leHBvcnRzLkN1c3RvbUxpc3RPdXRwdXRQYXJzZXIgPSBDdXN0b21MaXN0T3V0cHV0UGFyc2VyO1xuY2xhc3MgTnVtYmVyZWRMaXN0T3V0cHV0UGFyc2VyIGV4dGVuZHMgTGlzdE91dHB1dFBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJvdXRwdXRfcGFyc2Vyc1wiLCBcImxpc3RcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IC9cXGQrXFwuXFxzKFteXFxuXSspL2dcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJOdW1iZXJlZExpc3RPdXRwdXRQYXJzZXJcIjtcbiAgICB9XG4gICAgZ2V0Rm9ybWF0SW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gYFlvdXIgcmVzcG9uc2Ugc2hvdWxkIGJlIGEgbnVtYmVyZWQgbGlzdCB3aXRoIGVhY2ggaXRlbSBvbiBhIG5ldyBsaW5lLiBGb3IgZXhhbXBsZTogXFxuXFxuMS4gZm9vXFxuXFxuMi4gYmFyXFxuXFxuMy4gYmF6YDtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2UodGV4dCkge1xuICAgICAgICByZXR1cm4gWy4uLih0ZXh0Lm1hdGNoQWxsKHRoaXMucmUpID8/IFtdKV0ubWFwKChtKSA9PiBtWzFdKTtcbiAgICB9XG59XG5leHBvcnRzLk51bWJlcmVkTGlzdE91dHB1dFBhcnNlciA9IE51bWJlcmVkTGlzdE91dHB1dFBhcnNlcjtcbmNsYXNzIE1hcmtkb3duTGlzdE91dHB1dFBhcnNlciBleHRlbmRzIExpc3RPdXRwdXRQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwib3V0cHV0X3BhcnNlcnNcIiwgXCJsaXN0XCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAvXlxccypbLSpdXFxzKFteXFxuXSspJC9nbVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIk51bWJlcmVkTGlzdE91dHB1dFBhcnNlclwiO1xuICAgIH1cbiAgICBnZXRGb3JtYXRJbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBgWW91ciByZXNwb25zZSBzaG91bGQgYmUgYSBudW1iZXJlZCBsaXN0IHdpdGggZWFjaCBpdGVtIG9uIGEgbmV3IGxpbmUuIEZvciBleGFtcGxlOiBcXG5cXG4xLiBmb29cXG5cXG4yLiBiYXJcXG5cXG4zLiBiYXpgO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBbLi4uKHRleHQubWF0Y2hBbGwodGhpcy5yZSkgPz8gW10pXS5tYXAoKG0pID0+IG1bMV0pO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFya2Rvd25MaXN0T3V0cHV0UGFyc2VyID0gTWFya2Rvd25MaXN0T3V0cHV0UGFyc2VyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/list.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/openai_tools/index.cjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/openai_tools/index.cjs ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./json_output_tools_parsers.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/openai_tools/json_output_tools_parsers.cjs\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvb3BlbmFpX3Rvb2xzL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsNElBQWlDIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvb3BlbmFpX3Rvb2xzL2luZGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2pzb25fb3V0cHV0X3Rvb2xzX3BhcnNlcnMuY2pzXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/openai_tools/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/openai_tools/json_output_tools_parsers.cjs":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/openai_tools/json_output_tools_parsers.cjs ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JsonOutputKeyToolsParser = exports.JsonOutputToolsParser = void 0;\nexports.parseToolCall = parseToolCall;\nexports.convertLangChainToolCallToOpenAI = convertLangChainToolCallToOpenAI;\nexports.makeInvalidToolCall = makeInvalidToolCall;\nconst base_js_1 = __webpack_require__(/*! ../base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/base.cjs\");\nconst json_js_1 = __webpack_require__(/*! ../json.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/json.cjs\");\nconst transform_js_1 = __webpack_require__(/*! ../transform.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.cjs\");\nconst ai_js_1 = __webpack_require__(/*! ../../messages/ai.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/ai.cjs\");\nconst zod_js_1 = __webpack_require__(/*! ../../utils/types/zod.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.cjs\");\nfunction parseToolCall(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nrawToolCall, options) {\n    if (rawToolCall.function === undefined) {\n        return undefined;\n    }\n    let functionArgs;\n    if (options?.partial) {\n        try {\n            functionArgs = (0, json_js_1.parsePartialJson)(rawToolCall.function.arguments ?? \"{}\");\n        }\n        catch (e) {\n            return undefined;\n        }\n    }\n    else {\n        try {\n            functionArgs = JSON.parse(rawToolCall.function.arguments);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            throw new base_js_1.OutputParserException([\n                `Function \"${rawToolCall.function.name}\" arguments:`,\n                ``,\n                rawToolCall.function.arguments,\n                ``,\n                `are not valid JSON.`,\n                `Error: ${e.message}`,\n            ].join(\"\\n\"));\n        }\n    }\n    const parsedToolCall = {\n        name: rawToolCall.function.name,\n        args: functionArgs,\n        type: \"tool_call\",\n    };\n    if (options?.returnId) {\n        parsedToolCall.id = rawToolCall.id;\n    }\n    return parsedToolCall;\n}\nfunction convertLangChainToolCallToOpenAI(toolCall) {\n    if (toolCall.id === undefined) {\n        throw new Error(`All OpenAI tool calls must have an \"id\" field.`);\n    }\n    return {\n        id: toolCall.id,\n        type: \"function\",\n        function: {\n            name: toolCall.name,\n            arguments: JSON.stringify(toolCall.args),\n        },\n    };\n}\nfunction makeInvalidToolCall(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nrawToolCall, errorMsg) {\n    return {\n        name: rawToolCall.function?.name,\n        args: rawToolCall.function?.arguments,\n        id: rawToolCall.id,\n        error: errorMsg,\n        type: \"invalid_tool_call\",\n    };\n}\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object.\n */\nclass JsonOutputToolsParser extends transform_js_1.BaseCumulativeTransformOutputParser {\n    static lc_name() {\n        return \"JsonOutputToolsParser\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"returnId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"openai_tools\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.returnId = fields?.returnId ?? this.returnId;\n    }\n    _diff() {\n        throw new Error(\"Not supported.\");\n    }\n    async parse() {\n        throw new Error(\"Not implemented.\");\n    }\n    async parseResult(generations) {\n        const result = await this.parsePartialResult(generations, false);\n        return result;\n    }\n    /**\n     * Parses the output and returns a JSON object. If `argsOnly` is true,\n     * only the arguments of the function call are returned.\n     * @param generations The output of the LLM to parse.\n     * @returns A JSON object representation of the function call or its arguments.\n     */\n    async parsePartialResult(generations, partial = true\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        const message = generations[0].message;\n        let toolCalls;\n        if ((0, ai_js_1.isAIMessage)(message) && message.tool_calls?.length) {\n            toolCalls = message.tool_calls.map((toolCall) => {\n                const { id, ...rest } = toolCall;\n                if (!this.returnId) {\n                    return rest;\n                }\n                return {\n                    id,\n                    ...rest,\n                };\n            });\n        }\n        else if (message.additional_kwargs.tool_calls !== undefined) {\n            const rawToolCalls = JSON.parse(JSON.stringify(message.additional_kwargs.tool_calls));\n            toolCalls = rawToolCalls.map((rawToolCall) => {\n                return parseToolCall(rawToolCall, { returnId: this.returnId, partial });\n            });\n        }\n        if (!toolCalls) {\n            return [];\n        }\n        const parsedToolCalls = [];\n        for (const toolCall of toolCalls) {\n            if (toolCall !== undefined) {\n                const backwardsCompatibleToolCall = {\n                    type: toolCall.name,\n                    args: toolCall.args,\n                    id: toolCall.id,\n                };\n                parsedToolCalls.push(backwardsCompatibleToolCall);\n            }\n        }\n        return parsedToolCalls;\n    }\n}\nexports.JsonOutputToolsParser = JsonOutputToolsParser;\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object if you are\n * expecting only a single tool to be called.\n */\nclass JsonOutputKeyToolsParser extends JsonOutputToolsParser {\n    static lc_name() {\n        return \"JsonOutputKeyToolsParser\";\n    }\n    constructor(params) {\n        super(params);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"openai_tools\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"returnId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        /** The type of tool calls to return. */\n        Object.defineProperty(this, \"keyName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Whether to return only the first tool call. */\n        Object.defineProperty(this, \"returnSingle\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"zodSchema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.keyName = params.keyName;\n        this.returnSingle = params.returnSingle ?? this.returnSingle;\n        this.zodSchema = params.zodSchema;\n    }\n    async _validateResult(result) {\n        if (this.zodSchema === undefined) {\n            return result;\n        }\n        const zodParsedResult = await (0, zod_js_1.interopSafeParseAsync)(this.zodSchema, result);\n        if (zodParsedResult.success) {\n            return zodParsedResult.data;\n        }\n        else {\n            throw new base_js_1.OutputParserException(`Failed to parse. Text: \"${JSON.stringify(result, null, 2)}\". Error: ${JSON.stringify(zodParsedResult.error?.issues)}`, JSON.stringify(result, null, 2));\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async parsePartialResult(generations) {\n        const results = await super.parsePartialResult(generations);\n        const matchingResults = results.filter((result) => result.type === this.keyName);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let returnedValues = matchingResults;\n        if (!matchingResults.length) {\n            return undefined;\n        }\n        if (!this.returnId) {\n            returnedValues = matchingResults.map((result) => result.args);\n        }\n        if (this.returnSingle) {\n            return returnedValues[0];\n        }\n        return returnedValues;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async parseResult(generations) {\n        const results = await super.parsePartialResult(generations, false);\n        const matchingResults = results.filter((result) => result.type === this.keyName);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let returnedValues = matchingResults;\n        if (!matchingResults.length) {\n            return undefined;\n        }\n        if (!this.returnId) {\n            returnedValues = matchingResults.map((result) => result.args);\n        }\n        if (this.returnSingle) {\n            return this._validateResult(returnedValues[0]);\n        }\n        const toolCallResults = await Promise.all(returnedValues.map((value) => this._validateResult(value)));\n        return toolCallResults;\n    }\n}\nexports.JsonOutputKeyToolsParser = JsonOutputKeyToolsParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvb3BlbmFpX3Rvb2xzL2pzb25fb3V0cHV0X3Rvb2xzX3BhcnNlcnMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQyxHQUFHLDZCQUE2QjtBQUNoRSxxQkFBcUI7QUFDckIsd0NBQXdDO0FBQ3hDLDJCQUEyQjtBQUMzQixrQkFBa0IsbUJBQU8sQ0FBQyxzRkFBYTtBQUN2QyxrQkFBa0IsbUJBQU8sQ0FBQyxzRkFBYTtBQUN2Qyx1QkFBdUIsbUJBQU8sQ0FBQyxnR0FBa0I7QUFDakQsZ0JBQWdCLG1CQUFPLENBQUMsd0ZBQXVCO0FBQy9DLGlCQUFpQixtQkFBTyxDQUFDLGdHQUEyQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDBCQUEwQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtDQUFrQztBQUN0RixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLGdDQUFnQyxZQUFZLDhDQUE4QztBQUMzSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvb3BlbmFpX3Rvb2xzL2pzb25fb3V0cHV0X3Rvb2xzX3BhcnNlcnMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Kc29uT3V0cHV0S2V5VG9vbHNQYXJzZXIgPSBleHBvcnRzLkpzb25PdXRwdXRUb29sc1BhcnNlciA9IHZvaWQgMDtcbmV4cG9ydHMucGFyc2VUb29sQ2FsbCA9IHBhcnNlVG9vbENhbGw7XG5leHBvcnRzLmNvbnZlcnRMYW5nQ2hhaW5Ub29sQ2FsbFRvT3BlbkFJID0gY29udmVydExhbmdDaGFpblRvb2xDYWxsVG9PcGVuQUk7XG5leHBvcnRzLm1ha2VJbnZhbGlkVG9vbENhbGwgPSBtYWtlSW52YWxpZFRvb2xDYWxsO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4uL2Jhc2UuY2pzXCIpO1xuY29uc3QganNvbl9qc18xID0gcmVxdWlyZShcIi4uL2pzb24uY2pzXCIpO1xuY29uc3QgdHJhbnNmb3JtX2pzXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNmb3JtLmNqc1wiKTtcbmNvbnN0IGFpX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vbWVzc2FnZXMvYWkuY2pzXCIpO1xuY29uc3Qgem9kX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvdHlwZXMvem9kLmNqc1wiKTtcbmZ1bmN0aW9uIHBhcnNlVG9vbENhbGwoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxucmF3VG9vbENhbGwsIG9wdGlvbnMpIHtcbiAgICBpZiAocmF3VG9vbENhbGwuZnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgZnVuY3Rpb25BcmdzO1xuICAgIGlmIChvcHRpb25zPy5wYXJ0aWFsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmdW5jdGlvbkFyZ3MgPSAoMCwganNvbl9qc18xLnBhcnNlUGFydGlhbEpzb24pKHJhd1Rvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyA/PyBcInt9XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZnVuY3Rpb25BcmdzID0gSlNPTi5wYXJzZShyYXdUb29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGJhc2VfanNfMS5PdXRwdXRQYXJzZXJFeGNlcHRpb24oW1xuICAgICAgICAgICAgICAgIGBGdW5jdGlvbiBcIiR7cmF3VG9vbENhbGwuZnVuY3Rpb24ubmFtZX1cIiBhcmd1bWVudHM6YCxcbiAgICAgICAgICAgICAgICBgYCxcbiAgICAgICAgICAgICAgICByYXdUb29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgYGAsXG4gICAgICAgICAgICAgICAgYGFyZSBub3QgdmFsaWQgSlNPTi5gLFxuICAgICAgICAgICAgICAgIGBFcnJvcjogJHtlLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgIF0uam9pbihcIlxcblwiKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGFyc2VkVG9vbENhbGwgPSB7XG4gICAgICAgIG5hbWU6IHJhd1Rvb2xDYWxsLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgIGFyZ3M6IGZ1bmN0aW9uQXJncyxcbiAgICAgICAgdHlwZTogXCJ0b29sX2NhbGxcIixcbiAgICB9O1xuICAgIGlmIChvcHRpb25zPy5yZXR1cm5JZCkge1xuICAgICAgICBwYXJzZWRUb29sQ2FsbC5pZCA9IHJhd1Rvb2xDYWxsLmlkO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkVG9vbENhbGw7XG59XG5mdW5jdGlvbiBjb252ZXJ0TGFuZ0NoYWluVG9vbENhbGxUb09wZW5BSSh0b29sQ2FsbCkge1xuICAgIGlmICh0b29sQ2FsbC5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQWxsIE9wZW5BSSB0b29sIGNhbGxzIG11c3QgaGF2ZSBhbiBcImlkXCIgZmllbGQuYCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiB0b29sQ2FsbC5pZCxcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgbmFtZTogdG9vbENhbGwubmFtZSxcbiAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5zdHJpbmdpZnkodG9vbENhbGwuYXJncyksXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1ha2VJbnZhbGlkVG9vbENhbGwoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxucmF3VG9vbENhbGwsIGVycm9yTXNnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogcmF3VG9vbENhbGwuZnVuY3Rpb24/Lm5hbWUsXG4gICAgICAgIGFyZ3M6IHJhd1Rvb2xDYWxsLmZ1bmN0aW9uPy5hcmd1bWVudHMsXG4gICAgICAgIGlkOiByYXdUb29sQ2FsbC5pZCxcbiAgICAgICAgZXJyb3I6IGVycm9yTXNnLFxuICAgICAgICB0eXBlOiBcImludmFsaWRfdG9vbF9jYWxsXCIsXG4gICAgfTtcbn1cbi8qKlxuICogQ2xhc3MgZm9yIHBhcnNpbmcgdGhlIG91dHB1dCBvZiBhIHRvb2wtY2FsbGluZyBMTE0gaW50byBhIEpTT04gb2JqZWN0LlxuICovXG5jbGFzcyBKc29uT3V0cHV0VG9vbHNQYXJzZXIgZXh0ZW5kcyB0cmFuc2Zvcm1fanNfMS5CYXNlQ3VtdWxhdGl2ZVRyYW5zZm9ybU91dHB1dFBhcnNlciB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkpzb25PdXRwdXRUb29sc1BhcnNlclwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmV0dXJuSWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpblwiLCBcIm91dHB1dF9wYXJzZXJzXCIsIFwib3BlbmFpX3Rvb2xzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmV0dXJuSWQgPSBmaWVsZHM/LnJldHVybklkID8/IHRoaXMucmV0dXJuSWQ7XG4gICAgfVxuICAgIF9kaWZmKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3Qgc3VwcG9ydGVkLlwiKTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2UoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlUmVzdWx0KGdlbmVyYXRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucGFyc2VQYXJ0aWFsUmVzdWx0KGdlbmVyYXRpb25zLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgb3V0cHV0IGFuZCByZXR1cm5zIGEgSlNPTiBvYmplY3QuIElmIGBhcmdzT25seWAgaXMgdHJ1ZSxcbiAgICAgKiBvbmx5IHRoZSBhcmd1bWVudHMgb2YgdGhlIGZ1bmN0aW9uIGNhbGwgYXJlIHJldHVybmVkLlxuICAgICAqIEBwYXJhbSBnZW5lcmF0aW9ucyBUaGUgb3V0cHV0IG9mIHRoZSBMTE0gdG8gcGFyc2UuXG4gICAgICogQHJldHVybnMgQSBKU09OIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZnVuY3Rpb24gY2FsbCBvciBpdHMgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGFzeW5jIHBhcnNlUGFydGlhbFJlc3VsdChnZW5lcmF0aW9ucywgcGFydGlhbCA9IHRydWVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2VuZXJhdGlvbnNbMF0ubWVzc2FnZTtcbiAgICAgICAgbGV0IHRvb2xDYWxscztcbiAgICAgICAgaWYgKCgwLCBhaV9qc18xLmlzQUlNZXNzYWdlKShtZXNzYWdlKSAmJiBtZXNzYWdlLnRvb2xfY2FsbHM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgdG9vbENhbGxzID0gbWVzc2FnZS50b29sX2NhbGxzLm1hcCgodG9vbENhbGwpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlkLCAuLi5yZXN0IH0gPSB0b29sQ2FsbDtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmV0dXJuSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXNzYWdlLmFkZGl0aW9uYWxfa3dhcmdzLnRvb2xfY2FsbHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcmF3VG9vbENhbGxzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShtZXNzYWdlLmFkZGl0aW9uYWxfa3dhcmdzLnRvb2xfY2FsbHMpKTtcbiAgICAgICAgICAgIHRvb2xDYWxscyA9IHJhd1Rvb2xDYWxscy5tYXAoKHJhd1Rvb2xDYWxsKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9vbENhbGwocmF3VG9vbENhbGwsIHsgcmV0dXJuSWQ6IHRoaXMucmV0dXJuSWQsIHBhcnRpYWwgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvb2xDYWxscykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFRvb2xDYWxscyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsIG9mIHRvb2xDYWxscykge1xuICAgICAgICAgICAgaWYgKHRvb2xDYWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYWNrd2FyZHNDb21wYXRpYmxlVG9vbENhbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHRvb2xDYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IHRvb2xDYWxsLmFyZ3MsXG4gICAgICAgICAgICAgICAgICAgIGlkOiB0b29sQ2FsbC5pZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBhcnNlZFRvb2xDYWxscy5wdXNoKGJhY2t3YXJkc0NvbXBhdGlibGVUb29sQ2FsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZFRvb2xDYWxscztcbiAgICB9XG59XG5leHBvcnRzLkpzb25PdXRwdXRUb29sc1BhcnNlciA9IEpzb25PdXRwdXRUb29sc1BhcnNlcjtcbi8qKlxuICogQ2xhc3MgZm9yIHBhcnNpbmcgdGhlIG91dHB1dCBvZiBhIHRvb2wtY2FsbGluZyBMTE0gaW50byBhIEpTT04gb2JqZWN0IGlmIHlvdSBhcmVcbiAqIGV4cGVjdGluZyBvbmx5IGEgc2luZ2xlIHRvb2wgdG8gYmUgY2FsbGVkLlxuICovXG5jbGFzcyBKc29uT3V0cHV0S2V5VG9vbHNQYXJzZXIgZXh0ZW5kcyBKc29uT3V0cHV0VG9vbHNQYXJzZXIge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJKc29uT3V0cHV0S2V5VG9vbHNQYXJzZXJcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIHN1cGVyKHBhcmFtcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluXCIsIFwib3V0cHV0X3BhcnNlcnNcIiwgXCJvcGVuYWlfdG9vbHNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmV0dXJuSWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogVGhlIHR5cGUgb2YgdG9vbCBjYWxscyB0byByZXR1cm4uICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImtleU5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIFdoZXRoZXIgdG8gcmV0dXJuIG9ubHkgdGhlIGZpcnN0IHRvb2wgY2FsbC4gKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmV0dXJuU2luZ2xlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiem9kU2NoZW1hXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMua2V5TmFtZSA9IHBhcmFtcy5rZXlOYW1lO1xuICAgICAgICB0aGlzLnJldHVyblNpbmdsZSA9IHBhcmFtcy5yZXR1cm5TaW5nbGUgPz8gdGhpcy5yZXR1cm5TaW5nbGU7XG4gICAgICAgIHRoaXMuem9kU2NoZW1hID0gcGFyYW1zLnpvZFNjaGVtYTtcbiAgICB9XG4gICAgYXN5bmMgX3ZhbGlkYXRlUmVzdWx0KHJlc3VsdCkge1xuICAgICAgICBpZiAodGhpcy56b2RTY2hlbWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB6b2RQYXJzZWRSZXN1bHQgPSBhd2FpdCAoMCwgem9kX2pzXzEuaW50ZXJvcFNhZmVQYXJzZUFzeW5jKSh0aGlzLnpvZFNjaGVtYSwgcmVzdWx0KTtcbiAgICAgICAgaWYgKHpvZFBhcnNlZFJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gem9kUGFyc2VkUmVzdWx0LmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgYmFzZV9qc18xLk91dHB1dFBhcnNlckV4Y2VwdGlvbihgRmFpbGVkIHRvIHBhcnNlLiBUZXh0OiBcIiR7SlNPTi5zdHJpbmdpZnkocmVzdWx0LCBudWxsLCAyKX1cIi4gRXJyb3I6ICR7SlNPTi5zdHJpbmdpZnkoem9kUGFyc2VkUmVzdWx0LmVycm9yPy5pc3N1ZXMpfWAsIEpTT04uc3RyaW5naWZ5KHJlc3VsdCwgbnVsbCwgMikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgYXN5bmMgcGFyc2VQYXJ0aWFsUmVzdWx0KGdlbmVyYXRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBzdXBlci5wYXJzZVBhcnRpYWxSZXN1bHQoZ2VuZXJhdGlvbnMpO1xuICAgICAgICBjb25zdCBtYXRjaGluZ1Jlc3VsdHMgPSByZXN1bHRzLmZpbHRlcigocmVzdWx0KSA9PiByZXN1bHQudHlwZSA9PT0gdGhpcy5rZXlOYW1lKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgbGV0IHJldHVybmVkVmFsdWVzID0gbWF0Y2hpbmdSZXN1bHRzO1xuICAgICAgICBpZiAoIW1hdGNoaW5nUmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnJldHVybklkKSB7XG4gICAgICAgICAgICByZXR1cm5lZFZhbHVlcyA9IG1hdGNoaW5nUmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4gcmVzdWx0LmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJldHVyblNpbmdsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHVybmVkVmFsdWVzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXR1cm5lZFZhbHVlcztcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBhc3luYyBwYXJzZVJlc3VsdChnZW5lcmF0aW9ucykge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgc3VwZXIucGFyc2VQYXJ0aWFsUmVzdWx0KGdlbmVyYXRpb25zLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nUmVzdWx0cyA9IHJlc3VsdHMuZmlsdGVyKChyZXN1bHQpID0+IHJlc3VsdC50eXBlID09PSB0aGlzLmtleU5hbWUpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBsZXQgcmV0dXJuZWRWYWx1ZXMgPSBtYXRjaGluZ1Jlc3VsdHM7XG4gICAgICAgIGlmICghbWF0Y2hpbmdSZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucmV0dXJuSWQpIHtcbiAgICAgICAgICAgIHJldHVybmVkVmFsdWVzID0gbWF0Y2hpbmdSZXN1bHRzLm1hcCgocmVzdWx0KSA9PiByZXN1bHQuYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmV0dXJuU2luZ2xlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsaWRhdGVSZXN1bHQocmV0dXJuZWRWYWx1ZXNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHJldHVybmVkVmFsdWVzLm1hcCgodmFsdWUpID0+IHRoaXMuX3ZhbGlkYXRlUmVzdWx0KHZhbHVlKSkpO1xuICAgICAgICByZXR1cm4gdG9vbENhbGxSZXN1bHRzO1xuICAgIH1cbn1cbmV4cG9ydHMuSnNvbk91dHB1dEtleVRvb2xzUGFyc2VyID0gSnNvbk91dHB1dEtleVRvb2xzUGFyc2VyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/openai_tools/json_output_tools_parsers.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/string.cjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/string.cjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StringOutputParser = void 0;\nconst transform_js_1 = __webpack_require__(/*! ./transform.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.cjs\");\n/**\n * OutputParser that parses LLMResult into the top likely string.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n *\n * const chain = RunnableSequence.from([\n *   promptTemplate,\n *   new ChatOpenAI({ model: \"gpt-4o-mini\" }),\n *   new StringOutputParser(),\n * ]);\n *\n * const result = await chain.invoke({ topic: \"bears\" });\n * console.log(\"What do you call a bear with no teeth? A gummy bear!\");\n * ```\n */\nclass StringOutputParser extends transform_js_1.BaseTransformOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\", \"string\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    static lc_name() {\n        return \"StrOutputParser\";\n    }\n    /**\n     * Parses a string output from an LLM call. This method is meant to be\n     * implemented by subclasses to define how a string output from an LLM\n     * should be parsed.\n     * @param text The string output from an LLM call.\n     * @param callbacks Optional callbacks.\n     * @returns A promise of the parsed output.\n     */\n    parse(text) {\n        return Promise.resolve(text);\n    }\n    getFormatInstructions() {\n        return \"\";\n    }\n    _textContentToString(content) {\n        return content.text;\n    }\n    _imageUrlContentToString(_content) {\n        throw new Error(`Cannot coerce a multimodal \"image_url\" message part into a string.`);\n    }\n    _messageContentComplexToString(content) {\n        switch (content.type) {\n            case \"text\":\n            case \"text_delta\":\n                if (\"text\" in content) {\n                    // Type guard for MessageContentText\n                    return this._textContentToString(content);\n                }\n                break;\n            case \"image_url\":\n                if (\"image_url\" in content) {\n                    // Type guard for MessageContentImageUrl\n                    return this._imageUrlContentToString(content);\n                }\n                break;\n            default:\n                throw new Error(`Cannot coerce \"${content.type}\" message part into a string.`);\n        }\n        throw new Error(`Invalid content type: ${content.type}`);\n    }\n    _baseMessageContentToString(content) {\n        return content.reduce((acc, item) => acc + this._messageContentComplexToString(item), \"\");\n    }\n}\nexports.StringOutputParser = StringOutputParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvc3RyaW5nLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUIsdUJBQXVCLG1CQUFPLENBQUMsK0ZBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdCQUFnQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsYUFBYTtBQUMvRDtBQUNBLGlEQUFpRCxhQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9vdXRwdXRfcGFyc2Vycy9zdHJpbmcuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdHJpbmdPdXRwdXRQYXJzZXIgPSB2b2lkIDA7XG5jb25zdCB0cmFuc2Zvcm1fanNfMSA9IHJlcXVpcmUoXCIuL3RyYW5zZm9ybS5janNcIik7XG4vKipcbiAqIE91dHB1dFBhcnNlciB0aGF0IHBhcnNlcyBMTE1SZXN1bHQgaW50byB0aGUgdG9wIGxpa2VseSBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgcHJvbXB0VGVtcGxhdGUgPSBQcm9tcHRUZW1wbGF0ZS5mcm9tVGVtcGxhdGUoXG4gKiAgIFwiVGVsbCBtZSBhIGpva2UgYWJvdXQge3RvcGljfVwiLFxuICogKTtcbiAqXG4gKiBjb25zdCBjaGFpbiA9IFJ1bm5hYmxlU2VxdWVuY2UuZnJvbShbXG4gKiAgIHByb21wdFRlbXBsYXRlLFxuICogICBuZXcgQ2hhdE9wZW5BSSh7IG1vZGVsOiBcImdwdC00by1taW5pXCIgfSksXG4gKiAgIG5ldyBTdHJpbmdPdXRwdXRQYXJzZXIoKSxcbiAqIF0pO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNoYWluLmludm9rZSh7IHRvcGljOiBcImJlYXJzXCIgfSk7XG4gKiBjb25zb2xlLmxvZyhcIldoYXQgZG8geW91IGNhbGwgYSBiZWFyIHdpdGggbm8gdGVldGg/IEEgZ3VtbXkgYmVhciFcIik7XG4gKiBgYGBcbiAqL1xuY2xhc3MgU3RyaW5nT3V0cHV0UGFyc2VyIGV4dGVuZHMgdHJhbnNmb3JtX2pzXzEuQmFzZVRyYW5zZm9ybU91dHB1dFBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJvdXRwdXRfcGFyc2Vyc1wiLCBcInN0cmluZ1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiU3RyT3V0cHV0UGFyc2VyXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIHN0cmluZyBvdXRwdXQgZnJvbSBhbiBMTE0gY2FsbC4gVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmVcbiAgICAgKiBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzIHRvIGRlZmluZSBob3cgYSBzdHJpbmcgb3V0cHV0IGZyb20gYW4gTExNXG4gICAgICogc2hvdWxkIGJlIHBhcnNlZC5cbiAgICAgKiBAcGFyYW0gdGV4dCBUaGUgc3RyaW5nIG91dHB1dCBmcm9tIGFuIExMTSBjYWxsLlxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgT3B0aW9uYWwgY2FsbGJhY2tzLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSBvZiB0aGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBwYXJzZSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGV4dCk7XG4gICAgfVxuICAgIGdldEZvcm1hdEluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIF90ZXh0Q29udGVudFRvU3RyaW5nKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQudGV4dDtcbiAgICB9XG4gICAgX2ltYWdlVXJsQ29udGVudFRvU3RyaW5nKF9jb250ZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvZXJjZSBhIG11bHRpbW9kYWwgXCJpbWFnZV91cmxcIiBtZXNzYWdlIHBhcnQgaW50byBhIHN0cmluZy5gKTtcbiAgICB9XG4gICAgX21lc3NhZ2VDb250ZW50Q29tcGxleFRvU3RyaW5nKGNvbnRlbnQpIHtcbiAgICAgICAgc3dpdGNoIChjb250ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgICBjYXNlIFwidGV4dF9kZWx0YVwiOlxuICAgICAgICAgICAgICAgIGlmIChcInRleHRcIiBpbiBjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFR5cGUgZ3VhcmQgZm9yIE1lc3NhZ2VDb250ZW50VGV4dFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dENvbnRlbnRUb1N0cmluZyhjb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaW1hZ2VfdXJsXCI6XG4gICAgICAgICAgICAgICAgaWYgKFwiaW1hZ2VfdXJsXCIgaW4gY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUeXBlIGd1YXJkIGZvciBNZXNzYWdlQ29udGVudEltYWdlVXJsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbWFnZVVybENvbnRlbnRUb1N0cmluZyhjb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvZXJjZSBcIiR7Y29udGVudC50eXBlfVwiIG1lc3NhZ2UgcGFydCBpbnRvIGEgc3RyaW5nLmApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb250ZW50IHR5cGU6ICR7Y29udGVudC50eXBlfWApO1xuICAgIH1cbiAgICBfYmFzZU1lc3NhZ2VDb250ZW50VG9TdHJpbmcoY29udGVudCkge1xuICAgICAgICByZXR1cm4gY29udGVudC5yZWR1Y2UoKGFjYywgaXRlbSkgPT4gYWNjICsgdGhpcy5fbWVzc2FnZUNvbnRlbnRDb21wbGV4VG9TdHJpbmcoaXRlbSksIFwiXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RyaW5nT3V0cHV0UGFyc2VyID0gU3RyaW5nT3V0cHV0UGFyc2VyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/string.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/structured.cjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/structured.cjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsymmetricStructuredOutputParser = exports.JsonMarkdownStructuredOutputParser = exports.StructuredOutputParser = void 0;\nconst v3_1 = __webpack_require__(/*! zod/v3 */ \"(rsc)/./node_modules/zod/v3/index.cjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/base.cjs\");\nconst zod_js_1 = __webpack_require__(/*! ../utils/types/zod.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.cjs\");\nconst json_schema_js_1 = __webpack_require__(/*! ../utils/json_schema.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_schema.cjs\");\nclass StructuredOutputParser extends base_js_1.BaseOutputParser {\n    static lc_name() {\n        return \"StructuredOutputParser\";\n    }\n    toJSON() {\n        return this.toJSONNotImplemented();\n    }\n    constructor(schema) {\n        super(schema);\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: schema\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"structured\"]\n        });\n    }\n    /**\n     * Creates a new StructuredOutputParser from a Zod schema.\n     * @param schema The Zod schema which the output should match\n     * @returns A new instance of StructuredOutputParser.\n     */\n    static fromZodSchema(schema) {\n        return new this(schema);\n    }\n    /**\n     * Creates a new StructuredOutputParser from a set of names and\n     * descriptions.\n     * @param schemas An object where each key is a name and each value is a description\n     * @returns A new instance of StructuredOutputParser.\n     */\n    static fromNamesAndDescriptions(schemas) {\n        const zodSchema = v3_1.z.object(Object.fromEntries(Object.entries(schemas).map(([name, description]) => [name, v3_1.z.string().describe(description)])));\n        return new this(zodSchema);\n    }\n    /**\n     * Returns a markdown code snippet with a JSON object formatted according\n     * to the schema.\n     * @param options Optional. The options for formatting the instructions\n     * @returns A markdown code snippet with a JSON object formatted according to the schema.\n     */\n    getFormatInstructions() {\n        return `You must format your output as a JSON value that adheres to a given \"JSON Schema\" instance.\n\n\"JSON Schema\" is a declarative language that allows you to annotate and validate JSON documents.\n\nFor example, the example \"JSON Schema\" instance {{\"properties\": {{\"foo\": {{\"description\": \"a list of test words\", \"type\": \"array\", \"items\": {{\"type\": \"string\"}}}}}}, \"required\": [\"foo\"]}}\nwould match an object with one required property, \"foo\". The \"type\" property specifies \"foo\" must be an \"array\", and the \"description\" property semantically describes it as \"a list of test words\". The items within \"foo\" must be strings.\nThus, the object {{\"foo\": [\"bar\", \"baz\"]}} is a well-formatted instance of this example \"JSON Schema\". The object {{\"properties\": {{\"foo\": [\"bar\", \"baz\"]}}}} is not well-formatted.\n\nYour output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!\n\nHere is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:\n\\`\\`\\`json\n${JSON.stringify((0, json_schema_js_1.toJsonSchema)(this.schema))}\n\\`\\`\\`\n`;\n    }\n    /**\n     * Parses the given text according to the schema.\n     * @param text The text to parse\n     * @returns The parsed output.\n     */\n    async parse(text) {\n        try {\n            const trimmedText = text.trim();\n            const json = \n            // first case: if back ticks appear at the start of the text\n            trimmedText.match(/^```(?:json)?\\s*([\\s\\S]*?)```/)?.[1] ||\n                // second case: if back ticks with `json` appear anywhere in the text\n                trimmedText.match(/```json\\s*([\\s\\S]*?)```/)?.[1] ||\n                // otherwise, return the trimmed text\n                trimmedText;\n            const escapedJson = json\n                .replace(/\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"/g, (_match, capturedGroup) => {\n                const escapedInsideQuotes = capturedGroup.replace(/\\n/g, \"\\\\n\");\n                return `\"${escapedInsideQuotes}\"`;\n            })\n                .replace(/\\n/g, \"\");\n            return await (0, zod_js_1.interopParseAsync)(this.schema, JSON.parse(escapedJson));\n        }\n        catch (e) {\n            throw new base_js_1.OutputParserException(`Failed to parse. Text: \"${text}\". Error: ${e}`, text);\n        }\n    }\n}\nexports.StructuredOutputParser = StructuredOutputParser;\n/**\n * A specific type of `StructuredOutputParser` that parses JSON data\n * formatted as a markdown code snippet.\n */\nclass JsonMarkdownStructuredOutputParser extends StructuredOutputParser {\n    static lc_name() {\n        return \"JsonMarkdownStructuredOutputParser\";\n    }\n    getFormatInstructions(options) {\n        const interpolationDepth = options?.interpolationDepth ?? 1;\n        if (interpolationDepth < 1) {\n            throw new Error(\"f string interpolation depth must be at least 1\");\n        }\n        return `Return a markdown code snippet with a JSON object formatted to look like:\\n\\`\\`\\`json\\n${this._schemaToInstruction((0, json_schema_js_1.toJsonSchema)(this.schema))\n            .replaceAll(\"{\", \"{\".repeat(interpolationDepth))\n            .replaceAll(\"}\", \"}\".repeat(interpolationDepth))}\\n\\`\\`\\``;\n    }\n    _schemaToInstruction(schemaInput, indent = 2) {\n        const schema = schemaInput;\n        if (\"type\" in schema) {\n            let nullable = false;\n            let type;\n            if (Array.isArray(schema.type)) {\n                const nullIdx = schema.type.findIndex((type) => type === \"null\");\n                if (nullIdx !== -1) {\n                    nullable = true;\n                    schema.type.splice(nullIdx, 1);\n                }\n                type = schema.type.join(\" | \");\n            }\n            else {\n                type = schema.type;\n            }\n            if (schema.type === \"object\" && schema.properties) {\n                const description = schema.description\n                    ? ` // ${schema.description}`\n                    : \"\";\n                const properties = Object.entries(schema.properties)\n                    .map(([key, value]) => {\n                    const isOptional = schema.required?.includes(key)\n                        ? \"\"\n                        : \" (optional)\";\n                    return `${\" \".repeat(indent)}\"${key}\": ${this._schemaToInstruction(value, indent + 2)}${isOptional}`;\n                })\n                    .join(\"\\n\");\n                return `{\\n${properties}\\n${\" \".repeat(indent - 2)}}${description}`;\n            }\n            if (schema.type === \"array\" && schema.items) {\n                const description = schema.description\n                    ? ` // ${schema.description}`\n                    : \"\";\n                return `array[\\n${\" \".repeat(indent)}${this._schemaToInstruction(schema.items, indent + 2)}\\n${\" \".repeat(indent - 2)}] ${description}`;\n            }\n            const isNullable = nullable ? \" (nullable)\" : \"\";\n            const description = schema.description ? ` // ${schema.description}` : \"\";\n            return `${type}${description}${isNullable}`;\n        }\n        if (\"anyOf\" in schema) {\n            return schema.anyOf\n                .map((s) => this._schemaToInstruction(s, indent))\n                .join(`\\n${\" \".repeat(indent - 2)}`);\n        }\n        throw new Error(\"unsupported schema type\");\n    }\n    static fromZodSchema(schema) {\n        return new this(schema);\n    }\n    static fromNamesAndDescriptions(schemas) {\n        const zodSchema = v3_1.z.object(Object.fromEntries(Object.entries(schemas).map(([name, description]) => [name, v3_1.z.string().describe(description)])));\n        return new this(zodSchema);\n    }\n}\nexports.JsonMarkdownStructuredOutputParser = JsonMarkdownStructuredOutputParser;\n/**\n * A type of `StructuredOutputParser` that handles asymmetric input and\n * output schemas.\n */\nclass AsymmetricStructuredOutputParser extends base_js_1.BaseOutputParser {\n    constructor({ inputSchema }) {\n        super(...arguments);\n        Object.defineProperty(this, \"structuredInputParser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.structuredInputParser = new JsonMarkdownStructuredOutputParser(inputSchema);\n    }\n    async parse(text) {\n        let parsedInput;\n        try {\n            parsedInput = await this.structuredInputParser.parse(text);\n        }\n        catch (e) {\n            throw new base_js_1.OutputParserException(`Failed to parse. Text: \"${text}\". Error: ${e}`, text);\n        }\n        return this.outputProcessor(parsedInput);\n    }\n    getFormatInstructions() {\n        return this.structuredInputParser.getFormatInstructions();\n    }\n}\nexports.AsymmetricStructuredOutputParser = AsymmetricStructuredOutputParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvc3RydWN0dXJlZC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0NBQXdDLEdBQUcsMENBQTBDLEdBQUcsOEJBQThCO0FBQ3RILGFBQWEsbUJBQU8sQ0FBQyxxREFBUTtBQUM3QixrQkFBa0IsbUJBQU8sQ0FBQyxxRkFBWTtBQUN0QyxpQkFBaUIsbUJBQU8sQ0FBQyw2RkFBd0I7QUFDakQseUJBQXlCLG1CQUFPLENBQUMsaUdBQTBCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0RBQWtELGdCQUFnQixTQUFTLG1FQUFtRSxzQkFBc0I7QUFDcEs7QUFDQSxtQkFBbUIsd0JBQXdCLHlFQUF5RSxnQkFBZ0IsMEJBQTBCOztBQUU5Sjs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0MsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLEtBQUssWUFBWSxFQUFFO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF5RztBQUN6RywwQkFBMEIsS0FBSztBQUMvQiwwQkFBMEIsS0FBSyw4QkFBOEI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtQkFBbUIsR0FBRyxJQUFJLEtBQUssNkNBQTZDLEVBQUUsV0FBVztBQUN2SCxpQkFBaUI7QUFDakI7QUFDQSx5QkFBeUIsSUFBSSxXQUFXLElBQUksd0JBQXdCLEVBQUUsWUFBWTtBQUNsRjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0Esa0NBQWtDLG1CQUFtQixFQUFFLG9EQUFvRCxJQUFJLHVCQUF1QixJQUFJLFlBQVk7QUFDdEo7QUFDQTtBQUNBLDREQUE0RCxtQkFBbUI7QUFDL0Usc0JBQXNCLEtBQUssRUFBRSxZQUFZLEVBQUUsV0FBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsS0FBSyxZQUFZLEVBQUU7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9vdXRwdXRfcGFyc2Vycy9zdHJ1Y3R1cmVkLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXN5bW1ldHJpY1N0cnVjdHVyZWRPdXRwdXRQYXJzZXIgPSBleHBvcnRzLkpzb25NYXJrZG93blN0cnVjdHVyZWRPdXRwdXRQYXJzZXIgPSBleHBvcnRzLlN0cnVjdHVyZWRPdXRwdXRQYXJzZXIgPSB2b2lkIDA7XG5jb25zdCB2M18xID0gcmVxdWlyZShcInpvZC92M1wiKTtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2UuY2pzXCIpO1xuY29uc3Qgem9kX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvdHlwZXMvem9kLmNqc1wiKTtcbmNvbnN0IGpzb25fc2NoZW1hX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvanNvbl9zY2hlbWEuY2pzXCIpO1xuY2xhc3MgU3RydWN0dXJlZE91dHB1dFBhcnNlciBleHRlbmRzIGJhc2VfanNfMS5CYXNlT3V0cHV0UGFyc2VyIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiU3RydWN0dXJlZE91dHB1dFBhcnNlclwiO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSlNPTk5vdEltcGxlbWVudGVkKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSkge1xuICAgICAgICBzdXBlcihzY2hlbWEpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzY2hlbWFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHNjaGVtYVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5cIiwgXCJvdXRwdXRfcGFyc2Vyc1wiLCBcInN0cnVjdHVyZWRcIl1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU3RydWN0dXJlZE91dHB1dFBhcnNlciBmcm9tIGEgWm9kIHNjaGVtYS5cbiAgICAgKiBAcGFyYW0gc2NoZW1hIFRoZSBab2Qgc2NoZW1hIHdoaWNoIHRoZSBvdXRwdXQgc2hvdWxkIG1hdGNoXG4gICAgICogQHJldHVybnMgQSBuZXcgaW5zdGFuY2Ugb2YgU3RydWN0dXJlZE91dHB1dFBhcnNlci5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVpvZFNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHNjaGVtYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU3RydWN0dXJlZE91dHB1dFBhcnNlciBmcm9tIGEgc2V0IG9mIG5hbWVzIGFuZFxuICAgICAqIGRlc2NyaXB0aW9ucy5cbiAgICAgKiBAcGFyYW0gc2NoZW1hcyBBbiBvYmplY3Qgd2hlcmUgZWFjaCBrZXkgaXMgYSBuYW1lIGFuZCBlYWNoIHZhbHVlIGlzIGEgZGVzY3JpcHRpb25cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBpbnN0YW5jZSBvZiBTdHJ1Y3R1cmVkT3V0cHV0UGFyc2VyLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTmFtZXNBbmREZXNjcmlwdGlvbnMoc2NoZW1hcykge1xuICAgICAgICBjb25zdCB6b2RTY2hlbWEgPSB2M18xLnoub2JqZWN0KE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhzY2hlbWFzKS5tYXAoKFtuYW1lLCBkZXNjcmlwdGlvbl0pID0+IFtuYW1lLCB2M18xLnouc3RyaW5nKCkuZGVzY3JpYmUoZGVzY3JpcHRpb24pXSkpKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHpvZFNjaGVtYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBtYXJrZG93biBjb2RlIHNuaXBwZXQgd2l0aCBhIEpTT04gb2JqZWN0IGZvcm1hdHRlZCBhY2NvcmRpbmdcbiAgICAgKiB0byB0aGUgc2NoZW1hLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsLiBUaGUgb3B0aW9ucyBmb3IgZm9ybWF0dGluZyB0aGUgaW5zdHJ1Y3Rpb25zXG4gICAgICogQHJldHVybnMgQSBtYXJrZG93biBjb2RlIHNuaXBwZXQgd2l0aCBhIEpTT04gb2JqZWN0IGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHNjaGVtYS5cbiAgICAgKi9cbiAgICBnZXRGb3JtYXRJbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBgWW91IG11c3QgZm9ybWF0IHlvdXIgb3V0cHV0IGFzIGEgSlNPTiB2YWx1ZSB0aGF0IGFkaGVyZXMgdG8gYSBnaXZlbiBcIkpTT04gU2NoZW1hXCIgaW5zdGFuY2UuXG5cblwiSlNPTiBTY2hlbWFcIiBpcyBhIGRlY2xhcmF0aXZlIGxhbmd1YWdlIHRoYXQgYWxsb3dzIHlvdSB0byBhbm5vdGF0ZSBhbmQgdmFsaWRhdGUgSlNPTiBkb2N1bWVudHMuXG5cbkZvciBleGFtcGxlLCB0aGUgZXhhbXBsZSBcIkpTT04gU2NoZW1hXCIgaW5zdGFuY2Uge3tcInByb3BlcnRpZXNcIjoge3tcImZvb1wiOiB7e1wiZGVzY3JpcHRpb25cIjogXCJhIGxpc3Qgb2YgdGVzdCB3b3Jkc1wiLCBcInR5cGVcIjogXCJhcnJheVwiLCBcIml0ZW1zXCI6IHt7XCJ0eXBlXCI6IFwic3RyaW5nXCJ9fX19fX0sIFwicmVxdWlyZWRcIjogW1wiZm9vXCJdfX1cbndvdWxkIG1hdGNoIGFuIG9iamVjdCB3aXRoIG9uZSByZXF1aXJlZCBwcm9wZXJ0eSwgXCJmb29cIi4gVGhlIFwidHlwZVwiIHByb3BlcnR5IHNwZWNpZmllcyBcImZvb1wiIG11c3QgYmUgYW4gXCJhcnJheVwiLCBhbmQgdGhlIFwiZGVzY3JpcHRpb25cIiBwcm9wZXJ0eSBzZW1hbnRpY2FsbHkgZGVzY3JpYmVzIGl0IGFzIFwiYSBsaXN0IG9mIHRlc3Qgd29yZHNcIi4gVGhlIGl0ZW1zIHdpdGhpbiBcImZvb1wiIG11c3QgYmUgc3RyaW5ncy5cblRodXMsIHRoZSBvYmplY3Qge3tcImZvb1wiOiBbXCJiYXJcIiwgXCJiYXpcIl19fSBpcyBhIHdlbGwtZm9ybWF0dGVkIGluc3RhbmNlIG9mIHRoaXMgZXhhbXBsZSBcIkpTT04gU2NoZW1hXCIuIFRoZSBvYmplY3Qge3tcInByb3BlcnRpZXNcIjoge3tcImZvb1wiOiBbXCJiYXJcIiwgXCJiYXpcIl19fX19IGlzIG5vdCB3ZWxsLWZvcm1hdHRlZC5cblxuWW91ciBvdXRwdXQgd2lsbCBiZSBwYXJzZWQgYW5kIHR5cGUtY2hlY2tlZCBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkIHNjaGVtYSBpbnN0YW5jZSwgc28gbWFrZSBzdXJlIGFsbCBmaWVsZHMgaW4geW91ciBvdXRwdXQgbWF0Y2ggdGhlIHNjaGVtYSBleGFjdGx5IGFuZCB0aGVyZSBhcmUgbm8gdHJhaWxpbmcgY29tbWFzIVxuXG5IZXJlIGlzIHRoZSBKU09OIFNjaGVtYSBpbnN0YW5jZSB5b3VyIG91dHB1dCBtdXN0IGFkaGVyZSB0by4gSW5jbHVkZSB0aGUgZW5jbG9zaW5nIG1hcmtkb3duIGNvZGVibG9jazpcblxcYFxcYFxcYGpzb25cbiR7SlNPTi5zdHJpbmdpZnkoKDAsIGpzb25fc2NoZW1hX2pzXzEudG9Kc29uU2NoZW1hKSh0aGlzLnNjaGVtYSkpfVxuXFxgXFxgXFxgXG5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIGdpdmVuIHRleHQgYWNjb3JkaW5nIHRvIHRoZSBzY2hlbWEuXG4gICAgICogQHBhcmFtIHRleHQgVGhlIHRleHQgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBhc3luYyBwYXJzZSh0ZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0cmltbWVkVGV4dCA9IHRleHQudHJpbSgpO1xuICAgICAgICAgICAgY29uc3QganNvbiA9IFxuICAgICAgICAgICAgLy8gZmlyc3QgY2FzZTogaWYgYmFjayB0aWNrcyBhcHBlYXIgYXQgdGhlIHN0YXJ0IG9mIHRoZSB0ZXh0XG4gICAgICAgICAgICB0cmltbWVkVGV4dC5tYXRjaCgvXmBgYCg/Ompzb24pP1xccyooW1xcc1xcU10qPylgYGAvKT8uWzFdIHx8XG4gICAgICAgICAgICAgICAgLy8gc2Vjb25kIGNhc2U6IGlmIGJhY2sgdGlja3Mgd2l0aCBganNvbmAgYXBwZWFyIGFueXdoZXJlIGluIHRoZSB0ZXh0XG4gICAgICAgICAgICAgICAgdHJpbW1lZFRleHQubWF0Y2goL2BgYGpzb25cXHMqKFtcXHNcXFNdKj8pYGBgLyk/LlsxXSB8fFxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgcmV0dXJuIHRoZSB0cmltbWVkIHRleHRcbiAgICAgICAgICAgICAgICB0cmltbWVkVGV4dDtcbiAgICAgICAgICAgIGNvbnN0IGVzY2FwZWRKc29uID0ganNvblxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cIihbXlwiXFxcXF0qKFxcXFwuW15cIlxcXFxdKikqKVwiL2csIChfbWF0Y2gsIGNhcHR1cmVkR3JvdXApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlc2NhcGVkSW5zaWRlUXVvdGVzID0gY2FwdHVyZWRHcm91cC5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYFwiJHtlc2NhcGVkSW5zaWRlUXVvdGVzfVwiYDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCBcIlwiKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCAoMCwgem9kX2pzXzEuaW50ZXJvcFBhcnNlQXN5bmMpKHRoaXMuc2NoZW1hLCBKU09OLnBhcnNlKGVzY2FwZWRKc29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBiYXNlX2pzXzEuT3V0cHV0UGFyc2VyRXhjZXB0aW9uKGBGYWlsZWQgdG8gcGFyc2UuIFRleHQ6IFwiJHt0ZXh0fVwiLiBFcnJvcjogJHtlfWAsIHRleHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TdHJ1Y3R1cmVkT3V0cHV0UGFyc2VyID0gU3RydWN0dXJlZE91dHB1dFBhcnNlcjtcbi8qKlxuICogQSBzcGVjaWZpYyB0eXBlIG9mIGBTdHJ1Y3R1cmVkT3V0cHV0UGFyc2VyYCB0aGF0IHBhcnNlcyBKU09OIGRhdGFcbiAqIGZvcm1hdHRlZCBhcyBhIG1hcmtkb3duIGNvZGUgc25pcHBldC5cbiAqL1xuY2xhc3MgSnNvbk1hcmtkb3duU3RydWN0dXJlZE91dHB1dFBhcnNlciBleHRlbmRzIFN0cnVjdHVyZWRPdXRwdXRQYXJzZXIge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJKc29uTWFya2Rvd25TdHJ1Y3R1cmVkT3V0cHV0UGFyc2VyXCI7XG4gICAgfVxuICAgIGdldEZvcm1hdEluc3RydWN0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGludGVycG9sYXRpb25EZXB0aCA9IG9wdGlvbnM/LmludGVycG9sYXRpb25EZXB0aCA/PyAxO1xuICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkRlcHRoIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZiBzdHJpbmcgaW50ZXJwb2xhdGlvbiBkZXB0aCBtdXN0IGJlIGF0IGxlYXN0IDFcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBSZXR1cm4gYSBtYXJrZG93biBjb2RlIHNuaXBwZXQgd2l0aCBhIEpTT04gb2JqZWN0IGZvcm1hdHRlZCB0byBsb29rIGxpa2U6XFxuXFxgXFxgXFxganNvblxcbiR7dGhpcy5fc2NoZW1hVG9JbnN0cnVjdGlvbigoMCwganNvbl9zY2hlbWFfanNfMS50b0pzb25TY2hlbWEpKHRoaXMuc2NoZW1hKSlcbiAgICAgICAgICAgIC5yZXBsYWNlQWxsKFwie1wiLCBcIntcIi5yZXBlYXQoaW50ZXJwb2xhdGlvbkRlcHRoKSlcbiAgICAgICAgICAgIC5yZXBsYWNlQWxsKFwifVwiLCBcIn1cIi5yZXBlYXQoaW50ZXJwb2xhdGlvbkRlcHRoKSl9XFxuXFxgXFxgXFxgYDtcbiAgICB9XG4gICAgX3NjaGVtYVRvSW5zdHJ1Y3Rpb24oc2NoZW1hSW5wdXQsIGluZGVudCA9IDIpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gc2NoZW1hSW5wdXQ7XG4gICAgICAgIGlmIChcInR5cGVcIiBpbiBzY2hlbWEpIHtcbiAgICAgICAgICAgIGxldCBudWxsYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHR5cGU7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBudWxsSWR4ID0gc2NoZW1hLnR5cGUuZmluZEluZGV4KCh0eXBlKSA9PiB0eXBlID09PSBcIm51bGxcIik7XG4gICAgICAgICAgICAgICAgaWYgKG51bGxJZHggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bGxhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hLnR5cGUuc3BsaWNlKG51bGxJZHgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0eXBlID0gc2NoZW1hLnR5cGUuam9pbihcIiB8IFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHR5cGUgPSBzY2hlbWEudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2hlbWEudHlwZSA9PT0gXCJvYmplY3RcIiAmJiBzY2hlbWEucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gc2NoZW1hLmRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICAgID8gYCAvLyAke3NjaGVtYS5kZXNjcmlwdGlvbn1gXG4gICAgICAgICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gT2JqZWN0LmVudHJpZXMoc2NoZW1hLnByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc09wdGlvbmFsID0gc2NoZW1hLnJlcXVpcmVkPy5pbmNsdWRlcyhrZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCIgKG9wdGlvbmFsKVwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7XCIgXCIucmVwZWF0KGluZGVudCl9XCIke2tleX1cIjogJHt0aGlzLl9zY2hlbWFUb0luc3RydWN0aW9uKHZhbHVlLCBpbmRlbnQgKyAyKX0ke2lzT3B0aW9uYWx9YDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuam9pbihcIlxcblwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYHtcXG4ke3Byb3BlcnRpZXN9XFxuJHtcIiBcIi5yZXBlYXQoaW5kZW50IC0gMil9fSR7ZGVzY3JpcHRpb259YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2hlbWEudHlwZSA9PT0gXCJhcnJheVwiICYmIHNjaGVtYS5pdGVtcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gc2NoZW1hLmRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICAgID8gYCAvLyAke3NjaGVtYS5kZXNjcmlwdGlvbn1gXG4gICAgICAgICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gYGFycmF5W1xcbiR7XCIgXCIucmVwZWF0KGluZGVudCl9JHt0aGlzLl9zY2hlbWFUb0luc3RydWN0aW9uKHNjaGVtYS5pdGVtcywgaW5kZW50ICsgMil9XFxuJHtcIiBcIi5yZXBlYXQoaW5kZW50IC0gMil9XSAke2Rlc2NyaXB0aW9ufWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpc051bGxhYmxlID0gbnVsbGFibGUgPyBcIiAobnVsbGFibGUpXCIgOiBcIlwiO1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBzY2hlbWEuZGVzY3JpcHRpb24gPyBgIC8vICR7c2NoZW1hLmRlc2NyaXB0aW9ufWAgOiBcIlwiO1xuICAgICAgICAgICAgcmV0dXJuIGAke3R5cGV9JHtkZXNjcmlwdGlvbn0ke2lzTnVsbGFibGV9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJhbnlPZlwiIGluIHNjaGVtYSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5hbnlPZlxuICAgICAgICAgICAgICAgIC5tYXAoKHMpID0+IHRoaXMuX3NjaGVtYVRvSW5zdHJ1Y3Rpb24ocywgaW5kZW50KSlcbiAgICAgICAgICAgICAgICAuam9pbihgXFxuJHtcIiBcIi5yZXBlYXQoaW5kZW50IC0gMil9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgc2NoZW1hIHR5cGVcIik7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tWm9kU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoc2NoZW1hKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21OYW1lc0FuZERlc2NyaXB0aW9ucyhzY2hlbWFzKSB7XG4gICAgICAgIGNvbnN0IHpvZFNjaGVtYSA9IHYzXzEuei5vYmplY3QoT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHNjaGVtYXMpLm1hcCgoW25hbWUsIGRlc2NyaXB0aW9uXSkgPT4gW25hbWUsIHYzXzEuei5zdHJpbmcoKS5kZXNjcmliZShkZXNjcmlwdGlvbildKSkpO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoem9kU2NoZW1hKTtcbiAgICB9XG59XG5leHBvcnRzLkpzb25NYXJrZG93blN0cnVjdHVyZWRPdXRwdXRQYXJzZXIgPSBKc29uTWFya2Rvd25TdHJ1Y3R1cmVkT3V0cHV0UGFyc2VyO1xuLyoqXG4gKiBBIHR5cGUgb2YgYFN0cnVjdHVyZWRPdXRwdXRQYXJzZXJgIHRoYXQgaGFuZGxlcyBhc3ltbWV0cmljIGlucHV0IGFuZFxuICogb3V0cHV0IHNjaGVtYXMuXG4gKi9cbmNsYXNzIEFzeW1tZXRyaWNTdHJ1Y3R1cmVkT3V0cHV0UGFyc2VyIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VPdXRwdXRQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKHsgaW5wdXRTY2hlbWEgfSkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdHJ1Y3R1cmVkSW5wdXRQYXJzZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJ1Y3R1cmVkSW5wdXRQYXJzZXIgPSBuZXcgSnNvbk1hcmtkb3duU3RydWN0dXJlZE91dHB1dFBhcnNlcihpbnB1dFNjaGVtYSk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlKHRleHQpIHtcbiAgICAgICAgbGV0IHBhcnNlZElucHV0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGFyc2VkSW5wdXQgPSBhd2FpdCB0aGlzLnN0cnVjdHVyZWRJbnB1dFBhcnNlci5wYXJzZSh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGJhc2VfanNfMS5PdXRwdXRQYXJzZXJFeGNlcHRpb24oYEZhaWxlZCB0byBwYXJzZS4gVGV4dDogXCIke3RleHR9XCIuIEVycm9yOiAke2V9YCwgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0UHJvY2Vzc29yKHBhcnNlZElucHV0KTtcbiAgICB9XG4gICAgZ2V0Rm9ybWF0SW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJ1Y3R1cmVkSW5wdXRQYXJzZXIuZ2V0Rm9ybWF0SW5zdHJ1Y3Rpb25zKCk7XG4gICAgfVxufVxuZXhwb3J0cy5Bc3ltbWV0cmljU3RydWN0dXJlZE91dHB1dFBhcnNlciA9IEFzeW1tZXRyaWNTdHJ1Y3R1cmVkT3V0cHV0UGFyc2VyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/structured.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.cjs":
/*!************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/transform.cjs ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseCumulativeTransformOutputParser = exports.BaseTransformOutputParser = void 0;\nconst json_schema_1 = __webpack_require__(/*! @cfworker/json-schema */ \"(rsc)/./node_modules/@cfworker/json-schema/dist/commonjs/index.js\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/base.cjs\");\nconst base_js_2 = __webpack_require__(/*! ../messages/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ../messages/utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs\");\nconst outputs_js_1 = __webpack_require__(/*! ../outputs.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/outputs.cjs\");\n/**\n * Class to parse the output of an LLM call that also allows streaming inputs.\n */\nclass BaseTransformOutputParser extends base_js_1.BaseOutputParser {\n    async *_transform(inputGenerator) {\n        for await (const chunk of inputGenerator) {\n            if (typeof chunk === \"string\") {\n                yield this.parseResult([{ text: chunk }]);\n            }\n            else {\n                yield this.parseResult([\n                    {\n                        message: chunk,\n                        text: this._baseMessageToString(chunk),\n                    },\n                ]);\n            }\n        }\n    }\n    /**\n     * Transforms an asynchronous generator of input into an asynchronous\n     * generator of parsed output.\n     * @param inputGenerator An asynchronous generator of input.\n     * @param options A configuration object.\n     * @returns An asynchronous generator of parsed output.\n     */\n    async *transform(inputGenerator, options) {\n        yield* this._transformStreamWithConfig(inputGenerator, this._transform.bind(this), {\n            ...options,\n            runType: \"parser\",\n        });\n    }\n}\nexports.BaseTransformOutputParser = BaseTransformOutputParser;\n/**\n * A base class for output parsers that can handle streaming input. It\n * extends the `BaseTransformOutputParser` class and provides a method for\n * converting parsed outputs into a diff format.\n */\nclass BaseCumulativeTransformOutputParser extends BaseTransformOutputParser {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"diff\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        this.diff = fields?.diff ?? this.diff;\n    }\n    async *_transform(inputGenerator) {\n        let prevParsed;\n        let accGen;\n        for await (const chunk of inputGenerator) {\n            if (typeof chunk !== \"string\" && typeof chunk.content !== \"string\") {\n                throw new Error(\"Cannot handle non-string output.\");\n            }\n            let chunkGen;\n            if ((0, base_js_2.isBaseMessageChunk)(chunk)) {\n                if (typeof chunk.content !== \"string\") {\n                    throw new Error(\"Cannot handle non-string message output.\");\n                }\n                chunkGen = new outputs_js_1.ChatGenerationChunk({\n                    message: chunk,\n                    text: chunk.content,\n                });\n            }\n            else if ((0, base_js_2.isBaseMessage)(chunk)) {\n                if (typeof chunk.content !== \"string\") {\n                    throw new Error(\"Cannot handle non-string message output.\");\n                }\n                chunkGen = new outputs_js_1.ChatGenerationChunk({\n                    message: (0, utils_js_1.convertToChunk)(chunk),\n                    text: chunk.content,\n                });\n            }\n            else {\n                chunkGen = new outputs_js_1.GenerationChunk({ text: chunk });\n            }\n            if (accGen === undefined) {\n                accGen = chunkGen;\n            }\n            else {\n                accGen = accGen.concat(chunkGen);\n            }\n            const parsed = await this.parsePartialResult([accGen]);\n            if (parsed !== undefined &&\n                parsed !== null &&\n                !(0, json_schema_1.deepCompareStrict)(parsed, prevParsed)) {\n                if (this.diff) {\n                    yield this._diff(prevParsed, parsed);\n                }\n                else {\n                    yield parsed;\n                }\n                prevParsed = parsed;\n            }\n        }\n    }\n    getFormatInstructions() {\n        return \"\";\n    }\n}\nexports.BaseCumulativeTransformOutputParser = BaseCumulativeTransformOutputParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvdHJhbnNmb3JtLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQ0FBMkMsR0FBRyxpQ0FBaUM7QUFDL0Usc0JBQXNCLG1CQUFPLENBQUMsZ0dBQXVCO0FBQ3JELGtCQUFrQixtQkFBTyxDQUFDLHFGQUFZO0FBQ3RDLGtCQUFrQixtQkFBTyxDQUFDLHlGQUFzQjtBQUNoRCxtQkFBbUIsbUJBQU8sQ0FBQywyRkFBdUI7QUFDbEQscUJBQXFCLG1CQUFPLENBQUMsNkVBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGFBQWE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsOERBQThELGFBQWE7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9vdXRwdXRfcGFyc2Vycy90cmFuc2Zvcm0uY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlQ3VtdWxhdGl2ZVRyYW5zZm9ybU91dHB1dFBhcnNlciA9IGV4cG9ydHMuQmFzZVRyYW5zZm9ybU91dHB1dFBhcnNlciA9IHZvaWQgMDtcbmNvbnN0IGpzb25fc2NoZW1hXzEgPSByZXF1aXJlKFwiQGNmd29ya2VyL2pzb24tc2NoZW1hXCIpO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG5jb25zdCBiYXNlX2pzXzIgPSByZXF1aXJlKFwiLi4vbWVzc2FnZXMvYmFzZS5janNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4uL21lc3NhZ2VzL3V0aWxzLmNqc1wiKTtcbmNvbnN0IG91dHB1dHNfanNfMSA9IHJlcXVpcmUoXCIuLi9vdXRwdXRzLmNqc1wiKTtcbi8qKlxuICogQ2xhc3MgdG8gcGFyc2UgdGhlIG91dHB1dCBvZiBhbiBMTE0gY2FsbCB0aGF0IGFsc28gYWxsb3dzIHN0cmVhbWluZyBpbnB1dHMuXG4gKi9cbmNsYXNzIEJhc2VUcmFuc2Zvcm1PdXRwdXRQYXJzZXIgZXh0ZW5kcyBiYXNlX2pzXzEuQmFzZU91dHB1dFBhcnNlciB7XG4gICAgYXN5bmMgKl90cmFuc2Zvcm0oaW5wdXRHZW5lcmF0b3IpIHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBpbnB1dEdlbmVyYXRvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucGFyc2VSZXN1bHQoW3sgdGV4dDogY2h1bmsgfV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5wYXJzZVJlc3VsdChbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNodW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGhpcy5fYmFzZU1lc3NhZ2VUb1N0cmluZyhjaHVuayksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhbiBhc3luY2hyb25vdXMgZ2VuZXJhdG9yIG9mIGlucHV0IGludG8gYW4gYXN5bmNocm9ub3VzXG4gICAgICogZ2VuZXJhdG9yIG9mIHBhcnNlZCBvdXRwdXQuXG4gICAgICogQHBhcmFtIGlucHV0R2VuZXJhdG9yIEFuIGFzeW5jaHJvbm91cyBnZW5lcmF0b3Igb2YgaW5wdXQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyBBbiBhc3luY2hyb25vdXMgZ2VuZXJhdG9yIG9mIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgYXN5bmMgKnRyYW5zZm9ybShpbnB1dEdlbmVyYXRvciwgb3B0aW9ucykge1xuICAgICAgICB5aWVsZCogdGhpcy5fdHJhbnNmb3JtU3RyZWFtV2l0aENvbmZpZyhpbnB1dEdlbmVyYXRvciwgdGhpcy5fdHJhbnNmb3JtLmJpbmQodGhpcyksIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBydW5UeXBlOiBcInBhcnNlclwiLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VUcmFuc2Zvcm1PdXRwdXRQYXJzZXIgPSBCYXNlVHJhbnNmb3JtT3V0cHV0UGFyc2VyO1xuLyoqXG4gKiBBIGJhc2UgY2xhc3MgZm9yIG91dHB1dCBwYXJzZXJzIHRoYXQgY2FuIGhhbmRsZSBzdHJlYW1pbmcgaW5wdXQuIEl0XG4gKiBleHRlbmRzIHRoZSBgQmFzZVRyYW5zZm9ybU91dHB1dFBhcnNlcmAgY2xhc3MgYW5kIHByb3ZpZGVzIGEgbWV0aG9kIGZvclxuICogY29udmVydGluZyBwYXJzZWQgb3V0cHV0cyBpbnRvIGEgZGlmZiBmb3JtYXQuXG4gKi9cbmNsYXNzIEJhc2VDdW11bGF0aXZlVHJhbnNmb3JtT3V0cHV0UGFyc2VyIGV4dGVuZHMgQmFzZVRyYW5zZm9ybU91dHB1dFBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRpZmZcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRpZmYgPSBmaWVsZHM/LmRpZmYgPz8gdGhpcy5kaWZmO1xuICAgIH1cbiAgICBhc3luYyAqX3RyYW5zZm9ybShpbnB1dEdlbmVyYXRvcikge1xuICAgICAgICBsZXQgcHJldlBhcnNlZDtcbiAgICAgICAgbGV0IGFjY0dlbjtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBpbnB1dEdlbmVyYXRvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgY2h1bmsuY29udGVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBoYW5kbGUgbm9uLXN0cmluZyBvdXRwdXQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNodW5rR2VuO1xuICAgICAgICAgICAgaWYgKCgwLCBiYXNlX2pzXzIuaXNCYXNlTWVzc2FnZUNodW5rKShjaHVuaykpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNodW5rLmNvbnRlbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGhhbmRsZSBub24tc3RyaW5nIG1lc3NhZ2Ugb3V0cHV0LlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2h1bmtHZW4gPSBuZXcgb3V0cHV0c19qc18xLkNoYXRHZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaHVuayxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogY2h1bmsuY29udGVudCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCgwLCBiYXNlX2pzXzIuaXNCYXNlTWVzc2FnZSkoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaHVuay5jb250ZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBoYW5kbGUgbm9uLXN0cmluZyBtZXNzYWdlIG91dHB1dC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNodW5rR2VuID0gbmV3IG91dHB1dHNfanNfMS5DaGF0R2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogKDAsIHV0aWxzX2pzXzEuY29udmVydFRvQ2h1bmspKGNodW5rKSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogY2h1bmsuY29udGVudCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNodW5rR2VuID0gbmV3IG91dHB1dHNfanNfMS5HZW5lcmF0aW9uQ2h1bmsoeyB0ZXh0OiBjaHVuayB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY2NHZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFjY0dlbiA9IGNodW5rR2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWNjR2VuID0gYWNjR2VuLmNvbmNhdChjaHVua0dlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBhd2FpdCB0aGlzLnBhcnNlUGFydGlhbFJlc3VsdChbYWNjR2VuXSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBwYXJzZWQgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAhKDAsIGpzb25fc2NoZW1hXzEuZGVlcENvbXBhcmVTdHJpY3QpKHBhcnNlZCwgcHJldlBhcnNlZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kaWZmKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuX2RpZmYocHJldlBhcnNlZCwgcGFyc2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHBhcnNlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldlBhcnNlZCA9IHBhcnNlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRGb3JtYXRJbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUN1bXVsYXRpdmVUcmFuc2Zvcm1PdXRwdXRQYXJzZXIgPSBCYXNlQ3VtdWxhdGl2ZVRyYW5zZm9ybU91dHB1dFBhcnNlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/xml.cjs":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/xml.cjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.XMLOutputParser = exports.XML_FORMAT_INSTRUCTIONS = void 0;\nexports.parseXMLMarkdown = parseXMLMarkdown;\nconst transform_js_1 = __webpack_require__(/*! ./transform.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.cjs\");\nconst json_patch_js_1 = __webpack_require__(/*! ../utils/json_patch.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_patch.cjs\");\nconst sax_js_1 = __webpack_require__(/*! ../utils/sax-js/sax.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/sax-js/sax.cjs\");\nexports.XML_FORMAT_INSTRUCTIONS = `The output should be formatted as a XML file.\n1. Output should conform to the tags below. \n2. If tags are not given, make them on your own.\n3. Remember to always open and close all the tags.\n\nAs an example, for the tags [\"foo\", \"bar\", \"baz\"]:\n1. String \"<foo>\\n   <bar>\\n      <baz></baz>\\n   </bar>\\n</foo>\" is a well-formatted instance of the schema. \n2. String \"<foo>\\n   <bar>\\n   </foo>\" is a badly-formatted instance.\n3. String \"<foo>\\n   <tag>\\n   </tag>\\n</foo>\" is a badly-formatted instance.\n\nHere are the output tags:\n\\`\\`\\`\n{tags}\n\\`\\`\\``;\nclass XMLOutputParser extends transform_js_1.BaseCumulativeTransformOutputParser {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.tags = fields?.tags;\n    }\n    static lc_name() {\n        return \"XMLOutputParser\";\n    }\n    _diff(prev, next) {\n        if (!next) {\n            return undefined;\n        }\n        if (!prev) {\n            return [{ op: \"replace\", path: \"\", value: next }];\n        }\n        return (0, json_patch_js_1.compare)(prev, next);\n    }\n    async parsePartialResult(generations) {\n        return parseXMLMarkdown(generations[0].text);\n    }\n    async parse(text) {\n        return parseXMLMarkdown(text);\n    }\n    getFormatInstructions() {\n        const withTags = !!(this.tags && this.tags.length > 0);\n        return withTags\n            ? exports.XML_FORMAT_INSTRUCTIONS.replace(\"{tags}\", this.tags?.join(\", \") ?? \"\")\n            : exports.XML_FORMAT_INSTRUCTIONS;\n    }\n}\nexports.XMLOutputParser = XMLOutputParser;\nconst strip = (text) => text\n    .split(\"\\n\")\n    .map((line) => line.replace(/^\\s+/, \"\"))\n    .join(\"\\n\")\n    .trim();\nconst parseParsedResult = (input) => {\n    if (Object.keys(input).length === 0) {\n        return {};\n    }\n    const result = {};\n    if (input.children.length > 0) {\n        result[input.name] = input.children.map(parseParsedResult);\n        return result;\n    }\n    else {\n        result[input.name] = input.text ?? undefined;\n        return result;\n    }\n};\nfunction parseXMLMarkdown(s) {\n    const cleanedString = strip(s);\n    const parser = sax_js_1.sax.parser(true);\n    let parsedResult = {};\n    const elementStack = [];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parser.onopentag = (node) => {\n        const element = {\n            name: node.name,\n            attributes: node.attributes,\n            children: [],\n            text: \"\",\n            isSelfClosing: node.isSelfClosing,\n        };\n        if (elementStack.length > 0) {\n            const parentElement = elementStack[elementStack.length - 1];\n            parentElement.children.push(element);\n        }\n        else {\n            parsedResult = element;\n        }\n        if (!node.isSelfClosing) {\n            elementStack.push(element);\n        }\n    };\n    parser.onclosetag = () => {\n        if (elementStack.length > 0) {\n            const lastElement = elementStack.pop();\n            if (elementStack.length === 0 && lastElement) {\n                parsedResult = lastElement;\n            }\n        }\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parser.ontext = (text) => {\n        if (elementStack.length > 0) {\n            const currentElement = elementStack[elementStack.length - 1];\n            currentElement.text += text;\n        }\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parser.onattribute = (attr) => {\n        if (elementStack.length > 0) {\n            const currentElement = elementStack[elementStack.length - 1];\n            currentElement.attributes[attr.name] = attr.value;\n        }\n    };\n    // Try to find XML string within triple backticks.\n    const match = /```(xml)?(.*)```/s.exec(cleanedString);\n    const xmlString = match ? match[2] : cleanedString;\n    parser.write(xmlString).close();\n    // Remove the XML declaration if present\n    if (parsedResult && parsedResult.name === \"?xml\") {\n        parsedResult = parsedResult.children[0];\n    }\n    return parseParsedResult(parsedResult);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMveG1sLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRywrQkFBK0I7QUFDekQsd0JBQXdCO0FBQ3hCLHVCQUF1QixtQkFBTyxDQUFDLCtGQUFpQjtBQUNoRCx3QkFBd0IsbUJBQU8sQ0FBQywrRkFBeUI7QUFDekQsaUJBQWlCLG1CQUFPLENBQUMsK0ZBQXlCO0FBQ2xELCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNDQUFzQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsS0FBSztBQUM3RDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9vdXRwdXRfcGFyc2Vycy94bWwuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5YTUxPdXRwdXRQYXJzZXIgPSBleHBvcnRzLlhNTF9GT1JNQVRfSU5TVFJVQ1RJT05TID0gdm9pZCAwO1xuZXhwb3J0cy5wYXJzZVhNTE1hcmtkb3duID0gcGFyc2VYTUxNYXJrZG93bjtcbmNvbnN0IHRyYW5zZm9ybV9qc18xID0gcmVxdWlyZShcIi4vdHJhbnNmb3JtLmNqc1wiKTtcbmNvbnN0IGpzb25fcGF0Y2hfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9qc29uX3BhdGNoLmNqc1wiKTtcbmNvbnN0IHNheF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL3NheC1qcy9zYXguY2pzXCIpO1xuZXhwb3J0cy5YTUxfRk9STUFUX0lOU1RSVUNUSU9OUyA9IGBUaGUgb3V0cHV0IHNob3VsZCBiZSBmb3JtYXR0ZWQgYXMgYSBYTUwgZmlsZS5cbjEuIE91dHB1dCBzaG91bGQgY29uZm9ybSB0byB0aGUgdGFncyBiZWxvdy4gXG4yLiBJZiB0YWdzIGFyZSBub3QgZ2l2ZW4sIG1ha2UgdGhlbSBvbiB5b3VyIG93bi5cbjMuIFJlbWVtYmVyIHRvIGFsd2F5cyBvcGVuIGFuZCBjbG9zZSBhbGwgdGhlIHRhZ3MuXG5cbkFzIGFuIGV4YW1wbGUsIGZvciB0aGUgdGFncyBbXCJmb29cIiwgXCJiYXJcIiwgXCJiYXpcIl06XG4xLiBTdHJpbmcgXCI8Zm9vPlxcbiAgIDxiYXI+XFxuICAgICAgPGJhej48L2Jhej5cXG4gICA8L2Jhcj5cXG48L2Zvbz5cIiBpcyBhIHdlbGwtZm9ybWF0dGVkIGluc3RhbmNlIG9mIHRoZSBzY2hlbWEuIFxuMi4gU3RyaW5nIFwiPGZvbz5cXG4gICA8YmFyPlxcbiAgIDwvZm9vPlwiIGlzIGEgYmFkbHktZm9ybWF0dGVkIGluc3RhbmNlLlxuMy4gU3RyaW5nIFwiPGZvbz5cXG4gICA8dGFnPlxcbiAgIDwvdGFnPlxcbjwvZm9vPlwiIGlzIGEgYmFkbHktZm9ybWF0dGVkIGluc3RhbmNlLlxuXG5IZXJlIGFyZSB0aGUgb3V0cHV0IHRhZ3M6XG5cXGBcXGBcXGBcbnt0YWdzfVxuXFxgXFxgXFxgYDtcbmNsYXNzIFhNTE91dHB1dFBhcnNlciBleHRlbmRzIHRyYW5zZm9ybV9qc18xLkJhc2VDdW11bGF0aXZlVHJhbnNmb3JtT3V0cHV0UGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwib3V0cHV0X3BhcnNlcnNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50YWdzID0gZmllbGRzPy50YWdzO1xuICAgIH1cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiWE1MT3V0cHV0UGFyc2VyXCI7XG4gICAgfVxuICAgIF9kaWZmKHByZXYsIG5leHQpIHtcbiAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJldikge1xuICAgICAgICAgICAgcmV0dXJuIFt7IG9wOiBcInJlcGxhY2VcIiwgcGF0aDogXCJcIiwgdmFsdWU6IG5leHQgfV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBqc29uX3BhdGNoX2pzXzEuY29tcGFyZSkocHJldiwgbmV4dCk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlUGFydGlhbFJlc3VsdChnZW5lcmF0aW9ucykge1xuICAgICAgICByZXR1cm4gcGFyc2VYTUxNYXJrZG93bihnZW5lcmF0aW9uc1swXS50ZXh0KTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2UodGV4dCkge1xuICAgICAgICByZXR1cm4gcGFyc2VYTUxNYXJrZG93bih0ZXh0KTtcbiAgICB9XG4gICAgZ2V0Rm9ybWF0SW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICBjb25zdCB3aXRoVGFncyA9ICEhKHRoaXMudGFncyAmJiB0aGlzLnRhZ3MubGVuZ3RoID4gMCk7XG4gICAgICAgIHJldHVybiB3aXRoVGFnc1xuICAgICAgICAgICAgPyBleHBvcnRzLlhNTF9GT1JNQVRfSU5TVFJVQ1RJT05TLnJlcGxhY2UoXCJ7dGFnc31cIiwgdGhpcy50YWdzPy5qb2luKFwiLCBcIikgPz8gXCJcIilcbiAgICAgICAgICAgIDogZXhwb3J0cy5YTUxfRk9STUFUX0lOU1RSVUNUSU9OUztcbiAgICB9XG59XG5leHBvcnRzLlhNTE91dHB1dFBhcnNlciA9IFhNTE91dHB1dFBhcnNlcjtcbmNvbnN0IHN0cmlwID0gKHRleHQpID0+IHRleHRcbiAgICAuc3BsaXQoXCJcXG5cIilcbiAgICAubWFwKChsaW5lKSA9PiBsaW5lLnJlcGxhY2UoL15cXHMrLywgXCJcIikpXG4gICAgLmpvaW4oXCJcXG5cIilcbiAgICAudHJpbSgpO1xuY29uc3QgcGFyc2VQYXJzZWRSZXN1bHQgPSAoaW5wdXQpID0+IHtcbiAgICBpZiAoT2JqZWN0LmtleXMoaW5wdXQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGlmIChpbnB1dC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlc3VsdFtpbnB1dC5uYW1lXSA9IGlucHV0LmNoaWxkcmVuLm1hcChwYXJzZVBhcnNlZFJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHRbaW5wdXQubmFtZV0gPSBpbnB1dC50ZXh0ID8/IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuZnVuY3Rpb24gcGFyc2VYTUxNYXJrZG93bihzKSB7XG4gICAgY29uc3QgY2xlYW5lZFN0cmluZyA9IHN0cmlwKHMpO1xuICAgIGNvbnN0IHBhcnNlciA9IHNheF9qc18xLnNheC5wYXJzZXIodHJ1ZSk7XG4gICAgbGV0IHBhcnNlZFJlc3VsdCA9IHt9O1xuICAgIGNvbnN0IGVsZW1lbnRTdGFjayA9IFtdO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcGFyc2VyLm9ub3BlbnRhZyA9IChub2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB7XG4gICAgICAgICAgICBuYW1lOiBub2RlLm5hbWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBub2RlLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgaXNTZWxmQ2xvc2luZzogbm9kZS5pc1NlbGZDbG9zaW5nLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZWxlbWVudFN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEVsZW1lbnQgPSBlbGVtZW50U3RhY2tbZWxlbWVudFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgcGFyZW50RWxlbWVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VkUmVzdWx0ID0gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUuaXNTZWxmQ2xvc2luZykge1xuICAgICAgICAgICAgZWxlbWVudFN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHBhcnNlci5vbmNsb3NldGFnID0gKCkgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudFN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RFbGVtZW50ID0gZWxlbWVudFN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRTdGFjay5sZW5ndGggPT09IDAgJiYgbGFzdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBwYXJzZWRSZXN1bHQgPSBsYXN0RWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBwYXJzZXIub250ZXh0ID0gKHRleHQpID0+IHtcbiAgICAgICAgaWYgKGVsZW1lbnRTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RWxlbWVudCA9IGVsZW1lbnRTdGFja1tlbGVtZW50U3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjdXJyZW50RWxlbWVudC50ZXh0ICs9IHRleHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcGFyc2VyLm9uYXR0cmlidXRlID0gKGF0dHIpID0+IHtcbiAgICAgICAgaWYgKGVsZW1lbnRTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RWxlbWVudCA9IGVsZW1lbnRTdGFja1tlbGVtZW50U3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjdXJyZW50RWxlbWVudC5hdHRyaWJ1dGVzW2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBUcnkgdG8gZmluZCBYTUwgc3RyaW5nIHdpdGhpbiB0cmlwbGUgYmFja3RpY2tzLlxuICAgIGNvbnN0IG1hdGNoID0gL2BgYCh4bWwpPyguKilgYGAvcy5leGVjKGNsZWFuZWRTdHJpbmcpO1xuICAgIGNvbnN0IHhtbFN0cmluZyA9IG1hdGNoID8gbWF0Y2hbMl0gOiBjbGVhbmVkU3RyaW5nO1xuICAgIHBhcnNlci53cml0ZSh4bWxTdHJpbmcpLmNsb3NlKCk7XG4gICAgLy8gUmVtb3ZlIHRoZSBYTUwgZGVjbGFyYXRpb24gaWYgcHJlc2VudFxuICAgIGlmIChwYXJzZWRSZXN1bHQgJiYgcGFyc2VkUmVzdWx0Lm5hbWUgPT09IFwiP3htbFwiKSB7XG4gICAgICAgIHBhcnNlZFJlc3VsdCA9IHBhcnNlZFJlc3VsdC5jaGlsZHJlblswXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlUGFyc2VkUmVzdWx0KHBhcnNlZFJlc3VsdCk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/xml.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/outputs.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/@langchain/core/dist/outputs.cjs ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChatGenerationChunk = exports.GenerationChunk = exports.RUN_KEY = void 0;\nexports.RUN_KEY = \"__run\";\n/**\n * Chunk of a single generation. Used for streaming.\n */\nclass GenerationChunk {\n    constructor(fields) {\n        Object.defineProperty(this, \"text\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"generationInfo\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.text = fields.text;\n        this.generationInfo = fields.generationInfo;\n    }\n    concat(chunk) {\n        return new GenerationChunk({\n            text: this.text + chunk.text,\n            generationInfo: {\n                ...this.generationInfo,\n                ...chunk.generationInfo,\n            },\n        });\n    }\n}\nexports.GenerationChunk = GenerationChunk;\nclass ChatGenerationChunk extends GenerationChunk {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"message\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.message = fields.message;\n    }\n    concat(chunk) {\n        return new ChatGenerationChunk({\n            text: this.text + chunk.text,\n            generationInfo: {\n                ...this.generationInfo,\n                ...chunk.generationInfo,\n            },\n            message: this.message.concat(chunk.message),\n        });\n    }\n}\nexports.ChatGenerationChunk = ChatGenerationChunk;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0cy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcsdUJBQXVCLEdBQUcsZUFBZTtBQUN2RSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJCQUEyQiIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L291dHB1dHMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaGF0R2VuZXJhdGlvbkNodW5rID0gZXhwb3J0cy5HZW5lcmF0aW9uQ2h1bmsgPSBleHBvcnRzLlJVTl9LRVkgPSB2b2lkIDA7XG5leHBvcnRzLlJVTl9LRVkgPSBcIl9fcnVuXCI7XG4vKipcbiAqIENodW5rIG9mIGEgc2luZ2xlIGdlbmVyYXRpb24uIFVzZWQgZm9yIHN0cmVhbWluZy5cbiAqL1xuY2xhc3MgR2VuZXJhdGlvbkNodW5rIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGV4dFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZW5lcmF0aW9uSW5mb1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRleHQgPSBmaWVsZHMudGV4dDtcbiAgICAgICAgdGhpcy5nZW5lcmF0aW9uSW5mbyA9IGZpZWxkcy5nZW5lcmF0aW9uSW5mbztcbiAgICB9XG4gICAgY29uY2F0KGNodW5rKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgIHRleHQ6IHRoaXMudGV4dCArIGNodW5rLnRleHQsXG4gICAgICAgICAgICBnZW5lcmF0aW9uSW5mbzoge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICAgICAgLi4uY2h1bmsuZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkdlbmVyYXRpb25DaHVuayA9IEdlbmVyYXRpb25DaHVuaztcbmNsYXNzIENoYXRHZW5lcmF0aW9uQ2h1bmsgZXh0ZW5kcyBHZW5lcmF0aW9uQ2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXNzYWdlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGZpZWxkcy5tZXNzYWdlO1xuICAgIH1cbiAgICBjb25jYXQoY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGF0R2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgIHRleHQ6IHRoaXMudGV4dCArIGNodW5rLnRleHQsXG4gICAgICAgICAgICBnZW5lcmF0aW9uSW5mbzoge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICAgICAgLi4uY2h1bmsuZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLmNvbmNhdChjaHVuay5tZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5DaGF0R2VuZXJhdGlvbkNodW5rID0gQ2hhdEdlbmVyYXRpb25DaHVuaztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/outputs.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/prompt_values.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/prompt_values.cjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ImagePromptValue = exports.ChatPromptValue = exports.StringPromptValue = exports.BasePromptValue = void 0;\nconst serializable_js_1 = __webpack_require__(/*! ./load/serializable.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.cjs\");\nconst human_js_1 = __webpack_require__(/*! ./messages/human.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/human.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ./messages/utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs\");\n/**\n * Base PromptValue class. All prompt values should extend this class.\n */\nclass BasePromptValue extends serializable_js_1.Serializable {\n}\nexports.BasePromptValue = BasePromptValue;\n/**\n * Represents a prompt value as a string. It extends the BasePromptValue\n * class and overrides the toString and toChatMessages methods.\n */\nclass StringPromptValue extends BasePromptValue {\n    static lc_name() {\n        return \"StringPromptValue\";\n    }\n    constructor(value) {\n        super({ value });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"prompt_values\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"value\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.value = value;\n    }\n    toString() {\n        return this.value;\n    }\n    toChatMessages() {\n        return [new human_js_1.HumanMessage(this.value)];\n    }\n}\nexports.StringPromptValue = StringPromptValue;\n/**\n * Class that represents a chat prompt value. It extends the\n * BasePromptValue and includes an array of BaseMessage instances.\n */\nclass ChatPromptValue extends BasePromptValue {\n    static lc_name() {\n        return \"ChatPromptValue\";\n    }\n    constructor(fields) {\n        if (Array.isArray(fields)) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { messages: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"prompt_values\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"messages\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.messages = fields.messages;\n    }\n    toString() {\n        return (0, utils_js_1.getBufferString)(this.messages);\n    }\n    toChatMessages() {\n        return this.messages;\n    }\n}\nexports.ChatPromptValue = ChatPromptValue;\n/**\n * Class that represents an image prompt value. It extends the\n * BasePromptValue and includes an ImageURL instance.\n */\nclass ImagePromptValue extends BasePromptValue {\n    static lc_name() {\n        return \"ImagePromptValue\";\n    }\n    constructor(fields) {\n        if (!(\"imageUrl\" in fields)) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { imageUrl: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"prompt_values\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"imageUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** @ignore */\n        Object.defineProperty(this, \"value\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.imageUrl = fields.imageUrl;\n    }\n    toString() {\n        return this.imageUrl.url;\n    }\n    toChatMessages() {\n        return [\n            new human_js_1.HumanMessage({\n                content: [\n                    {\n                        type: \"image_url\",\n                        image_url: {\n                            detail: this.imageUrl.detail,\n                            url: this.imageUrl.url,\n                        },\n                    },\n                ],\n            }),\n        ];\n    }\n}\nexports.ImagePromptValue = ImagePromptValue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcHJvbXB0X3ZhbHVlcy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcseUJBQXlCLEdBQUcsdUJBQXVCO0FBQ3hHLDBCQUEwQixtQkFBTyxDQUFDLGdHQUF5QjtBQUMzRCxtQkFBbUIsbUJBQU8sQ0FBQywwRkFBc0I7QUFDakQsbUJBQW1CLG1CQUFPLENBQUMsMEZBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcHJvbXB0X3ZhbHVlcy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkltYWdlUHJvbXB0VmFsdWUgPSBleHBvcnRzLkNoYXRQcm9tcHRWYWx1ZSA9IGV4cG9ydHMuU3RyaW5nUHJvbXB0VmFsdWUgPSBleHBvcnRzLkJhc2VQcm9tcHRWYWx1ZSA9IHZvaWQgMDtcbmNvbnN0IHNlcmlhbGl6YWJsZV9qc18xID0gcmVxdWlyZShcIi4vbG9hZC9zZXJpYWxpemFibGUuY2pzXCIpO1xuY29uc3QgaHVtYW5fanNfMSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzL2h1bWFuLmNqc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy91dGlscy5janNcIik7XG4vKipcbiAqIEJhc2UgUHJvbXB0VmFsdWUgY2xhc3MuIEFsbCBwcm9tcHQgdmFsdWVzIHNob3VsZCBleHRlbmQgdGhpcyBjbGFzcy5cbiAqL1xuY2xhc3MgQmFzZVByb21wdFZhbHVlIGV4dGVuZHMgc2VyaWFsaXphYmxlX2pzXzEuU2VyaWFsaXphYmxlIHtcbn1cbmV4cG9ydHMuQmFzZVByb21wdFZhbHVlID0gQmFzZVByb21wdFZhbHVlO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgcHJvbXB0IHZhbHVlIGFzIGEgc3RyaW5nLiBJdCBleHRlbmRzIHRoZSBCYXNlUHJvbXB0VmFsdWVcbiAqIGNsYXNzIGFuZCBvdmVycmlkZXMgdGhlIHRvU3RyaW5nIGFuZCB0b0NoYXRNZXNzYWdlcyBtZXRob2RzLlxuICovXG5jbGFzcyBTdHJpbmdQcm9tcHRWYWx1ZSBleHRlbmRzIEJhc2VQcm9tcHRWYWx1ZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlN0cmluZ1Byb21wdFZhbHVlXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKHsgdmFsdWUgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJwcm9tcHRfdmFsdWVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICB0b0NoYXRNZXNzYWdlcygpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgaHVtYW5fanNfMS5IdW1hbk1lc3NhZ2UodGhpcy52YWx1ZSldO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RyaW5nUHJvbXB0VmFsdWUgPSBTdHJpbmdQcm9tcHRWYWx1ZTtcbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgY2hhdCBwcm9tcHQgdmFsdWUuIEl0IGV4dGVuZHMgdGhlXG4gKiBCYXNlUHJvbXB0VmFsdWUgYW5kIGluY2x1ZGVzIGFuIGFycmF5IG9mIEJhc2VNZXNzYWdlIGluc3RhbmNlcy5cbiAqL1xuY2xhc3MgQ2hhdFByb21wdFZhbHVlIGV4dGVuZHMgQmFzZVByb21wdFZhbHVlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2hhdFByb21wdFZhbHVlXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZHMpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGZpZWxkcyA9IHsgbWVzc2FnZXM6IGZpZWxkcyB9O1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJwcm9tcHRfdmFsdWVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1lc3NhZ2VzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBmaWVsZHMubWVzc2FnZXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxzX2pzXzEuZ2V0QnVmZmVyU3RyaW5nKSh0aGlzLm1lc3NhZ2VzKTtcbiAgICB9XG4gICAgdG9DaGF0TWVzc2FnZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhdFByb21wdFZhbHVlID0gQ2hhdFByb21wdFZhbHVlO1xuLyoqXG4gKiBDbGFzcyB0aGF0IHJlcHJlc2VudHMgYW4gaW1hZ2UgcHJvbXB0IHZhbHVlLiBJdCBleHRlbmRzIHRoZVxuICogQmFzZVByb21wdFZhbHVlIGFuZCBpbmNsdWRlcyBhbiBJbWFnZVVSTCBpbnN0YW5jZS5cbiAqL1xuY2xhc3MgSW1hZ2VQcm9tcHRWYWx1ZSBleHRlbmRzIEJhc2VQcm9tcHRWYWx1ZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkltYWdlUHJvbXB0VmFsdWVcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIGlmICghKFwiaW1hZ2VVcmxcIiBpbiBmaWVsZHMpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGZpZWxkcyA9IHsgaW1hZ2VVcmw6IGZpZWxkcyB9O1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJwcm9tcHRfdmFsdWVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImltYWdlVXJsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBAaWdub3JlICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW1hZ2VVcmwgPSBmaWVsZHMuaW1hZ2VVcmw7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZVVybC51cmw7XG4gICAgfVxuICAgIHRvQ2hhdE1lc3NhZ2VzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbmV3IGh1bWFuX2pzXzEuSHVtYW5NZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VfdXJsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZV91cmw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IHRoaXMuaW1hZ2VVcmwuZGV0YWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdGhpcy5pbWFnZVVybC51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9XG59XG5leHBvcnRzLkltYWdlUHJvbXB0VmFsdWUgPSBJbWFnZVByb21wdFZhbHVlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/prompt_values.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/retrievers/index.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/retrievers/index.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseRetriever = void 0;\nconst manager_js_1 = __webpack_require__(/*! ../callbacks/manager.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.cjs\");\nconst base_js_1 = __webpack_require__(/*! ../runnables/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nconst config_js_1 = __webpack_require__(/*! ../runnables/config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\n/**\n * Abstract base class for a document retrieval system, designed to\n * process string queries and return the most relevant documents from a source.\n *\n * `BaseRetriever` provides common properties and methods for derived retrievers,\n * such as callbacks, tagging, and verbose logging. Custom retrieval systems\n * should extend this class and implement `_getRelevantDocuments` to define\n * the specific retrieval logic.\n *\n * @template Metadata - The type of metadata associated with each document,\n *                      defaulting to `Record<string, any>`.\n */\nclass BaseRetriever extends base_js_1.Runnable {\n    /**\n     * Constructs a new `BaseRetriever` instance with optional configuration fields.\n     *\n     * @param fields - Optional input configuration that can include `callbacks`,\n     *                 `tags`, `metadata`, and `verbose` settings for custom retriever behavior.\n     */\n    constructor(fields) {\n        super(fields);\n        /**\n         * Optional callbacks to handle various events in the retrieval process.\n         */\n        Object.defineProperty(this, \"callbacks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Tags to label or categorize the retrieval operation.\n         */\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Metadata to provide additional context or information about the retrieval\n         * operation.\n         */\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * If set to `true`, enables verbose logging for the retrieval process.\n         */\n        Object.defineProperty(this, \"verbose\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.callbacks = fields?.callbacks;\n        this.tags = fields?.tags ?? [];\n        this.metadata = fields?.metadata ?? {};\n        this.verbose = fields?.verbose ?? false;\n    }\n    /**\n     * TODO: This should be an abstract method, but we'd like to avoid breaking\n     * changes to people currently using subclassed custom retrievers.\n     * Change it on next major release.\n     */\n    /**\n     * Placeholder method for retrieving relevant documents based on a query.\n     *\n     * This method is intended to be implemented by subclasses and will be\n     * converted to an abstract method in the next major release. Currently, it\n     * throws an error if not implemented, ensuring that custom retrievers define\n     * the specific retrieval logic.\n     *\n     * @param _query - The query string used to search for relevant documents.\n     * @param _callbacks - (optional) Callback manager for managing callbacks\n     *                     during retrieval.\n     * @returns A promise resolving to an array of `DocumentInterface` instances relevant to the query.\n     * @throws {Error} Throws an error indicating the method is not implemented.\n     */\n    _getRelevantDocuments(_query, _callbacks) {\n        throw new Error(\"Not implemented!\");\n    }\n    /**\n     * Executes a retrieval operation.\n     *\n     * @param input - The query string used to search for relevant documents.\n     * @param options - (optional) Configuration options for the retrieval run,\n     *                  which may include callbacks, tags, and metadata.\n     * @returns A promise that resolves to an array of `DocumentInterface` instances\n     *          representing the most relevant documents to the query.\n     */\n    async invoke(input, options) {\n        return this.getRelevantDocuments(input, (0, config_js_1.ensureConfig)(options));\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     *\n     * Main method used to retrieve relevant documents. It takes a query\n     * string and an optional configuration object, and returns a promise that\n     * resolves to an array of `Document` objects. This method handles the\n     * retrieval process, including starting and ending callbacks, and error\n     * handling.\n     * @param query The query string to retrieve relevant documents for.\n     * @param config Optional configuration object for the retrieval process.\n     * @returns A promise that resolves to an array of `Document` objects.\n     */\n    async getRelevantDocuments(query, config) {\n        const parsedConfig = (0, config_js_1.ensureConfig)((0, manager_js_1.parseCallbackConfigArg)(config));\n        const callbackManager_ = await manager_js_1.CallbackManager.configure(parsedConfig.callbacks, this.callbacks, parsedConfig.tags, this.tags, parsedConfig.metadata, this.metadata, { verbose: this.verbose });\n        const runManager = await callbackManager_?.handleRetrieverStart(this.toJSON(), query, parsedConfig.runId, undefined, undefined, undefined, parsedConfig.runName);\n        try {\n            const results = await this._getRelevantDocuments(query, runManager);\n            await runManager?.handleRetrieverEnd(results);\n            return results;\n        }\n        catch (error) {\n            await runManager?.handleRetrieverError(error);\n            throw error;\n        }\n    }\n}\nexports.BaseRetriever = BaseRetriever;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcmV0cmlldmVycy9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLHFCQUFxQixtQkFBTyxDQUFDLGlHQUEwQjtBQUN2RCxrQkFBa0IsbUJBQU8sQ0FBQywyRkFBdUI7QUFDakQsb0JBQW9CLG1CQUFPLENBQUMsK0ZBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRMQUE0TCx1QkFBdUI7QUFDbk47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcmV0cmlldmVycy9pbmRleC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhc2VSZXRyaWV2ZXIgPSB2b2lkIDA7XG5jb25zdCBtYW5hZ2VyX2pzXzEgPSByZXF1aXJlKFwiLi4vY2FsbGJhY2tzL21hbmFnZXIuY2pzXCIpO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4uL3J1bm5hYmxlcy9iYXNlLmNqc1wiKTtcbmNvbnN0IGNvbmZpZ19qc18xID0gcmVxdWlyZShcIi4uL3J1bm5hYmxlcy9jb25maWcuY2pzXCIpO1xuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBhIGRvY3VtZW50IHJldHJpZXZhbCBzeXN0ZW0sIGRlc2lnbmVkIHRvXG4gKiBwcm9jZXNzIHN0cmluZyBxdWVyaWVzIGFuZCByZXR1cm4gdGhlIG1vc3QgcmVsZXZhbnQgZG9jdW1lbnRzIGZyb20gYSBzb3VyY2UuXG4gKlxuICogYEJhc2VSZXRyaWV2ZXJgIHByb3ZpZGVzIGNvbW1vbiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciBkZXJpdmVkIHJldHJpZXZlcnMsXG4gKiBzdWNoIGFzIGNhbGxiYWNrcywgdGFnZ2luZywgYW5kIHZlcmJvc2UgbG9nZ2luZy4gQ3VzdG9tIHJldHJpZXZhbCBzeXN0ZW1zXG4gKiBzaG91bGQgZXh0ZW5kIHRoaXMgY2xhc3MgYW5kIGltcGxlbWVudCBgX2dldFJlbGV2YW50RG9jdW1lbnRzYCB0byBkZWZpbmVcbiAqIHRoZSBzcGVjaWZpYyByZXRyaWV2YWwgbG9naWMuXG4gKlxuICogQHRlbXBsYXRlIE1ldGFkYXRhIC0gVGhlIHR5cGUgb2YgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIGVhY2ggZG9jdW1lbnQsXG4gKiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0aW5nIHRvIGBSZWNvcmQ8c3RyaW5nLCBhbnk+YC5cbiAqL1xuY2xhc3MgQmFzZVJldHJpZXZlciBleHRlbmRzIGJhc2VfanNfMS5SdW5uYWJsZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBgQmFzZVJldHJpZXZlcmAgaW5zdGFuY2Ugd2l0aCBvcHRpb25hbCBjb25maWd1cmF0aW9uIGZpZWxkcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWVsZHMgLSBPcHRpb25hbCBpbnB1dCBjb25maWd1cmF0aW9uIHRoYXQgY2FuIGluY2x1ZGUgYGNhbGxiYWNrc2AsXG4gICAgICogICAgICAgICAgICAgICAgIGB0YWdzYCwgYG1ldGFkYXRhYCwgYW5kIGB2ZXJib3NlYCBzZXR0aW5ncyBmb3IgY3VzdG9tIHJldHJpZXZlciBiZWhhdmlvci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbmFsIGNhbGxiYWNrcyB0byBoYW5kbGUgdmFyaW91cyBldmVudHMgaW4gdGhlIHJldHJpZXZhbCBwcm9jZXNzLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FsbGJhY2tzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWdzIHRvIGxhYmVsIG9yIGNhdGVnb3JpemUgdGhlIHJldHJpZXZhbCBvcGVyYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRhZGF0YSB0byBwcm92aWRlIGFkZGl0aW9uYWwgY29udGV4dCBvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmV0cmlldmFsXG4gICAgICAgICAqIG9wZXJhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldGFkYXRhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQgdG8gYHRydWVgLCBlbmFibGVzIHZlcmJvc2UgbG9nZ2luZyBmb3IgdGhlIHJldHJpZXZhbCBwcm9jZXNzLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmVyYm9zZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IGZpZWxkcz8uY2FsbGJhY2tzO1xuICAgICAgICB0aGlzLnRhZ3MgPSBmaWVsZHM/LnRhZ3MgPz8gW107XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBmaWVsZHM/Lm1ldGFkYXRhID8/IHt9O1xuICAgICAgICB0aGlzLnZlcmJvc2UgPSBmaWVsZHM/LnZlcmJvc2UgPz8gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRPRE86IFRoaXMgc2hvdWxkIGJlIGFuIGFic3RyYWN0IG1ldGhvZCwgYnV0IHdlJ2QgbGlrZSB0byBhdm9pZCBicmVha2luZ1xuICAgICAqIGNoYW5nZXMgdG8gcGVvcGxlIGN1cnJlbnRseSB1c2luZyBzdWJjbGFzc2VkIGN1c3RvbSByZXRyaWV2ZXJzLlxuICAgICAqIENoYW5nZSBpdCBvbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUGxhY2Vob2xkZXIgbWV0aG9kIGZvciByZXRyaWV2aW5nIHJlbGV2YW50IGRvY3VtZW50cyBiYXNlZCBvbiBhIHF1ZXJ5LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgaW50ZW5kZWQgdG8gYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3NlcyBhbmQgd2lsbCBiZVxuICAgICAqIGNvbnZlcnRlZCB0byBhbiBhYnN0cmFjdCBtZXRob2QgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4gQ3VycmVudGx5LCBpdFxuICAgICAqIHRocm93cyBhbiBlcnJvciBpZiBub3QgaW1wbGVtZW50ZWQsIGVuc3VyaW5nIHRoYXQgY3VzdG9tIHJldHJpZXZlcnMgZGVmaW5lXG4gICAgICogdGhlIHNwZWNpZmljIHJldHJpZXZhbCBsb2dpYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBfcXVlcnkgLSBUaGUgcXVlcnkgc3RyaW5nIHVzZWQgdG8gc2VhcmNoIGZvciByZWxldmFudCBkb2N1bWVudHMuXG4gICAgICogQHBhcmFtIF9jYWxsYmFja3MgLSAob3B0aW9uYWwpIENhbGxiYWNrIG1hbmFnZXIgZm9yIG1hbmFnaW5nIGNhbGxiYWNrc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgZHVyaW5nIHJldHJpZXZhbC5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgcmVzb2x2aW5nIHRvIGFuIGFycmF5IG9mIGBEb2N1bWVudEludGVyZmFjZWAgaW5zdGFuY2VzIHJlbGV2YW50IHRvIHRoZSBxdWVyeS5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gVGhyb3dzIGFuIGVycm9yIGluZGljYXRpbmcgdGhlIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXG4gICAgICovXG4gICAgX2dldFJlbGV2YW50RG9jdW1lbnRzKF9xdWVyeSwgX2NhbGxiYWNrcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQhXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyBhIHJldHJpZXZhbCBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgLSBUaGUgcXVlcnkgc3RyaW5nIHVzZWQgdG8gc2VhcmNoIGZvciByZWxldmFudCBkb2N1bWVudHMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSAob3B0aW9uYWwpIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHJldHJpZXZhbCBydW4sXG4gICAgICogICAgICAgICAgICAgICAgICB3aGljaCBtYXkgaW5jbHVkZSBjYWxsYmFja3MsIHRhZ3MsIGFuZCBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhcnJheSBvZiBgRG9jdW1lbnRJbnRlcmZhY2VgIGluc3RhbmNlc1xuICAgICAqICAgICAgICAgIHJlcHJlc2VudGluZyB0aGUgbW9zdCByZWxldmFudCBkb2N1bWVudHMgdG8gdGhlIHF1ZXJ5LlxuICAgICAqL1xuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZWxldmFudERvY3VtZW50cyhpbnB1dCwgKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgLmludm9rZSgpIGluc3RlYWQuIFdpbGwgYmUgcmVtb3ZlZCBpbiAwLjMuMC5cbiAgICAgKlxuICAgICAqIE1haW4gbWV0aG9kIHVzZWQgdG8gcmV0cmlldmUgcmVsZXZhbnQgZG9jdW1lbnRzLiBJdCB0YWtlcyBhIHF1ZXJ5XG4gICAgICogc3RyaW5nIGFuZCBhbiBvcHRpb25hbCBjb25maWd1cmF0aW9uIG9iamVjdCwgYW5kIHJldHVybnMgYSBwcm9taXNlIHRoYXRcbiAgICAgKiByZXNvbHZlcyB0byBhbiBhcnJheSBvZiBgRG9jdW1lbnRgIG9iamVjdHMuIFRoaXMgbWV0aG9kIGhhbmRsZXMgdGhlXG4gICAgICogcmV0cmlldmFsIHByb2Nlc3MsIGluY2x1ZGluZyBzdGFydGluZyBhbmQgZW5kaW5nIGNhbGxiYWNrcywgYW5kIGVycm9yXG4gICAgICogaGFuZGxpbmcuXG4gICAgICogQHBhcmFtIHF1ZXJ5IFRoZSBxdWVyeSBzdHJpbmcgdG8gcmV0cmlldmUgcmVsZXZhbnQgZG9jdW1lbnRzIGZvci5cbiAgICAgKiBAcGFyYW0gY29uZmlnIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgcmV0cmlldmFsIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gYXJyYXkgb2YgYERvY3VtZW50YCBvYmplY3RzLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFJlbGV2YW50RG9jdW1lbnRzKHF1ZXJ5LCBjb25maWcpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkQ29uZmlnID0gKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykoKDAsIG1hbmFnZXJfanNfMS5wYXJzZUNhbGxiYWNrQ29uZmlnQXJnKShjb25maWcpKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0IG1hbmFnZXJfanNfMS5DYWxsYmFja01hbmFnZXIuY29uZmlndXJlKHBhcnNlZENvbmZpZy5jYWxsYmFja3MsIHRoaXMuY2FsbGJhY2tzLCBwYXJzZWRDb25maWcudGFncywgdGhpcy50YWdzLCBwYXJzZWRDb25maWcubWV0YWRhdGEsIHRoaXMubWV0YWRhdGEsIHsgdmVyYm9zZTogdGhpcy52ZXJib3NlIH0pO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VyID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlUmV0cmlldmVyU3RhcnQodGhpcy50b0pTT04oKSwgcXVlcnksIHBhcnNlZENvbmZpZy5ydW5JZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgcGFyc2VkQ29uZmlnLnJ1bk5hbWUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuX2dldFJlbGV2YW50RG9jdW1lbnRzKHF1ZXJ5LCBydW5NYW5hZ2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZVJldHJpZXZlckVuZChyZXN1bHRzKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlUmV0cmlldmVyRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkJhc2VSZXRyaWV2ZXIgPSBCYXNlUmV0cmlldmVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/retrievers/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/base.cjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RunnableToolLike = exports.RunnablePick = exports.RunnableAssign = exports.RunnableWithFallbacks = exports.RunnableParallel = exports.RunnableLambda = exports.RunnableTraceable = exports.RunnableMap = exports.RunnableSequence = exports.RunnableRetry = exports.RunnableEach = exports.RunnableBinding = exports.Runnable = void 0;\nexports._coerceToDict = _coerceToDict;\nexports._coerceToRunnable = _coerceToRunnable;\nexports.convertRunnableToTool = convertRunnableToTool;\nconst v3_1 = __webpack_require__(/*! zod/v3 */ \"(rsc)/./node_modules/zod/v3/index.cjs\");\nconst p_retry_1 = __importDefault(__webpack_require__(/*! p-retry */ \"(rsc)/./node_modules/p-retry/index.js\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/index.js\");\nconst traceable_1 = __webpack_require__(/*! langsmith/singletons/traceable */ \"(rsc)/./node_modules/langsmith/singletons/traceable.cjs\");\nconst log_stream_js_1 = __webpack_require__(/*! ../tracers/log_stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/log_stream.cjs\");\nconst event_stream_js_1 = __webpack_require__(/*! ../tracers/event_stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/event_stream.cjs\");\nconst serializable_js_1 = __webpack_require__(/*! ../load/serializable.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.cjs\");\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\nconst signal_js_1 = __webpack_require__(/*! ../utils/signal.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/signal.cjs\");\nconst config_js_1 = __webpack_require__(/*! ./config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\nconst async_caller_js_1 = __webpack_require__(/*! ../utils/async_caller.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.cjs\");\nconst root_listener_js_1 = __webpack_require__(/*! ../tracers/root_listener.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/root_listener.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/utils.cjs\");\nconst index_js_1 = __webpack_require__(/*! ../singletons/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/index.cjs\");\nconst graph_js_1 = __webpack_require__(/*! ./graph.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/graph.cjs\");\nconst wrappers_js_1 = __webpack_require__(/*! ./wrappers.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/wrappers.cjs\");\nconst iter_js_1 = __webpack_require__(/*! ./iter.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/iter.cjs\");\nconst utils_js_2 = __webpack_require__(/*! ../tools/utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tools/utils.cjs\");\nconst zod_js_1 = __webpack_require__(/*! ../utils/types/zod.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.cjs\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n    return value &&\n        !Array.isArray(value) &&\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        !(value instanceof Date) &&\n        typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\n/**\n * A Runnable is a generic unit of work that can be invoked, batched, streamed, and/or\n * transformed.\n */\nclass Runnable extends serializable_js_1.Serializable {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    getName(suffix) {\n        const name = \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.name ?? this.constructor.lc_name() ?? this.constructor.name;\n        return suffix ? `${name}${suffix}` : name;\n    }\n    /**\n     * Bind arguments to a Runnable, returning a new Runnable.\n     * @param kwargs\n     * @returns A new RunnableBinding that, when invoked, will apply the bound args.\n     *\n     * @deprecated Use {@link withConfig} instead. This will be removed in the next breaking release.\n     */\n    bind(kwargs) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({ bound: this, kwargs, config: {} });\n    }\n    /**\n     * Return a new Runnable that maps a list of inputs to a list of outputs,\n     * by calling invoke() with each input.\n     *\n     * @deprecated This will be removed in the next breaking release.\n     */\n    map() {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableEach({ bound: this });\n    }\n    /**\n     * Add retry logic to an existing runnable.\n     * @param fields.stopAfterAttempt The number of attempts to retry.\n     * @param fields.onFailedAttempt A function that is called when a retry fails.\n     * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.\n     */\n    withRetry(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableRetry({\n            bound: this,\n            kwargs: {},\n            config: {},\n            maxAttemptNumber: fields?.stopAfterAttempt,\n            ...fields,\n        });\n    }\n    /**\n     * Bind config to a Runnable, returning a new Runnable.\n     * @param config New configuration parameters to attach to the new runnable.\n     * @returns A new RunnableBinding with a config matching what's passed.\n     */\n    withConfig(config) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({\n            bound: this,\n            config,\n            kwargs: {},\n        });\n    }\n    /**\n     * Create a new runnable from the current one that will try invoking\n     * other passed fallback runnables if the initial invocation fails.\n     * @param fields.fallbacks Other runnables to call if the runnable errors.\n     * @returns A new RunnableWithFallbacks.\n     */\n    withFallbacks(fields) {\n        const fallbacks = Array.isArray(fields) ? fields : fields.fallbacks;\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableWithFallbacks({\n            runnable: this,\n            fallbacks,\n        });\n    }\n    _getOptionsList(options, length = 0) {\n        if (Array.isArray(options) && options.length !== length) {\n            throw new Error(`Passed \"options\" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);\n        }\n        if (Array.isArray(options)) {\n            return options.map(config_js_1.ensureConfig);\n        }\n        if (length > 1 && !Array.isArray(options) && options.runId) {\n            console.warn(\"Provided runId will be used only for the first element of the batch.\");\n            const subsequent = Object.fromEntries(Object.entries(options).filter(([key]) => key !== \"runId\"));\n            return Array.from({ length }, (_, i) => (0, config_js_1.ensureConfig)(i === 0 ? options : subsequent));\n        }\n        return Array.from({ length }, () => (0, config_js_1.ensureConfig)(options));\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const maxConcurrency = configList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n        const caller = new async_caller_js_1.AsyncCaller({\n            maxConcurrency,\n            onFailedAttempt: (e) => {\n                throw e;\n            },\n        });\n        const batchCalls = inputs.map((input, i) => caller.call(async () => {\n            try {\n                const result = await this.invoke(input, configList[i]);\n                return result;\n            }\n            catch (e) {\n                if (batchOptions?.returnExceptions) {\n                    return e;\n                }\n                throw e;\n            }\n        }));\n        return Promise.all(batchCalls);\n    }\n    /**\n     * Default streaming implementation.\n     * Subclasses should override this method if they support streaming output.\n     * @param input\n     * @param options\n     */\n    async *_streamIterator(input, options) {\n        yield this.invoke(input, options);\n    }\n    /**\n     * Stream output in chunks.\n     * @param input\n     * @param options\n     * @returns A readable stream that is also an iterable.\n     */\n    async stream(input, options) {\n        // Buffer the first streamed chunk to allow for initial errors\n        // to surface immediately.\n        const config = (0, config_js_1.ensureConfig)(options);\n        const wrappedGenerator = new stream_js_1.AsyncGeneratorWithSetup({\n            generator: this._streamIterator(input, config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return stream_js_1.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n    _separateRunnableConfigFromCallOptions(options) {\n        let runnableConfig;\n        if (options === undefined) {\n            runnableConfig = (0, config_js_1.ensureConfig)(options);\n        }\n        else {\n            runnableConfig = (0, config_js_1.ensureConfig)({\n                callbacks: options.callbacks,\n                tags: options.tags,\n                metadata: options.metadata,\n                runName: options.runName,\n                configurable: options.configurable,\n                recursionLimit: options.recursionLimit,\n                maxConcurrency: options.maxConcurrency,\n                runId: options.runId,\n                timeout: options.timeout,\n                signal: options.signal,\n            });\n        }\n        const callOptions = { ...options };\n        delete callOptions.callbacks;\n        delete callOptions.tags;\n        delete callOptions.metadata;\n        delete callOptions.runName;\n        delete callOptions.configurable;\n        delete callOptions.recursionLimit;\n        delete callOptions.maxConcurrency;\n        delete callOptions.runId;\n        delete callOptions.timeout;\n        delete callOptions.signal;\n        return [runnableConfig, callOptions];\n    }\n    async _callWithConfig(func, input, options) {\n        const config = (0, config_js_1.ensureConfig)(options);\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config.runId, config?.runType, undefined, undefined, config?.runName ?? this.getName());\n        delete config.runId;\n        let output;\n        try {\n            const promise = func.call(this, input, config, runManager);\n            output = await (0, signal_js_1.raceWithSignal)(promise, options?.signal);\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n        return output;\n    }\n    /**\n     * Internal method that handles batching and configuration for a runnable\n     * It takes a function, input values, and optional configuration, and\n     * returns a promise that resolves to the output values.\n     * @param func The function to be executed for each input value.\n     * @param input The input values to be processed.\n     * @param config Optional configuration for the function execution.\n     * @returns A promise that resolves to the output values.\n     */\n    async _batchWithConfig(func, inputs, options, batchOptions) {\n        const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(optionsList.map(config_js_1.getCallbackManagerForConfig));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), optionsList[i].runId, optionsList[i].runType, undefined, undefined, optionsList[i].runName ?? this.getName());\n            delete optionsList[i].runId;\n            return handleStartRes;\n        }));\n        let outputs;\n        try {\n            const promise = func.call(this, inputs, optionsList, runManagers, batchOptions);\n            outputs = await (0, signal_js_1.raceWithSignal)(promise, optionsList?.[0]?.signal);\n        }\n        catch (e) {\n            await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));\n            throw e;\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict(outputs, \"output\"))));\n        return outputs;\n    }\n    /** @internal */\n    _concatOutputChunks(first, second) {\n        return (0, stream_js_1.concat)(first, second);\n    }\n    /**\n     * Helper method to transform an Iterator of Input values into an Iterator of\n     * Output values, with callbacks.\n     * Use this to implement `stream()` or `transform()` in Runnable subclasses.\n     */\n    async *_transformStreamWithConfig(inputGenerator, transformer, options) {\n        let finalInput;\n        let finalInputSupported = true;\n        let finalOutput;\n        let finalOutputSupported = true;\n        const config = (0, config_js_1.ensureConfig)(options);\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(config);\n        const outerThis = this;\n        async function* wrapInputForTracing() {\n            for await (const chunk of inputGenerator) {\n                if (finalInputSupported) {\n                    if (finalInput === undefined) {\n                        finalInput = chunk;\n                    }\n                    else {\n                        try {\n                            finalInput = outerThis._concatOutputChunks(finalInput, \n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            chunk);\n                        }\n                        catch {\n                            finalInput = undefined;\n                            finalInputSupported = false;\n                        }\n                    }\n                }\n                yield chunk;\n            }\n        }\n        let runManager;\n        try {\n            const pipe = await (0, stream_js_1.pipeGeneratorWithSetup)(transformer.bind(this), wrapInputForTracing(), async () => callbackManager_?.handleChainStart(this.toJSON(), { input: \"\" }, config.runId, config.runType, undefined, undefined, config.runName ?? this.getName()), options?.signal, config);\n            delete config.runId;\n            runManager = pipe.setup;\n            const streamEventsHandler = runManager?.handlers.find(event_stream_js_1.isStreamEventsHandler);\n            let iterator = pipe.output;\n            if (streamEventsHandler !== undefined && runManager !== undefined) {\n                iterator = streamEventsHandler.tapOutputIterable(runManager.runId, iterator);\n            }\n            const streamLogHandler = runManager?.handlers.find(log_stream_js_1.isLogStreamHandler);\n            if (streamLogHandler !== undefined && runManager !== undefined) {\n                iterator = streamLogHandler.tapOutputIterable(runManager.runId, iterator);\n            }\n            for await (const chunk of iterator) {\n                yield chunk;\n                if (finalOutputSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = chunk;\n                    }\n                    else {\n                        try {\n                            finalOutput = this._concatOutputChunks(finalOutput, \n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            chunk);\n                        }\n                        catch {\n                            finalOutput = undefined;\n                            finalOutputSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e, undefined, undefined, undefined, {\n                inputs: _coerceToDict(finalInput, \"input\"),\n            });\n            throw e;\n        }\n        await runManager?.handleChainEnd(finalOutput ?? {}, undefined, undefined, undefined, { inputs: _coerceToDict(finalInput, \"input\") });\n    }\n    getGraph(_) {\n        const graph = new graph_js_1.Graph();\n        // TODO: Add input schema for runnables\n        const inputNode = graph.addNode({\n            name: `${this.getName()}Input`,\n            schema: v3_1.z.any(),\n        });\n        const runnableNode = graph.addNode(this);\n        // TODO: Add output schemas for runnables\n        const outputNode = graph.addNode({\n            name: `${this.getName()}Output`,\n            schema: v3_1.z.any(),\n        });\n        graph.addEdge(inputNode, runnableNode);\n        graph.addEdge(runnableNode, outputNode);\n        return graph;\n    }\n    /**\n     * Create a new runnable sequence that runs each individual runnable in series,\n     * piping the output of one runnable into another runnable or runnable-like.\n     * @param coerceable A runnable, function, or object whose values are functions or runnables.\n     * @returns A new runnable sequence.\n     */\n    pipe(coerceable) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableSequence({\n            first: this,\n            last: _coerceToRunnable(coerceable),\n        });\n    }\n    /**\n     * Pick keys from the dict output of this runnable. Returns a new runnable.\n     */\n    pick(keys) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return this.pipe(new RunnablePick(keys));\n    }\n    /**\n     * Assigns new fields to the dict output of this runnable. Returns a new runnable.\n     */\n    assign(mapping) {\n        return this.pipe(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new RunnableAssign(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new RunnableMap({ steps: mapping })));\n    }\n    /**\n     * Default implementation of transform, which buffers input and then calls stream.\n     * Subclasses should override this method if they can start producing output while\n     * input is still being generated.\n     * @param generator\n     * @param options\n     */\n    async *transform(generator, options) {\n        let finalChunk;\n        for await (const chunk of generator) {\n            if (finalChunk === undefined) {\n                finalChunk = chunk;\n            }\n            else {\n                // Make a best effort to gather, for any type that supports concat.\n                // This method should throw an error if gathering fails.\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                finalChunk = this._concatOutputChunks(finalChunk, chunk);\n            }\n        }\n        yield* this._streamIterator(finalChunk, (0, config_js_1.ensureConfig)(options));\n    }\n    /**\n     * Stream all output from a runnable, as reported to the callback system.\n     * This includes all inner runs of LLMs, Retrievers, Tools, etc.\n     * Output is streamed as Log objects, which include a list of\n     * jsonpatch ops that describe how the state of the run has changed in each\n     * step, and the final state of the run.\n     * The jsonpatch ops can be applied in order to construct state.\n     * @param input\n     * @param options\n     * @param streamOptions\n     */\n    async *streamLog(input, options, streamOptions) {\n        const logStreamCallbackHandler = new log_stream_js_1.LogStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n            _schemaFormat: \"original\",\n        });\n        const config = (0, config_js_1.ensureConfig)(options);\n        yield* this._streamLog(input, logStreamCallbackHandler, config);\n    }\n    async *_streamLog(input, logStreamCallbackHandler, config) {\n        const { callbacks } = config;\n        if (callbacks === undefined) {\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = [logStreamCallbackHandler];\n        }\n        else if (Array.isArray(callbacks)) {\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = callbacks.concat([logStreamCallbackHandler]);\n        }\n        else {\n            const copiedCallbacks = callbacks.copy();\n            copiedCallbacks.addHandler(logStreamCallbackHandler, true);\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = copiedCallbacks;\n        }\n        const runnableStreamPromise = this.stream(input, config);\n        async function consumeRunnableStream() {\n            try {\n                const runnableStream = await runnableStreamPromise;\n                for await (const chunk of runnableStream) {\n                    const patch = new log_stream_js_1.RunLogPatch({\n                        ops: [\n                            {\n                                op: \"add\",\n                                path: \"/streamed_output/-\",\n                                value: chunk,\n                            },\n                        ],\n                    });\n                    await logStreamCallbackHandler.writer.write(patch);\n                }\n            }\n            finally {\n                await logStreamCallbackHandler.writer.close();\n            }\n        }\n        const runnableStreamConsumePromise = consumeRunnableStream();\n        try {\n            for await (const log of logStreamCallbackHandler) {\n                yield log;\n            }\n        }\n        finally {\n            await runnableStreamConsumePromise;\n        }\n    }\n    streamEvents(input, options, streamOptions) {\n        let stream;\n        if (options.version === \"v1\") {\n            stream = this._streamEventsV1(input, options, streamOptions);\n        }\n        else if (options.version === \"v2\") {\n            stream = this._streamEventsV2(input, options, streamOptions);\n        }\n        else {\n            throw new Error(`Only versions \"v1\" and \"v2\" of the schema are currently supported.`);\n        }\n        if (options.encoding === \"text/event-stream\") {\n            return (0, wrappers_js_1.convertToHttpEventStream)(stream);\n        }\n        else {\n            return stream_js_1.IterableReadableStream.fromAsyncGenerator(stream);\n        }\n    }\n    async *_streamEventsV2(input, options, streamOptions) {\n        const eventStreamer = new event_stream_js_1.EventStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n        });\n        const config = (0, config_js_1.ensureConfig)(options);\n        const runId = config.runId ?? (0, uuid_1.v4)();\n        config.runId = runId;\n        const callbacks = config.callbacks;\n        if (callbacks === undefined) {\n            config.callbacks = [eventStreamer];\n        }\n        else if (Array.isArray(callbacks)) {\n            config.callbacks = callbacks.concat(eventStreamer);\n        }\n        else {\n            const copiedCallbacks = callbacks.copy();\n            copiedCallbacks.addHandler(eventStreamer, true);\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = copiedCallbacks;\n        }\n        const abortController = new AbortController();\n        // Call the runnable in streaming mode,\n        // add each chunk to the output stream\n        const outerThis = this;\n        async function consumeRunnableStream() {\n            let signal;\n            let listener = null;\n            try {\n                if (options?.signal) {\n                    if (\"any\" in AbortSignal) {\n                        // Use native AbortSignal.any() if available (Node 19+)\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        signal = AbortSignal.any([\n                            abortController.signal,\n                            options.signal,\n                        ]);\n                    }\n                    else {\n                        // Fallback for Node 18 and below - just use the provided signal\n                        signal = options.signal;\n                        // Ensure we still abort our controller when the parent signal aborts\n                        listener = () => {\n                            abortController.abort();\n                        };\n                        options.signal.addEventListener(\"abort\", listener, { once: true });\n                    }\n                }\n                else {\n                    signal = abortController.signal;\n                }\n                const runnableStream = await outerThis.stream(input, {\n                    ...config,\n                    signal,\n                });\n                const tappedStream = eventStreamer.tapOutputIterable(runId, runnableStream);\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                for await (const _ of tappedStream) {\n                    // Just iterate so that the callback handler picks up events\n                    if (abortController.signal.aborted)\n                        break;\n                }\n            }\n            finally {\n                await eventStreamer.finish();\n                if (signal && listener) {\n                    signal.removeEventListener(\"abort\", listener);\n                }\n            }\n        }\n        const runnableStreamConsumePromise = consumeRunnableStream();\n        let firstEventSent = false;\n        let firstEventRunId;\n        try {\n            for await (const event of eventStreamer) {\n                // This is a work-around an issue where the inputs into the\n                // chain are not available until the entire input is consumed.\n                // As a temporary solution, we'll modify the input to be the input\n                // that was passed into the chain.\n                if (!firstEventSent) {\n                    event.data.input = input;\n                    firstEventSent = true;\n                    firstEventRunId = event.run_id;\n                    yield event;\n                    continue;\n                }\n                if (event.run_id === firstEventRunId && event.event.endsWith(\"_end\")) {\n                    // If it's the end event corresponding to the root runnable\n                    // we dont include the input in the event since it's guaranteed\n                    // to be included in the first event.\n                    if (event.data?.input) {\n                        delete event.data.input;\n                    }\n                }\n                yield event;\n            }\n        }\n        finally {\n            abortController.abort();\n            await runnableStreamConsumePromise;\n        }\n    }\n    async *_streamEventsV1(input, options, streamOptions) {\n        let runLog;\n        let hasEncounteredStartEvent = false;\n        const config = (0, config_js_1.ensureConfig)(options);\n        const rootTags = config.tags ?? [];\n        const rootMetadata = config.metadata ?? {};\n        const rootName = config.runName ?? this.getName();\n        const logStreamCallbackHandler = new log_stream_js_1.LogStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n            _schemaFormat: \"streaming_events\",\n        });\n        const rootEventFilter = new utils_js_1._RootEventFilter({\n            ...streamOptions,\n        });\n        const logStream = this._streamLog(input, logStreamCallbackHandler, config);\n        for await (const log of logStream) {\n            if (!runLog) {\n                runLog = log_stream_js_1.RunLog.fromRunLogPatch(log);\n            }\n            else {\n                runLog = runLog.concat(log);\n            }\n            if (runLog.state === undefined) {\n                throw new Error(`Internal error: \"streamEvents\" state is missing. Please open a bug report.`);\n            }\n            // Yield the start event for the root runnable if it hasn't been seen.\n            // The root run is never filtered out\n            if (!hasEncounteredStartEvent) {\n                hasEncounteredStartEvent = true;\n                const state = { ...runLog.state };\n                const event = {\n                    run_id: state.id,\n                    event: `on_${state.type}_start`,\n                    name: rootName,\n                    tags: rootTags,\n                    metadata: rootMetadata,\n                    data: {\n                        input,\n                    },\n                };\n                if (rootEventFilter.includeEvent(event, state.type)) {\n                    yield event;\n                }\n            }\n            const paths = log.ops\n                .filter((op) => op.path.startsWith(\"/logs/\"))\n                .map((op) => op.path.split(\"/\")[2]);\n            const dedupedPaths = [...new Set(paths)];\n            for (const path of dedupedPaths) {\n                let eventType;\n                let data = {};\n                const logEntry = runLog.state.logs[path];\n                if (logEntry.end_time === undefined) {\n                    if (logEntry.streamed_output.length > 0) {\n                        eventType = \"stream\";\n                    }\n                    else {\n                        eventType = \"start\";\n                    }\n                }\n                else {\n                    eventType = \"end\";\n                }\n                if (eventType === \"start\") {\n                    // Include the inputs with the start event if they are available.\n                    // Usually they will NOT be available for components that operate\n                    // on streams, since those components stream the input and\n                    // don't know its final value until the end of the stream.\n                    if (logEntry.inputs !== undefined) {\n                        data.input = logEntry.inputs;\n                    }\n                }\n                else if (eventType === \"end\") {\n                    if (logEntry.inputs !== undefined) {\n                        data.input = logEntry.inputs;\n                    }\n                    data.output = logEntry.final_output;\n                }\n                else if (eventType === \"stream\") {\n                    const chunkCount = logEntry.streamed_output.length;\n                    if (chunkCount !== 1) {\n                        throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${logEntry.name}\"`);\n                    }\n                    data = { chunk: logEntry.streamed_output[0] };\n                    // Clean up the stream, we don't need it anymore.\n                    // And this avoids duplicates as well!\n                    logEntry.streamed_output = [];\n                }\n                yield {\n                    event: `on_${logEntry.type}_${eventType}`,\n                    name: logEntry.name,\n                    run_id: logEntry.id,\n                    tags: logEntry.tags,\n                    metadata: logEntry.metadata,\n                    data,\n                };\n            }\n            // Finally, we take care of the streaming output from the root chain\n            // if there is any.\n            const { state } = runLog;\n            if (state.streamed_output.length > 0) {\n                const chunkCount = state.streamed_output.length;\n                if (chunkCount !== 1) {\n                    throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${state.name}\"`);\n                }\n                const data = { chunk: state.streamed_output[0] };\n                // Clean up the stream, we don't need it anymore.\n                state.streamed_output = [];\n                const event = {\n                    event: `on_${state.type}_stream`,\n                    run_id: state.id,\n                    tags: rootTags,\n                    metadata: rootMetadata,\n                    name: rootName,\n                    data,\n                };\n                if (rootEventFilter.includeEvent(event, state.type)) {\n                    yield event;\n                }\n            }\n        }\n        const state = runLog?.state;\n        if (state !== undefined) {\n            // Finally, yield the end event for the root runnable.\n            const event = {\n                event: `on_${state.type}_end`,\n                name: rootName,\n                run_id: state.id,\n                tags: rootTags,\n                metadata: rootMetadata,\n                data: {\n                    output: state.final_output,\n                },\n            };\n            if (rootEventFilter.includeEvent(event, state.type))\n                yield event;\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnable(thing) {\n        return (0, utils_js_1.isRunnableInterface)(thing);\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({\n            bound: this,\n            config: {},\n            configFactories: [\n                (config) => ({\n                    callbacks: [\n                        new root_listener_js_1.RootListenersTracer({\n                            config,\n                            onStart,\n                            onEnd,\n                            onError,\n                        }),\n                    ],\n                }),\n            ],\n        });\n    }\n    /**\n     * Convert a runnable to a tool. Return a new instance of `RunnableToolLike`\n     * which contains the runnable, name, description and schema.\n     *\n     * @template {T extends RunInput = RunInput} RunInput - The input type of the runnable. Should be the same as the `RunInput` type of the runnable.\n     *\n     * @param fields\n     * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.\n     * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.\n     * @param {z.ZodType<T>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.\n     * @returns {RunnableToolLike<z.ZodType<T>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.\n     */\n    asTool(fields) {\n        return convertRunnableToTool(this, fields);\n    }\n}\nexports.Runnable = Runnable;\n/**\n * Wraps a runnable and applies partial config upon invocation.\n *\n * @example\n * ```typescript\n * import {\n *   type RunnableConfig,\n *   RunnableLambda,\n * } from \"@langchain/core/runnables\";\n *\n * const enhanceProfile = (\n *   profile: Record<string, any>,\n *   config?: RunnableConfig\n * ) => {\n *   if (config?.configurable?.role) {\n *     return { ...profile, role: config.configurable.role };\n *   }\n *   return profile;\n * };\n *\n * const runnable = RunnableLambda.from(enhanceProfile);\n *\n * // Bind configuration to the runnable to set the user's role dynamically\n * const adminRunnable = runnable.bind({ configurable: { role: \"Admin\" } });\n * const userRunnable = runnable.bind({ configurable: { role: \"User\" } });\n *\n * const result1 = await adminRunnable.invoke({\n *   name: \"Alice\",\n *   email: \"alice@example.com\"\n * });\n *\n * // { name: \"Alice\", email: \"alice@example.com\", role: \"Admin\" }\n *\n * const result2 = await userRunnable.invoke({\n *   name: \"Bob\",\n *   email: \"bob@example.com\"\n * });\n *\n * // { name: \"Bob\", email: \"bob@example.com\", role: \"User\" }\n * ```\n */\nclass RunnableBinding extends Runnable {\n    static lc_name() {\n        return \"RunnableBinding\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"configFactories\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.bound = fields.bound;\n        this.kwargs = fields.kwargs;\n        this.config = fields.config;\n        this.configFactories = fields.configFactories;\n    }\n    getName(suffix) {\n        return this.bound.getName(suffix);\n    }\n    async _mergeConfig(...options) {\n        const config = (0, config_js_1.mergeConfigs)(this.config, ...options);\n        return (0, config_js_1.mergeConfigs)(config, ...(this.configFactories\n            ? await Promise.all(this.configFactories.map(async (configFactory) => await configFactory(config)))\n            : []));\n    }\n    /**\n     * Binds the runnable with the specified arguments.\n     * @param kwargs The arguments to bind the runnable with.\n     * @returns A new instance of the `RunnableBinding` class that is bound with the specified arguments.\n     *\n     * @deprecated Use {@link withConfig} instead. This will be removed in the next breaking release.\n     */\n    bind(kwargs) {\n        return new this.constructor({\n            bound: this.bound,\n            kwargs: { ...this.kwargs, ...kwargs },\n            config: this.config,\n        });\n    }\n    withConfig(config) {\n        return new this.constructor({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: { ...this.config, ...config },\n        });\n    }\n    withRetry(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableRetry({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: this.config,\n            maxAttemptNumber: fields?.stopAfterAttempt,\n            ...fields,\n        });\n    }\n    async invoke(input, options) {\n        return this.bound.invoke(input, await this._mergeConfig((0, config_js_1.ensureConfig)(options), this.kwargs));\n    }\n    async batch(inputs, options, batchOptions) {\n        const mergedOptions = Array.isArray(options)\n            ? await Promise.all(options.map(async (individualOption) => this._mergeConfig((0, config_js_1.ensureConfig)(individualOption), this.kwargs)))\n            : await this._mergeConfig((0, config_js_1.ensureConfig)(options), this.kwargs);\n        return this.bound.batch(inputs, mergedOptions, batchOptions);\n    }\n    /** @internal */\n    _concatOutputChunks(first, second) {\n        return this.bound._concatOutputChunks(first, second);\n    }\n    async *_streamIterator(input, options) {\n        yield* this.bound._streamIterator(input, await this._mergeConfig((0, config_js_1.ensureConfig)(options), this.kwargs));\n    }\n    async stream(input, options) {\n        return this.bound.stream(input, await this._mergeConfig((0, config_js_1.ensureConfig)(options), this.kwargs));\n    }\n    async *transform(generator, options) {\n        yield* this.bound.transform(generator, await this._mergeConfig((0, config_js_1.ensureConfig)(options), this.kwargs));\n    }\n    streamEvents(input, options, streamOptions) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const outerThis = this;\n        const generator = async function* () {\n            yield* outerThis.bound.streamEvents(input, {\n                ...(await outerThis._mergeConfig((0, config_js_1.ensureConfig)(options), outerThis.kwargs)),\n                version: options.version,\n            }, streamOptions);\n        };\n        return stream_js_1.IterableReadableStream.fromAsyncGenerator(generator());\n    }\n    static isRunnableBinding(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    thing\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        return thing.bound && Runnable.isRunnable(thing.bound);\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        return new RunnableBinding({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: this.config,\n            configFactories: [\n                (config) => ({\n                    callbacks: [\n                        new root_listener_js_1.RootListenersTracer({\n                            config,\n                            onStart,\n                            onEnd,\n                            onError,\n                        }),\n                    ],\n                }),\n            ],\n        });\n    }\n}\nexports.RunnableBinding = RunnableBinding;\n/**\n * A runnable that delegates calls to another runnable\n * with each element of the input sequence.\n * @example\n * ```typescript\n * import { RunnableEach, RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const toUpperCase = (input: string): string => input.toUpperCase();\n * const addGreeting = (input: string): string => `Hello, ${input}!`;\n *\n * const upperCaseLambda = RunnableLambda.from(toUpperCase);\n * const greetingLambda = RunnableLambda.from(addGreeting);\n *\n * const chain = new RunnableEach({\n *   bound: upperCaseLambda.pipe(greetingLambda),\n * });\n *\n * const result = await chain.invoke([\"alice\", \"bob\", \"carol\"])\n *\n * // [\"Hello, ALICE!\", \"Hello, BOB!\", \"Hello, CAROL!\"]\n * ```\n *\n * @deprecated This will be removed in the next breaking release.\n */\nclass RunnableEach extends Runnable {\n    static lc_name() {\n        return \"RunnableEach\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.bound = fields.bound;\n    }\n    /**\n     * Binds the runnable with the specified arguments.\n     * @param kwargs The arguments to bind the runnable with.\n     * @returns A new instance of the `RunnableEach` class that is bound with the specified arguments.\n     *\n     * @deprecated Use {@link withConfig} instead. This will be removed in the next breaking release.\n     */\n    bind(kwargs) {\n        return new RunnableEach({\n            bound: this.bound.bind(kwargs),\n        });\n    }\n    /**\n     * Invokes the runnable with the specified input and configuration.\n     * @param input The input to invoke the runnable with.\n     * @param config The configuration to invoke the runnable with.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async invoke(inputs, config) {\n        return this._callWithConfig(this._invoke.bind(this), inputs, config);\n    }\n    /**\n     * A helper method that is used to invoke the runnable with the specified input and configuration.\n     * @param input The input to invoke the runnable with.\n     * @param config The configuration to invoke the runnable with.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async _invoke(inputs, config, runManager) {\n        return this.bound.batch(inputs, (0, config_js_1.patchConfig)(config, { callbacks: runManager?.getChild() }));\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        return new RunnableEach({\n            bound: this.bound.withListeners({ onStart, onEnd, onError }),\n        });\n    }\n}\nexports.RunnableEach = RunnableEach;\n/**\n * Base class for runnables that can be retried a\n * specified number of times.\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableRetry,\n * } from \"@langchain/core/runnables\";\n *\n * // Simulate an API call that fails\n * const simulateApiCall = (input: string): string => {\n *   console.log(`Attempting API call with input: ${input}`);\n *   throw new Error(\"API call failed due to network issue\");\n * };\n *\n * const apiCallLambda = RunnableLambda.from(simulateApiCall);\n *\n * // Apply retry logic using the .withRetry() method\n * const apiCallWithRetry = apiCallLambda.withRetry({ stopAfterAttempt: 3 });\n *\n * // Alternatively, create a RunnableRetry instance manually\n * const manualRetry = new RunnableRetry({\n *   bound: apiCallLambda,\n *   maxAttemptNumber: 3,\n *   config: {},\n * });\n *\n * // Example invocation using the .withRetry() method\n * const res = await apiCallWithRetry\n *   .invoke(\"Request 1\")\n *   .catch((error) => {\n *     console.error(\"Failed after multiple retries:\", error.message);\n *   });\n *\n * // Example invocation using the manual retry instance\n * const res2 = await manualRetry\n *   .invoke(\"Request 2\")\n *   .catch((error) => {\n *     console.error(\"Failed after multiple retries:\", error.message);\n *   });\n * ```\n */\nclass RunnableRetry extends RunnableBinding {\n    static lc_name() {\n        return \"RunnableRetry\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"maxAttemptNumber\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 3\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"onFailedAttempt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: () => { }\n        });\n        this.maxAttemptNumber = fields.maxAttemptNumber ?? this.maxAttemptNumber;\n        this.onFailedAttempt = fields.onFailedAttempt ?? this.onFailedAttempt;\n    }\n    _patchConfigForRetry(attempt, config, runManager) {\n        const tag = attempt > 1 ? `retry:attempt:${attempt}` : undefined;\n        return (0, config_js_1.patchConfig)(config, { callbacks: runManager?.getChild(tag) });\n    }\n    async _invoke(input, config, runManager) {\n        return (0, p_retry_1.default)((attemptNumber) => super.invoke(input, this._patchConfigForRetry(attemptNumber, config, runManager)), {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onFailedAttempt: (error) => this.onFailedAttempt(error, input),\n            retries: Math.max(this.maxAttemptNumber - 1, 0),\n            randomize: true,\n        });\n    }\n    /**\n     * Method that invokes the runnable with the specified input, run manager,\n     * and config. It handles the retry logic by catching any errors and\n     * recursively invoking itself with the updated config for the next retry\n     * attempt.\n     * @param input The input for the runnable.\n     * @param runManager The run manager for the runnable.\n     * @param config The config for the runnable.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async invoke(input, config) {\n        return this._callWithConfig(this._invoke.bind(this), input, config);\n    }\n    async _batch(inputs, configs, runManagers, batchOptions) {\n        const resultsMap = {};\n        try {\n            await (0, p_retry_1.default)(async (attemptNumber) => {\n                const remainingIndexes = inputs\n                    .map((_, i) => i)\n                    .filter((i) => resultsMap[i.toString()] === undefined ||\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    resultsMap[i.toString()] instanceof Error);\n                const remainingInputs = remainingIndexes.map((i) => inputs[i]);\n                const patchedConfigs = remainingIndexes.map((i) => this._patchConfigForRetry(attemptNumber, configs?.[i], runManagers?.[i]));\n                const results = await super.batch(remainingInputs, patchedConfigs, {\n                    ...batchOptions,\n                    returnExceptions: true,\n                });\n                let firstException;\n                for (let i = 0; i < results.length; i += 1) {\n                    const result = results[i];\n                    const resultMapIndex = remainingIndexes[i];\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    if (result instanceof Error) {\n                        if (firstException === undefined) {\n                            firstException = result;\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            firstException.input = remainingInputs[i];\n                        }\n                    }\n                    resultsMap[resultMapIndex.toString()] = result;\n                }\n                if (firstException) {\n                    throw firstException;\n                }\n                return results;\n            }, {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                onFailedAttempt: (error) => this.onFailedAttempt(error, error.input),\n                retries: Math.max(this.maxAttemptNumber - 1, 0),\n                randomize: true,\n            });\n        }\n        catch (e) {\n            if (batchOptions?.returnExceptions !== true) {\n                throw e;\n            }\n        }\n        return Object.keys(resultsMap)\n            .sort((a, b) => parseInt(a, 10) - parseInt(b, 10))\n            .map((key) => resultsMap[parseInt(key, 10)]);\n    }\n    async batch(inputs, options, batchOptions) {\n        return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);\n    }\n}\nexports.RunnableRetry = RunnableRetry;\n/**\n * A sequence of runnables, where the output of each is the input of the next.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n * const chain = RunnableSequence.from([promptTemplate, new ChatOpenAI({ model: \"gpt-4o-mini\" })]);\n * const result = await chain.invoke({ topic: \"bears\" });\n * ```\n */\nclass RunnableSequence extends Runnable {\n    static lc_name() {\n        return \"RunnableSequence\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"first\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"middle\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"last\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"omitSequenceTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        this.first = fields.first;\n        this.middle = fields.middle ?? this.middle;\n        this.last = fields.last;\n        this.name = fields.name;\n        this.omitSequenceTags = fields.omitSequenceTags ?? this.omitSequenceTags;\n    }\n    get steps() {\n        return [this.first, ...this.middle, this.last];\n    }\n    async invoke(input, options) {\n        const config = (0, config_js_1.ensureConfig)(options);\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config.runId, undefined, undefined, undefined, config?.runName);\n        delete config.runId;\n        let nextStepInput = input;\n        let finalOutput;\n        try {\n            const initialSteps = [this.first, ...this.middle];\n            for (let i = 0; i < initialSteps.length; i += 1) {\n                const step = initialSteps[i];\n                const promise = step.invoke(nextStepInput, (0, config_js_1.patchConfig)(config, {\n                    callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`),\n                }));\n                nextStepInput = await (0, signal_js_1.raceWithSignal)(promise, options?.signal);\n            }\n            // TypeScript can't detect that the last output of the sequence returns RunOutput, so call it out of the loop here\n            if (options?.signal?.aborted) {\n                throw new Error(\"Aborted\");\n            }\n            finalOutput = await this.last.invoke(nextStepInput, (0, config_js_1.patchConfig)(config, {\n                callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${this.steps.length}`),\n            }));\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n        return finalOutput;\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map(config_js_1.getCallbackManagerForConfig));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);\n            delete configList[i].runId;\n            return handleStartRes;\n        }));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let nextStepInputs = inputs;\n        try {\n            for (let i = 0; i < this.steps.length; i += 1) {\n                const step = this.steps[i];\n                const promise = step.batch(nextStepInputs, runManagers.map((runManager, j) => {\n                    const childRunManager = runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`);\n                    return (0, config_js_1.patchConfig)(configList[j], { callbacks: childRunManager });\n                }), batchOptions);\n                nextStepInputs = await (0, signal_js_1.raceWithSignal)(promise, configList[0]?.signal);\n            }\n        }\n        catch (e) {\n            await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));\n            throw e;\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict(nextStepInputs, \"output\"))));\n        return nextStepInputs;\n    }\n    /** @internal */\n    _concatOutputChunks(first, second) {\n        return this.last._concatOutputChunks(first, second);\n    }\n    async *_streamIterator(input, options) {\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(options);\n        const { runId, ...otherOptions } = options ?? {};\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherOptions?.runName);\n        const steps = [this.first, ...this.middle, this.last];\n        let concatSupported = true;\n        let finalOutput;\n        async function* inputGenerator() {\n            yield input;\n        }\n        try {\n            let finalGenerator = steps[0].transform(inputGenerator(), (0, config_js_1.patchConfig)(otherOptions, {\n                callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:1`),\n            }));\n            for (let i = 1; i < steps.length; i += 1) {\n                const step = steps[i];\n                finalGenerator = await step.transform(finalGenerator, (0, config_js_1.patchConfig)(otherOptions, {\n                    callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`),\n                }));\n            }\n            for await (const chunk of finalGenerator) {\n                options?.signal?.throwIfAborted();\n                yield chunk;\n                if (concatSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalOutput = this._concatOutputChunks(finalOutput, chunk);\n                        }\n                        catch (e) {\n                            finalOutput = undefined;\n                            concatSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n    }\n    getGraph(config) {\n        const graph = new graph_js_1.Graph();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let currentLastNode = null;\n        this.steps.forEach((step, index) => {\n            const stepGraph = step.getGraph(config);\n            if (index !== 0) {\n                stepGraph.trimFirstNode();\n            }\n            if (index !== this.steps.length - 1) {\n                stepGraph.trimLastNode();\n            }\n            graph.extend(stepGraph);\n            const stepFirstNode = stepGraph.firstNode();\n            if (!stepFirstNode) {\n                throw new Error(`Runnable ${step} has no first node`);\n            }\n            if (currentLastNode) {\n                graph.addEdge(currentLastNode, stepFirstNode);\n            }\n            currentLastNode = stepGraph.lastNode();\n        });\n        return graph;\n    }\n    pipe(coerceable) {\n        if (RunnableSequence.isRunnableSequence(coerceable)) {\n            return new RunnableSequence({\n                first: this.first,\n                middle: this.middle.concat([\n                    this.last,\n                    coerceable.first,\n                    ...coerceable.middle,\n                ]),\n                last: coerceable.last,\n                name: this.name ?? coerceable.name,\n            });\n        }\n        else {\n            return new RunnableSequence({\n                first: this.first,\n                middle: [...this.middle, this.last],\n                last: _coerceToRunnable(coerceable),\n                name: this.name,\n            });\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnableSequence(thing) {\n        return Array.isArray(thing.middle) && Runnable.isRunnable(thing);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static from([first, ...runnables], nameOrFields) {\n        let extra = {};\n        if (typeof nameOrFields === \"string\") {\n            extra.name = nameOrFields;\n        }\n        else if (nameOrFields !== undefined) {\n            extra = nameOrFields;\n        }\n        return new RunnableSequence({\n            ...extra,\n            first: _coerceToRunnable(first),\n            middle: runnables.slice(0, -1).map(_coerceToRunnable),\n            last: _coerceToRunnable(runnables[runnables.length - 1]),\n        });\n    }\n}\nexports.RunnableSequence = RunnableSequence;\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * const mapChain = RunnableMap.from({\n *   joke: PromptTemplate.fromTemplate(\"Tell me a joke about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n *   poem: PromptTemplate.fromTemplate(\"write a 2-line poem about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n * });\n * const result = await mapChain.invoke({ topic: \"bear\" });\n * ```\n */\nclass RunnableMap extends Runnable {\n    static lc_name() {\n        return \"RunnableMap\";\n    }\n    getStepsKeys() {\n        return Object.keys(this.steps);\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"steps\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.steps = {};\n        for (const [key, value] of Object.entries(fields.steps)) {\n            this.steps[key] = _coerceToRunnable(value);\n        }\n    }\n    static from(steps) {\n        return new RunnableMap({ steps });\n    }\n    async invoke(input, options) {\n        const config = (0, config_js_1.ensureConfig)(options);\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), {\n            input,\n        }, config.runId, undefined, undefined, undefined, config?.runName);\n        delete config.runId;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const output = {};\n        try {\n            const promises = Object.entries(this.steps).map(async ([key, runnable]) => {\n                output[key] = await runnable.invoke(input, (0, config_js_1.patchConfig)(config, {\n                    callbacks: runManager?.getChild(`map:key:${key}`),\n                }));\n            });\n            await (0, signal_js_1.raceWithSignal)(Promise.all(promises), options?.signal);\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(output);\n        return output;\n    }\n    async *_transform(generator, runManager, options) {\n        // shallow copy steps to ignore changes while iterating\n        const steps = { ...this.steps };\n        // each step gets a copy of the input iterator\n        const inputCopies = (0, stream_js_1.atee)(generator, Object.keys(steps).length);\n        // start the first iteration of each output iterator\n        const tasks = new Map(Object.entries(steps).map(([key, runnable], i) => {\n            const gen = runnable.transform(inputCopies[i], (0, config_js_1.patchConfig)(options, {\n                callbacks: runManager?.getChild(`map:key:${key}`),\n            }));\n            return [key, gen.next().then((result) => ({ key, gen, result }))];\n        }));\n        // yield chunks as they become available,\n        // starting new iterations as needed,\n        // until all iterators are done\n        while (tasks.size) {\n            const promise = Promise.race(tasks.values());\n            const { key, result, gen } = await (0, signal_js_1.raceWithSignal)(promise, options?.signal);\n            tasks.delete(key);\n            if (!result.done) {\n                yield { [key]: result.value };\n                tasks.set(key, gen.next().then((result) => ({ key, gen, result })));\n            }\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = (0, config_js_1.ensureConfig)(options);\n        const wrappedGenerator = new stream_js_1.AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return stream_js_1.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\nexports.RunnableMap = RunnableMap;\n/**\n * A runnable that wraps a traced LangSmith function.\n */\nclass RunnableTraceable extends Runnable {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (!(0, traceable_1.isTraceableFunction)(fields.func)) {\n            throw new Error(\"RunnableTraceable requires a function that is wrapped in traceable higher-order function\");\n        }\n        this.func = fields.func;\n    }\n    async invoke(input, options) {\n        const [config] = this._getOptionsList(options ?? {}, 1);\n        const callbacks = await (0, config_js_1.getCallbackManagerForConfig)(config);\n        const promise = this.func((0, config_js_1.patchConfig)(config, { callbacks }), input);\n        return (0, signal_js_1.raceWithSignal)(promise, config?.signal);\n    }\n    async *_streamIterator(input, options) {\n        const [config] = this._getOptionsList(options ?? {}, 1);\n        const result = await this.invoke(input, options);\n        if ((0, iter_js_1.isAsyncIterable)(result)) {\n            for await (const item of result) {\n                config?.signal?.throwIfAborted();\n                yield item;\n            }\n            return;\n        }\n        if ((0, iter_js_1.isIterator)(result)) {\n            while (true) {\n                config?.signal?.throwIfAborted();\n                const state = result.next();\n                if (state.done)\n                    break;\n                yield state.value;\n            }\n            return;\n        }\n        yield result;\n    }\n    static from(func) {\n        return new RunnableTraceable({ func });\n    }\n}\nexports.RunnableTraceable = RunnableTraceable;\nfunction assertNonTraceableFunction(func) {\n    if ((0, traceable_1.isTraceableFunction)(func)) {\n        throw new Error(\"RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.\");\n    }\n}\n/**\n * A runnable that wraps an arbitrary function that takes a single argument.\n * @example\n * ```typescript\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const add = (input: { x: number; y: number }) => input.x + input.y;\n *\n * const multiply = (input: { value: number; multiplier: number }) =>\n *   input.value * input.multiplier;\n *\n * // Create runnables for the functions\n * const addLambda = RunnableLambda.from(add);\n * const multiplyLambda = RunnableLambda.from(multiply);\n *\n * // Chain the lambdas for a mathematical operation\n * const chainedLambda = addLambda.pipe((result) =>\n *   multiplyLambda.invoke({ value: result, multiplier: 2 })\n * );\n *\n * // Example invocation of the chainedLambda\n * const result = await chainedLambda.invoke({ x: 2, y: 3 });\n *\n * // Will log \"10\" (since (2 + 3) * 2 = 10)\n * ```\n */\nclass RunnableLambda extends Runnable {\n    static lc_name() {\n        return \"RunnableLambda\";\n    }\n    constructor(fields) {\n        if ((0, traceable_1.isTraceableFunction)(fields.func)) {\n            // eslint-disable-next-line no-constructor-return\n            return RunnableTraceable.from(fields.func);\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        assertNonTraceableFunction(fields.func);\n        this.func = fields.func;\n    }\n    static from(func) {\n        return new RunnableLambda({\n            func,\n        });\n    }\n    async _invoke(input, config, runManager) {\n        return new Promise((resolve, reject) => {\n            const childConfig = (0, config_js_1.patchConfig)(config, {\n                callbacks: runManager?.getChild(),\n                recursionLimit: (config?.recursionLimit ?? config_js_1.DEFAULT_RECURSION_LIMIT) - 1,\n            });\n            void index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig((0, config_js_1.pickRunnableConfigKeys)(childConfig), async () => {\n                try {\n                    let output = await this.func(input, {\n                        ...childConfig,\n                    });\n                    if (output && Runnable.isRunnable(output)) {\n                        if (config?.recursionLimit === 0) {\n                            throw new Error(\"Recursion limit reached.\");\n                        }\n                        output = await output.invoke(input, {\n                            ...childConfig,\n                            recursionLimit: (childConfig.recursionLimit ?? config_js_1.DEFAULT_RECURSION_LIMIT) - 1,\n                        });\n                    }\n                    else if ((0, iter_js_1.isAsyncIterable)(output)) {\n                        let finalOutput;\n                        for await (const chunk of (0, iter_js_1.consumeAsyncIterableInContext)(childConfig, output)) {\n                            config?.signal?.throwIfAborted();\n                            if (finalOutput === undefined) {\n                                finalOutput = chunk;\n                            }\n                            else {\n                                // Make a best effort to gather, for any type that supports concat.\n                                try {\n                                    finalOutput = this._concatOutputChunks(finalOutput, \n                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                                    chunk);\n                                }\n                                catch (e) {\n                                    finalOutput = chunk;\n                                }\n                            }\n                        }\n                        output = finalOutput;\n                    }\n                    else if ((0, iter_js_1.isIterableIterator)(output)) {\n                        let finalOutput;\n                        for (const chunk of (0, iter_js_1.consumeIteratorInContext)(childConfig, output)) {\n                            config?.signal?.throwIfAborted();\n                            if (finalOutput === undefined) {\n                                finalOutput = chunk;\n                            }\n                            else {\n                                // Make a best effort to gather, for any type that supports concat.\n                                try {\n                                    finalOutput = this._concatOutputChunks(finalOutput, \n                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                                    chunk);\n                                }\n                                catch (e) {\n                                    finalOutput = chunk;\n                                }\n                            }\n                        }\n                        output = finalOutput;\n                    }\n                    resolve(output);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(this._invoke.bind(this), input, options);\n    }\n    async *_transform(generator, runManager, config) {\n        let finalChunk;\n        for await (const chunk of generator) {\n            if (finalChunk === undefined) {\n                finalChunk = chunk;\n            }\n            else {\n                // Make a best effort to gather, for any type that supports concat.\n                try {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    finalChunk = this._concatOutputChunks(finalChunk, chunk);\n                }\n                catch (e) {\n                    finalChunk = chunk;\n                }\n            }\n        }\n        const childConfig = (0, config_js_1.patchConfig)(config, {\n            callbacks: runManager?.getChild(),\n            recursionLimit: (config?.recursionLimit ?? config_js_1.DEFAULT_RECURSION_LIMIT) - 1,\n        });\n        const output = await new Promise((resolve, reject) => {\n            void index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig((0, config_js_1.pickRunnableConfigKeys)(childConfig), async () => {\n                try {\n                    const res = await this.func(finalChunk, {\n                        ...childConfig,\n                        config: childConfig,\n                    });\n                    resolve(res);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n        if (output && Runnable.isRunnable(output)) {\n            if (config?.recursionLimit === 0) {\n                throw new Error(\"Recursion limit reached.\");\n            }\n            const stream = await output.stream(finalChunk, childConfig);\n            for await (const chunk of stream) {\n                yield chunk;\n            }\n        }\n        else if ((0, iter_js_1.isAsyncIterable)(output)) {\n            for await (const chunk of (0, iter_js_1.consumeAsyncIterableInContext)(childConfig, output)) {\n                config?.signal?.throwIfAborted();\n                yield chunk;\n            }\n        }\n        else if ((0, iter_js_1.isIterableIterator)(output)) {\n            for (const chunk of (0, iter_js_1.consumeIteratorInContext)(childConfig, output)) {\n                config?.signal?.throwIfAborted();\n                yield chunk;\n            }\n        }\n        else {\n            yield output;\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = (0, config_js_1.ensureConfig)(options);\n        const wrappedGenerator = new stream_js_1.AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return stream_js_1.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\nexports.RunnableLambda = RunnableLambda;\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableParallel,\n * } from \"@langchain/core/runnables\";\n *\n * const addYears = (age: number): number => age + 5;\n * const yearsToFifty = (age: number): number => 50 - age;\n * const yearsToHundred = (age: number): number => 100 - age;\n *\n * const addYearsLambda = RunnableLambda.from(addYears);\n * const milestoneFiftyLambda = RunnableLambda.from(yearsToFifty);\n * const milestoneHundredLambda = RunnableLambda.from(yearsToHundred);\n *\n * // Pipe will coerce objects into RunnableParallel by default, but we\n * // explicitly instantiate one here to demonstrate\n * const sequence = addYearsLambda.pipe(\n *   RunnableParallel.from({\n *     years_to_fifty: milestoneFiftyLambda,\n *     years_to_hundred: milestoneHundredLambda,\n *   })\n * );\n *\n * // Invoke the sequence with a single age input\n * const res = await sequence.invoke(25);\n *\n * // { years_to_fifty: 20, years_to_hundred: 70 }\n * ```\n */\nclass RunnableParallel extends RunnableMap {\n}\nexports.RunnableParallel = RunnableParallel;\n/**\n * A Runnable that can fallback to other Runnables if it fails.\n * External APIs (e.g., APIs for a language model) may at times experience\n * degraded performance or even downtime.\n *\n * In these cases, it can be useful to have a fallback Runnable that can be\n * used in place of the original Runnable (e.g., fallback to another LLM provider).\n *\n * Fallbacks can be defined at the level of a single Runnable, or at the level\n * of a chain of Runnables. Fallbacks are tried in order until one succeeds or\n * all fail.\n *\n * While you can instantiate a `RunnableWithFallbacks` directly, it is usually\n * more convenient to use the `withFallbacks` method on an existing Runnable.\n *\n * When streaming, fallbacks will only be called on failures during the initial\n * stream creation. Errors that occur after a stream starts will not fallback\n * to the next Runnable.\n *\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableWithFallbacks,\n * } from \"@langchain/core/runnables\";\n *\n * const primaryOperation = (input: string): string => {\n *   if (input !== \"safe\") {\n *     throw new Error(\"Primary operation failed due to unsafe input\");\n *   }\n *   return `Processed: ${input}`;\n * };\n *\n * // Define a fallback operation that processes the input differently\n * const fallbackOperation = (input: string): string =>\n *   `Fallback processed: ${input}`;\n *\n * const primaryRunnable = RunnableLambda.from(primaryOperation);\n * const fallbackRunnable = RunnableLambda.from(fallbackOperation);\n *\n * // Apply the fallback logic using the .withFallbacks() method\n * const runnableWithFallback = primaryRunnable.withFallbacks([fallbackRunnable]);\n *\n * // Alternatively, create a RunnableWithFallbacks instance manually\n * const manualFallbackChain = new RunnableWithFallbacks({\n *   runnable: primaryRunnable,\n *   fallbacks: [fallbackRunnable],\n * });\n *\n * // Example invocation using .withFallbacks()\n * const res = await runnableWithFallback\n *   .invoke(\"unsafe input\")\n *   .catch((error) => {\n *     console.error(\"Failed after all attempts:\", error.message);\n *   });\n *\n * // \"Fallback processed: unsafe input\"\n *\n * // Example invocation using manual instantiation\n * const res = await manualFallbackChain\n *   .invoke(\"safe\")\n *   .catch((error) => {\n *     console.error(\"Failed after all attempts:\", error.message);\n *   });\n *\n * // \"Processed: safe\"\n * ```\n */\nclass RunnableWithFallbacks extends Runnable {\n    static lc_name() {\n        return \"RunnableWithFallbacks\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fallbacks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnable = fields.runnable;\n        this.fallbacks = fields.fallbacks;\n    }\n    *runnables() {\n        yield this.runnable;\n        for (const fallback of this.fallbacks) {\n            yield fallback;\n        }\n    }\n    async invoke(input, options) {\n        const config = (0, config_js_1.ensureConfig)(options);\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(config);\n        const { runId, ...otherConfigFields } = config;\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherConfigFields?.runName);\n        const childConfig = (0, config_js_1.patchConfig)(otherConfigFields, {\n            callbacks: runManager?.getChild(),\n        });\n        const res = await index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, async () => {\n            let firstError;\n            for (const runnable of this.runnables()) {\n                config?.signal?.throwIfAborted();\n                try {\n                    const output = await runnable.invoke(input, childConfig);\n                    await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n                    return output;\n                }\n                catch (e) {\n                    if (firstError === undefined) {\n                        firstError = e;\n                    }\n                }\n            }\n            if (firstError === undefined) {\n                throw new Error(\"No error stored at end of fallback.\");\n            }\n            await runManager?.handleChainError(firstError);\n            throw firstError;\n        });\n        return res;\n    }\n    async *_streamIterator(input, options) {\n        const config = (0, config_js_1.ensureConfig)(options);\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(config);\n        const { runId, ...otherConfigFields } = config;\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherConfigFields?.runName);\n        let firstError;\n        let stream;\n        for (const runnable of this.runnables()) {\n            config?.signal?.throwIfAborted();\n            const childConfig = (0, config_js_1.patchConfig)(otherConfigFields, {\n                callbacks: runManager?.getChild(),\n            });\n            try {\n                const originalStream = await runnable.stream(input, childConfig);\n                stream = (0, iter_js_1.consumeAsyncIterableInContext)(childConfig, originalStream);\n                break;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (stream === undefined) {\n            const error = firstError ?? new Error(\"No error stored at end of fallback.\");\n            await runManager?.handleChainError(error);\n            throw error;\n        }\n        let output;\n        try {\n            for await (const chunk of stream) {\n                yield chunk;\n                try {\n                    output =\n                        output === undefined\n                            ? output\n                            : this._concatOutputChunks(output, chunk);\n                }\n                catch (e) {\n                    output = undefined;\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n    }\n    async batch(inputs, options, batchOptions) {\n        if (batchOptions?.returnExceptions) {\n            throw new Error(\"Not implemented.\");\n        }\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map((config) => (0, config_js_1.getCallbackManagerForConfig)(config)));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);\n            delete configList[i].runId;\n            return handleStartRes;\n        }));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let firstError;\n        for (const runnable of this.runnables()) {\n            configList[0].signal?.throwIfAborted();\n            try {\n                const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => (0, config_js_1.patchConfig)(configList[j], {\n                    callbacks: runManager?.getChild(),\n                })), batchOptions);\n                await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(outputs[i], \"output\"))));\n                return outputs;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (!firstError) {\n            throw new Error(\"No error stored at end of fallbacks.\");\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(firstError)));\n        throw firstError;\n    }\n}\nexports.RunnableWithFallbacks = RunnableWithFallbacks;\n// TODO: Figure out why the compiler needs help eliminating Error as a RunOutput type\nfunction _coerceToRunnable(coerceable) {\n    if (typeof coerceable === \"function\") {\n        return new RunnableLambda({ func: coerceable });\n    }\n    else if (Runnable.isRunnable(coerceable)) {\n        return coerceable;\n    }\n    else if (!Array.isArray(coerceable) && typeof coerceable === \"object\") {\n        const runnables = {};\n        for (const [key, value] of Object.entries(coerceable)) {\n            runnables[key] = _coerceToRunnable(value);\n        }\n        return new RunnableMap({\n            steps: runnables,\n        });\n    }\n    else {\n        throw new Error(`Expected a Runnable, function or object.\\nInstead got an unsupported type.`);\n    }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n * @example\n * ```typescript\n * import {\n *   RunnableAssign,\n *   RunnableLambda,\n *   RunnableParallel,\n * } from \"@langchain/core/runnables\";\n *\n * const calculateAge = (x: { birthYear: number }): { age: number } => {\n *   const currentYear = new Date().getFullYear();\n *   return { age: currentYear - x.birthYear };\n * };\n *\n * const createGreeting = (x: { name: string }): { greeting: string } => {\n *   return { greeting: `Hello, ${x.name}!` };\n * };\n *\n * const mapper = RunnableParallel.from({\n *   age_step: RunnableLambda.from(calculateAge),\n *   greeting_step: RunnableLambda.from(createGreeting),\n * });\n *\n * const runnableAssign = new RunnableAssign({ mapper });\n *\n * const res = await runnableAssign.invoke({ name: \"Alice\", birthYear: 1990 });\n *\n * // { name: \"Alice\", birthYear: 1990, age_step: { age: 34 }, greeting_step: { greeting: \"Hello, Alice!\" } }\n * ```\n */\nclass RunnableAssign extends Runnable {\n    static lc_name() {\n        return \"RunnableAssign\";\n    }\n    constructor(fields) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (fields instanceof RunnableMap) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { mapper: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"mapper\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.mapper = fields.mapper;\n    }\n    async invoke(input, options) {\n        const mapperResult = await this.mapper.invoke(input, options);\n        return {\n            ...input,\n            ...mapperResult,\n        };\n    }\n    async *_transform(generator, runManager, options) {\n        // collect mapper keys\n        const mapperKeys = this.mapper.getStepsKeys();\n        // create two input gens, one for the mapper, one for the input\n        const [forPassthrough, forMapper] = (0, stream_js_1.atee)(generator);\n        // create mapper output gen\n        const mapperOutput = this.mapper.transform(forMapper, (0, config_js_1.patchConfig)(options, { callbacks: runManager?.getChild() }));\n        // start the mapper\n        const firstMapperChunkPromise = mapperOutput.next();\n        // yield the passthrough\n        for await (const chunk of forPassthrough) {\n            if (typeof chunk !== \"object\" || Array.isArray(chunk)) {\n                throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof chunk}`);\n            }\n            const filtered = Object.fromEntries(Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key)));\n            if (Object.keys(filtered).length > 0) {\n                yield filtered;\n            }\n        }\n        // yield the mapper output\n        yield (await firstMapperChunkPromise).value;\n        for await (const chunk of mapperOutput) {\n            yield chunk;\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = (0, config_js_1.ensureConfig)(options);\n        const wrappedGenerator = new stream_js_1.AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return stream_js_1.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\nexports.RunnableAssign = RunnableAssign;\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n * Useful for streaming, can be automatically created and chained by calling `runnable.pick();`.\n * @example\n * ```typescript\n * import { RunnablePick } from \"@langchain/core/runnables\";\n *\n * const inputData = {\n *   name: \"John\",\n *   age: 30,\n *   city: \"New York\",\n *   country: \"USA\",\n *   email: \"john.doe@example.com\",\n *   phone: \"+1234567890\",\n * };\n *\n * const basicInfoRunnable = new RunnablePick([\"name\", \"city\"]);\n *\n * // Example invocation\n * const res = await basicInfoRunnable.invoke(inputData);\n *\n * // { name: 'John', city: 'New York' }\n * ```\n */\nclass RunnablePick extends Runnable {\n    static lc_name() {\n        return \"RunnablePick\";\n    }\n    constructor(fields) {\n        if (typeof fields === \"string\" || Array.isArray(fields)) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { keys: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"keys\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.keys = fields.keys;\n    }\n    async _pick(input) {\n        if (typeof this.keys === \"string\") {\n            return input[this.keys];\n        }\n        else {\n            const picked = this.keys\n                .map((key) => [key, input[key]])\n                .filter((v) => v[1] !== undefined);\n            return picked.length === 0\n                ? undefined\n                : Object.fromEntries(picked);\n        }\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(this._pick.bind(this), input, options);\n    }\n    async *_transform(generator) {\n        for await (const chunk of generator) {\n            const picked = await this._pick(chunk);\n            if (picked !== undefined) {\n                yield picked;\n            }\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = (0, config_js_1.ensureConfig)(options);\n        const wrappedGenerator = new stream_js_1.AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return stream_js_1.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\nexports.RunnablePick = RunnablePick;\nclass RunnableToolLike extends RunnableBinding {\n    constructor(fields) {\n        const sequence = RunnableSequence.from([\n            RunnableLambda.from(async (input) => {\n                let toolInput;\n                if ((0, utils_js_2._isToolCall)(input)) {\n                    try {\n                        toolInput = await (0, zod_js_1.interopParseAsync)(this.schema, input.args);\n                    }\n                    catch (e) {\n                        throw new utils_js_2.ToolInputParsingException(`Received tool input did not match expected schema`, JSON.stringify(input.args));\n                    }\n                }\n                else {\n                    toolInput = input;\n                }\n                return toolInput;\n            }).withConfig({ runName: `${fields.name}:parse_input` }),\n            fields.bound,\n        ]).withConfig({ runName: fields.name });\n        super({\n            bound: sequence,\n            config: fields.config ?? {},\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.description = fields.description;\n        this.schema = fields.schema;\n    }\n    static lc_name() {\n        return \"RunnableToolLike\";\n    }\n}\nexports.RunnableToolLike = RunnableToolLike;\n/**\n * Given a runnable and a Zod schema, convert the runnable to a tool.\n *\n * @template RunInput The input type for the runnable.\n * @template RunOutput The output type for the runnable.\n *\n * @param {Runnable<RunInput, RunOutput>} runnable The runnable to convert to a tool.\n * @param fields\n * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.\n * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.\n * @param {InteropZodType<RunInput>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.\n * @returns {RunnableToolLike<InteropZodType<RunInput>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.\n */\nfunction convertRunnableToTool(runnable, fields) {\n    const name = fields.name ?? runnable.getName();\n    const description = fields.description ?? (0, zod_js_1.getSchemaDescription)(fields.schema);\n    if ((0, zod_js_1.isSimpleStringZodSchema)(fields.schema)) {\n        return new RunnableToolLike({\n            name,\n            description,\n            schema: v3_1.z\n                .object({ input: v3_1.z.string() })\n                .transform((input) => input.input),\n            bound: runnable,\n        });\n    }\n    return new RunnableToolLike({\n        name,\n        description,\n        schema: fields.schema,\n        bound: runnable,\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2Jhc2UuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsb0JBQW9CLEdBQUcsc0JBQXNCLEdBQUcsNkJBQTZCLEdBQUcsd0JBQXdCLEdBQUcsc0JBQXNCLEdBQUcseUJBQXlCLEdBQUcsbUJBQW1CLEdBQUcsd0JBQXdCLEdBQUcscUJBQXFCLEdBQUcsb0JBQW9CLEdBQUcsdUJBQXVCLEdBQUcsZ0JBQWdCO0FBQ3JVLHFCQUFxQjtBQUNyQix5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyxxREFBUTtBQUM3QixrQ0FBa0MsbUJBQU8sQ0FBQyxzREFBUztBQUNuRCxlQUFlLG1CQUFPLENBQUMsMkZBQU07QUFDN0Isb0JBQW9CLG1CQUFPLENBQUMsK0ZBQWdDO0FBQzVELHdCQUF3QixtQkFBTyxDQUFDLG1HQUEyQjtBQUMzRCwwQkFBMEIsbUJBQU8sQ0FBQyx1R0FBNkI7QUFDL0QsMEJBQTBCLG1CQUFPLENBQUMsaUdBQTBCO0FBQzVELG9CQUFvQixtQkFBTyxDQUFDLHVGQUFxQjtBQUNqRCxvQkFBb0IsbUJBQU8sQ0FBQyx1RkFBcUI7QUFDakQsb0JBQW9CLG1CQUFPLENBQUMsb0ZBQWM7QUFDMUMsMEJBQTBCLG1CQUFPLENBQUMsbUdBQTJCO0FBQzdELDJCQUEyQixtQkFBTyxDQUFDLHlHQUE4QjtBQUNqRSxtQkFBbUIsbUJBQU8sQ0FBQyxrRkFBYTtBQUN4QyxtQkFBbUIsbUJBQU8sQ0FBQywrRkFBeUI7QUFDcEQsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQWE7QUFDeEMsc0JBQXNCLG1CQUFPLENBQUMsd0ZBQWdCO0FBQzlDLGtCQUFrQixtQkFBTyxDQUFDLGdGQUFZO0FBQ3RDLG1CQUFtQixtQkFBTyxDQUFDLHFGQUFvQjtBQUMvQyxpQkFBaUIsbUJBQU8sQ0FBQyw2RkFBd0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSyxFQUFFLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUNBQWlDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxhQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNkdBQTZHLGdCQUFnQixjQUFjLFFBQVE7QUFDbko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNMQUFzTCxXQUFXO0FBQ2pNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwwREFBMEQscUNBQXFDLDRDQUE0QztBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsWUFBWTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxpQ0FBaUMsV0FBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixZQUFZLDRCQUE0QixjQUFjO0FBQ3BKO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYyxHQUFHLFVBQVU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLFlBQVksNEJBQTRCLFdBQVc7QUFDN0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLG9CQUFvQjtBQUNuQztBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrQkFBK0I7QUFDakQ7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsY0FBYztBQUM3QixpQkFBaUIsMkNBQTJDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCLGlCQUFpQjtBQUMxRSx3Q0FBd0MsZ0JBQWdCLGdCQUFnQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLG9CQUFvQjtBQUNuQztBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0JBQStCO0FBQzNDO0FBQ0E7QUFDQSw0REFBNEQsTUFBTTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLG1DQUFtQztBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLG9CQUFvQjtBQUNuQztBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQSw4Q0FBOEMseUJBQXlCO0FBQ3ZFLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHFCQUFxQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Qsc0RBQXNELHNDQUFzQztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGdDQUFnQyxvQkFBb0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQSx5RUFBeUUsc0JBQXNCO0FBQy9GLHVDQUF1QyxnQkFBZ0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0Esb0dBQW9HLE1BQU07QUFDMUcsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLGtCQUFrQjtBQUNsSCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0EsaUhBQWlILE1BQU07QUFDdkgseUVBQXlFLDRCQUE0QjtBQUNyRyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBLG9HQUFvRyxNQUFNO0FBQzFHLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsTUFBTTtBQUNwRSwyQkFBMkI7QUFDM0I7QUFDQSxtRUFBbUUsTUFBTTtBQUN6RSwyQkFBMkI7QUFDM0I7QUFDQSxJQUFJO0FBQ0osMENBQTBDLGVBQWU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsSUFBSTtBQUNuRSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxJQUFJO0FBQy9ELGFBQWE7QUFDYix3REFBd0Qsa0JBQWtCO0FBQzFFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLDhEQUE4RCxrQkFBa0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQSx5RUFBeUUsV0FBVztBQUNwRjtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE1BQU07QUFDN0M7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBLHlCQUF5QixXQUFXLFdBQVc7QUFDL0M7QUFDQSw4QkFBOEIsZUFBZSxvQkFBb0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGtCQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOEJBQThCLG1CQUFtQixLQUFLLGNBQWM7QUFDcEU7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGdDQUFnQyxjQUFjLEtBQUssbUJBQW1CO0FBQ3RFLGNBQWMsb0JBQW9CLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0EsNkNBQTZDLGdDQUFnQztBQUM3RTtBQUNBLFFBQVEsNENBQTRDLFNBQVMsbUJBQW1CO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0csbUNBQW1DO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsYUFBYTtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSw4RkFBOEY7QUFDOUY7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlLFlBQVksWUFBWSxlQUFlO0FBQ25FO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0JBQStCO0FBQzFDO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVywwQkFBMEI7QUFDckMsYUFBYSx1REFBdUQ7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdCQUF3QjtBQUNsRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3J1bm5hYmxlcy9iYXNlLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUnVubmFibGVUb29sTGlrZSA9IGV4cG9ydHMuUnVubmFibGVQaWNrID0gZXhwb3J0cy5SdW5uYWJsZUFzc2lnbiA9IGV4cG9ydHMuUnVubmFibGVXaXRoRmFsbGJhY2tzID0gZXhwb3J0cy5SdW5uYWJsZVBhcmFsbGVsID0gZXhwb3J0cy5SdW5uYWJsZUxhbWJkYSA9IGV4cG9ydHMuUnVubmFibGVUcmFjZWFibGUgPSBleHBvcnRzLlJ1bm5hYmxlTWFwID0gZXhwb3J0cy5SdW5uYWJsZVNlcXVlbmNlID0gZXhwb3J0cy5SdW5uYWJsZVJldHJ5ID0gZXhwb3J0cy5SdW5uYWJsZUVhY2ggPSBleHBvcnRzLlJ1bm5hYmxlQmluZGluZyA9IGV4cG9ydHMuUnVubmFibGUgPSB2b2lkIDA7XG5leHBvcnRzLl9jb2VyY2VUb0RpY3QgPSBfY29lcmNlVG9EaWN0O1xuZXhwb3J0cy5fY29lcmNlVG9SdW5uYWJsZSA9IF9jb2VyY2VUb1J1bm5hYmxlO1xuZXhwb3J0cy5jb252ZXJ0UnVubmFibGVUb1Rvb2wgPSBjb252ZXJ0UnVubmFibGVUb1Rvb2w7XG5jb25zdCB2M18xID0gcmVxdWlyZShcInpvZC92M1wiKTtcbmNvbnN0IHBfcmV0cnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicC1yZXRyeVwiKSk7XG5jb25zdCB1dWlkXzEgPSByZXF1aXJlKFwidXVpZFwiKTtcbmNvbnN0IHRyYWNlYWJsZV8xID0gcmVxdWlyZShcImxhbmdzbWl0aC9zaW5nbGV0b25zL3RyYWNlYWJsZVwiKTtcbmNvbnN0IGxvZ19zdHJlYW1fanNfMSA9IHJlcXVpcmUoXCIuLi90cmFjZXJzL2xvZ19zdHJlYW0uY2pzXCIpO1xuY29uc3QgZXZlbnRfc3RyZWFtX2pzXzEgPSByZXF1aXJlKFwiLi4vdHJhY2Vycy9ldmVudF9zdHJlYW0uY2pzXCIpO1xuY29uc3Qgc2VyaWFsaXphYmxlX2pzXzEgPSByZXF1aXJlKFwiLi4vbG9hZC9zZXJpYWxpemFibGUuY2pzXCIpO1xuY29uc3Qgc3RyZWFtX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvc3RyZWFtLmNqc1wiKTtcbmNvbnN0IHNpZ25hbF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL3NpZ25hbC5janNcIik7XG5jb25zdCBjb25maWdfanNfMSA9IHJlcXVpcmUoXCIuL2NvbmZpZy5janNcIik7XG5jb25zdCBhc3luY19jYWxsZXJfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9hc3luY19jYWxsZXIuY2pzXCIpO1xuY29uc3Qgcm9vdF9saXN0ZW5lcl9qc18xID0gcmVxdWlyZShcIi4uL3RyYWNlcnMvcm9vdF9saXN0ZW5lci5janNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuY2pzXCIpO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9zaW5nbGV0b25zL2luZGV4LmNqc1wiKTtcbmNvbnN0IGdyYXBoX2pzXzEgPSByZXF1aXJlKFwiLi9ncmFwaC5janNcIik7XG5jb25zdCB3cmFwcGVyc19qc18xID0gcmVxdWlyZShcIi4vd3JhcHBlcnMuY2pzXCIpO1xuY29uc3QgaXRlcl9qc18xID0gcmVxdWlyZShcIi4vaXRlci5janNcIik7XG5jb25zdCB1dGlsc19qc18yID0gcmVxdWlyZShcIi4uL3Rvb2xzL3V0aWxzLmNqc1wiKTtcbmNvbnN0IHpvZF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL3R5cGVzL3pvZC5janNcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gX2NvZXJjZVRvRGljdCh2YWx1ZSwgZGVmYXVsdEtleSkge1xuICAgIHJldHVybiB2YWx1ZSAmJlxuICAgICAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiZcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAhKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiB7IFtkZWZhdWx0S2V5XTogdmFsdWUgfTtcbn1cbi8qKlxuICogQSBSdW5uYWJsZSBpcyBhIGdlbmVyaWMgdW5pdCBvZiB3b3JrIHRoYXQgY2FuIGJlIGludm9rZWQsIGJhdGNoZWQsIHN0cmVhbWVkLCBhbmQvb3JcbiAqIHRyYW5zZm9ybWVkLlxuICovXG5jbGFzcyBSdW5uYWJsZSBleHRlbmRzIHNlcmlhbGl6YWJsZV9qc18xLlNlcmlhbGl6YWJsZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3J1bm5hYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldE5hbWUoc3VmZml4KSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgdGhpcy5uYW1lID8/IHRoaXMuY29uc3RydWN0b3IubGNfbmFtZSgpID8/IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgcmV0dXJuIHN1ZmZpeCA/IGAke25hbWV9JHtzdWZmaXh9YCA6IG5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmQgYXJndW1lbnRzIHRvIGEgUnVubmFibGUsIHJldHVybmluZyBhIG5ldyBSdW5uYWJsZS5cbiAgICAgKiBAcGFyYW0ga3dhcmdzXG4gICAgICogQHJldHVybnMgQSBuZXcgUnVubmFibGVCaW5kaW5nIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBhcHBseSB0aGUgYm91bmQgYXJncy5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgd2l0aENvbmZpZ30gaW5zdGVhZC4gVGhpcyB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgYnJlYWtpbmcgcmVsZWFzZS5cbiAgICAgKi9cbiAgICBiaW5kKGt3YXJncykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVCaW5kaW5nKHsgYm91bmQ6IHRoaXMsIGt3YXJncywgY29uZmlnOiB7fSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbmV3IFJ1bm5hYmxlIHRoYXQgbWFwcyBhIGxpc3Qgb2YgaW5wdXRzIHRvIGEgbGlzdCBvZiBvdXRwdXRzLFxuICAgICAqIGJ5IGNhbGxpbmcgaW52b2tlKCkgd2l0aCBlYWNoIGlucHV0LlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVGhpcyB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgYnJlYWtpbmcgcmVsZWFzZS5cbiAgICAgKi9cbiAgICBtYXAoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZUVhY2goeyBib3VuZDogdGhpcyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHJldHJ5IGxvZ2ljIHRvIGFuIGV4aXN0aW5nIHJ1bm5hYmxlLlxuICAgICAqIEBwYXJhbSBmaWVsZHMuc3RvcEFmdGVyQXR0ZW1wdCBUaGUgbnVtYmVyIG9mIGF0dGVtcHRzIHRvIHJldHJ5LlxuICAgICAqIEBwYXJhbSBmaWVsZHMub25GYWlsZWRBdHRlbXB0IEEgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBhIHJldHJ5IGZhaWxzLlxuICAgICAqIEByZXR1cm5zIEEgbmV3IFJ1bm5hYmxlUmV0cnkgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIHJldHJ5IGFjY29yZGluZyB0byB0aGUgcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICB3aXRoUmV0cnkoZmllbGRzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZVJldHJ5KHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLFxuICAgICAgICAgICAga3dhcmdzOiB7fSxcbiAgICAgICAgICAgIGNvbmZpZzoge30sXG4gICAgICAgICAgICBtYXhBdHRlbXB0TnVtYmVyOiBmaWVsZHM/LnN0b3BBZnRlckF0dGVtcHQsXG4gICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kIGNvbmZpZyB0byBhIFJ1bm5hYmxlLCByZXR1cm5pbmcgYSBuZXcgUnVubmFibGUuXG4gICAgICogQHBhcmFtIGNvbmZpZyBOZXcgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzIHRvIGF0dGFjaCB0byB0aGUgbmV3IHJ1bm5hYmxlLlxuICAgICAqIEByZXR1cm5zIEEgbmV3IFJ1bm5hYmxlQmluZGluZyB3aXRoIGEgY29uZmlnIG1hdGNoaW5nIHdoYXQncyBwYXNzZWQuXG4gICAgICovXG4gICAgd2l0aENvbmZpZyhjb25maWcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlQmluZGluZyh7XG4gICAgICAgICAgICBib3VuZDogdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGt3YXJnczoge30sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgcnVubmFibGUgZnJvbSB0aGUgY3VycmVudCBvbmUgdGhhdCB3aWxsIHRyeSBpbnZva2luZ1xuICAgICAqIG90aGVyIHBhc3NlZCBmYWxsYmFjayBydW5uYWJsZXMgaWYgdGhlIGluaXRpYWwgaW52b2NhdGlvbiBmYWlscy5cbiAgICAgKiBAcGFyYW0gZmllbGRzLmZhbGxiYWNrcyBPdGhlciBydW5uYWJsZXMgdG8gY2FsbCBpZiB0aGUgcnVubmFibGUgZXJyb3JzLlxuICAgICAqIEByZXR1cm5zIEEgbmV3IFJ1bm5hYmxlV2l0aEZhbGxiYWNrcy5cbiAgICAgKi9cbiAgICB3aXRoRmFsbGJhY2tzKGZpZWxkcykge1xuICAgICAgICBjb25zdCBmYWxsYmFja3MgPSBBcnJheS5pc0FycmF5KGZpZWxkcykgPyBmaWVsZHMgOiBmaWVsZHMuZmFsbGJhY2tzO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVXaXRoRmFsbGJhY2tzKHtcbiAgICAgICAgICAgIHJ1bm5hYmxlOiB0aGlzLFxuICAgICAgICAgICAgZmFsbGJhY2tzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldE9wdGlvbnNMaXN0KG9wdGlvbnMsIGxlbmd0aCA9IDApIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykgJiYgb3B0aW9ucy5sZW5ndGggIT09IGxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXNzZWQgXCJvcHRpb25zXCIgbXVzdCBiZSBhbiBhcnJheSB3aXRoIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGUgaW5wdXRzLCBidXQgZ290ICR7b3B0aW9ucy5sZW5ndGh9IG9wdGlvbnMgZm9yICR7bGVuZ3RofSBpbnB1dHNgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMubWFwKGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA+IDEgJiYgIUFycmF5LmlzQXJyYXkob3B0aW9ucykgJiYgb3B0aW9ucy5ydW5JZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiUHJvdmlkZWQgcnVuSWQgd2lsbCBiZSB1c2VkIG9ubHkgZm9yIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBiYXRjaC5cIik7XG4gICAgICAgICAgICBjb25zdCBzdWJzZXF1ZW50ID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKG9wdGlvbnMpLmZpbHRlcigoW2tleV0pID0+IGtleSAhPT0gXCJydW5JZFwiKSk7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aCB9LCAoXywgaSkgPT4gKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykoaSA9PT0gMCA/IG9wdGlvbnMgOiBzdWJzZXF1ZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGggfSwgKCkgPT4gKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucykpO1xuICAgIH1cbiAgICBhc3luYyBiYXRjaChpbnB1dHMsIG9wdGlvbnMsIGJhdGNoT3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb25maWdMaXN0ID0gdGhpcy5fZ2V0T3B0aW9uc0xpc3Qob3B0aW9ucyA/PyB7fSwgaW5wdXRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IG1heENvbmN1cnJlbmN5ID0gY29uZmlnTGlzdFswXT8ubWF4Q29uY3VycmVuY3kgPz8gYmF0Y2hPcHRpb25zPy5tYXhDb25jdXJyZW5jeTtcbiAgICAgICAgY29uc3QgY2FsbGVyID0gbmV3IGFzeW5jX2NhbGxlcl9qc18xLkFzeW5jQ2FsbGVyKHtcbiAgICAgICAgICAgIG1heENvbmN1cnJlbmN5LFxuICAgICAgICAgICAgb25GYWlsZWRBdHRlbXB0OiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYmF0Y2hDYWxscyA9IGlucHV0cy5tYXAoKGlucHV0LCBpKSA9PiBjYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuaW52b2tlKGlucHV0LCBjb25maWdMaXN0W2ldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmF0Y2hPcHRpb25zPy5yZXR1cm5FeGNlcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChiYXRjaENhbGxzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBzdHJlYW1pbmcgaW1wbGVtZW50YXRpb24uXG4gICAgICogU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgdGhleSBzdXBwb3J0IHN0cmVhbWluZyBvdXRwdXQuXG4gICAgICogQHBhcmFtIGlucHV0XG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBhc3luYyAqX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuaW52b2tlKGlucHV0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RyZWFtIG91dHB1dCBpbiBjaHVua3MuXG4gICAgICogQHBhcmFtIGlucHV0XG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyBBIHJlYWRhYmxlIHN0cmVhbSB0aGF0IGlzIGFsc28gYW4gaXRlcmFibGUuXG4gICAgICovXG4gICAgYXN5bmMgc3RyZWFtKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIEJ1ZmZlciB0aGUgZmlyc3Qgc3RyZWFtZWQgY2h1bmsgdG8gYWxsb3cgZm9yIGluaXRpYWwgZXJyb3JzXG4gICAgICAgIC8vIHRvIHN1cmZhY2UgaW1tZWRpYXRlbHkuXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB3cmFwcGVkR2VuZXJhdG9yID0gbmV3IHN0cmVhbV9qc18xLkFzeW5jR2VuZXJhdG9yV2l0aFNldHVwKHtcbiAgICAgICAgICAgIGdlbmVyYXRvcjogdGhpcy5fc3RyZWFtSXRlcmF0b3IoaW5wdXQsIGNvbmZpZyksXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB3cmFwcGVkR2VuZXJhdG9yLnNldHVwO1xuICAgICAgICByZXR1cm4gc3RyZWFtX2pzXzEuSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tQXN5bmNHZW5lcmF0b3Iod3JhcHBlZEdlbmVyYXRvcik7XG4gICAgfVxuICAgIF9zZXBhcmF0ZVJ1bm5hYmxlQ29uZmlnRnJvbUNhbGxPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHJ1bm5hYmxlQ29uZmlnO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBydW5uYWJsZUNvbmZpZyA9ICgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcnVubmFibGVDb25maWcgPSAoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKSh7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBvcHRpb25zLmNhbGxiYWNrcyxcbiAgICAgICAgICAgICAgICB0YWdzOiBvcHRpb25zLnRhZ3MsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG9wdGlvbnMubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgcnVuTmFtZTogb3B0aW9ucy5ydW5OYW1lLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogb3B0aW9ucy5jb25maWd1cmFibGUsXG4gICAgICAgICAgICAgICAgcmVjdXJzaW9uTGltaXQ6IG9wdGlvbnMucmVjdXJzaW9uTGltaXQsXG4gICAgICAgICAgICAgICAgbWF4Q29uY3VycmVuY3k6IG9wdGlvbnMubWF4Q29uY3VycmVuY3ksXG4gICAgICAgICAgICAgICAgcnVuSWQ6IG9wdGlvbnMucnVuSWQsXG4gICAgICAgICAgICAgICAgdGltZW91dDogb3B0aW9ucy50aW1lb3V0LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWxsT3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICAgICAgICBkZWxldGUgY2FsbE9wdGlvbnMuY2FsbGJhY2tzO1xuICAgICAgICBkZWxldGUgY2FsbE9wdGlvbnMudGFncztcbiAgICAgICAgZGVsZXRlIGNhbGxPcHRpb25zLm1ldGFkYXRhO1xuICAgICAgICBkZWxldGUgY2FsbE9wdGlvbnMucnVuTmFtZTtcbiAgICAgICAgZGVsZXRlIGNhbGxPcHRpb25zLmNvbmZpZ3VyYWJsZTtcbiAgICAgICAgZGVsZXRlIGNhbGxPcHRpb25zLnJlY3Vyc2lvbkxpbWl0O1xuICAgICAgICBkZWxldGUgY2FsbE9wdGlvbnMubWF4Q29uY3VycmVuY3k7XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy5ydW5JZDtcbiAgICAgICAgZGVsZXRlIGNhbGxPcHRpb25zLnRpbWVvdXQ7XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy5zaWduYWw7XG4gICAgICAgIHJldHVybiBbcnVubmFibGVDb25maWcsIGNhbGxPcHRpb25zXTtcbiAgICB9XG4gICAgYXN5bmMgX2NhbGxXaXRoQ29uZmlnKGZ1bmMsIGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgKDAsIGNvbmZpZ19qc18xLmdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZykoY29uZmlnKTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlciA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgX2NvZXJjZVRvRGljdChpbnB1dCwgXCJpbnB1dFwiKSwgY29uZmlnLnJ1bklkLCBjb25maWc/LnJ1blR5cGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb25maWc/LnJ1bk5hbWUgPz8gdGhpcy5nZXROYW1lKCkpO1xuICAgICAgICBkZWxldGUgY29uZmlnLnJ1bklkO1xuICAgICAgICBsZXQgb3V0cHV0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IGZ1bmMuY2FsbCh0aGlzLCBpbnB1dCwgY29uZmlnLCBydW5NYW5hZ2VyKTtcbiAgICAgICAgICAgIG91dHB1dCA9IGF3YWl0ICgwLCBzaWduYWxfanNfMS5yYWNlV2l0aFNpZ25hbCkocHJvbWlzZSwgb3B0aW9ucz8uc2lnbmFsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoX2NvZXJjZVRvRGljdChvdXRwdXQsIFwib3V0cHV0XCIpKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHRoYXQgaGFuZGxlcyBiYXRjaGluZyBhbmQgY29uZmlndXJhdGlvbiBmb3IgYSBydW5uYWJsZVxuICAgICAqIEl0IHRha2VzIGEgZnVuY3Rpb24sIGlucHV0IHZhbHVlcywgYW5kIG9wdGlvbmFsIGNvbmZpZ3VyYXRpb24sIGFuZFxuICAgICAqIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG91dHB1dCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGZvciBlYWNoIGlucHV0IHZhbHVlLlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdmFsdWVzIHRvIGJlIHByb2Nlc3NlZC5cbiAgICAgKiBAcGFyYW0gY29uZmlnIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBmdW5jdGlvbiBleGVjdXRpb24uXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG91dHB1dCB2YWx1ZXMuXG4gICAgICovXG4gICAgYXN5bmMgX2JhdGNoV2l0aENvbmZpZyhmdW5jLCBpbnB1dHMsIG9wdGlvbnMsIGJhdGNoT3B0aW9ucykge1xuICAgICAgICBjb25zdCBvcHRpb25zTGlzdCA9IHRoaXMuX2dldE9wdGlvbnNMaXN0KG9wdGlvbnMgPz8ge30sIGlucHV0cy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwob3B0aW9uc0xpc3QubWFwKGNvbmZpZ19qc18xLmdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZykpO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VycyA9IGF3YWl0IFByb21pc2UuYWxsKGNhbGxiYWNrTWFuYWdlcnMubWFwKGFzeW5jIChjYWxsYmFja01hbmFnZXIsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZVN0YXJ0UmVzID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIF9jb2VyY2VUb0RpY3QoaW5wdXRzW2ldLCBcImlucHV0XCIpLCBvcHRpb25zTGlzdFtpXS5ydW5JZCwgb3B0aW9uc0xpc3RbaV0ucnVuVHlwZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9wdGlvbnNMaXN0W2ldLnJ1bk5hbWUgPz8gdGhpcy5nZXROYW1lKCkpO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnNMaXN0W2ldLnJ1bklkO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0YXJ0UmVzO1xuICAgICAgICB9KSk7XG4gICAgICAgIGxldCBvdXRwdXRzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IGZ1bmMuY2FsbCh0aGlzLCBpbnB1dHMsIG9wdGlvbnNMaXN0LCBydW5NYW5hZ2VycywgYmF0Y2hPcHRpb25zKTtcbiAgICAgICAgICAgIG91dHB1dHMgPSBhd2FpdCAoMCwgc2lnbmFsX2pzXzEucmFjZVdpdGhTaWduYWwpKHByb21pc2UsIG9wdGlvbnNMaXN0Py5bMF0/LnNpZ25hbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlKSkpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChydW5NYW5hZ2Vycy5tYXAoKHJ1bk1hbmFnZXIpID0+IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKF9jb2VyY2VUb0RpY3Qob3V0cHV0cywgXCJvdXRwdXRcIikpKSk7XG4gICAgICAgIHJldHVybiBvdXRwdXRzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2NvbmNhdE91dHB1dENodW5rcyhmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIHJldHVybiAoMCwgc3RyZWFtX2pzXzEuY29uY2F0KShmaXJzdCwgc2Vjb25kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byB0cmFuc2Zvcm0gYW4gSXRlcmF0b3Igb2YgSW5wdXQgdmFsdWVzIGludG8gYW4gSXRlcmF0b3Igb2ZcbiAgICAgKiBPdXRwdXQgdmFsdWVzLCB3aXRoIGNhbGxiYWNrcy5cbiAgICAgKiBVc2UgdGhpcyB0byBpbXBsZW1lbnQgYHN0cmVhbSgpYCBvciBgdHJhbnNmb3JtKClgIGluIFJ1bm5hYmxlIHN1YmNsYXNzZXMuXG4gICAgICovXG4gICAgYXN5bmMgKl90cmFuc2Zvcm1TdHJlYW1XaXRoQ29uZmlnKGlucHV0R2VuZXJhdG9yLCB0cmFuc2Zvcm1lciwgb3B0aW9ucykge1xuICAgICAgICBsZXQgZmluYWxJbnB1dDtcbiAgICAgICAgbGV0IGZpbmFsSW5wdXRTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICBsZXQgZmluYWxPdXRwdXQ7XG4gICAgICAgIGxldCBmaW5hbE91dHB1dFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgKDAsIGNvbmZpZ19qc18xLmdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZykoY29uZmlnKTtcbiAgICAgICAgY29uc3Qgb3V0ZXJUaGlzID0gdGhpcztcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24qIHdyYXBJbnB1dEZvclRyYWNpbmcoKSB7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGlucHV0R2VuZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmFsSW5wdXRTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsSW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxJbnB1dCA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbElucHV0ID0gb3V0ZXJUaGlzLl9jb25jYXRPdXRwdXRDaHVua3MoZmluYWxJbnB1dCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxJbnB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbElucHV0U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJ1bk1hbmFnZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwaXBlID0gYXdhaXQgKDAsIHN0cmVhbV9qc18xLnBpcGVHZW5lcmF0b3JXaXRoU2V0dXApKHRyYW5zZm9ybWVyLmJpbmQodGhpcyksIHdyYXBJbnB1dEZvclRyYWNpbmcoKSwgYXN5bmMgKCkgPT4gY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCB7IGlucHV0OiBcIlwiIH0sIGNvbmZpZy5ydW5JZCwgY29uZmlnLnJ1blR5cGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb25maWcucnVuTmFtZSA/PyB0aGlzLmdldE5hbWUoKSksIG9wdGlvbnM/LnNpZ25hbCwgY29uZmlnKTtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcucnVuSWQ7XG4gICAgICAgICAgICBydW5NYW5hZ2VyID0gcGlwZS5zZXR1cDtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbUV2ZW50c0hhbmRsZXIgPSBydW5NYW5hZ2VyPy5oYW5kbGVycy5maW5kKGV2ZW50X3N0cmVhbV9qc18xLmlzU3RyZWFtRXZlbnRzSGFuZGxlcik7XG4gICAgICAgICAgICBsZXQgaXRlcmF0b3IgPSBwaXBlLm91dHB1dDtcbiAgICAgICAgICAgIGlmIChzdHJlYW1FdmVudHNIYW5kbGVyICE9PSB1bmRlZmluZWQgJiYgcnVuTWFuYWdlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IgPSBzdHJlYW1FdmVudHNIYW5kbGVyLnRhcE91dHB1dEl0ZXJhYmxlKHJ1bk1hbmFnZXIucnVuSWQsIGl0ZXJhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbUxvZ0hhbmRsZXIgPSBydW5NYW5hZ2VyPy5oYW5kbGVycy5maW5kKGxvZ19zdHJlYW1fanNfMS5pc0xvZ1N0cmVhbUhhbmRsZXIpO1xuICAgICAgICAgICAgaWYgKHN0cmVhbUxvZ0hhbmRsZXIgIT09IHVuZGVmaW5lZCAmJiBydW5NYW5hZ2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvciA9IHN0cmVhbUxvZ0hhbmRsZXIudGFwT3V0cHV0SXRlcmFibGUocnVuTWFuYWdlci5ydW5JZCwgaXRlcmF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBpdGVyYXRvcikge1xuICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgICAgIGlmIChmaW5hbE91dHB1dFN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxPdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSB0aGlzLl9jb25jYXRPdXRwdXRDaHVua3MoZmluYWxPdXRwdXQsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgIGlucHV0czogX2NvZXJjZVRvRGljdChmaW5hbElucHV0LCBcImlucHV0XCIpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKGZpbmFsT3V0cHV0ID8/IHt9LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7IGlucHV0czogX2NvZXJjZVRvRGljdChmaW5hbElucHV0LCBcImlucHV0XCIpIH0pO1xuICAgIH1cbiAgICBnZXRHcmFwaChfKSB7XG4gICAgICAgIGNvbnN0IGdyYXBoID0gbmV3IGdyYXBoX2pzXzEuR3JhcGgoKTtcbiAgICAgICAgLy8gVE9ETzogQWRkIGlucHV0IHNjaGVtYSBmb3IgcnVubmFibGVzXG4gICAgICAgIGNvbnN0IGlucHV0Tm9kZSA9IGdyYXBoLmFkZE5vZGUoe1xuICAgICAgICAgICAgbmFtZTogYCR7dGhpcy5nZXROYW1lKCl9SW5wdXRgLFxuICAgICAgICAgICAgc2NoZW1hOiB2M18xLnouYW55KCksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBydW5uYWJsZU5vZGUgPSBncmFwaC5hZGROb2RlKHRoaXMpO1xuICAgICAgICAvLyBUT0RPOiBBZGQgb3V0cHV0IHNjaGVtYXMgZm9yIHJ1bm5hYmxlc1xuICAgICAgICBjb25zdCBvdXRwdXROb2RlID0gZ3JhcGguYWRkTm9kZSh7XG4gICAgICAgICAgICBuYW1lOiBgJHt0aGlzLmdldE5hbWUoKX1PdXRwdXRgLFxuICAgICAgICAgICAgc2NoZW1hOiB2M18xLnouYW55KCksXG4gICAgICAgIH0pO1xuICAgICAgICBncmFwaC5hZGRFZGdlKGlucHV0Tm9kZSwgcnVubmFibGVOb2RlKTtcbiAgICAgICAgZ3JhcGguYWRkRWRnZShydW5uYWJsZU5vZGUsIG91dHB1dE5vZGUpO1xuICAgICAgICByZXR1cm4gZ3JhcGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBydW5uYWJsZSBzZXF1ZW5jZSB0aGF0IHJ1bnMgZWFjaCBpbmRpdmlkdWFsIHJ1bm5hYmxlIGluIHNlcmllcyxcbiAgICAgKiBwaXBpbmcgdGhlIG91dHB1dCBvZiBvbmUgcnVubmFibGUgaW50byBhbm90aGVyIHJ1bm5hYmxlIG9yIHJ1bm5hYmxlLWxpa2UuXG4gICAgICogQHBhcmFtIGNvZXJjZWFibGUgQSBydW5uYWJsZSwgZnVuY3Rpb24sIG9yIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGZ1bmN0aW9ucyBvciBydW5uYWJsZXMuXG4gICAgICogQHJldHVybnMgQSBuZXcgcnVubmFibGUgc2VxdWVuY2UuXG4gICAgICovXG4gICAgcGlwZShjb2VyY2VhYmxlKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZVNlcXVlbmNlKHtcbiAgICAgICAgICAgIGZpcnN0OiB0aGlzLFxuICAgICAgICAgICAgbGFzdDogX2NvZXJjZVRvUnVubmFibGUoY29lcmNlYWJsZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQaWNrIGtleXMgZnJvbSB0aGUgZGljdCBvdXRwdXQgb2YgdGhpcyBydW5uYWJsZS4gUmV0dXJucyBhIG5ldyBydW5uYWJsZS5cbiAgICAgKi9cbiAgICBwaWNrKGtleXMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gdGhpcy5waXBlKG5ldyBSdW5uYWJsZVBpY2soa2V5cykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG5ldyBmaWVsZHMgdG8gdGhlIGRpY3Qgb3V0cHV0IG9mIHRoaXMgcnVubmFibGUuIFJldHVybnMgYSBuZXcgcnVubmFibGUuXG4gICAgICovXG4gICAgYXNzaWduKG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlwZShcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICBuZXcgUnVubmFibGVBc3NpZ24oXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgbmV3IFJ1bm5hYmxlTWFwKHsgc3RlcHM6IG1hcHBpbmcgfSkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0cmFuc2Zvcm0sIHdoaWNoIGJ1ZmZlcnMgaW5wdXQgYW5kIHRoZW4gY2FsbHMgc3RyZWFtLlxuICAgICAqIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHRoZXkgY2FuIHN0YXJ0IHByb2R1Y2luZyBvdXRwdXQgd2hpbGVcbiAgICAgKiBpbnB1dCBpcyBzdGlsbCBiZWluZyBnZW5lcmF0ZWQuXG4gICAgICogQHBhcmFtIGdlbmVyYXRvclxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgYXN5bmMgKnRyYW5zZm9ybShnZW5lcmF0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGZpbmFsQ2h1bms7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgZ2VuZXJhdG9yKSB7XG4gICAgICAgICAgICBpZiAoZmluYWxDaHVuayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZmluYWxDaHVuayA9IGNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBhIGJlc3QgZWZmb3J0IHRvIGdhdGhlciwgZm9yIGFueSB0eXBlIHRoYXQgc3VwcG9ydHMgY29uY2F0LlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbWV0aG9kIHNob3VsZCB0aHJvdyBhbiBlcnJvciBpZiBnYXRoZXJpbmcgZmFpbHMuXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBmaW5hbENodW5rID0gdGhpcy5fY29uY2F0T3V0cHV0Q2h1bmtzKGZpbmFsQ2h1bmssIGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB5aWVsZCogdGhpcy5fc3RyZWFtSXRlcmF0b3IoZmluYWxDaHVuaywgKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJlYW0gYWxsIG91dHB1dCBmcm9tIGEgcnVubmFibGUsIGFzIHJlcG9ydGVkIHRvIHRoZSBjYWxsYmFjayBzeXN0ZW0uXG4gICAgICogVGhpcyBpbmNsdWRlcyBhbGwgaW5uZXIgcnVucyBvZiBMTE1zLCBSZXRyaWV2ZXJzLCBUb29scywgZXRjLlxuICAgICAqIE91dHB1dCBpcyBzdHJlYW1lZCBhcyBMb2cgb2JqZWN0cywgd2hpY2ggaW5jbHVkZSBhIGxpc3Qgb2ZcbiAgICAgKiBqc29ucGF0Y2ggb3BzIHRoYXQgZGVzY3JpYmUgaG93IHRoZSBzdGF0ZSBvZiB0aGUgcnVuIGhhcyBjaGFuZ2VkIGluIGVhY2hcbiAgICAgKiBzdGVwLCBhbmQgdGhlIGZpbmFsIHN0YXRlIG9mIHRoZSBydW4uXG4gICAgICogVGhlIGpzb25wYXRjaCBvcHMgY2FuIGJlIGFwcGxpZWQgaW4gb3JkZXIgdG8gY29uc3RydWN0IHN0YXRlLlxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIHN0cmVhbU9wdGlvbnNcbiAgICAgKi9cbiAgICBhc3luYyAqc3RyZWFtTG9nKGlucHV0LCBvcHRpb25zLCBzdHJlYW1PcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlciA9IG5ldyBsb2dfc3RyZWFtX2pzXzEuTG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyKHtcbiAgICAgICAgICAgIC4uLnN0cmVhbU9wdGlvbnMsXG4gICAgICAgICAgICBhdXRvQ2xvc2U6IGZhbHNlLFxuICAgICAgICAgICAgX3NjaGVtYUZvcm1hdDogXCJvcmlnaW5hbFwiLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucyk7XG4gICAgICAgIHlpZWxkKiB0aGlzLl9zdHJlYW1Mb2coaW5wdXQsIGxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlciwgY29uZmlnKTtcbiAgICB9XG4gICAgYXN5bmMgKl9zdHJlYW1Mb2coaW5wdXQsIGxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlciwgY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHsgY2FsbGJhY2tzIH0gPSBjb25maWc7XG4gICAgICAgIGlmIChjYWxsYmFja3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBjb25maWcuY2FsbGJhY2tzID0gW2xvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlcl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjYWxsYmFja3MpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGNvbmZpZy5jYWxsYmFja3MgPSBjYWxsYmFja3MuY29uY2F0KFtsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXJdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNvcGllZENhbGxiYWNrcyA9IGNhbGxiYWNrcy5jb3B5KCk7XG4gICAgICAgICAgICBjb3BpZWRDYWxsYmFja3MuYWRkSGFuZGxlcihsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIsIHRydWUpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBjb25maWcuY2FsbGJhY2tzID0gY29waWVkQ2FsbGJhY2tzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJ1bm5hYmxlU3RyZWFtUHJvbWlzZSA9IHRoaXMuc3RyZWFtKGlucHV0LCBjb25maWcpO1xuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb25zdW1lUnVubmFibGVTdHJlYW0oKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bm5hYmxlU3RyZWFtID0gYXdhaXQgcnVubmFibGVTdHJlYW1Qcm9taXNlO1xuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcnVubmFibGVTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0Y2ggPSBuZXcgbG9nX3N0cmVhbV9qc18xLlJ1bkxvZ1BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IFwiL3N0cmVhbWVkX291dHB1dC8tXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlci53cml0ZXIud3JpdGUocGF0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlci53cml0ZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW5uYWJsZVN0cmVhbUNvbnN1bWVQcm9taXNlID0gY29uc3VtZVJ1bm5hYmxlU3RyZWFtKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGxvZyBvZiBsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBsb2c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBhd2FpdCBydW5uYWJsZVN0cmVhbUNvbnN1bWVQcm9taXNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0cmVhbUV2ZW50cyhpbnB1dCwgb3B0aW9ucywgc3RyZWFtT3B0aW9ucykge1xuICAgICAgICBsZXQgc3RyZWFtO1xuICAgICAgICBpZiAob3B0aW9ucy52ZXJzaW9uID09PSBcInYxXCIpIHtcbiAgICAgICAgICAgIHN0cmVhbSA9IHRoaXMuX3N0cmVhbUV2ZW50c1YxKGlucHV0LCBvcHRpb25zLCBzdHJlYW1PcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLnZlcnNpb24gPT09IFwidjJcIikge1xuICAgICAgICAgICAgc3RyZWFtID0gdGhpcy5fc3RyZWFtRXZlbnRzVjIoaW5wdXQsIG9wdGlvbnMsIHN0cmVhbU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPbmx5IHZlcnNpb25zIFwidjFcIiBhbmQgXCJ2MlwiIG9mIHRoZSBzY2hlbWEgYXJlIGN1cnJlbnRseSBzdXBwb3J0ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW5jb2RpbmcgPT09IFwidGV4dC9ldmVudC1zdHJlYW1cIikge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB3cmFwcGVyc19qc18xLmNvbnZlcnRUb0h0dHBFdmVudFN0cmVhbSkoc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJlYW1fanNfMS5JdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21Bc3luY0dlbmVyYXRvcihzdHJlYW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICpfc3RyZWFtRXZlbnRzVjIoaW5wdXQsIG9wdGlvbnMsIHN0cmVhbU9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZXZlbnRTdHJlYW1lciA9IG5ldyBldmVudF9zdHJlYW1fanNfMS5FdmVudFN0cmVhbUNhbGxiYWNrSGFuZGxlcih7XG4gICAgICAgICAgICAuLi5zdHJlYW1PcHRpb25zLFxuICAgICAgICAgICAgYXV0b0Nsb3NlOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBydW5JZCA9IGNvbmZpZy5ydW5JZCA/PyAoMCwgdXVpZF8xLnY0KSgpO1xuICAgICAgICBjb25maWcucnVuSWQgPSBydW5JZDtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gY29uZmlnLmNhbGxiYWNrcztcbiAgICAgICAgaWYgKGNhbGxiYWNrcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25maWcuY2FsbGJhY2tzID0gW2V2ZW50U3RyZWFtZXJdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2FsbGJhY2tzKSkge1xuICAgICAgICAgICAgY29uZmlnLmNhbGxiYWNrcyA9IGNhbGxiYWNrcy5jb25jYXQoZXZlbnRTdHJlYW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjb3BpZWRDYWxsYmFja3MgPSBjYWxsYmFja3MuY29weSgpO1xuICAgICAgICAgICAgY29waWVkQ2FsbGJhY2tzLmFkZEhhbmRsZXIoZXZlbnRTdHJlYW1lciwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGNvbmZpZy5jYWxsYmFja3MgPSBjb3BpZWRDYWxsYmFja3M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAvLyBDYWxsIHRoZSBydW5uYWJsZSBpbiBzdHJlYW1pbmcgbW9kZSxcbiAgICAgICAgLy8gYWRkIGVhY2ggY2h1bmsgdG8gdGhlIG91dHB1dCBzdHJlYW1cbiAgICAgICAgY29uc3Qgb3V0ZXJUaGlzID0gdGhpcztcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29uc3VtZVJ1bm5hYmxlU3RyZWFtKCkge1xuICAgICAgICAgICAgbGV0IHNpZ25hbDtcbiAgICAgICAgICAgIGxldCBsaXN0ZW5lciA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zPy5zaWduYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiYW55XCIgaW4gQWJvcnRTaWduYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBuYXRpdmUgQWJvcnRTaWduYWwuYW55KCkgaWYgYXZhaWxhYmxlIChOb2RlIDE5KylcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYWwgPSBBYm9ydFNpZ25hbC5hbnkoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIGZvciBOb2RlIDE4IGFuZCBiZWxvdyAtIGp1c3QgdXNlIHRoZSBwcm92aWRlZCBzaWduYWxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHdlIHN0aWxsIGFib3J0IG91ciBjb250cm9sbGVyIHdoZW4gdGhlIHBhcmVudCBzaWduYWwgYWJvcnRzXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgbGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcnVubmFibGVTdHJlYW0gPSBhd2FpdCBvdXRlclRoaXMuc3RyZWFtKGlucHV0LCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcHBlZFN0cmVhbSA9IGV2ZW50U3RyZWFtZXIudGFwT3V0cHV0SXRlcmFibGUocnVuSWQsIHJ1bm5hYmxlU3RyZWFtKTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBfIG9mIHRhcHBlZFN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBKdXN0IGl0ZXJhdGUgc28gdGhhdCB0aGUgY2FsbGJhY2sgaGFuZGxlciBwaWNrcyB1cCBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGV2ZW50U3RyZWFtZXIuZmluaXNoKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNpZ25hbCAmJiBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVubmFibGVTdHJlYW1Db25zdW1lUHJvbWlzZSA9IGNvbnN1bWVSdW5uYWJsZVN0cmVhbSgpO1xuICAgICAgICBsZXQgZmlyc3RFdmVudFNlbnQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGZpcnN0RXZlbnRSdW5JZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgZXZlbnQgb2YgZXZlbnRTdHJlYW1lcikge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSB3b3JrLWFyb3VuZCBhbiBpc3N1ZSB3aGVyZSB0aGUgaW5wdXRzIGludG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gY2hhaW4gYXJlIG5vdCBhdmFpbGFibGUgdW50aWwgdGhlIGVudGlyZSBpbnB1dCBpcyBjb25zdW1lZC5cbiAgICAgICAgICAgICAgICAvLyBBcyBhIHRlbXBvcmFyeSBzb2x1dGlvbiwgd2UnbGwgbW9kaWZ5IHRoZSBpbnB1dCB0byBiZSB0aGUgaW5wdXRcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHdhcyBwYXNzZWQgaW50byB0aGUgY2hhaW4uXG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdEV2ZW50U2VudCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5kYXRhLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0RXZlbnRTZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RFdmVudFJ1bklkID0gZXZlbnQucnVuX2lkO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBldmVudDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudC5ydW5faWQgPT09IGZpcnN0RXZlbnRSdW5JZCAmJiBldmVudC5ldmVudC5lbmRzV2l0aChcIl9lbmRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQncyB0aGUgZW5kIGV2ZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHJvb3QgcnVubmFibGVcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9udCBpbmNsdWRlIHRoZSBpbnB1dCBpbiB0aGUgZXZlbnQgc2luY2UgaXQncyBndWFyYW50ZWVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBmaXJzdCBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGE/LmlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZXZlbnQuZGF0YS5pbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5aWVsZCBldmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgYXdhaXQgcnVubmFibGVTdHJlYW1Db25zdW1lUHJvbWlzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbUV2ZW50c1YxKGlucHV0LCBvcHRpb25zLCBzdHJlYW1PcHRpb25zKSB7XG4gICAgICAgIGxldCBydW5Mb2c7XG4gICAgICAgIGxldCBoYXNFbmNvdW50ZXJlZFN0YXJ0RXZlbnQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJvb3RUYWdzID0gY29uZmlnLnRhZ3MgPz8gW107XG4gICAgICAgIGNvbnN0IHJvb3RNZXRhZGF0YSA9IGNvbmZpZy5tZXRhZGF0YSA/PyB7fTtcbiAgICAgICAgY29uc3Qgcm9vdE5hbWUgPSBjb25maWcucnVuTmFtZSA/PyB0aGlzLmdldE5hbWUoKTtcbiAgICAgICAgY29uc3QgbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyID0gbmV3IGxvZ19zdHJlYW1fanNfMS5Mb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIoe1xuICAgICAgICAgICAgLi4uc3RyZWFtT3B0aW9ucyxcbiAgICAgICAgICAgIGF1dG9DbG9zZTogZmFsc2UsXG4gICAgICAgICAgICBfc2NoZW1hRm9ybWF0OiBcInN0cmVhbWluZ19ldmVudHNcIixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJvb3RFdmVudEZpbHRlciA9IG5ldyB1dGlsc19qc18xLl9Sb290RXZlbnRGaWx0ZXIoe1xuICAgICAgICAgICAgLi4uc3RyZWFtT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGxvZ1N0cmVhbSA9IHRoaXMuX3N0cmVhbUxvZyhpbnB1dCwgbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyLCBjb25maWcpO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGxvZyBvZiBsb2dTdHJlYW0pIHtcbiAgICAgICAgICAgIGlmICghcnVuTG9nKSB7XG4gICAgICAgICAgICAgICAgcnVuTG9nID0gbG9nX3N0cmVhbV9qc18xLlJ1bkxvZy5mcm9tUnVuTG9nUGF0Y2gobG9nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJ1bkxvZyA9IHJ1bkxvZy5jb25jYXQobG9nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChydW5Mb2cuc3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW50ZXJuYWwgZXJyb3I6IFwic3RyZWFtRXZlbnRzXCIgc3RhdGUgaXMgbWlzc2luZy4gUGxlYXNlIG9wZW4gYSBidWcgcmVwb3J0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gWWllbGQgdGhlIHN0YXJ0IGV2ZW50IGZvciB0aGUgcm9vdCBydW5uYWJsZSBpZiBpdCBoYXNuJ3QgYmVlbiBzZWVuLlxuICAgICAgICAgICAgLy8gVGhlIHJvb3QgcnVuIGlzIG5ldmVyIGZpbHRlcmVkIG91dFxuICAgICAgICAgICAgaWYgKCFoYXNFbmNvdW50ZXJlZFN0YXJ0RXZlbnQpIHtcbiAgICAgICAgICAgICAgICBoYXNFbmNvdW50ZXJlZFN0YXJ0RXZlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0geyAuLi5ydW5Mb2cuc3RhdGUgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuX2lkOiBzdGF0ZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGBvbl8ke3N0YXRlLnR5cGV9X3N0YXJ0YCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcm9vdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHRhZ3M6IHJvb3RUYWdzLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogcm9vdE1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChyb290RXZlbnRGaWx0ZXIuaW5jbHVkZUV2ZW50KGV2ZW50LCBzdGF0ZS50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBldmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXRocyA9IGxvZy5vcHNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChvcCkgPT4gb3AucGF0aC5zdGFydHNXaXRoKFwiL2xvZ3MvXCIpKVxuICAgICAgICAgICAgICAgIC5tYXAoKG9wKSA9PiBvcC5wYXRoLnNwbGl0KFwiL1wiKVsyXSk7XG4gICAgICAgICAgICBjb25zdCBkZWR1cGVkUGF0aHMgPSBbLi4ubmV3IFNldChwYXRocyldO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXRoIG9mIGRlZHVwZWRQYXRocykge1xuICAgICAgICAgICAgICAgIGxldCBldmVudFR5cGU7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGEgPSB7fTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2dFbnRyeSA9IHJ1bkxvZy5zdGF0ZS5sb2dzW3BhdGhdO1xuICAgICAgICAgICAgICAgIGlmIChsb2dFbnRyeS5lbmRfdGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2dFbnRyeS5zdHJlYW1lZF9vdXRwdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRUeXBlID0gXCJzdHJlYW1cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VHlwZSA9IFwic3RhcnRcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRUeXBlID0gXCJlbmRcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluY2x1ZGUgdGhlIGlucHV0cyB3aXRoIHRoZSBzdGFydCBldmVudCBpZiB0aGV5IGFyZSBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzdWFsbHkgdGhleSB3aWxsIE5PVCBiZSBhdmFpbGFibGUgZm9yIGNvbXBvbmVudHMgdGhhdCBvcGVyYXRlXG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIHN0cmVhbXMsIHNpbmNlIHRob3NlIGNvbXBvbmVudHMgc3RyZWFtIHRoZSBpbnB1dCBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3Qga25vdyBpdHMgZmluYWwgdmFsdWUgdW50aWwgdGhlIGVuZCBvZiB0aGUgc3RyZWFtLlxuICAgICAgICAgICAgICAgICAgICBpZiAobG9nRW50cnkuaW5wdXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaW5wdXQgPSBsb2dFbnRyeS5pbnB1dHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnRUeXBlID09PSBcImVuZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2dFbnRyeS5pbnB1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5pbnB1dCA9IGxvZ0VudHJ5LmlucHV0cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXRhLm91dHB1dCA9IGxvZ0VudHJ5LmZpbmFsX291dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnRUeXBlID09PSBcInN0cmVhbVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rQ291bnQgPSBsb2dFbnRyeS5zdHJlYW1lZF9vdXRwdXQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmtDb3VudCAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBleGFjdGx5IG9uZSBjaHVuayBvZiBzdHJlYW1lZCBvdXRwdXQsIGdvdCAke2NodW5rQ291bnR9IGluc3RlYWQuIEVuY291bnRlcmVkIGluOiBcIiR7bG9nRW50cnkubmFtZX1cImApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB7IGNodW5rOiBsb2dFbnRyeS5zdHJlYW1lZF9vdXRwdXRbMF0gfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIHN0cmVhbSwgd2UgZG9uJ3QgbmVlZCBpdCBhbnltb3JlLlxuICAgICAgICAgICAgICAgICAgICAvLyBBbmQgdGhpcyBhdm9pZHMgZHVwbGljYXRlcyBhcyB3ZWxsIVxuICAgICAgICAgICAgICAgICAgICBsb2dFbnRyeS5zdHJlYW1lZF9vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgICAgICAgICBldmVudDogYG9uXyR7bG9nRW50cnkudHlwZX1fJHtldmVudFR5cGV9YCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbG9nRW50cnkubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcnVuX2lkOiBsb2dFbnRyeS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdGFnczogbG9nRW50cnkudGFncyxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IGxvZ0VudHJ5Lm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaW5hbGx5LCB3ZSB0YWtlIGNhcmUgb2YgdGhlIHN0cmVhbWluZyBvdXRwdXQgZnJvbSB0aGUgcm9vdCBjaGFpblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55LlxuICAgICAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gcnVuTG9nO1xuICAgICAgICAgICAgaWYgKHN0YXRlLnN0cmVhbWVkX291dHB1dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmtDb3VudCA9IHN0YXRlLnN0cmVhbWVkX291dHB1dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGNodW5rQ291bnQgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBleGFjdGx5IG9uZSBjaHVuayBvZiBzdHJlYW1lZCBvdXRwdXQsIGdvdCAke2NodW5rQ291bnR9IGluc3RlYWQuIEVuY291bnRlcmVkIGluOiBcIiR7c3RhdGUubmFtZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geyBjaHVuazogc3RhdGUuc3RyZWFtZWRfb3V0cHV0WzBdIH07XG4gICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIHN0cmVhbSwgd2UgZG9uJ3QgbmVlZCBpdCBhbnltb3JlLlxuICAgICAgICAgICAgICAgIHN0YXRlLnN0cmVhbWVkX291dHB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBldmVudDogYG9uXyR7c3RhdGUudHlwZX1fc3RyZWFtYCxcbiAgICAgICAgICAgICAgICAgICAgcnVuX2lkOiBzdGF0ZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdGFnczogcm9vdFRhZ3MsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiByb290TWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHJvb3ROYW1lLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHJvb3RFdmVudEZpbHRlci5pbmNsdWRlRXZlbnQoZXZlbnQsIHN0YXRlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGV2ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0ZSA9IHJ1bkxvZz8uc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBGaW5hbGx5LCB5aWVsZCB0aGUgZW5kIGV2ZW50IGZvciB0aGUgcm9vdCBydW5uYWJsZS5cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgIGV2ZW50OiBgb25fJHtzdGF0ZS50eXBlfV9lbmRgLFxuICAgICAgICAgICAgICAgIG5hbWU6IHJvb3ROYW1lLFxuICAgICAgICAgICAgICAgIHJ1bl9pZDogc3RhdGUuaWQsXG4gICAgICAgICAgICAgICAgdGFnczogcm9vdFRhZ3MsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHJvb3RNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dDogc3RhdGUuZmluYWxfb3V0cHV0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJvb3RFdmVudEZpbHRlci5pbmNsdWRlRXZlbnQoZXZlbnQsIHN0YXRlLnR5cGUpKVxuICAgICAgICAgICAgICAgIHlpZWxkIGV2ZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc3RhdGljIGlzUnVubmFibGUodGhpbmcpIHtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc19qc18xLmlzUnVubmFibGVJbnRlcmZhY2UpKHRoaW5nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZCBsaWZlY3ljbGUgbGlzdGVuZXJzIHRvIGEgUnVubmFibGUsIHJldHVybmluZyBhIG5ldyBSdW5uYWJsZS5cbiAgICAgKiBUaGUgUnVuIG9iamVjdCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcnVuLCBpbmNsdWRpbmcgaXRzIGlkLFxuICAgICAqIHR5cGUsIGlucHV0LCBvdXRwdXQsIGVycm9yLCBzdGFydFRpbWUsIGVuZFRpbWUsIGFuZCBhbnkgdGFncyBvciBtZXRhZGF0YVxuICAgICAqIGFkZGVkIHRvIHRoZSBydW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIG9iamVjdCBjb250YWluaW5nIHRoZSBjYWxsYmFjayBmdW5jdGlvbnMuXG4gICAgICogQHBhcmFtIHsocnVuOiBSdW4pID0+IHZvaWR9IHBhcmFtcy5vblN0YXJ0IC0gQ2FsbGVkIGJlZm9yZSB0aGUgcnVubmFibGUgc3RhcnRzIHJ1bm5pbmcsIHdpdGggdGhlIFJ1biBvYmplY3QuXG4gICAgICogQHBhcmFtIHsocnVuOiBSdW4pID0+IHZvaWR9IHBhcmFtcy5vbkVuZCAtIENhbGxlZCBhZnRlciB0aGUgcnVubmFibGUgZmluaXNoZXMgcnVubmluZywgd2l0aCB0aGUgUnVuIG9iamVjdC5cbiAgICAgKiBAcGFyYW0geyhydW46IFJ1bikgPT4gdm9pZH0gcGFyYW1zLm9uRXJyb3IgLSBDYWxsZWQgaWYgdGhlIHJ1bm5hYmxlIHRocm93cyBhbiBlcnJvciwgd2l0aCB0aGUgUnVuIG9iamVjdC5cbiAgICAgKi9cbiAgICB3aXRoTGlzdGVuZXJzKHsgb25TdGFydCwgb25FbmQsIG9uRXJyb3IsIH0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlQmluZGluZyh7XG4gICAgICAgICAgICBib3VuZDogdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZzoge30sXG4gICAgICAgICAgICBjb25maWdGYWN0b3JpZXM6IFtcbiAgICAgICAgICAgICAgICAoY29uZmlnKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyByb290X2xpc3RlbmVyX2pzXzEuUm9vdExpc3RlbmVyc1RyYWNlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBydW5uYWJsZSB0byBhIHRvb2wuIFJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBgUnVubmFibGVUb29sTGlrZWBcbiAgICAgKiB3aGljaCBjb250YWlucyB0aGUgcnVubmFibGUsIG5hbWUsIGRlc2NyaXB0aW9uIGFuZCBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAdGVtcGxhdGUge1QgZXh0ZW5kcyBSdW5JbnB1dCA9IFJ1bklucHV0fSBSdW5JbnB1dCAtIFRoZSBpbnB1dCB0eXBlIG9mIHRoZSBydW5uYWJsZS4gU2hvdWxkIGJlIHRoZSBzYW1lIGFzIHRoZSBgUnVuSW5wdXRgIHR5cGUgb2YgdGhlIHJ1bm5hYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpZWxkc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbZmllbGRzLm5hbWVdIFRoZSBuYW1lIG9mIHRoZSB0b29sLiBJZiBub3QgcHJvdmlkZWQsIGl0IHdpbGwgZGVmYXVsdCB0byB0aGUgbmFtZSBvZiB0aGUgcnVubmFibGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFtmaWVsZHMuZGVzY3JpcHRpb25dIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgdG9vbC4gRmFsbHMgYmFjayB0byB0aGUgZGVzY3JpcHRpb24gb24gdGhlIFpvZCBzY2hlbWEgaWYgbm90IHByb3ZpZGVkLCBvciB1bmRlZmluZWQgaWYgbmVpdGhlciBhcmUgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHt6LlpvZFR5cGU8VD59IFtmaWVsZHMuc2NoZW1hXSBUaGUgWm9kIHNjaGVtYSBmb3IgdGhlIGlucHV0IG9mIHRoZSB0b29sLiBJbmZlcnMgdGhlIFpvZCB0eXBlIGZyb20gdGhlIGlucHV0IHR5cGUgb2YgdGhlIHJ1bm5hYmxlLlxuICAgICAqIEByZXR1cm5zIHtSdW5uYWJsZVRvb2xMaWtlPHouWm9kVHlwZTxUPiwgUnVuT3V0cHV0Pn0gQW4gaW5zdGFuY2Ugb2YgYFJ1bm5hYmxlVG9vbExpa2VgIHdoaWNoIGlzIGEgcnVubmFibGUgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIHRvb2wuXG4gICAgICovXG4gICAgYXNUb29sKGZpZWxkcykge1xuICAgICAgICByZXR1cm4gY29udmVydFJ1bm5hYmxlVG9Ub29sKHRoaXMsIGZpZWxkcyk7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5uYWJsZSA9IFJ1bm5hYmxlO1xuLyoqXG4gKiBXcmFwcyBhIHJ1bm5hYmxlIGFuZCBhcHBsaWVzIHBhcnRpYWwgY29uZmlnIHVwb24gaW52b2NhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHtcbiAqICAgdHlwZSBSdW5uYWJsZUNvbmZpZyxcbiAqICAgUnVubmFibGVMYW1iZGEsXG4gKiB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG4gKlxuICogY29uc3QgZW5oYW5jZVByb2ZpbGUgPSAoXG4gKiAgIHByb2ZpbGU6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gKiAgIGNvbmZpZz86IFJ1bm5hYmxlQ29uZmlnXG4gKiApID0+IHtcbiAqICAgaWYgKGNvbmZpZz8uY29uZmlndXJhYmxlPy5yb2xlKSB7XG4gKiAgICAgcmV0dXJuIHsgLi4ucHJvZmlsZSwgcm9sZTogY29uZmlnLmNvbmZpZ3VyYWJsZS5yb2xlIH07XG4gKiAgIH1cbiAqICAgcmV0dXJuIHByb2ZpbGU7XG4gKiB9O1xuICpcbiAqIGNvbnN0IHJ1bm5hYmxlID0gUnVubmFibGVMYW1iZGEuZnJvbShlbmhhbmNlUHJvZmlsZSk7XG4gKlxuICogLy8gQmluZCBjb25maWd1cmF0aW9uIHRvIHRoZSBydW5uYWJsZSB0byBzZXQgdGhlIHVzZXIncyByb2xlIGR5bmFtaWNhbGx5XG4gKiBjb25zdCBhZG1pblJ1bm5hYmxlID0gcnVubmFibGUuYmluZCh7IGNvbmZpZ3VyYWJsZTogeyByb2xlOiBcIkFkbWluXCIgfSB9KTtcbiAqIGNvbnN0IHVzZXJSdW5uYWJsZSA9IHJ1bm5hYmxlLmJpbmQoeyBjb25maWd1cmFibGU6IHsgcm9sZTogXCJVc2VyXCIgfSB9KTtcbiAqXG4gKiBjb25zdCByZXN1bHQxID0gYXdhaXQgYWRtaW5SdW5uYWJsZS5pbnZva2Uoe1xuICogICBuYW1lOiBcIkFsaWNlXCIsXG4gKiAgIGVtYWlsOiBcImFsaWNlQGV4YW1wbGUuY29tXCJcbiAqIH0pO1xuICpcbiAqIC8vIHsgbmFtZTogXCJBbGljZVwiLCBlbWFpbDogXCJhbGljZUBleGFtcGxlLmNvbVwiLCByb2xlOiBcIkFkbWluXCIgfVxuICpcbiAqIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCB1c2VyUnVubmFibGUuaW52b2tlKHtcbiAqICAgbmFtZTogXCJCb2JcIixcbiAqICAgZW1haWw6IFwiYm9iQGV4YW1wbGUuY29tXCJcbiAqIH0pO1xuICpcbiAqIC8vIHsgbmFtZTogXCJCb2JcIiwgZW1haWw6IFwiYm9iQGV4YW1wbGUuY29tXCIsIHJvbGU6IFwiVXNlclwiIH1cbiAqIGBgYFxuICovXG5jbGFzcyBSdW5uYWJsZUJpbmRpbmcgZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlQmluZGluZ1wiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJib3VuZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb25maWdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwia3dhcmdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbmZpZ0ZhY3Rvcmllc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvdW5kID0gZmllbGRzLmJvdW5kO1xuICAgICAgICB0aGlzLmt3YXJncyA9IGZpZWxkcy5rd2FyZ3M7XG4gICAgICAgIHRoaXMuY29uZmlnID0gZmllbGRzLmNvbmZpZztcbiAgICAgICAgdGhpcy5jb25maWdGYWN0b3JpZXMgPSBmaWVsZHMuY29uZmlnRmFjdG9yaWVzO1xuICAgIH1cbiAgICBnZXROYW1lKHN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZC5nZXROYW1lKHN1ZmZpeCk7XG4gICAgfVxuICAgIGFzeW5jIF9tZXJnZUNvbmZpZyguLi5vcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBjb25maWdfanNfMS5tZXJnZUNvbmZpZ3MpKHRoaXMuY29uZmlnLCAuLi5vcHRpb25zKTtcbiAgICAgICAgcmV0dXJuICgwLCBjb25maWdfanNfMS5tZXJnZUNvbmZpZ3MpKGNvbmZpZywgLi4uKHRoaXMuY29uZmlnRmFjdG9yaWVzXG4gICAgICAgICAgICA/IGF3YWl0IFByb21pc2UuYWxsKHRoaXMuY29uZmlnRmFjdG9yaWVzLm1hcChhc3luYyAoY29uZmlnRmFjdG9yeSkgPT4gYXdhaXQgY29uZmlnRmFjdG9yeShjb25maWcpKSlcbiAgICAgICAgICAgIDogW10pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZHMgdGhlIHJ1bm5hYmxlIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIGt3YXJncyBUaGUgYXJndW1lbnRzIHRvIGJpbmQgdGhlIHJ1bm5hYmxlIHdpdGguXG4gICAgICogQHJldHVybnMgQSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBSdW5uYWJsZUJpbmRpbmdgIGNsYXNzIHRoYXQgaXMgYm91bmQgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgd2l0aENvbmZpZ30gaW5zdGVhZC4gVGhpcyB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgYnJlYWtpbmcgcmVsZWFzZS5cbiAgICAgKi9cbiAgICBiaW5kKGt3YXJncykge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3Ioe1xuICAgICAgICAgICAgYm91bmQ6IHRoaXMuYm91bmQsXG4gICAgICAgICAgICBrd2FyZ3M6IHsgLi4udGhpcy5rd2FyZ3MsIC4uLmt3YXJncyB9LFxuICAgICAgICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHdpdGhDb25maWcoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih7XG4gICAgICAgICAgICBib3VuZDogdGhpcy5ib3VuZCxcbiAgICAgICAgICAgIGt3YXJnczogdGhpcy5rd2FyZ3MsXG4gICAgICAgICAgICBjb25maWc6IHsgLi4udGhpcy5jb25maWcsIC4uLmNvbmZpZyB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgd2l0aFJldHJ5KGZpZWxkcykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVSZXRyeSh7XG4gICAgICAgICAgICBib3VuZDogdGhpcy5ib3VuZCxcbiAgICAgICAgICAgIGt3YXJnczogdGhpcy5rd2FyZ3MsXG4gICAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICAgICAgbWF4QXR0ZW1wdE51bWJlcjogZmllbGRzPy5zdG9wQWZ0ZXJBdHRlbXB0LFxuICAgICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kLmludm9rZShpbnB1dCwgYXdhaXQgdGhpcy5fbWVyZ2VDb25maWcoKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucyksIHRoaXMua3dhcmdzKSk7XG4gICAgfVxuICAgIGFzeW5jIGJhdGNoKGlucHV0cywgb3B0aW9ucywgYmF0Y2hPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMpXG4gICAgICAgICAgICA/IGF3YWl0IFByb21pc2UuYWxsKG9wdGlvbnMubWFwKGFzeW5jIChpbmRpdmlkdWFsT3B0aW9uKSA9PiB0aGlzLl9tZXJnZUNvbmZpZygoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShpbmRpdmlkdWFsT3B0aW9uKSwgdGhpcy5rd2FyZ3MpKSlcbiAgICAgICAgICAgIDogYXdhaXQgdGhpcy5fbWVyZ2VDb25maWcoKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucyksIHRoaXMua3dhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmQuYmF0Y2goaW5wdXRzLCBtZXJnZWRPcHRpb25zLCBiYXRjaE9wdGlvbnMpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2NvbmNhdE91dHB1dENodW5rcyhmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kLl9jb25jYXRPdXRwdXRDaHVua3MoZmlyc3QsIHNlY29uZCk7XG4gICAgfVxuICAgIGFzeW5jICpfc3RyZWFtSXRlcmF0b3IoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgeWllbGQqIHRoaXMuYm91bmQuX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBhd2FpdCB0aGlzLl9tZXJnZUNvbmZpZygoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShvcHRpb25zKSwgdGhpcy5rd2FyZ3MpKTtcbiAgICB9XG4gICAgYXN5bmMgc3RyZWFtKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kLnN0cmVhbShpbnB1dCwgYXdhaXQgdGhpcy5fbWVyZ2VDb25maWcoKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucyksIHRoaXMua3dhcmdzKSk7XG4gICAgfVxuICAgIGFzeW5jICp0cmFuc2Zvcm0oZ2VuZXJhdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIHlpZWxkKiB0aGlzLmJvdW5kLnRyYW5zZm9ybShnZW5lcmF0b3IsIGF3YWl0IHRoaXMuX21lcmdlQ29uZmlnKCgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpLCB0aGlzLmt3YXJncykpO1xuICAgIH1cbiAgICBzdHJlYW1FdmVudHMoaW5wdXQsIG9wdGlvbnMsIHN0cmVhbU9wdGlvbnMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgIGNvbnN0IG91dGVyVGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRvciA9IGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCogb3V0ZXJUaGlzLmJvdW5kLnN0cmVhbUV2ZW50cyhpbnB1dCwge1xuICAgICAgICAgICAgICAgIC4uLihhd2FpdCBvdXRlclRoaXMuX21lcmdlQ29uZmlnKCgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpLCBvdXRlclRoaXMua3dhcmdzKSksXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogb3B0aW9ucy52ZXJzaW9uLFxuICAgICAgICAgICAgfSwgc3RyZWFtT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzdHJlYW1fanNfMS5JdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21Bc3luY0dlbmVyYXRvcihnZW5lcmF0b3IoKSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc1J1bm5hYmxlQmluZGluZyhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHRoaW5nXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHRoaW5nLmJvdW5kICYmIFJ1bm5hYmxlLmlzUnVubmFibGUodGhpbmcuYm91bmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kIGxpZmVjeWNsZSBsaXN0ZW5lcnMgdG8gYSBSdW5uYWJsZSwgcmV0dXJuaW5nIGEgbmV3IFJ1bm5hYmxlLlxuICAgICAqIFRoZSBSdW4gb2JqZWN0IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBydW4sIGluY2x1ZGluZyBpdHMgaWQsXG4gICAgICogdHlwZSwgaW5wdXQsIG91dHB1dCwgZXJyb3IsIHN0YXJ0VGltZSwgZW5kVGltZSwgYW5kIGFueSB0YWdzIG9yIG1ldGFkYXRhXG4gICAgICogYWRkZWQgdG8gdGhlIHJ1bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgICAgKiBAcGFyYW0geyhydW46IFJ1bikgPT4gdm9pZH0gcGFyYW1zLm9uU3RhcnQgLSBDYWxsZWQgYmVmb3JlIHRoZSBydW5uYWJsZSBzdGFydHMgcnVubmluZywgd2l0aCB0aGUgUnVuIG9iamVjdC5cbiAgICAgKiBAcGFyYW0geyhydW46IFJ1bikgPT4gdm9pZH0gcGFyYW1zLm9uRW5kIC0gQ2FsbGVkIGFmdGVyIHRoZSBydW5uYWJsZSBmaW5pc2hlcyBydW5uaW5nLCB3aXRoIHRoZSBSdW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7KHJ1bjogUnVuKSA9PiB2b2lkfSBwYXJhbXMub25FcnJvciAtIENhbGxlZCBpZiB0aGUgcnVubmFibGUgdGhyb3dzIGFuIGVycm9yLCB3aXRoIHRoZSBSdW4gb2JqZWN0LlxuICAgICAqL1xuICAgIHdpdGhMaXN0ZW5lcnMoeyBvblN0YXJ0LCBvbkVuZCwgb25FcnJvciwgfSkge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlQmluZGluZyh7XG4gICAgICAgICAgICBib3VuZDogdGhpcy5ib3VuZCxcbiAgICAgICAgICAgIGt3YXJnczogdGhpcy5rd2FyZ3MsXG4gICAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICAgICAgY29uZmlnRmFjdG9yaWVzOiBbXG4gICAgICAgICAgICAgICAgKGNvbmZpZykgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgcm9vdF9saXN0ZW5lcl9qc18xLlJvb3RMaXN0ZW5lcnNUcmFjZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuUnVubmFibGVCaW5kaW5nID0gUnVubmFibGVCaW5kaW5nO1xuLyoqXG4gKiBBIHJ1bm5hYmxlIHRoYXQgZGVsZWdhdGVzIGNhbGxzIHRvIGFub3RoZXIgcnVubmFibGVcbiAqIHdpdGggZWFjaCBlbGVtZW50IG9mIHRoZSBpbnB1dCBzZXF1ZW5jZS5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBSdW5uYWJsZUVhY2gsIFJ1bm5hYmxlTGFtYmRhIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXNcIjtcbiAqXG4gKiBjb25zdCB0b1VwcGVyQ2FzZSA9IChpbnB1dDogc3RyaW5nKTogc3RyaW5nID0+IGlucHV0LnRvVXBwZXJDYXNlKCk7XG4gKiBjb25zdCBhZGRHcmVldGluZyA9IChpbnB1dDogc3RyaW5nKTogc3RyaW5nID0+IGBIZWxsbywgJHtpbnB1dH0hYDtcbiAqXG4gKiBjb25zdCB1cHBlckNhc2VMYW1iZGEgPSBSdW5uYWJsZUxhbWJkYS5mcm9tKHRvVXBwZXJDYXNlKTtcbiAqIGNvbnN0IGdyZWV0aW5nTGFtYmRhID0gUnVubmFibGVMYW1iZGEuZnJvbShhZGRHcmVldGluZyk7XG4gKlxuICogY29uc3QgY2hhaW4gPSBuZXcgUnVubmFibGVFYWNoKHtcbiAqICAgYm91bmQ6IHVwcGVyQ2FzZUxhbWJkYS5waXBlKGdyZWV0aW5nTGFtYmRhKSxcbiAqIH0pO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNoYWluLmludm9rZShbXCJhbGljZVwiLCBcImJvYlwiLCBcImNhcm9sXCJdKVxuICpcbiAqIC8vIFtcIkhlbGxvLCBBTElDRSFcIiwgXCJIZWxsbywgQk9CIVwiLCBcIkhlbGxvLCBDQVJPTCFcIl1cbiAqIGBgYFxuICpcbiAqIEBkZXByZWNhdGVkIFRoaXMgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IGJyZWFraW5nIHJlbGVhc2UuXG4gKi9cbmNsYXNzIFJ1bm5hYmxlRWFjaCBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVFYWNoXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJvdW5kXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm91bmQgPSBmaWVsZHMuYm91bmQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmRzIHRoZSBydW5uYWJsZSB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBrd2FyZ3MgVGhlIGFyZ3VtZW50cyB0byBiaW5kIHRoZSBydW5uYWJsZSB3aXRoLlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGluc3RhbmNlIG9mIHRoZSBgUnVubmFibGVFYWNoYCBjbGFzcyB0aGF0IGlzIGJvdW5kIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIHdpdGhDb25maWd9IGluc3RlYWQuIFRoaXMgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IGJyZWFraW5nIHJlbGVhc2UuXG4gICAgICovXG4gICAgYmluZChrd2FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZUVhY2goe1xuICAgICAgICAgICAgYm91bmQ6IHRoaXMuYm91bmQuYmluZChrd2FyZ3MpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgcnVubmFibGUgd2l0aCB0aGUgc3BlY2lmaWVkIGlucHV0IGFuZCBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gaW52b2tlIHRoZSBydW5uYWJsZSB3aXRoLlxuICAgICAqIEBwYXJhbSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gdG8gaW52b2tlIHRoZSBydW5uYWJsZSB3aXRoLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBvdXRwdXQgb2YgdGhlIHJ1bm5hYmxlLlxuICAgICAqL1xuICAgIGFzeW5jIGludm9rZShpbnB1dHMsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFdpdGhDb25maWcodGhpcy5faW52b2tlLmJpbmQodGhpcyksIGlucHV0cywgY29uZmlnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbnZva2UgdGhlIHJ1bm5hYmxlIHdpdGggdGhlIHNwZWNpZmllZCBpbnB1dCBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGludm9rZSB0aGUgcnVubmFibGUgd2l0aC5cbiAgICAgKiBAcGFyYW0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIHRvIGludm9rZSB0aGUgcnVubmFibGUgd2l0aC5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgb3V0cHV0IG9mIHRoZSBydW5uYWJsZS5cbiAgICAgKi9cbiAgICBhc3luYyBfaW52b2tlKGlucHV0cywgY29uZmlnLCBydW5NYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kLmJhdGNoKGlucHV0cywgKDAsIGNvbmZpZ19qc18xLnBhdGNoQ29uZmlnKShjb25maWcsIHsgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZCgpIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZCBsaWZlY3ljbGUgbGlzdGVuZXJzIHRvIGEgUnVubmFibGUsIHJldHVybmluZyBhIG5ldyBSdW5uYWJsZS5cbiAgICAgKiBUaGUgUnVuIG9iamVjdCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcnVuLCBpbmNsdWRpbmcgaXRzIGlkLFxuICAgICAqIHR5cGUsIGlucHV0LCBvdXRwdXQsIGVycm9yLCBzdGFydFRpbWUsIGVuZFRpbWUsIGFuZCBhbnkgdGFncyBvciBtZXRhZGF0YVxuICAgICAqIGFkZGVkIHRvIHRoZSBydW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIG9iamVjdCBjb250YWluaW5nIHRoZSBjYWxsYmFjayBmdW5jdGlvbnMuXG4gICAgICogQHBhcmFtIHsocnVuOiBSdW4pID0+IHZvaWR9IHBhcmFtcy5vblN0YXJ0IC0gQ2FsbGVkIGJlZm9yZSB0aGUgcnVubmFibGUgc3RhcnRzIHJ1bm5pbmcsIHdpdGggdGhlIFJ1biBvYmplY3QuXG4gICAgICogQHBhcmFtIHsocnVuOiBSdW4pID0+IHZvaWR9IHBhcmFtcy5vbkVuZCAtIENhbGxlZCBhZnRlciB0aGUgcnVubmFibGUgZmluaXNoZXMgcnVubmluZywgd2l0aCB0aGUgUnVuIG9iamVjdC5cbiAgICAgKiBAcGFyYW0geyhydW46IFJ1bikgPT4gdm9pZH0gcGFyYW1zLm9uRXJyb3IgLSBDYWxsZWQgaWYgdGhlIHJ1bm5hYmxlIHRocm93cyBhbiBlcnJvciwgd2l0aCB0aGUgUnVuIG9iamVjdC5cbiAgICAgKi9cbiAgICB3aXRoTGlzdGVuZXJzKHsgb25TdGFydCwgb25FbmQsIG9uRXJyb3IsIH0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZUVhY2goe1xuICAgICAgICAgICAgYm91bmQ6IHRoaXMuYm91bmQud2l0aExpc3RlbmVycyh7IG9uU3RhcnQsIG9uRW5kLCBvbkVycm9yIH0pLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlJ1bm5hYmxlRWFjaCA9IFJ1bm5hYmxlRWFjaDtcbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgcnVubmFibGVzIHRoYXQgY2FuIGJlIHJldHJpZWQgYVxuICogc3BlY2lmaWVkIG51bWJlciBvZiB0aW1lcy5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQge1xuICogICBSdW5uYWJsZUxhbWJkYSxcbiAqICAgUnVubmFibGVSZXRyeSxcbiAqIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXNcIjtcbiAqXG4gKiAvLyBTaW11bGF0ZSBhbiBBUEkgY2FsbCB0aGF0IGZhaWxzXG4gKiBjb25zdCBzaW11bGF0ZUFwaUNhbGwgPSAoaW5wdXQ6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKGBBdHRlbXB0aW5nIEFQSSBjYWxsIHdpdGggaW5wdXQ6ICR7aW5wdXR9YCk7XG4gKiAgIHRocm93IG5ldyBFcnJvcihcIkFQSSBjYWxsIGZhaWxlZCBkdWUgdG8gbmV0d29yayBpc3N1ZVwiKTtcbiAqIH07XG4gKlxuICogY29uc3QgYXBpQ2FsbExhbWJkYSA9IFJ1bm5hYmxlTGFtYmRhLmZyb20oc2ltdWxhdGVBcGlDYWxsKTtcbiAqXG4gKiAvLyBBcHBseSByZXRyeSBsb2dpYyB1c2luZyB0aGUgLndpdGhSZXRyeSgpIG1ldGhvZFxuICogY29uc3QgYXBpQ2FsbFdpdGhSZXRyeSA9IGFwaUNhbGxMYW1iZGEud2l0aFJldHJ5KHsgc3RvcEFmdGVyQXR0ZW1wdDogMyB9KTtcbiAqXG4gKiAvLyBBbHRlcm5hdGl2ZWx5LCBjcmVhdGUgYSBSdW5uYWJsZVJldHJ5IGluc3RhbmNlIG1hbnVhbGx5XG4gKiBjb25zdCBtYW51YWxSZXRyeSA9IG5ldyBSdW5uYWJsZVJldHJ5KHtcbiAqICAgYm91bmQ6IGFwaUNhbGxMYW1iZGEsXG4gKiAgIG1heEF0dGVtcHROdW1iZXI6IDMsXG4gKiAgIGNvbmZpZzoge30sXG4gKiB9KTtcbiAqXG4gKiAvLyBFeGFtcGxlIGludm9jYXRpb24gdXNpbmcgdGhlIC53aXRoUmV0cnkoKSBtZXRob2RcbiAqIGNvbnN0IHJlcyA9IGF3YWl0IGFwaUNhbGxXaXRoUmV0cnlcbiAqICAgLmludm9rZShcIlJlcXVlc3QgMVwiKVxuICogICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gKiAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCBhZnRlciBtdWx0aXBsZSByZXRyaWVzOlwiLCBlcnJvci5tZXNzYWdlKTtcbiAqICAgfSk7XG4gKlxuICogLy8gRXhhbXBsZSBpbnZvY2F0aW9uIHVzaW5nIHRoZSBtYW51YWwgcmV0cnkgaW5zdGFuY2VcbiAqIGNvbnN0IHJlczIgPSBhd2FpdCBtYW51YWxSZXRyeVxuICogICAuaW52b2tlKFwiUmVxdWVzdCAyXCIpXG4gKiAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAqICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIGFmdGVyIG11bHRpcGxlIHJldHJpZXM6XCIsIGVycm9yLm1lc3NhZ2UpO1xuICogICB9KTtcbiAqIGBgYFxuICovXG5jbGFzcyBSdW5uYWJsZVJldHJ5IGV4dGVuZHMgUnVubmFibGVCaW5kaW5nIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVSZXRyeVwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4QXR0ZW1wdE51bWJlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogM1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib25GYWlsZWRBdHRlbXB0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAoKSA9PiB7IH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWF4QXR0ZW1wdE51bWJlciA9IGZpZWxkcy5tYXhBdHRlbXB0TnVtYmVyID8/IHRoaXMubWF4QXR0ZW1wdE51bWJlcjtcbiAgICAgICAgdGhpcy5vbkZhaWxlZEF0dGVtcHQgPSBmaWVsZHMub25GYWlsZWRBdHRlbXB0ID8/IHRoaXMub25GYWlsZWRBdHRlbXB0O1xuICAgIH1cbiAgICBfcGF0Y2hDb25maWdGb3JSZXRyeShhdHRlbXB0LCBjb25maWcsIHJ1bk1hbmFnZXIpIHtcbiAgICAgICAgY29uc3QgdGFnID0gYXR0ZW1wdCA+IDEgPyBgcmV0cnk6YXR0ZW1wdDoke2F0dGVtcHR9YCA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuICgwLCBjb25maWdfanNfMS5wYXRjaENvbmZpZykoY29uZmlnLCB7IGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQodGFnKSB9KTtcbiAgICB9XG4gICAgYXN5bmMgX2ludm9rZShpbnB1dCwgY29uZmlnLCBydW5NYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybiAoMCwgcF9yZXRyeV8xLmRlZmF1bHQpKChhdHRlbXB0TnVtYmVyKSA9PiBzdXBlci5pbnZva2UoaW5wdXQsIHRoaXMuX3BhdGNoQ29uZmlnRm9yUmV0cnkoYXR0ZW1wdE51bWJlciwgY29uZmlnLCBydW5NYW5hZ2VyKSksIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBvbkZhaWxlZEF0dGVtcHQ6IChlcnJvcikgPT4gdGhpcy5vbkZhaWxlZEF0dGVtcHQoZXJyb3IsIGlucHV0KSxcbiAgICAgICAgICAgIHJldHJpZXM6IE1hdGgubWF4KHRoaXMubWF4QXR0ZW1wdE51bWJlciAtIDEsIDApLFxuICAgICAgICAgICAgcmFuZG9taXplOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgaW52b2tlcyB0aGUgcnVubmFibGUgd2l0aCB0aGUgc3BlY2lmaWVkIGlucHV0LCBydW4gbWFuYWdlcixcbiAgICAgKiBhbmQgY29uZmlnLiBJdCBoYW5kbGVzIHRoZSByZXRyeSBsb2dpYyBieSBjYXRjaGluZyBhbnkgZXJyb3JzIGFuZFxuICAgICAqIHJlY3Vyc2l2ZWx5IGludm9raW5nIGl0c2VsZiB3aXRoIHRoZSB1cGRhdGVkIGNvbmZpZyBmb3IgdGhlIG5leHQgcmV0cnlcbiAgICAgKiBhdHRlbXB0LlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgZm9yIHRoZSBydW5uYWJsZS5cbiAgICAgKiBAcGFyYW0gcnVuTWFuYWdlciBUaGUgcnVuIG1hbmFnZXIgZm9yIHRoZSBydW5uYWJsZS5cbiAgICAgKiBAcGFyYW0gY29uZmlnIFRoZSBjb25maWcgZm9yIHRoZSBydW5uYWJsZS5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgb3V0cHV0IG9mIHRoZSBydW5uYWJsZS5cbiAgICAgKi9cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFdpdGhDb25maWcodGhpcy5faW52b2tlLmJpbmQodGhpcyksIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgICBhc3luYyBfYmF0Y2goaW5wdXRzLCBjb25maWdzLCBydW5NYW5hZ2VycywgYmF0Y2hPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHNNYXAgPSB7fTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0ICgwLCBwX3JldHJ5XzEuZGVmYXVsdCkoYXN5bmMgKGF0dGVtcHROdW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1haW5pbmdJbmRleGVzID0gaW5wdXRzXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKF8sIGkpID0+IGkpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGkpID0+IHJlc3VsdHNNYXBbaS50b1N0cmluZygpXSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c01hcFtpLnRvU3RyaW5nKCldIGluc3RhbmNlb2YgRXJyb3IpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ0lucHV0cyA9IHJlbWFpbmluZ0luZGV4ZXMubWFwKChpKSA9PiBpbnB1dHNbaV0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGNoZWRDb25maWdzID0gcmVtYWluaW5nSW5kZXhlcy5tYXAoKGkpID0+IHRoaXMuX3BhdGNoQ29uZmlnRm9yUmV0cnkoYXR0ZW1wdE51bWJlciwgY29uZmlncz8uW2ldLCBydW5NYW5hZ2Vycz8uW2ldKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHN1cGVyLmJhdGNoKHJlbWFpbmluZ0lucHV0cywgcGF0Y2hlZENvbmZpZ3MsIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYmF0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5FeGNlcHRpb25zOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxldCBmaXJzdEV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzdWx0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0TWFwSW5kZXggPSByZW1haW5pbmdJbmRleGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0RXhjZXB0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdEV4Y2VwdGlvbiA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0RXhjZXB0aW9uLmlucHV0ID0gcmVtYWluaW5nSW5wdXRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNNYXBbcmVzdWx0TWFwSW5kZXgudG9TdHJpbmcoKV0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaXJzdEV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBmaXJzdEV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBvbkZhaWxlZEF0dGVtcHQ6IChlcnJvcikgPT4gdGhpcy5vbkZhaWxlZEF0dGVtcHQoZXJyb3IsIGVycm9yLmlucHV0KSxcbiAgICAgICAgICAgICAgICByZXRyaWVzOiBNYXRoLm1heCh0aGlzLm1heEF0dGVtcHROdW1iZXIgLSAxLCAwKSxcbiAgICAgICAgICAgICAgICByYW5kb21pemU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGJhdGNoT3B0aW9ucz8ucmV0dXJuRXhjZXB0aW9ucyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHJlc3VsdHNNYXApXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gcGFyc2VJbnQoYSwgMTApIC0gcGFyc2VJbnQoYiwgMTApKVxuICAgICAgICAgICAgLm1hcCgoa2V5KSA9PiByZXN1bHRzTWFwW3BhcnNlSW50KGtleSwgMTApXSk7XG4gICAgfVxuICAgIGFzeW5jIGJhdGNoKGlucHV0cywgb3B0aW9ucywgYmF0Y2hPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iYXRjaFdpdGhDb25maWcodGhpcy5fYmF0Y2guYmluZCh0aGlzKSwgaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuUnVubmFibGVSZXRyeSA9IFJ1bm5hYmxlUmV0cnk7XG4vKipcbiAqIEEgc2VxdWVuY2Ugb2YgcnVubmFibGVzLCB3aGVyZSB0aGUgb3V0cHV0IG9mIGVhY2ggaXMgdGhlIGlucHV0IG9mIHRoZSBuZXh0LlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHByb21wdFRlbXBsYXRlID0gUHJvbXB0VGVtcGxhdGUuZnJvbVRlbXBsYXRlKFxuICogICBcIlRlbGwgbWUgYSBqb2tlIGFib3V0IHt0b3BpY31cIixcbiAqICk7XG4gKiBjb25zdCBjaGFpbiA9IFJ1bm5hYmxlU2VxdWVuY2UuZnJvbShbcHJvbXB0VGVtcGxhdGUsIG5ldyBDaGF0T3BlbkFJKHsgbW9kZWw6IFwiZ3B0LTRvLW1pbmlcIiB9KV0pO1xuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hhaW4uaW52b2tlKHsgdG9waWM6IFwiYmVhcnNcIiB9KTtcbiAqIGBgYFxuICovXG5jbGFzcyBSdW5uYWJsZVNlcXVlbmNlIGV4dGVuZHMgUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZVNlcXVlbmNlXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmaXJzdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtaWRkbGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsYXN0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9taXRTZXF1ZW5jZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZmlyc3QgPSBmaWVsZHMuZmlyc3Q7XG4gICAgICAgIHRoaXMubWlkZGxlID0gZmllbGRzLm1pZGRsZSA/PyB0aGlzLm1pZGRsZTtcbiAgICAgICAgdGhpcy5sYXN0ID0gZmllbGRzLmxhc3Q7XG4gICAgICAgIHRoaXMubmFtZSA9IGZpZWxkcy5uYW1lO1xuICAgICAgICB0aGlzLm9taXRTZXF1ZW5jZVRhZ3MgPSBmaWVsZHMub21pdFNlcXVlbmNlVGFncyA/PyB0aGlzLm9taXRTZXF1ZW5jZVRhZ3M7XG4gICAgfVxuICAgIGdldCBzdGVwcygpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLmZpcnN0LCAuLi50aGlzLm1pZGRsZSwgdGhpcy5sYXN0XTtcbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgKDAsIGNvbmZpZ19qc18xLmdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZykoY29uZmlnKTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlciA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgX2NvZXJjZVRvRGljdChpbnB1dCwgXCJpbnB1dFwiKSwgY29uZmlnLnJ1bklkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb25maWc/LnJ1bk5hbWUpO1xuICAgICAgICBkZWxldGUgY29uZmlnLnJ1bklkO1xuICAgICAgICBsZXQgbmV4dFN0ZXBJbnB1dCA9IGlucHV0O1xuICAgICAgICBsZXQgZmluYWxPdXRwdXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsU3RlcHMgPSBbdGhpcy5maXJzdCwgLi4udGhpcy5taWRkbGVdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbml0aWFsU3RlcHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwID0gaW5pdGlhbFN0ZXBzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBzdGVwLmludm9rZShuZXh0U3RlcElucHV0LCAoMCwgY29uZmlnX2pzXzEucGF0Y2hDb25maWcpKGNvbmZpZywge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKHRoaXMub21pdFNlcXVlbmNlVGFncyA/IHVuZGVmaW5lZCA6IGBzZXE6c3RlcDoke2kgKyAxfWApLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBuZXh0U3RlcElucHV0ID0gYXdhaXQgKDAsIHNpZ25hbF9qc18xLnJhY2VXaXRoU2lnbmFsKShwcm9taXNlLCBvcHRpb25zPy5zaWduYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCBjYW4ndCBkZXRlY3QgdGhhdCB0aGUgbGFzdCBvdXRwdXQgb2YgdGhlIHNlcXVlbmNlIHJldHVybnMgUnVuT3V0cHV0LCBzbyBjYWxsIGl0IG91dCBvZiB0aGUgbG9vcCBoZXJlXG4gICAgICAgICAgICBpZiAob3B0aW9ucz8uc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWJvcnRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gYXdhaXQgdGhpcy5sYXN0Lmludm9rZShuZXh0U3RlcElucHV0LCAoMCwgY29uZmlnX2pzXzEucGF0Y2hDb25maWcpKGNvbmZpZywge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQodGhpcy5vbWl0U2VxdWVuY2VUYWdzID8gdW5kZWZpbmVkIDogYHNlcTpzdGVwOiR7dGhpcy5zdGVwcy5sZW5ndGh9YCksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKF9jb2VyY2VUb0RpY3QoZmluYWxPdXRwdXQsIFwib3V0cHV0XCIpKTtcbiAgICAgICAgcmV0dXJuIGZpbmFsT3V0cHV0O1xuICAgIH1cbiAgICBhc3luYyBiYXRjaChpbnB1dHMsIG9wdGlvbnMsIGJhdGNoT3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb25maWdMaXN0ID0gdGhpcy5fZ2V0T3B0aW9uc0xpc3Qob3B0aW9ucyA/PyB7fSwgaW5wdXRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcnMgPSBhd2FpdCBQcm9taXNlLmFsbChjb25maWdMaXN0Lm1hcChjb25maWdfanNfMS5nZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcpKTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlcnMgPSBhd2FpdCBQcm9taXNlLmFsbChjYWxsYmFja01hbmFnZXJzLm1hcChhc3luYyAoY2FsbGJhY2tNYW5hZ2VyLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVTdGFydFJlcyA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcj8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCBfY29lcmNlVG9EaWN0KGlucHV0c1tpXSwgXCJpbnB1dFwiKSwgY29uZmlnTGlzdFtpXS5ydW5JZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29uZmlnTGlzdFtpXS5ydW5OYW1lKTtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWdMaXN0W2ldLnJ1bklkO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0YXJ0UmVzO1xuICAgICAgICB9KSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGxldCBuZXh0U3RlcElucHV0cyA9IGlucHV0cztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGVwcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLnN0ZXBzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBzdGVwLmJhdGNoKG5leHRTdGVwSW5wdXRzLCBydW5NYW5hZ2Vycy5tYXAoKHJ1bk1hbmFnZXIsIGopID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRSdW5NYW5hZ2VyID0gcnVuTWFuYWdlcj8uZ2V0Q2hpbGQodGhpcy5vbWl0U2VxdWVuY2VUYWdzID8gdW5kZWZpbmVkIDogYHNlcTpzdGVwOiR7aSArIDF9YCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY29uZmlnX2pzXzEucGF0Y2hDb25maWcpKGNvbmZpZ0xpc3Rbal0sIHsgY2FsbGJhY2tzOiBjaGlsZFJ1bk1hbmFnZXIgfSk7XG4gICAgICAgICAgICAgICAgfSksIGJhdGNoT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgbmV4dFN0ZXBJbnB1dHMgPSBhd2FpdCAoMCwgc2lnbmFsX2pzXzEucmFjZVdpdGhTaWduYWwpKHByb21pc2UsIGNvbmZpZ0xpc3RbMF0/LnNpZ25hbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlKSkpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChydW5NYW5hZ2Vycy5tYXAoKHJ1bk1hbmFnZXIpID0+IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKF9jb2VyY2VUb0RpY3QobmV4dFN0ZXBJbnB1dHMsIFwib3V0cHV0XCIpKSkpO1xuICAgICAgICByZXR1cm4gbmV4dFN0ZXBJbnB1dHM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfY29uY2F0T3V0cHV0Q2h1bmtzKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdC5fY29uY2F0T3V0cHV0Q2h1bmtzKGZpcnN0LCBzZWNvbmQpO1xuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCAoMCwgY29uZmlnX2pzXzEuZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKShvcHRpb25zKTtcbiAgICAgICAgY29uc3QgeyBydW5JZCwgLi4ub3RoZXJPcHRpb25zIH0gPSBvcHRpb25zID8/IHt9O1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VyID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCBfY29lcmNlVG9EaWN0KGlucHV0LCBcImlucHV0XCIpLCBydW5JZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb3RoZXJPcHRpb25zPy5ydW5OYW1lKTtcbiAgICAgICAgY29uc3Qgc3RlcHMgPSBbdGhpcy5maXJzdCwgLi4udGhpcy5taWRkbGUsIHRoaXMubGFzdF07XG4gICAgICAgIGxldCBjb25jYXRTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICBsZXQgZmluYWxPdXRwdXQ7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uKiBpbnB1dEdlbmVyYXRvcigpIHtcbiAgICAgICAgICAgIHlpZWxkIGlucHV0O1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgZmluYWxHZW5lcmF0b3IgPSBzdGVwc1swXS50cmFuc2Zvcm0oaW5wdXRHZW5lcmF0b3IoKSwgKDAsIGNvbmZpZ19qc18xLnBhdGNoQ29uZmlnKShvdGhlck9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKHRoaXMub21pdFNlcXVlbmNlVGFncyA/IHVuZGVmaW5lZCA6IGBzZXE6c3RlcDoxYCksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0ZXBzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcCA9IHN0ZXBzW2ldO1xuICAgICAgICAgICAgICAgIGZpbmFsR2VuZXJhdG9yID0gYXdhaXQgc3RlcC50cmFuc2Zvcm0oZmluYWxHZW5lcmF0b3IsICgwLCBjb25maWdfanNfMS5wYXRjaENvbmZpZykob3RoZXJPcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQodGhpcy5vbWl0U2VxdWVuY2VUYWdzID8gdW5kZWZpbmVkIDogYHNlcTpzdGVwOiR7aSArIDF9YCksXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBmaW5hbEdlbmVyYXRvcikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnM/LnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgICAgICAgICBpZiAoY29uY2F0U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbE91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gdGhpcy5fY29uY2F0T3V0cHV0Q2h1bmtzKGZpbmFsT3V0cHV0LCBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNhdFN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChfY29lcmNlVG9EaWN0KGZpbmFsT3V0cHV0LCBcIm91dHB1dFwiKSk7XG4gICAgfVxuICAgIGdldEdyYXBoKGNvbmZpZykge1xuICAgICAgICBjb25zdCBncmFwaCA9IG5ldyBncmFwaF9qc18xLkdyYXBoKCk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGxldCBjdXJyZW50TGFzdE5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLnN0ZXBzLmZvckVhY2goKHN0ZXAsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGVwR3JhcGggPSBzdGVwLmdldEdyYXBoKGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICBzdGVwR3JhcGgudHJpbUZpcnN0Tm9kZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSB0aGlzLnN0ZXBzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBzdGVwR3JhcGgudHJpbUxhc3ROb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncmFwaC5leHRlbmQoc3RlcEdyYXBoKTtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBGaXJzdE5vZGUgPSBzdGVwR3JhcGguZmlyc3ROb2RlKCk7XG4gICAgICAgICAgICBpZiAoIXN0ZXBGaXJzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJ1bm5hYmxlICR7c3RlcH0gaGFzIG5vIGZpcnN0IG5vZGVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50TGFzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICBncmFwaC5hZGRFZGdlKGN1cnJlbnRMYXN0Tm9kZSwgc3RlcEZpcnN0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50TGFzdE5vZGUgPSBzdGVwR3JhcGgubGFzdE5vZGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBncmFwaDtcbiAgICB9XG4gICAgcGlwZShjb2VyY2VhYmxlKSB7XG4gICAgICAgIGlmIChSdW5uYWJsZVNlcXVlbmNlLmlzUnVubmFibGVTZXF1ZW5jZShjb2VyY2VhYmxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZVNlcXVlbmNlKHtcbiAgICAgICAgICAgICAgICBmaXJzdDogdGhpcy5maXJzdCxcbiAgICAgICAgICAgICAgICBtaWRkbGU6IHRoaXMubWlkZGxlLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdCxcbiAgICAgICAgICAgICAgICAgICAgY29lcmNlYWJsZS5maXJzdCxcbiAgICAgICAgICAgICAgICAgICAgLi4uY29lcmNlYWJsZS5taWRkbGUsXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgbGFzdDogY29lcmNlYWJsZS5sYXN0LFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSA/PyBjb2VyY2VhYmxlLm5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUnVubmFibGVTZXF1ZW5jZSh7XG4gICAgICAgICAgICAgICAgZmlyc3Q6IHRoaXMuZmlyc3QsXG4gICAgICAgICAgICAgICAgbWlkZGxlOiBbLi4udGhpcy5taWRkbGUsIHRoaXMubGFzdF0sXG4gICAgICAgICAgICAgICAgbGFzdDogX2NvZXJjZVRvUnVubmFibGUoY29lcmNlYWJsZSksXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzdGF0aWMgaXNSdW5uYWJsZVNlcXVlbmNlKHRoaW5nKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRoaW5nLm1pZGRsZSkgJiYgUnVubmFibGUuaXNSdW5uYWJsZSh0aGluZyk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc3RhdGljIGZyb20oW2ZpcnN0LCAuLi5ydW5uYWJsZXNdLCBuYW1lT3JGaWVsZHMpIHtcbiAgICAgICAgbGV0IGV4dHJhID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZU9yRmllbGRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBleHRyYS5uYW1lID0gbmFtZU9yRmllbGRzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWVPckZpZWxkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHRyYSA9IG5hbWVPckZpZWxkcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlU2VxdWVuY2Uoe1xuICAgICAgICAgICAgLi4uZXh0cmEsXG4gICAgICAgICAgICBmaXJzdDogX2NvZXJjZVRvUnVubmFibGUoZmlyc3QpLFxuICAgICAgICAgICAgbWlkZGxlOiBydW5uYWJsZXMuc2xpY2UoMCwgLTEpLm1hcChfY29lcmNlVG9SdW5uYWJsZSksXG4gICAgICAgICAgICBsYXN0OiBfY29lcmNlVG9SdW5uYWJsZShydW5uYWJsZXNbcnVubmFibGVzLmxlbmd0aCAtIDFdKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5uYWJsZVNlcXVlbmNlID0gUnVubmFibGVTZXF1ZW5jZTtcbi8qKlxuICogQSBydW5uYWJsZSB0aGF0IHJ1bnMgYSBtYXBwaW5nIG9mIHJ1bm5hYmxlcyBpbiBwYXJhbGxlbCxcbiAqIGFuZCByZXR1cm5zIGEgbWFwcGluZyBvZiB0aGVpciBvdXRwdXRzLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IG1hcENoYWluID0gUnVubmFibGVNYXAuZnJvbSh7XG4gKiAgIGpva2U6IFByb21wdFRlbXBsYXRlLmZyb21UZW1wbGF0ZShcIlRlbGwgbWUgYSBqb2tlIGFib3V0IHt0b3BpY31cIikucGlwZShcbiAqICAgICBuZXcgQ2hhdEFudGhyb3BpYyh7fSksXG4gKiAgICksXG4gKiAgIHBvZW06IFByb21wdFRlbXBsYXRlLmZyb21UZW1wbGF0ZShcIndyaXRlIGEgMi1saW5lIHBvZW0gYWJvdXQge3RvcGljfVwiKS5waXBlKFxuICogICAgIG5ldyBDaGF0QW50aHJvcGljKHt9KSxcbiAqICAgKSxcbiAqIH0pO1xuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgbWFwQ2hhaW4uaW52b2tlKHsgdG9waWM6IFwiYmVhclwiIH0pO1xuICogYGBgXG4gKi9cbmNsYXNzIFJ1bm5hYmxlTWFwIGV4dGVuZHMgUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZU1hcFwiO1xuICAgIH1cbiAgICBnZXRTdGVwc0tleXMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnN0ZXBzKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RlcHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdGVwcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmaWVsZHMuc3RlcHMpKSB7XG4gICAgICAgICAgICB0aGlzLnN0ZXBzW2tleV0gPSBfY29lcmNlVG9SdW5uYWJsZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZyb20oc3RlcHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZU1hcCh7IHN0ZXBzIH0pO1xuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCAoMCwgY29uZmlnX2pzXzEuZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKShjb25maWcpO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VyID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCB7XG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgfSwgY29uZmlnLnJ1bklkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb25maWc/LnJ1bk5hbWUpO1xuICAgICAgICBkZWxldGUgY29uZmlnLnJ1bklkO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBvdXRwdXQgPSB7fTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gT2JqZWN0LmVudHJpZXModGhpcy5zdGVwcykubWFwKGFzeW5jIChba2V5LCBydW5uYWJsZV0pID0+IHtcbiAgICAgICAgICAgICAgICBvdXRwdXRba2V5XSA9IGF3YWl0IHJ1bm5hYmxlLmludm9rZShpbnB1dCwgKDAsIGNvbmZpZ19qc18xLnBhdGNoQ29uZmlnKShjb25maWcsIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZChgbWFwOmtleToke2tleX1gKSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0ICgwLCBzaWduYWxfanNfMS5yYWNlV2l0aFNpZ25hbCkoUHJvbWlzZS5hbGwocHJvbWlzZXMpLCBvcHRpb25zPy5zaWduYWwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChvdXRwdXQpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBhc3luYyAqX3RyYW5zZm9ybShnZW5lcmF0b3IsIHJ1bk1hbmFnZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gc2hhbGxvdyBjb3B5IHN0ZXBzIHRvIGlnbm9yZSBjaGFuZ2VzIHdoaWxlIGl0ZXJhdGluZ1xuICAgICAgICBjb25zdCBzdGVwcyA9IHsgLi4udGhpcy5zdGVwcyB9O1xuICAgICAgICAvLyBlYWNoIHN0ZXAgZ2V0cyBhIGNvcHkgb2YgdGhlIGlucHV0IGl0ZXJhdG9yXG4gICAgICAgIGNvbnN0IGlucHV0Q29waWVzID0gKDAsIHN0cmVhbV9qc18xLmF0ZWUpKGdlbmVyYXRvciwgT2JqZWN0LmtleXMoc3RlcHMpLmxlbmd0aCk7XG4gICAgICAgIC8vIHN0YXJ0IHRoZSBmaXJzdCBpdGVyYXRpb24gb2YgZWFjaCBvdXRwdXQgaXRlcmF0b3JcbiAgICAgICAgY29uc3QgdGFza3MgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKHN0ZXBzKS5tYXAoKFtrZXksIHJ1bm5hYmxlXSwgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZ2VuID0gcnVubmFibGUudHJhbnNmb3JtKGlucHV0Q29waWVzW2ldLCAoMCwgY29uZmlnX2pzXzEucGF0Y2hDb25maWcpKG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKGBtYXA6a2V5OiR7a2V5fWApLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIFtrZXksIGdlbi5uZXh0KCkudGhlbigocmVzdWx0KSA9PiAoeyBrZXksIGdlbiwgcmVzdWx0IH0pKV07XG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8geWllbGQgY2h1bmtzIGFzIHRoZXkgYmVjb21lIGF2YWlsYWJsZSxcbiAgICAgICAgLy8gc3RhcnRpbmcgbmV3IGl0ZXJhdGlvbnMgYXMgbmVlZGVkLFxuICAgICAgICAvLyB1bnRpbCBhbGwgaXRlcmF0b3JzIGFyZSBkb25lXG4gICAgICAgIHdoaWxlICh0YXNrcy5zaXplKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yYWNlKHRhc2tzLnZhbHVlcygpKTtcbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCByZXN1bHQsIGdlbiB9ID0gYXdhaXQgKDAsIHNpZ25hbF9qc18xLnJhY2VXaXRoU2lnbmFsKShwcm9taXNlLCBvcHRpb25zPy5zaWduYWwpO1xuICAgICAgICAgICAgdGFza3MuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgeyBba2V5XTogcmVzdWx0LnZhbHVlIH07XG4gICAgICAgICAgICAgICAgdGFza3Muc2V0KGtleSwgZ2VuLm5leHQoKS50aGVuKChyZXN1bHQpID0+ICh7IGtleSwgZ2VuLCByZXN1bHQgfSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmFuc2Zvcm0oZ2VuZXJhdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm1TdHJlYW1XaXRoQ29uZmlnKGdlbmVyYXRvciwgdGhpcy5fdHJhbnNmb3JtLmJpbmQodGhpcyksIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzdHJlYW0oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24qIGdlbmVyYXRvcigpIHtcbiAgICAgICAgICAgIHlpZWxkIGlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB3cmFwcGVkR2VuZXJhdG9yID0gbmV3IHN0cmVhbV9qc18xLkFzeW5jR2VuZXJhdG9yV2l0aFNldHVwKHtcbiAgICAgICAgICAgIGdlbmVyYXRvcjogdGhpcy50cmFuc2Zvcm0oZ2VuZXJhdG9yKCksIGNvbmZpZyksXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB3cmFwcGVkR2VuZXJhdG9yLnNldHVwO1xuICAgICAgICByZXR1cm4gc3RyZWFtX2pzXzEuSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tQXN5bmNHZW5lcmF0b3Iod3JhcHBlZEdlbmVyYXRvcik7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5uYWJsZU1hcCA9IFJ1bm5hYmxlTWFwO1xuLyoqXG4gKiBBIHJ1bm5hYmxlIHRoYXQgd3JhcHMgYSB0cmFjZWQgTGFuZ1NtaXRoIGZ1bmN0aW9uLlxuICovXG5jbGFzcyBSdW5uYWJsZVRyYWNlYWJsZSBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZnVuY1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoISgwLCB0cmFjZWFibGVfMS5pc1RyYWNlYWJsZUZ1bmN0aW9uKShmaWVsZHMuZnVuYykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJ1bm5hYmxlVHJhY2VhYmxlIHJlcXVpcmVzIGEgZnVuY3Rpb24gdGhhdCBpcyB3cmFwcGVkIGluIHRyYWNlYWJsZSBoaWdoZXItb3JkZXIgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mdW5jID0gZmllbGRzLmZ1bmM7XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBbY29uZmlnXSA9IHRoaXMuX2dldE9wdGlvbnNMaXN0KG9wdGlvbnMgPz8ge30sIDEpO1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBhd2FpdCAoMCwgY29uZmlnX2pzXzEuZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKShjb25maWcpO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5mdW5jKCgwLCBjb25maWdfanNfMS5wYXRjaENvbmZpZykoY29uZmlnLCB7IGNhbGxiYWNrcyB9KSwgaW5wdXQpO1xuICAgICAgICByZXR1cm4gKDAsIHNpZ25hbF9qc18xLnJhY2VXaXRoU2lnbmFsKShwcm9taXNlLCBjb25maWc/LnNpZ25hbCk7XG4gICAgfVxuICAgIGFzeW5jICpfc3RyZWFtSXRlcmF0b3IoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgW2NvbmZpZ10gPSB0aGlzLl9nZXRPcHRpb25zTGlzdChvcHRpb25zID8/IHt9LCAxKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5pbnZva2UoaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoKDAsIGl0ZXJfanNfMS5pc0FzeW5jSXRlcmFibGUpKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgaXRlbSBvZiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBjb25maWc/LnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgaXRlcl9qc18xLmlzSXRlcmF0b3IpKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnPy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSByZXN1bHQubmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5kb25lKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB5aWVsZCBzdGF0ZS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZVRyYWNlYWJsZSh7IGZ1bmMgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5uYWJsZVRyYWNlYWJsZSA9IFJ1bm5hYmxlVHJhY2VhYmxlO1xuZnVuY3Rpb24gYXNzZXJ0Tm9uVHJhY2VhYmxlRnVuY3Rpb24oZnVuYykge1xuICAgIGlmICgoMCwgdHJhY2VhYmxlXzEuaXNUcmFjZWFibGVGdW5jdGlvbikoZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUnVubmFibGVMYW1iZGEgcmVxdWlyZXMgYSBmdW5jdGlvbiB0aGF0IGlzIG5vdCB3cmFwcGVkIGluIHRyYWNlYWJsZSBoaWdoZXItb3JkZXIgZnVuY3Rpb24uIFRoaXMgc2hvdWxkbid0IGhhcHBlbi5cIik7XG4gICAgfVxufVxuLyoqXG4gKiBBIHJ1bm5hYmxlIHRoYXQgd3JhcHMgYW4gYXJiaXRyYXJ5IGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBzaW5nbGUgYXJndW1lbnQuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgUnVubmFibGVMYW1iZGEgfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlc1wiO1xuICpcbiAqIGNvbnN0IGFkZCA9IChpbnB1dDogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9KSA9PiBpbnB1dC54ICsgaW5wdXQueTtcbiAqXG4gKiBjb25zdCBtdWx0aXBseSA9IChpbnB1dDogeyB2YWx1ZTogbnVtYmVyOyBtdWx0aXBsaWVyOiBudW1iZXIgfSkgPT5cbiAqICAgaW5wdXQudmFsdWUgKiBpbnB1dC5tdWx0aXBsaWVyO1xuICpcbiAqIC8vIENyZWF0ZSBydW5uYWJsZXMgZm9yIHRoZSBmdW5jdGlvbnNcbiAqIGNvbnN0IGFkZExhbWJkYSA9IFJ1bm5hYmxlTGFtYmRhLmZyb20oYWRkKTtcbiAqIGNvbnN0IG11bHRpcGx5TGFtYmRhID0gUnVubmFibGVMYW1iZGEuZnJvbShtdWx0aXBseSk7XG4gKlxuICogLy8gQ2hhaW4gdGhlIGxhbWJkYXMgZm9yIGEgbWF0aGVtYXRpY2FsIG9wZXJhdGlvblxuICogY29uc3QgY2hhaW5lZExhbWJkYSA9IGFkZExhbWJkYS5waXBlKChyZXN1bHQpID0+XG4gKiAgIG11bHRpcGx5TGFtYmRhLmludm9rZSh7IHZhbHVlOiByZXN1bHQsIG11bHRpcGxpZXI6IDIgfSlcbiAqICk7XG4gKlxuICogLy8gRXhhbXBsZSBpbnZvY2F0aW9uIG9mIHRoZSBjaGFpbmVkTGFtYmRhXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBjaGFpbmVkTGFtYmRhLmludm9rZSh7IHg6IDIsIHk6IDMgfSk7XG4gKlxuICogLy8gV2lsbCBsb2cgXCIxMFwiIChzaW5jZSAoMiArIDMpICogMiA9IDEwKVxuICogYGBgXG4gKi9cbmNsYXNzIFJ1bm5hYmxlTGFtYmRhIGV4dGVuZHMgUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZUxhbWJkYVwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgaWYgKCgwLCB0cmFjZWFibGVfMS5pc1RyYWNlYWJsZUZ1bmN0aW9uKShmaWVsZHMuZnVuYykpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdHJ1Y3Rvci1yZXR1cm5cbiAgICAgICAgICAgIHJldHVybiBSdW5uYWJsZVRyYWNlYWJsZS5mcm9tKGZpZWxkcy5mdW5jKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmdW5jXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGFzc2VydE5vblRyYWNlYWJsZUZ1bmN0aW9uKGZpZWxkcy5mdW5jKTtcbiAgICAgICAgdGhpcy5mdW5jID0gZmllbGRzLmZ1bmM7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZUxhbWJkYSh7XG4gICAgICAgICAgICBmdW5jLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX2ludm9rZShpbnB1dCwgY29uZmlnLCBydW5NYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZENvbmZpZyA9ICgwLCBjb25maWdfanNfMS5wYXRjaENvbmZpZykoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZCgpLFxuICAgICAgICAgICAgICAgIHJlY3Vyc2lvbkxpbWl0OiAoY29uZmlnPy5yZWN1cnNpb25MaW1pdCA/PyBjb25maWdfanNfMS5ERUZBVUxUX1JFQ1VSU0lPTl9MSU1JVCkgLSAxLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2b2lkIGluZGV4X2pzXzEuQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5ydW5XaXRoQ29uZmlnKCgwLCBjb25maWdfanNfMS5waWNrUnVubmFibGVDb25maWdLZXlzKShjaGlsZENvbmZpZyksIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3V0cHV0ID0gYXdhaXQgdGhpcy5mdW5jKGlucHV0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jaGlsZENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQgJiYgUnVubmFibGUuaXNSdW5uYWJsZShvdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnPy5yZWN1cnNpb25MaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlY3Vyc2lvbiBsaW1pdCByZWFjaGVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IGF3YWl0IG91dHB1dC5pbnZva2UoaW5wdXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jaGlsZENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN1cnNpb25MaW1pdDogKGNoaWxkQ29uZmlnLnJlY3Vyc2lvbkxpbWl0ID8/IGNvbmZpZ19qc18xLkRFRkFVTFRfUkVDVVJTSU9OX0xJTUlUKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgoMCwgaXRlcl9qc18xLmlzQXN5bmNJdGVyYWJsZSkob3V0cHV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbmFsT3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiAoMCwgaXRlcl9qc18xLmNvbnN1bWVBc3luY0l0ZXJhYmxlSW5Db250ZXh0KShjaGlsZENvbmZpZywgb3V0cHV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZz8uc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbE91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIGEgYmVzdCBlZmZvcnQgdG8gZ2F0aGVyLCBmb3IgYW55IHR5cGUgdGhhdCBzdXBwb3J0cyBjb25jYXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IHRoaXMuX2NvbmNhdE91dHB1dENodW5rcyhmaW5hbE91dHB1dCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gZmluYWxPdXRwdXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKDAsIGl0ZXJfanNfMS5pc0l0ZXJhYmxlSXRlcmF0b3IpKG91dHB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaW5hbE91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgKDAsIGl0ZXJfanNfMS5jb25zdW1lSXRlcmF0b3JJbkNvbnRleHQpKGNoaWxkQ29uZmlnLCBvdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnPy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsT3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgYSBiZXN0IGVmZm9ydCB0byBnYXRoZXIsIGZvciBhbnkgdHlwZSB0aGF0IHN1cHBvcnRzIGNvbmNhdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gdGhpcy5fY29uY2F0T3V0cHV0Q2h1bmtzKGZpbmFsT3V0cHV0LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBmaW5hbE91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFdpdGhDb25maWcodGhpcy5faW52b2tlLmJpbmQodGhpcyksIGlucHV0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgKl90cmFuc2Zvcm0oZ2VuZXJhdG9yLCBydW5NYW5hZ2VyLCBjb25maWcpIHtcbiAgICAgICAgbGV0IGZpbmFsQ2h1bms7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgZ2VuZXJhdG9yKSB7XG4gICAgICAgICAgICBpZiAoZmluYWxDaHVuayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZmluYWxDaHVuayA9IGNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBhIGJlc3QgZWZmb3J0IHRvIGdhdGhlciwgZm9yIGFueSB0eXBlIHRoYXQgc3VwcG9ydHMgY29uY2F0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsQ2h1bmsgPSB0aGlzLl9jb25jYXRPdXRwdXRDaHVua3MoZmluYWxDaHVuaywgY2h1bmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBmaW5hbENodW5rID0gY2h1bms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkQ29uZmlnID0gKDAsIGNvbmZpZ19qc18xLnBhdGNoQ29uZmlnKShjb25maWcsIHtcbiAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoKSxcbiAgICAgICAgICAgIHJlY3Vyc2lvbkxpbWl0OiAoY29uZmlnPy5yZWN1cnNpb25MaW1pdCA/PyBjb25maWdfanNfMS5ERUZBVUxUX1JFQ1VSU0lPTl9MSU1JVCkgLSAxLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdm9pZCBpbmRleF9qc18xLkFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24ucnVuV2l0aENvbmZpZygoMCwgY29uZmlnX2pzXzEucGlja1J1bm5hYmxlQ29uZmlnS2V5cykoY2hpbGRDb25maWcpLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5mdW5jKGZpbmFsQ2h1bmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNoaWxkQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjaGlsZENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG91dHB1dCAmJiBSdW5uYWJsZS5pc1J1bm5hYmxlKG91dHB1dCkpIHtcbiAgICAgICAgICAgIGlmIChjb25maWc/LnJlY3Vyc2lvbkxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVjdXJzaW9uIGxpbWl0IHJlYWNoZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgb3V0cHV0LnN0cmVhbShmaW5hbENodW5rLCBjaGlsZENvbmZpZyk7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCBpdGVyX2pzXzEuaXNBc3luY0l0ZXJhYmxlKShvdXRwdXQpKSB7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mICgwLCBpdGVyX2pzXzEuY29uc3VtZUFzeW5jSXRlcmFibGVJbkNvbnRleHQpKGNoaWxkQ29uZmlnLCBvdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnPy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKDAsIGl0ZXJfanNfMS5pc0l0ZXJhYmxlSXRlcmF0b3IpKG91dHB1dCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgKDAsIGl0ZXJfanNfMS5jb25zdW1lSXRlcmF0b3JJbkNvbnRleHQpKGNoaWxkQ29uZmlnLCBvdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnPy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhbnNmb3JtKGdlbmVyYXRvciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtU3RyZWFtV2l0aENvbmZpZyhnZW5lcmF0b3IsIHRoaXMuX3RyYW5zZm9ybS5iaW5kKHRoaXMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc3RyZWFtKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uKiBnZW5lcmF0b3IoKSB7XG4gICAgICAgICAgICB5aWVsZCBpbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWcgPSAoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgd3JhcHBlZEdlbmVyYXRvciA9IG5ldyBzdHJlYW1fanNfMS5Bc3luY0dlbmVyYXRvcldpdGhTZXR1cCh7XG4gICAgICAgICAgICBnZW5lcmF0b3I6IHRoaXMudHJhbnNmb3JtKGdlbmVyYXRvcigpLCBjb25maWcpLFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgd3JhcHBlZEdlbmVyYXRvci5zZXR1cDtcbiAgICAgICAgcmV0dXJuIHN0cmVhbV9qc18xLkl0ZXJhYmxlUmVhZGFibGVTdHJlYW0uZnJvbUFzeW5jR2VuZXJhdG9yKHdyYXBwZWRHZW5lcmF0b3IpO1xuICAgIH1cbn1cbmV4cG9ydHMuUnVubmFibGVMYW1iZGEgPSBSdW5uYWJsZUxhbWJkYTtcbi8qKlxuICogQSBydW5uYWJsZSB0aGF0IHJ1bnMgYSBtYXBwaW5nIG9mIHJ1bm5hYmxlcyBpbiBwYXJhbGxlbCxcbiAqIGFuZCByZXR1cm5zIGEgbWFwcGluZyBvZiB0aGVpciBvdXRwdXRzLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7XG4gKiAgIFJ1bm5hYmxlTGFtYmRhLFxuICogICBSdW5uYWJsZVBhcmFsbGVsLFxuICogfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlc1wiO1xuICpcbiAqIGNvbnN0IGFkZFllYXJzID0gKGFnZTogbnVtYmVyKTogbnVtYmVyID0+IGFnZSArIDU7XG4gKiBjb25zdCB5ZWFyc1RvRmlmdHkgPSAoYWdlOiBudW1iZXIpOiBudW1iZXIgPT4gNTAgLSBhZ2U7XG4gKiBjb25zdCB5ZWFyc1RvSHVuZHJlZCA9IChhZ2U6IG51bWJlcik6IG51bWJlciA9PiAxMDAgLSBhZ2U7XG4gKlxuICogY29uc3QgYWRkWWVhcnNMYW1iZGEgPSBSdW5uYWJsZUxhbWJkYS5mcm9tKGFkZFllYXJzKTtcbiAqIGNvbnN0IG1pbGVzdG9uZUZpZnR5TGFtYmRhID0gUnVubmFibGVMYW1iZGEuZnJvbSh5ZWFyc1RvRmlmdHkpO1xuICogY29uc3QgbWlsZXN0b25lSHVuZHJlZExhbWJkYSA9IFJ1bm5hYmxlTGFtYmRhLmZyb20oeWVhcnNUb0h1bmRyZWQpO1xuICpcbiAqIC8vIFBpcGUgd2lsbCBjb2VyY2Ugb2JqZWN0cyBpbnRvIFJ1bm5hYmxlUGFyYWxsZWwgYnkgZGVmYXVsdCwgYnV0IHdlXG4gKiAvLyBleHBsaWNpdGx5IGluc3RhbnRpYXRlIG9uZSBoZXJlIHRvIGRlbW9uc3RyYXRlXG4gKiBjb25zdCBzZXF1ZW5jZSA9IGFkZFllYXJzTGFtYmRhLnBpcGUoXG4gKiAgIFJ1bm5hYmxlUGFyYWxsZWwuZnJvbSh7XG4gKiAgICAgeWVhcnNfdG9fZmlmdHk6IG1pbGVzdG9uZUZpZnR5TGFtYmRhLFxuICogICAgIHllYXJzX3RvX2h1bmRyZWQ6IG1pbGVzdG9uZUh1bmRyZWRMYW1iZGEsXG4gKiAgIH0pXG4gKiApO1xuICpcbiAqIC8vIEludm9rZSB0aGUgc2VxdWVuY2Ugd2l0aCBhIHNpbmdsZSBhZ2UgaW5wdXRcbiAqIGNvbnN0IHJlcyA9IGF3YWl0IHNlcXVlbmNlLmludm9rZSgyNSk7XG4gKlxuICogLy8geyB5ZWFyc190b19maWZ0eTogMjAsIHllYXJzX3RvX2h1bmRyZWQ6IDcwIH1cbiAqIGBgYFxuICovXG5jbGFzcyBSdW5uYWJsZVBhcmFsbGVsIGV4dGVuZHMgUnVubmFibGVNYXAge1xufVxuZXhwb3J0cy5SdW5uYWJsZVBhcmFsbGVsID0gUnVubmFibGVQYXJhbGxlbDtcbi8qKlxuICogQSBSdW5uYWJsZSB0aGF0IGNhbiBmYWxsYmFjayB0byBvdGhlciBSdW5uYWJsZXMgaWYgaXQgZmFpbHMuXG4gKiBFeHRlcm5hbCBBUElzIChlLmcuLCBBUElzIGZvciBhIGxhbmd1YWdlIG1vZGVsKSBtYXkgYXQgdGltZXMgZXhwZXJpZW5jZVxuICogZGVncmFkZWQgcGVyZm9ybWFuY2Ugb3IgZXZlbiBkb3dudGltZS5cbiAqXG4gKiBJbiB0aGVzZSBjYXNlcywgaXQgY2FuIGJlIHVzZWZ1bCB0byBoYXZlIGEgZmFsbGJhY2sgUnVubmFibGUgdGhhdCBjYW4gYmVcbiAqIHVzZWQgaW4gcGxhY2Ugb2YgdGhlIG9yaWdpbmFsIFJ1bm5hYmxlIChlLmcuLCBmYWxsYmFjayB0byBhbm90aGVyIExMTSBwcm92aWRlcikuXG4gKlxuICogRmFsbGJhY2tzIGNhbiBiZSBkZWZpbmVkIGF0IHRoZSBsZXZlbCBvZiBhIHNpbmdsZSBSdW5uYWJsZSwgb3IgYXQgdGhlIGxldmVsXG4gKiBvZiBhIGNoYWluIG9mIFJ1bm5hYmxlcy4gRmFsbGJhY2tzIGFyZSB0cmllZCBpbiBvcmRlciB1bnRpbCBvbmUgc3VjY2VlZHMgb3JcbiAqIGFsbCBmYWlsLlxuICpcbiAqIFdoaWxlIHlvdSBjYW4gaW5zdGFudGlhdGUgYSBgUnVubmFibGVXaXRoRmFsbGJhY2tzYCBkaXJlY3RseSwgaXQgaXMgdXN1YWxseVxuICogbW9yZSBjb252ZW5pZW50IHRvIHVzZSB0aGUgYHdpdGhGYWxsYmFja3NgIG1ldGhvZCBvbiBhbiBleGlzdGluZyBSdW5uYWJsZS5cbiAqXG4gKiBXaGVuIHN0cmVhbWluZywgZmFsbGJhY2tzIHdpbGwgb25seSBiZSBjYWxsZWQgb24gZmFpbHVyZXMgZHVyaW5nIHRoZSBpbml0aWFsXG4gKiBzdHJlYW0gY3JlYXRpb24uIEVycm9ycyB0aGF0IG9jY3VyIGFmdGVyIGEgc3RyZWFtIHN0YXJ0cyB3aWxsIG5vdCBmYWxsYmFja1xuICogdG8gdGhlIG5leHQgUnVubmFibGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7XG4gKiAgIFJ1bm5hYmxlTGFtYmRhLFxuICogICBSdW5uYWJsZVdpdGhGYWxsYmFja3MsXG4gKiB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG4gKlxuICogY29uc3QgcHJpbWFyeU9wZXJhdGlvbiA9IChpbnB1dDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAqICAgaWYgKGlucHV0ICE9PSBcInNhZmVcIikge1xuICogICAgIHRocm93IG5ldyBFcnJvcihcIlByaW1hcnkgb3BlcmF0aW9uIGZhaWxlZCBkdWUgdG8gdW5zYWZlIGlucHV0XCIpO1xuICogICB9XG4gKiAgIHJldHVybiBgUHJvY2Vzc2VkOiAke2lucHV0fWA7XG4gKiB9O1xuICpcbiAqIC8vIERlZmluZSBhIGZhbGxiYWNrIG9wZXJhdGlvbiB0aGF0IHByb2Nlc3NlcyB0aGUgaW5wdXQgZGlmZmVyZW50bHlcbiAqIGNvbnN0IGZhbGxiYWNrT3BlcmF0aW9uID0gKGlucHV0OiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAqICAgYEZhbGxiYWNrIHByb2Nlc3NlZDogJHtpbnB1dH1gO1xuICpcbiAqIGNvbnN0IHByaW1hcnlSdW5uYWJsZSA9IFJ1bm5hYmxlTGFtYmRhLmZyb20ocHJpbWFyeU9wZXJhdGlvbik7XG4gKiBjb25zdCBmYWxsYmFja1J1bm5hYmxlID0gUnVubmFibGVMYW1iZGEuZnJvbShmYWxsYmFja09wZXJhdGlvbik7XG4gKlxuICogLy8gQXBwbHkgdGhlIGZhbGxiYWNrIGxvZ2ljIHVzaW5nIHRoZSAud2l0aEZhbGxiYWNrcygpIG1ldGhvZFxuICogY29uc3QgcnVubmFibGVXaXRoRmFsbGJhY2sgPSBwcmltYXJ5UnVubmFibGUud2l0aEZhbGxiYWNrcyhbZmFsbGJhY2tSdW5uYWJsZV0pO1xuICpcbiAqIC8vIEFsdGVybmF0aXZlbHksIGNyZWF0ZSBhIFJ1bm5hYmxlV2l0aEZhbGxiYWNrcyBpbnN0YW5jZSBtYW51YWxseVxuICogY29uc3QgbWFudWFsRmFsbGJhY2tDaGFpbiA9IG5ldyBSdW5uYWJsZVdpdGhGYWxsYmFja3Moe1xuICogICBydW5uYWJsZTogcHJpbWFyeVJ1bm5hYmxlLFxuICogICBmYWxsYmFja3M6IFtmYWxsYmFja1J1bm5hYmxlXSxcbiAqIH0pO1xuICpcbiAqIC8vIEV4YW1wbGUgaW52b2NhdGlvbiB1c2luZyAud2l0aEZhbGxiYWNrcygpXG4gKiBjb25zdCByZXMgPSBhd2FpdCBydW5uYWJsZVdpdGhGYWxsYmFja1xuICogICAuaW52b2tlKFwidW5zYWZlIGlucHV0XCIpXG4gKiAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAqICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIGFmdGVyIGFsbCBhdHRlbXB0czpcIiwgZXJyb3IubWVzc2FnZSk7XG4gKiAgIH0pO1xuICpcbiAqIC8vIFwiRmFsbGJhY2sgcHJvY2Vzc2VkOiB1bnNhZmUgaW5wdXRcIlxuICpcbiAqIC8vIEV4YW1wbGUgaW52b2NhdGlvbiB1c2luZyBtYW51YWwgaW5zdGFudGlhdGlvblxuICogY29uc3QgcmVzID0gYXdhaXQgbWFudWFsRmFsbGJhY2tDaGFpblxuICogICAuaW52b2tlKFwic2FmZVwiKVxuICogICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gKiAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCBhZnRlciBhbGwgYXR0ZW1wdHM6XCIsIGVycm9yLm1lc3NhZ2UpO1xuICogICB9KTtcbiAqXG4gKiAvLyBcIlByb2Nlc3NlZDogc2FmZVwiXG4gKiBgYGBcbiAqL1xuY2xhc3MgUnVubmFibGVXaXRoRmFsbGJhY2tzIGV4dGVuZHMgUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZVdpdGhGYWxsYmFja3NcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicnVubmFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmFsbGJhY2tzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucnVubmFibGUgPSBmaWVsZHMucnVubmFibGU7XG4gICAgICAgIHRoaXMuZmFsbGJhY2tzID0gZmllbGRzLmZhbGxiYWNrcztcbiAgICB9XG4gICAgKnJ1bm5hYmxlcygpIHtcbiAgICAgICAgeWllbGQgdGhpcy5ydW5uYWJsZTtcbiAgICAgICAgZm9yIChjb25zdCBmYWxsYmFjayBvZiB0aGlzLmZhbGxiYWNrcykge1xuICAgICAgICAgICAgeWllbGQgZmFsbGJhY2s7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgKDAsIGNvbmZpZ19qc18xLmdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZykoY29uZmlnKTtcbiAgICAgICAgY29uc3QgeyBydW5JZCwgLi4ub3RoZXJDb25maWdGaWVsZHMgfSA9IGNvbmZpZztcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlciA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgX2NvZXJjZVRvRGljdChpbnB1dCwgXCJpbnB1dFwiKSwgcnVuSWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG90aGVyQ29uZmlnRmllbGRzPy5ydW5OYW1lKTtcbiAgICAgICAgY29uc3QgY2hpbGRDb25maWcgPSAoMCwgY29uZmlnX2pzXzEucGF0Y2hDb25maWcpKG90aGVyQ29uZmlnRmllbGRzLCB7XG4gICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKCksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBpbmRleF9qc18xLkFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24ucnVuV2l0aENvbmZpZyhjaGlsZENvbmZpZywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGZpcnN0RXJyb3I7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJ1bm5hYmxlIG9mIHRoaXMucnVubmFibGVzKCkpIHtcbiAgICAgICAgICAgICAgICBjb25maWc/LnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCBydW5uYWJsZS5pbnZva2UoaW5wdXQsIGNoaWxkQ29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoX2NvZXJjZVRvRGljdChvdXRwdXQsIFwib3V0cHV0XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0RXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RFcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RFcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZXJyb3Igc3RvcmVkIGF0IGVuZCBvZiBmYWxsYmFjay5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGZpcnN0RXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZmlyc3RFcnJvcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGFzeW5jICpfc3RyZWFtSXRlcmF0b3IoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCAoMCwgY29uZmlnX2pzXzEuZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKShjb25maWcpO1xuICAgICAgICBjb25zdCB7IHJ1bklkLCAuLi5vdGhlckNvbmZpZ0ZpZWxkcyB9ID0gY29uZmlnO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VyID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCBfY29lcmNlVG9EaWN0KGlucHV0LCBcImlucHV0XCIpLCBydW5JZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb3RoZXJDb25maWdGaWVsZHM/LnJ1bk5hbWUpO1xuICAgICAgICBsZXQgZmlyc3RFcnJvcjtcbiAgICAgICAgbGV0IHN0cmVhbTtcbiAgICAgICAgZm9yIChjb25zdCBydW5uYWJsZSBvZiB0aGlzLnJ1bm5hYmxlcygpKSB7XG4gICAgICAgICAgICBjb25maWc/LnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkQ29uZmlnID0gKDAsIGNvbmZpZ19qc18xLnBhdGNoQ29uZmlnKShvdGhlckNvbmZpZ0ZpZWxkcywge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFN0cmVhbSA9IGF3YWl0IHJ1bm5hYmxlLnN0cmVhbShpbnB1dCwgY2hpbGRDb25maWcpO1xuICAgICAgICAgICAgICAgIHN0cmVhbSA9ICgwLCBpdGVyX2pzXzEuY29uc3VtZUFzeW5jSXRlcmFibGVJbkNvbnRleHQpKGNoaWxkQ29uZmlnLCBvcmlnaW5hbFN0cmVhbSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdEVycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RFcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBmaXJzdEVycm9yID8/IG5ldyBFcnJvcihcIk5vIGVycm9yIHN0b3JlZCBhdCBlbmQgb2YgZmFsbGJhY2suXCIpO1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3V0cHV0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG91dHB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5fY29uY2F0T3V0cHV0Q2h1bmtzKG91dHB1dCwgY2h1bmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChfY29lcmNlVG9EaWN0KG91dHB1dCwgXCJvdXRwdXRcIikpO1xuICAgIH1cbiAgICBhc3luYyBiYXRjaChpbnB1dHMsIG9wdGlvbnMsIGJhdGNoT3B0aW9ucykge1xuICAgICAgICBpZiAoYmF0Y2hPcHRpb25zPy5yZXR1cm5FeGNlcHRpb25zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmZpZ0xpc3QgPSB0aGlzLl9nZXRPcHRpb25zTGlzdChvcHRpb25zID8/IHt9LCBpbnB1dHMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VycyA9IGF3YWl0IFByb21pc2UuYWxsKGNvbmZpZ0xpc3QubWFwKChjb25maWcpID0+ICgwLCBjb25maWdfanNfMS5nZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcpKGNvbmZpZykpKTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlcnMgPSBhd2FpdCBQcm9taXNlLmFsbChjYWxsYmFja01hbmFnZXJzLm1hcChhc3luYyAoY2FsbGJhY2tNYW5hZ2VyLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVTdGFydFJlcyA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcj8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCBfY29lcmNlVG9EaWN0KGlucHV0c1tpXSwgXCJpbnB1dFwiKSwgY29uZmlnTGlzdFtpXS5ydW5JZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29uZmlnTGlzdFtpXS5ydW5OYW1lKTtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWdMaXN0W2ldLnJ1bklkO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0YXJ0UmVzO1xuICAgICAgICB9KSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGxldCBmaXJzdEVycm9yO1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bm5hYmxlIG9mIHRoaXMucnVubmFibGVzKCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0xpc3RbMF0uc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRzID0gYXdhaXQgcnVubmFibGUuYmF0Y2goaW5wdXRzLCBydW5NYW5hZ2Vycy5tYXAoKHJ1bk1hbmFnZXIsIGopID0+ICgwLCBjb25maWdfanNfMS5wYXRjaENvbmZpZykoY29uZmlnTGlzdFtqXSwge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKCksXG4gICAgICAgICAgICAgICAgfSkpLCBiYXRjaE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlciwgaSkgPT4gcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoX2NvZXJjZVRvRGljdChvdXRwdXRzW2ldLCBcIm91dHB1dFwiKSkpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0RXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEVycm9yID0gZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmaXJzdEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBlcnJvciBzdG9yZWQgYXQgZW5kIG9mIGZhbGxiYWNrcy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocnVuTWFuYWdlcnMubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGZpcnN0RXJyb3IpKSk7XG4gICAgICAgIHRocm93IGZpcnN0RXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5uYWJsZVdpdGhGYWxsYmFja3MgPSBSdW5uYWJsZVdpdGhGYWxsYmFja3M7XG4vLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSB0aGUgY29tcGlsZXIgbmVlZHMgaGVscCBlbGltaW5hdGluZyBFcnJvciBhcyBhIFJ1bk91dHB1dCB0eXBlXG5mdW5jdGlvbiBfY29lcmNlVG9SdW5uYWJsZShjb2VyY2VhYmxlKSB7XG4gICAgaWYgKHR5cGVvZiBjb2VyY2VhYmxlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZUxhbWJkYSh7IGZ1bmM6IGNvZXJjZWFibGUgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKFJ1bm5hYmxlLmlzUnVubmFibGUoY29lcmNlYWJsZSkpIHtcbiAgICAgICAgcmV0dXJuIGNvZXJjZWFibGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGNvZXJjZWFibGUpICYmIHR5cGVvZiBjb2VyY2VhYmxlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5hYmxlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhjb2VyY2VhYmxlKSkge1xuICAgICAgICAgICAgcnVubmFibGVzW2tleV0gPSBfY29lcmNlVG9SdW5uYWJsZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZU1hcCh7XG4gICAgICAgICAgICBzdGVwczogcnVubmFibGVzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBSdW5uYWJsZSwgZnVuY3Rpb24gb3Igb2JqZWN0Llxcbkluc3RlYWQgZ290IGFuIHVuc3VwcG9ydGVkIHR5cGUuYCk7XG4gICAgfVxufVxuLyoqXG4gKiBBIHJ1bm5hYmxlIHRoYXQgYXNzaWducyBrZXktdmFsdWUgcGFpcnMgdG8gaW5wdXRzIG9mIHR5cGUgYFJlY29yZDxzdHJpbmcsIHVua25vd24+YC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQge1xuICogICBSdW5uYWJsZUFzc2lnbixcbiAqICAgUnVubmFibGVMYW1iZGEsXG4gKiAgIFJ1bm5hYmxlUGFyYWxsZWwsXG4gKiB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG4gKlxuICogY29uc3QgY2FsY3VsYXRlQWdlID0gKHg6IHsgYmlydGhZZWFyOiBudW1iZXIgfSk6IHsgYWdlOiBudW1iZXIgfSA9PiB7XG4gKiAgIGNvbnN0IGN1cnJlbnRZZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuICogICByZXR1cm4geyBhZ2U6IGN1cnJlbnRZZWFyIC0geC5iaXJ0aFllYXIgfTtcbiAqIH07XG4gKlxuICogY29uc3QgY3JlYXRlR3JlZXRpbmcgPSAoeDogeyBuYW1lOiBzdHJpbmcgfSk6IHsgZ3JlZXRpbmc6IHN0cmluZyB9ID0+IHtcbiAqICAgcmV0dXJuIHsgZ3JlZXRpbmc6IGBIZWxsbywgJHt4Lm5hbWV9IWAgfTtcbiAqIH07XG4gKlxuICogY29uc3QgbWFwcGVyID0gUnVubmFibGVQYXJhbGxlbC5mcm9tKHtcbiAqICAgYWdlX3N0ZXA6IFJ1bm5hYmxlTGFtYmRhLmZyb20oY2FsY3VsYXRlQWdlKSxcbiAqICAgZ3JlZXRpbmdfc3RlcDogUnVubmFibGVMYW1iZGEuZnJvbShjcmVhdGVHcmVldGluZyksXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBydW5uYWJsZUFzc2lnbiA9IG5ldyBSdW5uYWJsZUFzc2lnbih7IG1hcHBlciB9KTtcbiAqXG4gKiBjb25zdCByZXMgPSBhd2FpdCBydW5uYWJsZUFzc2lnbi5pbnZva2UoeyBuYW1lOiBcIkFsaWNlXCIsIGJpcnRoWWVhcjogMTk5MCB9KTtcbiAqXG4gKiAvLyB7IG5hbWU6IFwiQWxpY2VcIiwgYmlydGhZZWFyOiAxOTkwLCBhZ2Vfc3RlcDogeyBhZ2U6IDM0IH0sIGdyZWV0aW5nX3N0ZXA6IHsgZ3JlZXRpbmc6IFwiSGVsbG8sIEFsaWNlIVwiIH0gfVxuICogYGBgXG4gKi9cbmNsYXNzIFJ1bm5hYmxlQXNzaWduIGV4dGVuZHMgUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZUFzc2lnblwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICBpZiAoZmllbGRzIGluc3RhbmNlb2YgUnVubmFibGVNYXApIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgZmllbGRzID0geyBtYXBwZXI6IGZpZWxkcyB9O1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWFwcGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFwcGVyID0gZmllbGRzLm1hcHBlcjtcbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1hcHBlclJlc3VsdCA9IGF3YWl0IHRoaXMubWFwcGVyLmludm9rZShpbnB1dCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5pbnB1dCxcbiAgICAgICAgICAgIC4uLm1hcHBlclJlc3VsdCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgKl90cmFuc2Zvcm0oZ2VuZXJhdG9yLCBydW5NYW5hZ2VyLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIGNvbGxlY3QgbWFwcGVyIGtleXNcbiAgICAgICAgY29uc3QgbWFwcGVyS2V5cyA9IHRoaXMubWFwcGVyLmdldFN0ZXBzS2V5cygpO1xuICAgICAgICAvLyBjcmVhdGUgdHdvIGlucHV0IGdlbnMsIG9uZSBmb3IgdGhlIG1hcHBlciwgb25lIGZvciB0aGUgaW5wdXRcbiAgICAgICAgY29uc3QgW2ZvclBhc3N0aHJvdWdoLCBmb3JNYXBwZXJdID0gKDAsIHN0cmVhbV9qc18xLmF0ZWUpKGdlbmVyYXRvcik7XG4gICAgICAgIC8vIGNyZWF0ZSBtYXBwZXIgb3V0cHV0IGdlblxuICAgICAgICBjb25zdCBtYXBwZXJPdXRwdXQgPSB0aGlzLm1hcHBlci50cmFuc2Zvcm0oZm9yTWFwcGVyLCAoMCwgY29uZmlnX2pzXzEucGF0Y2hDb25maWcpKG9wdGlvbnMsIHsgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZCgpIH0pKTtcbiAgICAgICAgLy8gc3RhcnQgdGhlIG1hcHBlclxuICAgICAgICBjb25zdCBmaXJzdE1hcHBlckNodW5rUHJvbWlzZSA9IG1hcHBlck91dHB1dC5uZXh0KCk7XG4gICAgICAgIC8vIHlpZWxkIHRoZSBwYXNzdGhyb3VnaFxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGZvclBhc3N0aHJvdWdoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNodW5rICE9PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSdW5uYWJsZUFzc2lnbiBjYW4gb25seSBiZSB1c2VkIHdpdGggb2JqZWN0cyBhcyBpbnB1dCwgZ290ICR7dHlwZW9mIGNodW5rfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoY2h1bmspLmZpbHRlcigoW2tleV0pID0+ICFtYXBwZXJLZXlzLmluY2x1ZGVzKGtleSkpKTtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhmaWx0ZXJlZCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGZpbHRlcmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHlpZWxkIHRoZSBtYXBwZXIgb3V0cHV0XG4gICAgICAgIHlpZWxkIChhd2FpdCBmaXJzdE1hcHBlckNodW5rUHJvbWlzZSkudmFsdWU7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgbWFwcGVyT3V0cHV0KSB7XG4gICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmFuc2Zvcm0oZ2VuZXJhdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm1TdHJlYW1XaXRoQ29uZmlnKGdlbmVyYXRvciwgdGhpcy5fdHJhbnNmb3JtLmJpbmQodGhpcyksIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzdHJlYW0oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24qIGdlbmVyYXRvcigpIHtcbiAgICAgICAgICAgIHlpZWxkIGlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB3cmFwcGVkR2VuZXJhdG9yID0gbmV3IHN0cmVhbV9qc18xLkFzeW5jR2VuZXJhdG9yV2l0aFNldHVwKHtcbiAgICAgICAgICAgIGdlbmVyYXRvcjogdGhpcy50cmFuc2Zvcm0oZ2VuZXJhdG9yKCksIGNvbmZpZyksXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB3cmFwcGVkR2VuZXJhdG9yLnNldHVwO1xuICAgICAgICByZXR1cm4gc3RyZWFtX2pzXzEuSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tQXN5bmNHZW5lcmF0b3Iod3JhcHBlZEdlbmVyYXRvcik7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5uYWJsZUFzc2lnbiA9IFJ1bm5hYmxlQXNzaWduO1xuLyoqXG4gKiBBIHJ1bm5hYmxlIHRoYXQgYXNzaWducyBrZXktdmFsdWUgcGFpcnMgdG8gaW5wdXRzIG9mIHR5cGUgYFJlY29yZDxzdHJpbmcsIHVua25vd24+YC5cbiAqIFVzZWZ1bCBmb3Igc3RyZWFtaW5nLCBjYW4gYmUgYXV0b21hdGljYWxseSBjcmVhdGVkIGFuZCBjaGFpbmVkIGJ5IGNhbGxpbmcgYHJ1bm5hYmxlLnBpY2soKTtgLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IFJ1bm5hYmxlUGljayB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG4gKlxuICogY29uc3QgaW5wdXREYXRhID0ge1xuICogICBuYW1lOiBcIkpvaG5cIixcbiAqICAgYWdlOiAzMCxcbiAqICAgY2l0eTogXCJOZXcgWW9ya1wiLFxuICogICBjb3VudHJ5OiBcIlVTQVwiLFxuICogICBlbWFpbDogXCJqb2huLmRvZUBleGFtcGxlLmNvbVwiLFxuICogICBwaG9uZTogXCIrMTIzNDU2Nzg5MFwiLFxuICogfTtcbiAqXG4gKiBjb25zdCBiYXNpY0luZm9SdW5uYWJsZSA9IG5ldyBSdW5uYWJsZVBpY2soW1wibmFtZVwiLCBcImNpdHlcIl0pO1xuICpcbiAqIC8vIEV4YW1wbGUgaW52b2NhdGlvblxuICogY29uc3QgcmVzID0gYXdhaXQgYmFzaWNJbmZvUnVubmFibGUuaW52b2tlKGlucHV0RGF0YSk7XG4gKlxuICogLy8geyBuYW1lOiAnSm9obicsIGNpdHk6ICdOZXcgWW9yaycgfVxuICogYGBgXG4gKi9cbmNsYXNzIFJ1bm5hYmxlUGljayBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVQaWNrXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkcyA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KGZpZWxkcykpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgZmllbGRzID0geyBrZXlzOiBmaWVsZHMgfTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImtleXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5rZXlzID0gZmllbGRzLmtleXM7XG4gICAgfVxuICAgIGFzeW5jIF9waWNrKGlucHV0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5rZXlzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRbdGhpcy5rZXlzXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBpY2tlZCA9IHRoaXMua2V5c1xuICAgICAgICAgICAgICAgIC5tYXAoKGtleSkgPT4gW2tleSwgaW5wdXRba2V5XV0pXG4gICAgICAgICAgICAgICAgLmZpbHRlcigodikgPT4gdlsxXSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHJldHVybiBwaWNrZWQubGVuZ3RoID09PSAwXG4gICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA6IE9iamVjdC5mcm9tRW50cmllcyhwaWNrZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFdpdGhDb25maWcodGhpcy5fcGljay5iaW5kKHRoaXMpLCBpbnB1dCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jICpfdHJhbnNmb3JtKGdlbmVyYXRvcikge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGdlbmVyYXRvcikge1xuICAgICAgICAgICAgY29uc3QgcGlja2VkID0gYXdhaXQgdGhpcy5fcGljayhjaHVuayk7XG4gICAgICAgICAgICBpZiAocGlja2VkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBwaWNrZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhbnNmb3JtKGdlbmVyYXRvciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtU3RyZWFtV2l0aENvbmZpZyhnZW5lcmF0b3IsIHRoaXMuX3RyYW5zZm9ybS5iaW5kKHRoaXMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc3RyZWFtKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uKiBnZW5lcmF0b3IoKSB7XG4gICAgICAgICAgICB5aWVsZCBpbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWcgPSAoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgd3JhcHBlZEdlbmVyYXRvciA9IG5ldyBzdHJlYW1fanNfMS5Bc3luY0dlbmVyYXRvcldpdGhTZXR1cCh7XG4gICAgICAgICAgICBnZW5lcmF0b3I6IHRoaXMudHJhbnNmb3JtKGdlbmVyYXRvcigpLCBjb25maWcpLFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgd3JhcHBlZEdlbmVyYXRvci5zZXR1cDtcbiAgICAgICAgcmV0dXJuIHN0cmVhbV9qc18xLkl0ZXJhYmxlUmVhZGFibGVTdHJlYW0uZnJvbUFzeW5jR2VuZXJhdG9yKHdyYXBwZWRHZW5lcmF0b3IpO1xuICAgIH1cbn1cbmV4cG9ydHMuUnVubmFibGVQaWNrID0gUnVubmFibGVQaWNrO1xuY2xhc3MgUnVubmFibGVUb29sTGlrZSBleHRlbmRzIFJ1bm5hYmxlQmluZGluZyB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IHNlcXVlbmNlID0gUnVubmFibGVTZXF1ZW5jZS5mcm9tKFtcbiAgICAgICAgICAgIFJ1bm5hYmxlTGFtYmRhLmZyb20oYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHRvb2xJbnB1dDtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzX2pzXzIuX2lzVG9vbENhbGwpKGlucHV0KSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbElucHV0ID0gYXdhaXQgKDAsIHpvZF9qc18xLmludGVyb3BQYXJzZUFzeW5jKSh0aGlzLnNjaGVtYSwgaW5wdXQuYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyB1dGlsc19qc18yLlRvb2xJbnB1dFBhcnNpbmdFeGNlcHRpb24oYFJlY2VpdmVkIHRvb2wgaW5wdXQgZGlkIG5vdCBtYXRjaCBleHBlY3RlZCBzY2hlbWFgLCBKU09OLnN0cmluZ2lmeShpbnB1dC5hcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xJbnB1dCA9IGlucHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbElucHV0O1xuICAgICAgICAgICAgfSkud2l0aENvbmZpZyh7IHJ1bk5hbWU6IGAke2ZpZWxkcy5uYW1lfTpwYXJzZV9pbnB1dGAgfSksXG4gICAgICAgICAgICBmaWVsZHMuYm91bmQsXG4gICAgICAgIF0pLndpdGhDb25maWcoeyBydW5OYW1lOiBmaWVsZHMubmFtZSB9KTtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgYm91bmQ6IHNlcXVlbmNlLFxuICAgICAgICAgICAgY29uZmlnOiBmaWVsZHMuY29uZmlnID8/IHt9LFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZXNjcmlwdGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzY2hlbWFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gZmllbGRzLm5hbWU7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBmaWVsZHMuZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMuc2NoZW1hID0gZmllbGRzLnNjaGVtYTtcbiAgICB9XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlVG9vbExpa2VcIjtcbiAgICB9XG59XG5leHBvcnRzLlJ1bm5hYmxlVG9vbExpa2UgPSBSdW5uYWJsZVRvb2xMaWtlO1xuLyoqXG4gKiBHaXZlbiBhIHJ1bm5hYmxlIGFuZCBhIFpvZCBzY2hlbWEsIGNvbnZlcnQgdGhlIHJ1bm5hYmxlIHRvIGEgdG9vbC5cbiAqXG4gKiBAdGVtcGxhdGUgUnVuSW5wdXQgVGhlIGlucHV0IHR5cGUgZm9yIHRoZSBydW5uYWJsZS5cbiAqIEB0ZW1wbGF0ZSBSdW5PdXRwdXQgVGhlIG91dHB1dCB0eXBlIGZvciB0aGUgcnVubmFibGUuXG4gKlxuICogQHBhcmFtIHtSdW5uYWJsZTxSdW5JbnB1dCwgUnVuT3V0cHV0Pn0gcnVubmFibGUgVGhlIHJ1bm5hYmxlIHRvIGNvbnZlcnQgdG8gYSB0b29sLlxuICogQHBhcmFtIGZpZWxkc1xuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFtmaWVsZHMubmFtZV0gVGhlIG5hbWUgb2YgdGhlIHRvb2wuIElmIG5vdCBwcm92aWRlZCwgaXQgd2lsbCBkZWZhdWx0IHRvIHRoZSBuYW1lIG9mIHRoZSBydW5uYWJsZS5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbZmllbGRzLmRlc2NyaXB0aW9uXSBUaGUgZGVzY3JpcHRpb24gb2YgdGhlIHRvb2wuIEZhbGxzIGJhY2sgdG8gdGhlIGRlc2NyaXB0aW9uIG9uIHRoZSBab2Qgc2NoZW1hIGlmIG5vdCBwcm92aWRlZCwgb3IgdW5kZWZpbmVkIGlmIG5laXRoZXIgYXJlIHByb3ZpZGVkLlxuICogQHBhcmFtIHtJbnRlcm9wWm9kVHlwZTxSdW5JbnB1dD59IFtmaWVsZHMuc2NoZW1hXSBUaGUgWm9kIHNjaGVtYSBmb3IgdGhlIGlucHV0IG9mIHRoZSB0b29sLiBJbmZlcnMgdGhlIFpvZCB0eXBlIGZyb20gdGhlIGlucHV0IHR5cGUgb2YgdGhlIHJ1bm5hYmxlLlxuICogQHJldHVybnMge1J1bm5hYmxlVG9vbExpa2U8SW50ZXJvcFpvZFR5cGU8UnVuSW5wdXQ+LCBSdW5PdXRwdXQ+fSBBbiBpbnN0YW5jZSBvZiBgUnVubmFibGVUb29sTGlrZWAgd2hpY2ggaXMgYSBydW5uYWJsZSB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgdG9vbC5cbiAqL1xuZnVuY3Rpb24gY29udmVydFJ1bm5hYmxlVG9Ub29sKHJ1bm5hYmxlLCBmaWVsZHMpIHtcbiAgICBjb25zdCBuYW1lID0gZmllbGRzLm5hbWUgPz8gcnVubmFibGUuZ2V0TmFtZSgpO1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gZmllbGRzLmRlc2NyaXB0aW9uID8/ICgwLCB6b2RfanNfMS5nZXRTY2hlbWFEZXNjcmlwdGlvbikoZmllbGRzLnNjaGVtYSk7XG4gICAgaWYgKCgwLCB6b2RfanNfMS5pc1NpbXBsZVN0cmluZ1pvZFNjaGVtYSkoZmllbGRzLnNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZVRvb2xMaWtlKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHNjaGVtYTogdjNfMS56XG4gICAgICAgICAgICAgICAgLm9iamVjdCh7IGlucHV0OiB2M18xLnouc3RyaW5nKCkgfSlcbiAgICAgICAgICAgICAgICAudHJhbnNmb3JtKChpbnB1dCkgPT4gaW5wdXQuaW5wdXQpLFxuICAgICAgICAgICAgYm91bmQ6IHJ1bm5hYmxlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSdW5uYWJsZVRvb2xMaWtlKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIHNjaGVtYTogZmllbGRzLnNjaGVtYSxcbiAgICAgICAgYm91bmQ6IHJ1bm5hYmxlLFxuICAgIH0pO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/branch.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/branch.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RunnableBranch = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nconst config_js_1 = __webpack_require__(/*! ./config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\n/**\n * Class that represents a runnable branch. The RunnableBranch is\n * initialized with an array of branches and a default branch. When invoked,\n * it evaluates the condition of each branch in order and executes the\n * corresponding branch if the condition is true. If none of the conditions\n * are true, it executes the default branch.\n * @example\n * ```typescript\n * const branch = RunnableBranch.from([\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"anthropic\"),\n *     anthropicChain,\n *   ],\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"langchain\"),\n *     langChainChain,\n *   ],\n *   generalChain,\n * ]);\n *\n * const fullChain = RunnableSequence.from([\n *   {\n *     topic: classificationChain,\n *     question: (input: { question: string }) => input.question,\n *   },\n *   branch,\n * ]);\n *\n * const result = await fullChain.invoke({\n *   question: \"how do I use LangChain?\",\n * });\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass RunnableBranch extends base_js_1.Runnable {\n    static lc_name() {\n        return \"RunnableBranch\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"default\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"branches\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.branches = fields.branches;\n        this.default = fields.default;\n    }\n    /**\n     * Convenience method for instantiating a RunnableBranch from\n     * RunnableLikes (objects, functions, or Runnables).\n     *\n     * Each item in the input except for the last one should be a\n     * tuple with two items. The first is a \"condition\" RunnableLike that\n     * returns \"true\" if the second RunnableLike in the tuple should run.\n     *\n     * The final item in the input should be a RunnableLike that acts as a\n     * default branch if no other branches match.\n     *\n     * @example\n     * ```ts\n     * import { RunnableBranch } from \"@langchain/core/runnables\";\n     *\n     * const branch = RunnableBranch.from([\n     *   [(x: number) => x > 0, (x: number) => x + 1],\n     *   [(x: number) => x < 0, (x: number) => x - 1],\n     *   (x: number) => x\n     * ]);\n     * ```\n     * @param branches An array where the every item except the last is a tuple of [condition, runnable]\n     *   pairs. The last item is a default runnable which is invoked if no other condition matches.\n     * @returns A new RunnableBranch.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static from(branches) {\n        if (branches.length < 1) {\n            throw new Error(\"RunnableBranch requires at least one branch\");\n        }\n        const branchLikes = branches.slice(0, -1);\n        const coercedBranches = branchLikes.map(([condition, runnable]) => [\n            (0, base_js_1._coerceToRunnable)(condition),\n            (0, base_js_1._coerceToRunnable)(runnable),\n        ]);\n        const defaultBranch = (0, base_js_1._coerceToRunnable)(branches[branches.length - 1]);\n        return new this({\n            branches: coercedBranches,\n            default: defaultBranch,\n        });\n    }\n    async _invoke(input, config, runManager) {\n        let result;\n        for (let i = 0; i < this.branches.length; i += 1) {\n            const [condition, branchRunnable] = this.branches[i];\n            const conditionValue = await condition.invoke(input, (0, config_js_1.patchConfig)(config, {\n                callbacks: runManager?.getChild(`condition:${i + 1}`),\n            }));\n            if (conditionValue) {\n                result = await branchRunnable.invoke(input, (0, config_js_1.patchConfig)(config, {\n                    callbacks: runManager?.getChild(`branch:${i + 1}`),\n                }));\n                break;\n            }\n        }\n        if (!result) {\n            result = await this.default.invoke(input, (0, config_js_1.patchConfig)(config, {\n                callbacks: runManager?.getChild(\"branch:default\"),\n            }));\n        }\n        return result;\n    }\n    async invoke(input, config = {}) {\n        return this._callWithConfig(this._invoke, input, config);\n    }\n    async *_streamIterator(input, config) {\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), (0, base_js_1._coerceToDict)(input, \"input\"), config?.runId, undefined, undefined, undefined, config?.runName);\n        let finalOutput;\n        let finalOutputSupported = true;\n        let stream;\n        try {\n            for (let i = 0; i < this.branches.length; i += 1) {\n                const [condition, branchRunnable] = this.branches[i];\n                const conditionValue = await condition.invoke(input, (0, config_js_1.patchConfig)(config, {\n                    callbacks: runManager?.getChild(`condition:${i + 1}`),\n                }));\n                if (conditionValue) {\n                    stream = await branchRunnable.stream(input, (0, config_js_1.patchConfig)(config, {\n                        callbacks: runManager?.getChild(`branch:${i + 1}`),\n                    }));\n                    for await (const chunk of stream) {\n                        yield chunk;\n                        if (finalOutputSupported) {\n                            if (finalOutput === undefined) {\n                                finalOutput = chunk;\n                            }\n                            else {\n                                try {\n                                    finalOutput = (0, stream_js_1.concat)(finalOutput, chunk);\n                                }\n                                catch (e) {\n                                    finalOutput = undefined;\n                                    finalOutputSupported = false;\n                                }\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n            if (stream === undefined) {\n                stream = await this.default.stream(input, (0, config_js_1.patchConfig)(config, {\n                    callbacks: runManager?.getChild(\"branch:default\"),\n                }));\n                for await (const chunk of stream) {\n                    yield chunk;\n                    if (finalOutputSupported) {\n                        if (finalOutput === undefined) {\n                            finalOutput = chunk;\n                        }\n                        else {\n                            try {\n                                finalOutput = (0, stream_js_1.concat)(finalOutput, chunk);\n                            }\n                            catch (e) {\n                                finalOutput = undefined;\n                                finalOutputSupported = false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(finalOutput ?? {});\n    }\n}\nexports.RunnableBranch = RunnableBranch;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2JyYW5jaC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCLGtCQUFrQixtQkFBTyxDQUFDLGdGQUFZO0FBQ3RDLG9CQUFvQixtQkFBTyxDQUFDLG9GQUFjO0FBQzFDLG9CQUFvQixtQkFBTyxDQUFDLHVGQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZSxrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWUsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0MsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0EsNkRBQTZELE1BQU07QUFDbkUsYUFBYTtBQUNiO0FBQ0E7QUFDQSw4REFBOEQsTUFBTTtBQUNwRSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQSxpRUFBaUUsTUFBTTtBQUN2RSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGtFQUFrRSxNQUFNO0FBQ3hFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLHNCQUFzQiIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3J1bm5hYmxlcy9icmFuY2guY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SdW5uYWJsZUJyYW5jaCA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2UuY2pzXCIpO1xuY29uc3QgY29uZmlnX2pzXzEgPSByZXF1aXJlKFwiLi9jb25maWcuY2pzXCIpO1xuY29uc3Qgc3RyZWFtX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvc3RyZWFtLmNqc1wiKTtcbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgcnVubmFibGUgYnJhbmNoLiBUaGUgUnVubmFibGVCcmFuY2ggaXNcbiAqIGluaXRpYWxpemVkIHdpdGggYW4gYXJyYXkgb2YgYnJhbmNoZXMgYW5kIGEgZGVmYXVsdCBicmFuY2guIFdoZW4gaW52b2tlZCxcbiAqIGl0IGV2YWx1YXRlcyB0aGUgY29uZGl0aW9uIG9mIGVhY2ggYnJhbmNoIGluIG9yZGVyIGFuZCBleGVjdXRlcyB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgYnJhbmNoIGlmIHRoZSBjb25kaXRpb24gaXMgdHJ1ZS4gSWYgbm9uZSBvZiB0aGUgY29uZGl0aW9uc1xuICogYXJlIHRydWUsIGl0IGV4ZWN1dGVzIHRoZSBkZWZhdWx0IGJyYW5jaC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBicmFuY2ggPSBSdW5uYWJsZUJyYW5jaC5mcm9tKFtcbiAqICAgW1xuICogICAgICh4OiB7IHRvcGljOiBzdHJpbmc7IHF1ZXN0aW9uOiBzdHJpbmcgfSkgPT5cbiAqICAgICAgIHgudG9waWMudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImFudGhyb3BpY1wiKSxcbiAqICAgICBhbnRocm9waWNDaGFpbixcbiAqICAgXSxcbiAqICAgW1xuICogICAgICh4OiB7IHRvcGljOiBzdHJpbmc7IHF1ZXN0aW9uOiBzdHJpbmcgfSkgPT5cbiAqICAgICAgIHgudG9waWMudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImxhbmdjaGFpblwiKSxcbiAqICAgICBsYW5nQ2hhaW5DaGFpbixcbiAqICAgXSxcbiAqICAgZ2VuZXJhbENoYWluLFxuICogXSk7XG4gKlxuICogY29uc3QgZnVsbENoYWluID0gUnVubmFibGVTZXF1ZW5jZS5mcm9tKFtcbiAqICAge1xuICogICAgIHRvcGljOiBjbGFzc2lmaWNhdGlvbkNoYWluLFxuICogICAgIHF1ZXN0aW9uOiAoaW5wdXQ6IHsgcXVlc3Rpb246IHN0cmluZyB9KSA9PiBpbnB1dC5xdWVzdGlvbixcbiAqICAgfSxcbiAqICAgYnJhbmNoLFxuICogXSk7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZnVsbENoYWluLmludm9rZSh7XG4gKiAgIHF1ZXN0aW9uOiBcImhvdyBkbyBJIHVzZSBMYW5nQ2hhaW4/XCIsXG4gKiB9KTtcbiAqIGBgYFxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY2xhc3MgUnVubmFibGVCcmFuY2ggZXh0ZW5kcyBiYXNlX2pzXzEuUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZUJyYW5jaFwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJyYW5jaGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYnJhbmNoZXMgPSBmaWVsZHMuYnJhbmNoZXM7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IGZpZWxkcy5kZWZhdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIGluc3RhbnRpYXRpbmcgYSBSdW5uYWJsZUJyYW5jaCBmcm9tXG4gICAgICogUnVubmFibGVMaWtlcyAob2JqZWN0cywgZnVuY3Rpb25zLCBvciBSdW5uYWJsZXMpLlxuICAgICAqXG4gICAgICogRWFjaCBpdGVtIGluIHRoZSBpbnB1dCBleGNlcHQgZm9yIHRoZSBsYXN0IG9uZSBzaG91bGQgYmUgYVxuICAgICAqIHR1cGxlIHdpdGggdHdvIGl0ZW1zLiBUaGUgZmlyc3QgaXMgYSBcImNvbmRpdGlvblwiIFJ1bm5hYmxlTGlrZSB0aGF0XG4gICAgICogcmV0dXJucyBcInRydWVcIiBpZiB0aGUgc2Vjb25kIFJ1bm5hYmxlTGlrZSBpbiB0aGUgdHVwbGUgc2hvdWxkIHJ1bi5cbiAgICAgKlxuICAgICAqIFRoZSBmaW5hbCBpdGVtIGluIHRoZSBpbnB1dCBzaG91bGQgYmUgYSBSdW5uYWJsZUxpa2UgdGhhdCBhY3RzIGFzIGFcbiAgICAgKiBkZWZhdWx0IGJyYW5jaCBpZiBubyBvdGhlciBicmFuY2hlcyBtYXRjaC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBpbXBvcnQgeyBSdW5uYWJsZUJyYW5jaCB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG4gICAgICpcbiAgICAgKiBjb25zdCBicmFuY2ggPSBSdW5uYWJsZUJyYW5jaC5mcm9tKFtcbiAgICAgKiAgIFsoeDogbnVtYmVyKSA9PiB4ID4gMCwgKHg6IG51bWJlcikgPT4geCArIDFdLFxuICAgICAqICAgWyh4OiBudW1iZXIpID0+IHggPCAwLCAoeDogbnVtYmVyKSA9PiB4IC0gMV0sXG4gICAgICogICAoeDogbnVtYmVyKSA9PiB4XG4gICAgICogXSk7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIGJyYW5jaGVzIEFuIGFycmF5IHdoZXJlIHRoZSBldmVyeSBpdGVtIGV4Y2VwdCB0aGUgbGFzdCBpcyBhIHR1cGxlIG9mIFtjb25kaXRpb24sIHJ1bm5hYmxlXVxuICAgICAqICAgcGFpcnMuIFRoZSBsYXN0IGl0ZW0gaXMgYSBkZWZhdWx0IHJ1bm5hYmxlIHdoaWNoIGlzIGludm9rZWQgaWYgbm8gb3RoZXIgY29uZGl0aW9uIG1hdGNoZXMuXG4gICAgICogQHJldHVybnMgQSBuZXcgUnVubmFibGVCcmFuY2guXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzdGF0aWMgZnJvbShicmFuY2hlcykge1xuICAgICAgICBpZiAoYnJhbmNoZXMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUnVubmFibGVCcmFuY2ggcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGJyYW5jaFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBicmFuY2hMaWtlcyA9IGJyYW5jaGVzLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgY29uc3QgY29lcmNlZEJyYW5jaGVzID0gYnJhbmNoTGlrZXMubWFwKChbY29uZGl0aW9uLCBydW5uYWJsZV0pID0+IFtcbiAgICAgICAgICAgICgwLCBiYXNlX2pzXzEuX2NvZXJjZVRvUnVubmFibGUpKGNvbmRpdGlvbiksXG4gICAgICAgICAgICAoMCwgYmFzZV9qc18xLl9jb2VyY2VUb1J1bm5hYmxlKShydW5uYWJsZSksXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBkZWZhdWx0QnJhbmNoID0gKDAsIGJhc2VfanNfMS5fY29lcmNlVG9SdW5uYWJsZSkoYnJhbmNoZXNbYnJhbmNoZXMubGVuZ3RoIC0gMV0pO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoe1xuICAgICAgICAgICAgYnJhbmNoZXM6IGNvZXJjZWRCcmFuY2hlcyxcbiAgICAgICAgICAgIGRlZmF1bHQ6IGRlZmF1bHRCcmFuY2gsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfaW52b2tlKGlucHV0LCBjb25maWcsIHJ1bk1hbmFnZXIpIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJyYW5jaGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBbY29uZGl0aW9uLCBicmFuY2hSdW5uYWJsZV0gPSB0aGlzLmJyYW5jaGVzW2ldO1xuICAgICAgICAgICAgY29uc3QgY29uZGl0aW9uVmFsdWUgPSBhd2FpdCBjb25kaXRpb24uaW52b2tlKGlucHV0LCAoMCwgY29uZmlnX2pzXzEucGF0Y2hDb25maWcpKGNvbmZpZywge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoYGNvbmRpdGlvbjoke2kgKyAxfWApLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKGNvbmRpdGlvblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgYnJhbmNoUnVubmFibGUuaW52b2tlKGlucHV0LCAoMCwgY29uZmlnX2pzXzEucGF0Y2hDb25maWcpKGNvbmZpZywge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKGBicmFuY2g6JHtpICsgMX1gKSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMuZGVmYXVsdC5pbnZva2UoaW5wdXQsICgwLCBjb25maWdfanNfMS5wYXRjaENvbmZpZykoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZChcImJyYW5jaDpkZWZhdWx0XCIpLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShpbnB1dCwgY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxXaXRoQ29uZmlnKHRoaXMuX2ludm9rZSwgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICAgIGFzeW5jICpfc3RyZWFtSXRlcmF0b3IoaW5wdXQsIGNvbmZpZykge1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgKDAsIGNvbmZpZ19qc18xLmdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZykoY29uZmlnKTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlciA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgKDAsIGJhc2VfanNfMS5fY29lcmNlVG9EaWN0KShpbnB1dCwgXCJpbnB1dFwiKSwgY29uZmlnPy5ydW5JZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29uZmlnPy5ydW5OYW1lKTtcbiAgICAgICAgbGV0IGZpbmFsT3V0cHV0O1xuICAgICAgICBsZXQgZmluYWxPdXRwdXRTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICBsZXQgc3RyZWFtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJyYW5jaGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2NvbmRpdGlvbiwgYnJhbmNoUnVubmFibGVdID0gdGhpcy5icmFuY2hlc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25kaXRpb25WYWx1ZSA9IGF3YWl0IGNvbmRpdGlvbi5pbnZva2UoaW5wdXQsICgwLCBjb25maWdfanNfMS5wYXRjaENvbmZpZykoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoYGNvbmRpdGlvbjoke2kgKyAxfWApLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtID0gYXdhaXQgYnJhbmNoUnVubmFibGUuc3RyZWFtKGlucHV0LCAoMCwgY29uZmlnX2pzXzEucGF0Y2hDb25maWcpKGNvbmZpZywge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZChgYnJhbmNoOiR7aSArIDF9YCksXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsT3V0cHV0U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsT3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9ICgwLCBzdHJlYW1fanNfMS5jb25jYXQpKGZpbmFsT3V0cHV0LCBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXRTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0gPSBhd2FpdCB0aGlzLmRlZmF1bHQuc3RyZWFtKGlucHV0LCAoMCwgY29uZmlnX2pzXzEucGF0Y2hDb25maWcpKGNvbmZpZywge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKFwiYnJhbmNoOmRlZmF1bHRcIiksXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxPdXRwdXRTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbE91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gKDAsIHN0cmVhbV9qc18xLmNvbmNhdCkoZmluYWxPdXRwdXQsIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChmaW5hbE91dHB1dCA/PyB7fSk7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5uYWJsZUJyYW5jaCA9IFJ1bm5hYmxlQnJhbmNoO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/branch.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/config.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_RECURSION_LIMIT = void 0;\nexports.getCallbackManagerForConfig = getCallbackManagerForConfig;\nexports.mergeConfigs = mergeConfigs;\nexports.ensureConfig = ensureConfig;\nexports.patchConfig = patchConfig;\nexports.pickRunnableConfigKeys = pickRunnableConfigKeys;\nconst manager_js_1 = __webpack_require__(/*! ../callbacks/manager.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.cjs\");\nconst index_js_1 = __webpack_require__(/*! ../singletons/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/index.cjs\");\nexports.DEFAULT_RECURSION_LIMIT = 25;\nasync function getCallbackManagerForConfig(config) {\n    return manager_js_1.CallbackManager._configureSync(config?.callbacks, undefined, config?.tags, undefined, config?.metadata);\n}\nfunction mergeConfigs(...configs) {\n    // We do not want to call ensureConfig on the empty state here as this may cause\n    // double loading of callbacks if async local storage is being used.\n    const copy = {};\n    for (const options of configs.filter((c) => !!c)) {\n        for (const key of Object.keys(options)) {\n            if (key === \"metadata\") {\n                copy[key] = { ...copy[key], ...options[key] };\n            }\n            else if (key === \"tags\") {\n                const baseKeys = copy[key] ?? [];\n                copy[key] = [...new Set(baseKeys.concat(options[key] ?? []))];\n            }\n            else if (key === \"configurable\") {\n                copy[key] = { ...copy[key], ...options[key] };\n            }\n            else if (key === \"timeout\") {\n                if (copy.timeout === undefined) {\n                    copy.timeout = options.timeout;\n                }\n                else if (options.timeout !== undefined) {\n                    copy.timeout = Math.min(copy.timeout, options.timeout);\n                }\n            }\n            else if (key === \"signal\") {\n                if (copy.signal === undefined) {\n                    copy.signal = options.signal;\n                }\n                else if (options.signal !== undefined) {\n                    if (\"any\" in AbortSignal) {\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        copy.signal = AbortSignal.any([\n                            copy.signal,\n                            options.signal,\n                        ]);\n                    }\n                    else {\n                        copy.signal = options.signal;\n                    }\n                }\n            }\n            else if (key === \"callbacks\") {\n                const baseCallbacks = copy.callbacks;\n                const providedCallbacks = options.callbacks;\n                // callbacks can be either undefined, Array<handler> or manager\n                // so merging two callbacks values has 6 cases\n                if (Array.isArray(providedCallbacks)) {\n                    if (!baseCallbacks) {\n                        copy.callbacks = providedCallbacks;\n                    }\n                    else if (Array.isArray(baseCallbacks)) {\n                        copy.callbacks = baseCallbacks.concat(providedCallbacks);\n                    }\n                    else {\n                        // baseCallbacks is a manager\n                        const manager = baseCallbacks.copy();\n                        for (const callback of providedCallbacks) {\n                            manager.addHandler((0, manager_js_1.ensureHandler)(callback), true);\n                        }\n                        copy.callbacks = manager;\n                    }\n                }\n                else if (providedCallbacks) {\n                    // providedCallbacks is a manager\n                    if (!baseCallbacks) {\n                        copy.callbacks = providedCallbacks;\n                    }\n                    else if (Array.isArray(baseCallbacks)) {\n                        const manager = providedCallbacks.copy();\n                        for (const callback of baseCallbacks) {\n                            manager.addHandler((0, manager_js_1.ensureHandler)(callback), true);\n                        }\n                        copy.callbacks = manager;\n                    }\n                    else {\n                        // baseCallbacks is also a manager\n                        copy.callbacks = new manager_js_1.CallbackManager(providedCallbacks._parentRunId, {\n                            handlers: baseCallbacks.handlers.concat(providedCallbacks.handlers),\n                            inheritableHandlers: baseCallbacks.inheritableHandlers.concat(providedCallbacks.inheritableHandlers),\n                            tags: Array.from(new Set(baseCallbacks.tags.concat(providedCallbacks.tags))),\n                            inheritableTags: Array.from(new Set(baseCallbacks.inheritableTags.concat(providedCallbacks.inheritableTags))),\n                            metadata: {\n                                ...baseCallbacks.metadata,\n                                ...providedCallbacks.metadata,\n                            },\n                        });\n                    }\n                }\n            }\n            else {\n                const typedKey = key;\n                copy[typedKey] = options[typedKey] ?? copy[typedKey];\n            }\n        }\n    }\n    return copy;\n}\nconst PRIMITIVES = new Set([\"string\", \"number\", \"boolean\"]);\n/**\n * Ensure that a passed config is an object with all required keys present.\n */\nfunction ensureConfig(config) {\n    const implicitConfig = index_js_1.AsyncLocalStorageProviderSingleton.getRunnableConfig();\n    let empty = {\n        tags: [],\n        metadata: {},\n        recursionLimit: 25,\n        runId: undefined,\n    };\n    if (implicitConfig) {\n        // Don't allow runId and runName to be loaded implicitly, as this can cause\n        // child runs to improperly inherit their parents' run ids.\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { runId, runName, ...rest } = implicitConfig;\n        empty = Object.entries(rest).reduce(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (currentConfig, [key, value]) => {\n            if (value !== undefined) {\n                // eslint-disable-next-line no-param-reassign\n                currentConfig[key] = value;\n            }\n            return currentConfig;\n        }, empty);\n    }\n    if (config) {\n        empty = Object.entries(config).reduce(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (currentConfig, [key, value]) => {\n            if (value !== undefined) {\n                // eslint-disable-next-line no-param-reassign\n                currentConfig[key] = value;\n            }\n            return currentConfig;\n        }, empty);\n    }\n    if (empty?.configurable) {\n        for (const key of Object.keys(empty.configurable)) {\n            if (PRIMITIVES.has(typeof empty.configurable[key]) &&\n                !empty.metadata?.[key]) {\n                if (!empty.metadata) {\n                    empty.metadata = {};\n                }\n                empty.metadata[key] = empty.configurable[key];\n            }\n        }\n    }\n    if (empty.timeout !== undefined) {\n        if (empty.timeout <= 0) {\n            throw new Error(\"Timeout must be a positive number\");\n        }\n        const timeoutSignal = AbortSignal.timeout(empty.timeout);\n        if (empty.signal !== undefined) {\n            if (\"any\" in AbortSignal) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                empty.signal = AbortSignal.any([empty.signal, timeoutSignal]);\n            }\n        }\n        else {\n            empty.signal = timeoutSignal;\n        }\n        delete empty.timeout;\n    }\n    return empty;\n}\n/**\n * Helper function that patches runnable configs with updated properties.\n */\nfunction patchConfig(config = {}, { callbacks, maxConcurrency, recursionLimit, runName, configurable, runId, } = {}) {\n    const newConfig = ensureConfig(config);\n    if (callbacks !== undefined) {\n        /**\n         * If we're replacing callbacks we need to unset runName\n         * since that should apply only to the same run as the original callbacks\n         */\n        delete newConfig.runName;\n        newConfig.callbacks = callbacks;\n    }\n    if (recursionLimit !== undefined) {\n        newConfig.recursionLimit = recursionLimit;\n    }\n    if (maxConcurrency !== undefined) {\n        newConfig.maxConcurrency = maxConcurrency;\n    }\n    if (runName !== undefined) {\n        newConfig.runName = runName;\n    }\n    if (configurable !== undefined) {\n        newConfig.configurable = { ...newConfig.configurable, ...configurable };\n    }\n    if (runId !== undefined) {\n        delete newConfig.runId;\n    }\n    return newConfig;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction pickRunnableConfigKeys(config) {\n    return config\n        ? {\n            configurable: config.configurable,\n            recursionLimit: config.recursionLimit,\n            callbacks: config.callbacks,\n            tags: config.tags,\n            metadata: config.metadata,\n            maxConcurrency: config.maxConcurrency,\n            timeout: config.timeout,\n            signal: config.signal,\n        }\n        : undefined;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2NvbmZpZy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsK0JBQStCO0FBQy9CLG1DQUFtQztBQUNuQyxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQiw4QkFBOEI7QUFDOUIscUJBQXFCLG1CQUFPLENBQUMsaUdBQTBCO0FBQ3ZELG1CQUFtQixtQkFBTyxDQUFDLCtGQUF5QjtBQUNwRCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLElBQUksMkVBQTJFLElBQUk7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2NvbmZpZy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRFRkFVTFRfUkVDVVJTSU9OX0xJTUlUID0gdm9pZCAwO1xuZXhwb3J0cy5nZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcgPSBnZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWc7XG5leHBvcnRzLm1lcmdlQ29uZmlncyA9IG1lcmdlQ29uZmlncztcbmV4cG9ydHMuZW5zdXJlQ29uZmlnID0gZW5zdXJlQ29uZmlnO1xuZXhwb3J0cy5wYXRjaENvbmZpZyA9IHBhdGNoQ29uZmlnO1xuZXhwb3J0cy5waWNrUnVubmFibGVDb25maWdLZXlzID0gcGlja1J1bm5hYmxlQ29uZmlnS2V5cztcbmNvbnN0IG1hbmFnZXJfanNfMSA9IHJlcXVpcmUoXCIuLi9jYWxsYmFja3MvbWFuYWdlci5janNcIik7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3NpbmdsZXRvbnMvaW5kZXguY2pzXCIpO1xuZXhwb3J0cy5ERUZBVUxUX1JFQ1VSU0lPTl9MSU1JVCA9IDI1O1xuYXN5bmMgZnVuY3Rpb24gZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKGNvbmZpZykge1xuICAgIHJldHVybiBtYW5hZ2VyX2pzXzEuQ2FsbGJhY2tNYW5hZ2VyLl9jb25maWd1cmVTeW5jKGNvbmZpZz8uY2FsbGJhY2tzLCB1bmRlZmluZWQsIGNvbmZpZz8udGFncywgdW5kZWZpbmVkLCBjb25maWc/Lm1ldGFkYXRhKTtcbn1cbmZ1bmN0aW9uIG1lcmdlQ29uZmlncyguLi5jb25maWdzKSB7XG4gICAgLy8gV2UgZG8gbm90IHdhbnQgdG8gY2FsbCBlbnN1cmVDb25maWcgb24gdGhlIGVtcHR5IHN0YXRlIGhlcmUgYXMgdGhpcyBtYXkgY2F1c2VcbiAgICAvLyBkb3VibGUgbG9hZGluZyBvZiBjYWxsYmFja3MgaWYgYXN5bmMgbG9jYWwgc3RvcmFnZSBpcyBiZWluZyB1c2VkLlxuICAgIGNvbnN0IGNvcHkgPSB7fTtcbiAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2YgY29uZmlncy5maWx0ZXIoKGMpID0+ICEhYykpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob3B0aW9ucykpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwibWV0YWRhdGFcIikge1xuICAgICAgICAgICAgICAgIGNvcHlba2V5XSA9IHsgLi4uY29weVtrZXldLCAuLi5vcHRpb25zW2tleV0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJ0YWdzXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlS2V5cyA9IGNvcHlba2V5XSA/PyBbXTtcbiAgICAgICAgICAgICAgICBjb3B5W2tleV0gPSBbLi4ubmV3IFNldChiYXNlS2V5cy5jb25jYXQob3B0aW9uc1trZXldID8/IFtdKSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcImNvbmZpZ3VyYWJsZVwiKSB7XG4gICAgICAgICAgICAgICAgY29weVtrZXldID0geyAuLi5jb3B5W2tleV0sIC4uLm9wdGlvbnNba2V5XSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcInRpbWVvdXRcIikge1xuICAgICAgICAgICAgICAgIGlmIChjb3B5LnRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb3B5LnRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMudGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcHkudGltZW91dCA9IE1hdGgubWluKGNvcHkudGltZW91dCwgb3B0aW9ucy50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwic2lnbmFsXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29weS5zaWduYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb3B5LnNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLnNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImFueVwiIGluIEFib3J0U2lnbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgY29weS5zaWduYWwgPSBBYm9ydFNpZ25hbC5hbnkoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkuc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5LnNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcImNhbGxiYWNrc1wiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZUNhbGxiYWNrcyA9IGNvcHkuY2FsbGJhY2tzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVkQ2FsbGJhY2tzID0gb3B0aW9ucy5jYWxsYmFja3M7XG4gICAgICAgICAgICAgICAgLy8gY2FsbGJhY2tzIGNhbiBiZSBlaXRoZXIgdW5kZWZpbmVkLCBBcnJheTxoYW5kbGVyPiBvciBtYW5hZ2VyXG4gICAgICAgICAgICAgICAgLy8gc28gbWVyZ2luZyB0d28gY2FsbGJhY2tzIHZhbHVlcyBoYXMgNiBjYXNlc1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3ZpZGVkQ2FsbGJhY2tzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJhc2VDYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkuY2FsbGJhY2tzID0gcHJvdmlkZWRDYWxsYmFja3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShiYXNlQ2FsbGJhY2tzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weS5jYWxsYmFja3MgPSBiYXNlQ2FsbGJhY2tzLmNvbmNhdChwcm92aWRlZENhbGxiYWNrcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiYXNlQ2FsbGJhY2tzIGlzIGEgbWFuYWdlclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFuYWdlciA9IGJhc2VDYWxsYmFja3MuY29weSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBwcm92aWRlZENhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hbmFnZXIuYWRkSGFuZGxlcigoMCwgbWFuYWdlcl9qc18xLmVuc3VyZUhhbmRsZXIpKGNhbGxiYWNrKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5LmNhbGxiYWNrcyA9IG1hbmFnZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZWRDYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvdmlkZWRDYWxsYmFja3MgaXMgYSBtYW5hZ2VyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYmFzZUNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weS5jYWxsYmFja3MgPSBwcm92aWRlZENhbGxiYWNrcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJhc2VDYWxsYmFja3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYW5hZ2VyID0gcHJvdmlkZWRDYWxsYmFja3MuY29weSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBiYXNlQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFuYWdlci5hZGRIYW5kbGVyKCgwLCBtYW5hZ2VyX2pzXzEuZW5zdXJlSGFuZGxlcikoY2FsbGJhY2spLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkuY2FsbGJhY2tzID0gbWFuYWdlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhc2VDYWxsYmFja3MgaXMgYWxzbyBhIG1hbmFnZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkuY2FsbGJhY2tzID0gbmV3IG1hbmFnZXJfanNfMS5DYWxsYmFja01hbmFnZXIocHJvdmlkZWRDYWxsYmFja3MuX3BhcmVudFJ1bklkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnM6IGJhc2VDYWxsYmFja3MuaGFuZGxlcnMuY29uY2F0KHByb3ZpZGVkQ2FsbGJhY2tzLmhhbmRsZXJzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmhlcml0YWJsZUhhbmRsZXJzOiBiYXNlQ2FsbGJhY2tzLmluaGVyaXRhYmxlSGFuZGxlcnMuY29uY2F0KHByb3ZpZGVkQ2FsbGJhY2tzLmluaGVyaXRhYmxlSGFuZGxlcnMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3M6IEFycmF5LmZyb20obmV3IFNldChiYXNlQ2FsbGJhY2tzLnRhZ3MuY29uY2F0KHByb3ZpZGVkQ2FsbGJhY2tzLnRhZ3MpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5oZXJpdGFibGVUYWdzOiBBcnJheS5mcm9tKG5ldyBTZXQoYmFzZUNhbGxiYWNrcy5pbmhlcml0YWJsZVRhZ3MuY29uY2F0KHByb3ZpZGVkQ2FsbGJhY2tzLmluaGVyaXRhYmxlVGFncykpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5iYXNlQ2FsbGJhY2tzLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5wcm92aWRlZENhbGxiYWNrcy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZEtleSA9IGtleTtcbiAgICAgICAgICAgICAgICBjb3B5W3R5cGVkS2V5XSA9IG9wdGlvbnNbdHlwZWRLZXldID8/IGNvcHlbdHlwZWRLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xufVxuY29uc3QgUFJJTUlUSVZFUyA9IG5ldyBTZXQoW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiYm9vbGVhblwiXSk7XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgcGFzc2VkIGNvbmZpZyBpcyBhbiBvYmplY3Qgd2l0aCBhbGwgcmVxdWlyZWQga2V5cyBwcmVzZW50LlxuICovXG5mdW5jdGlvbiBlbnN1cmVDb25maWcoY29uZmlnKSB7XG4gICAgY29uc3QgaW1wbGljaXRDb25maWcgPSBpbmRleF9qc18xLkFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24uZ2V0UnVubmFibGVDb25maWcoKTtcbiAgICBsZXQgZW1wdHkgPSB7XG4gICAgICAgIHRhZ3M6IFtdLFxuICAgICAgICBtZXRhZGF0YToge30sXG4gICAgICAgIHJlY3Vyc2lvbkxpbWl0OiAyNSxcbiAgICAgICAgcnVuSWQ6IHVuZGVmaW5lZCxcbiAgICB9O1xuICAgIGlmIChpbXBsaWNpdENvbmZpZykge1xuICAgICAgICAvLyBEb24ndCBhbGxvdyBydW5JZCBhbmQgcnVuTmFtZSB0byBiZSBsb2FkZWQgaW1wbGljaXRseSwgYXMgdGhpcyBjYW4gY2F1c2VcbiAgICAgICAgLy8gY2hpbGQgcnVucyB0byBpbXByb3Blcmx5IGluaGVyaXQgdGhlaXIgcGFyZW50cycgcnVuIGlkcy5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICBjb25zdCB7IHJ1bklkLCBydW5OYW1lLCAuLi5yZXN0IH0gPSBpbXBsaWNpdENvbmZpZztcbiAgICAgICAgZW1wdHkgPSBPYmplY3QuZW50cmllcyhyZXN0KS5yZWR1Y2UoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIChjdXJyZW50Q29uZmlnLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgY3VycmVudENvbmZpZ1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudENvbmZpZztcbiAgICAgICAgfSwgZW1wdHkpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgIGVtcHR5ID0gT2JqZWN0LmVudHJpZXMoY29uZmlnKS5yZWR1Y2UoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIChjdXJyZW50Q29uZmlnLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgY3VycmVudENvbmZpZ1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudENvbmZpZztcbiAgICAgICAgfSwgZW1wdHkpO1xuICAgIH1cbiAgICBpZiAoZW1wdHk/LmNvbmZpZ3VyYWJsZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhlbXB0eS5jb25maWd1cmFibGUpKSB7XG4gICAgICAgICAgICBpZiAoUFJJTUlUSVZFUy5oYXModHlwZW9mIGVtcHR5LmNvbmZpZ3VyYWJsZVtrZXldKSAmJlxuICAgICAgICAgICAgICAgICFlbXB0eS5tZXRhZGF0YT8uW2tleV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVtcHR5Lm1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtcHR5Lm1ldGFkYXRhID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVtcHR5Lm1ldGFkYXRhW2tleV0gPSBlbXB0eS5jb25maWd1cmFibGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW1wdHkudGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChlbXB0eS50aW1lb3V0IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRpbWVvdXQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lb3V0U2lnbmFsID0gQWJvcnRTaWduYWwudGltZW91dChlbXB0eS50aW1lb3V0KTtcbiAgICAgICAgaWYgKGVtcHR5LnNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoXCJhbnlcIiBpbiBBYm9ydFNpZ25hbCkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgZW1wdHkuc2lnbmFsID0gQWJvcnRTaWduYWwuYW55KFtlbXB0eS5zaWduYWwsIHRpbWVvdXRTaWduYWxdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVtcHR5LnNpZ25hbCA9IHRpbWVvdXRTaWduYWw7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGVtcHR5LnRpbWVvdXQ7XG4gICAgfVxuICAgIHJldHVybiBlbXB0eTtcbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgcGF0Y2hlcyBydW5uYWJsZSBjb25maWdzIHdpdGggdXBkYXRlZCBwcm9wZXJ0aWVzLlxuICovXG5mdW5jdGlvbiBwYXRjaENvbmZpZyhjb25maWcgPSB7fSwgeyBjYWxsYmFja3MsIG1heENvbmN1cnJlbmN5LCByZWN1cnNpb25MaW1pdCwgcnVuTmFtZSwgY29uZmlndXJhYmxlLCBydW5JZCwgfSA9IHt9KSB7XG4gICAgY29uc3QgbmV3Q29uZmlnID0gZW5zdXJlQ29uZmlnKGNvbmZpZyk7XG4gICAgaWYgKGNhbGxiYWNrcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSdyZSByZXBsYWNpbmcgY2FsbGJhY2tzIHdlIG5lZWQgdG8gdW5zZXQgcnVuTmFtZVxuICAgICAgICAgKiBzaW5jZSB0aGF0IHNob3VsZCBhcHBseSBvbmx5IHRvIHRoZSBzYW1lIHJ1biBhcyB0aGUgb3JpZ2luYWwgY2FsbGJhY2tzXG4gICAgICAgICAqL1xuICAgICAgICBkZWxldGUgbmV3Q29uZmlnLnJ1bk5hbWU7XG4gICAgICAgIG5ld0NvbmZpZy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgfVxuICAgIGlmIChyZWN1cnNpb25MaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld0NvbmZpZy5yZWN1cnNpb25MaW1pdCA9IHJlY3Vyc2lvbkxpbWl0O1xuICAgIH1cbiAgICBpZiAobWF4Q29uY3VycmVuY3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdDb25maWcubWF4Q29uY3VycmVuY3kgPSBtYXhDb25jdXJyZW5jeTtcbiAgICB9XG4gICAgaWYgKHJ1bk5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdDb25maWcucnVuTmFtZSA9IHJ1bk5hbWU7XG4gICAgfVxuICAgIGlmIChjb25maWd1cmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdDb25maWcuY29uZmlndXJhYmxlID0geyAuLi5uZXdDb25maWcuY29uZmlndXJhYmxlLCAuLi5jb25maWd1cmFibGUgfTtcbiAgICB9XG4gICAgaWYgKHJ1bklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsZXRlIG5ld0NvbmZpZy5ydW5JZDtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0NvbmZpZztcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBwaWNrUnVubmFibGVDb25maWdLZXlzKGNvbmZpZykge1xuICAgIHJldHVybiBjb25maWdcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGNvbmZpZy5jb25maWd1cmFibGUsXG4gICAgICAgICAgICByZWN1cnNpb25MaW1pdDogY29uZmlnLnJlY3Vyc2lvbkxpbWl0LFxuICAgICAgICAgICAgY2FsbGJhY2tzOiBjb25maWcuY2FsbGJhY2tzLFxuICAgICAgICAgICAgdGFnczogY29uZmlnLnRhZ3MsXG4gICAgICAgICAgICBtZXRhZGF0YTogY29uZmlnLm1ldGFkYXRhLFxuICAgICAgICAgICAgbWF4Q29uY3VycmVuY3k6IGNvbmZpZy5tYXhDb25jdXJyZW5jeSxcbiAgICAgICAgICAgIHRpbWVvdXQ6IGNvbmZpZy50aW1lb3V0LFxuICAgICAgICAgICAgc2lnbmFsOiBjb25maWcuc2lnbmFsLFxuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/graph.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/graph.cjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Graph = void 0;\nconst uuid_1 = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/index.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/utils.cjs\");\nconst graph_mermaid_js_1 = __webpack_require__(/*! ./graph_mermaid.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/graph_mermaid.cjs\");\nconst json_schema_js_1 = __webpack_require__(/*! ../utils/json_schema.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_schema.cjs\");\nfunction nodeDataStr(id, data) {\n    if (id !== undefined && !(0, uuid_1.validate)(id)) {\n        return id;\n    }\n    else if ((0, utils_js_1.isRunnableInterface)(data)) {\n        try {\n            let dataStr = data.getName();\n            dataStr = dataStr.startsWith(\"Runnable\")\n                ? dataStr.slice(\"Runnable\".length)\n                : dataStr;\n            return dataStr;\n        }\n        catch (error) {\n            return data.getName();\n        }\n    }\n    else {\n        return data.name ?? \"UnknownSchema\";\n    }\n}\nfunction nodeDataJson(node) {\n    // if node.data implements Runnable\n    if ((0, utils_js_1.isRunnableInterface)(node.data)) {\n        return {\n            type: \"runnable\",\n            data: {\n                id: node.data.lc_id,\n                name: node.data.getName(),\n            },\n        };\n    }\n    else {\n        return {\n            type: \"schema\",\n            data: { ...(0, json_schema_js_1.toJsonSchema)(node.data.schema), title: node.data.name },\n        };\n    }\n}\nclass Graph {\n    constructor(params) {\n        Object.defineProperty(this, \"nodes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"edges\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        this.nodes = params?.nodes ?? this.nodes;\n        this.edges = params?.edges ?? this.edges;\n    }\n    // Convert the graph to a JSON-serializable format.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    toJSON() {\n        const stableNodeIds = {};\n        Object.values(this.nodes).forEach((node, i) => {\n            stableNodeIds[node.id] = (0, uuid_1.validate)(node.id) ? i : node.id;\n        });\n        return {\n            nodes: Object.values(this.nodes).map((node) => ({\n                id: stableNodeIds[node.id],\n                ...nodeDataJson(node),\n            })),\n            edges: this.edges.map((edge) => {\n                const item = {\n                    source: stableNodeIds[edge.source],\n                    target: stableNodeIds[edge.target],\n                };\n                if (typeof edge.data !== \"undefined\") {\n                    item.data = edge.data;\n                }\n                if (typeof edge.conditional !== \"undefined\") {\n                    item.conditional = edge.conditional;\n                }\n                return item;\n            }),\n        };\n    }\n    addNode(data, id, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    metadata) {\n        if (id !== undefined && this.nodes[id] !== undefined) {\n            throw new Error(`Node with id ${id} already exists`);\n        }\n        const nodeId = id ?? (0, uuid_1.v4)();\n        const node = {\n            id: nodeId,\n            data,\n            name: nodeDataStr(id, data),\n            metadata,\n        };\n        this.nodes[nodeId] = node;\n        return node;\n    }\n    removeNode(node) {\n        // Remove the node from the nodes map\n        delete this.nodes[node.id];\n        // Filter out edges connected to the node\n        this.edges = this.edges.filter((edge) => edge.source !== node.id && edge.target !== node.id);\n    }\n    addEdge(source, target, data, conditional) {\n        if (this.nodes[source.id] === undefined) {\n            throw new Error(`Source node ${source.id} not in graph`);\n        }\n        if (this.nodes[target.id] === undefined) {\n            throw new Error(`Target node ${target.id} not in graph`);\n        }\n        const edge = {\n            source: source.id,\n            target: target.id,\n            data,\n            conditional,\n        };\n        this.edges.push(edge);\n        return edge;\n    }\n    firstNode() {\n        return _firstNode(this);\n    }\n    lastNode() {\n        return _lastNode(this);\n    }\n    /**\n     * Add all nodes and edges from another graph.\n     * Note this doesn't check for duplicates, nor does it connect the graphs.\n     */\n    extend(graph, prefix = \"\") {\n        let finalPrefix = prefix;\n        const nodeIds = Object.values(graph.nodes).map((node) => node.id);\n        if (nodeIds.every(uuid_1.validate)) {\n            finalPrefix = \"\";\n        }\n        const prefixed = (id) => {\n            return finalPrefix ? `${finalPrefix}:${id}` : id;\n        };\n        Object.entries(graph.nodes).forEach(([key, value]) => {\n            this.nodes[prefixed(key)] = { ...value, id: prefixed(key) };\n        });\n        const newEdges = graph.edges.map((edge) => {\n            return {\n                ...edge,\n                source: prefixed(edge.source),\n                target: prefixed(edge.target),\n            };\n        });\n        // Add all edges from the other graph\n        this.edges = [...this.edges, ...newEdges];\n        const first = graph.firstNode();\n        const last = graph.lastNode();\n        return [\n            first ? { id: prefixed(first.id), data: first.data } : undefined,\n            last ? { id: prefixed(last.id), data: last.data } : undefined,\n        ];\n    }\n    trimFirstNode() {\n        const firstNode = this.firstNode();\n        if (firstNode && _firstNode(this, [firstNode.id])) {\n            this.removeNode(firstNode);\n        }\n    }\n    trimLastNode() {\n        const lastNode = this.lastNode();\n        if (lastNode && _lastNode(this, [lastNode.id])) {\n            this.removeNode(lastNode);\n        }\n    }\n    /**\n     * Return a new graph with all nodes re-identified,\n     * using their unique, readable names where possible.\n     */\n    reid() {\n        const nodeLabels = Object.fromEntries(Object.values(this.nodes).map((node) => [node.id, node.name]));\n        const nodeLabelCounts = new Map();\n        Object.values(nodeLabels).forEach((label) => {\n            nodeLabelCounts.set(label, (nodeLabelCounts.get(label) || 0) + 1);\n        });\n        const getNodeId = (nodeId) => {\n            const label = nodeLabels[nodeId];\n            if ((0, uuid_1.validate)(nodeId) && nodeLabelCounts.get(label) === 1) {\n                return label;\n            }\n            else {\n                return nodeId;\n            }\n        };\n        return new Graph({\n            nodes: Object.fromEntries(Object.entries(this.nodes).map(([id, node]) => [\n                getNodeId(id),\n                { ...node, id: getNodeId(id) },\n            ])),\n            edges: this.edges.map((edge) => ({\n                ...edge,\n                source: getNodeId(edge.source),\n                target: getNodeId(edge.target),\n            })),\n        });\n    }\n    drawMermaid(params) {\n        const { withStyles, curveStyle, nodeColors = {\n            default: \"fill:#f2f0ff,line-height:1.2\",\n            first: \"fill-opacity:0\",\n            last: \"fill:#bfb6fc\",\n        }, wrapLabelNWords, } = params ?? {};\n        const graph = this.reid();\n        const firstNode = graph.firstNode();\n        const lastNode = graph.lastNode();\n        return (0, graph_mermaid_js_1.drawMermaid)(graph.nodes, graph.edges, {\n            firstNode: firstNode?.id,\n            lastNode: lastNode?.id,\n            withStyles,\n            curveStyle,\n            nodeColors,\n            wrapLabelNWords,\n        });\n    }\n    async drawMermaidPng(params) {\n        const mermaidSyntax = this.drawMermaid(params);\n        return (0, graph_mermaid_js_1.drawMermaidPng)(mermaidSyntax, {\n            backgroundColor: params?.backgroundColor,\n        });\n    }\n}\nexports.Graph = Graph;\n/**\n * Find the single node that is not a target of any edge.\n * Exclude nodes/sources with ids in the exclude list.\n * If there is no such node, or there are multiple, return undefined.\n * When drawing the graph, this node would be the origin.\n */\nfunction _firstNode(graph, exclude = []) {\n    const targets = new Set(graph.edges\n        .filter((edge) => !exclude.includes(edge.source))\n        .map((edge) => edge.target));\n    const found = [];\n    for (const node of Object.values(graph.nodes)) {\n        if (!exclude.includes(node.id) && !targets.has(node.id)) {\n            found.push(node);\n        }\n    }\n    return found.length === 1 ? found[0] : undefined;\n}\n/**\n * Find the single node that is not a source of any edge.\n * Exclude nodes/targets with ids in the exclude list.\n * If there is no such node, or there are multiple, return undefined.\n * When drawing the graph, this node would be the destination.\n */\nfunction _lastNode(graph, exclude = []) {\n    const sources = new Set(graph.edges\n        .filter((edge) => !exclude.includes(edge.target))\n        .map((edge) => edge.source));\n    const found = [];\n    for (const node of Object.values(graph.nodes)) {\n        if (!exclude.includes(node.id) && !sources.has(node.id)) {\n            found.push(node);\n        }\n    }\n    return found.length === 1 ? found[0] : undefined;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2dyYXBoLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhO0FBQ2IsZUFBZSxtQkFBTyxDQUFDLDJGQUFNO0FBQzdCLG1CQUFtQixtQkFBTyxDQUFDLGtGQUFhO0FBQ3hDLDJCQUEyQixtQkFBTyxDQUFDLGtHQUFxQjtBQUN4RCx5QkFBeUIsbUJBQU8sQ0FBQyxpR0FBMEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnRkFBZ0Y7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxJQUFJO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZLEdBQUcsR0FBRztBQUN0RDtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQ0FBMkM7QUFDakUscUJBQXFCLHlDQUF5QztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0QkFBNEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFCQUFxQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2dyYXBoLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR3JhcGggPSB2b2lkIDA7XG5jb25zdCB1dWlkXzEgPSByZXF1aXJlKFwidXVpZFwiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5janNcIik7XG5jb25zdCBncmFwaF9tZXJtYWlkX2pzXzEgPSByZXF1aXJlKFwiLi9ncmFwaF9tZXJtYWlkLmNqc1wiKTtcbmNvbnN0IGpzb25fc2NoZW1hX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvanNvbl9zY2hlbWEuY2pzXCIpO1xuZnVuY3Rpb24gbm9kZURhdGFTdHIoaWQsIGRhdGEpIHtcbiAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCAmJiAhKDAsIHV1aWRfMS52YWxpZGF0ZSkoaWQpKSB7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIHV0aWxzX2pzXzEuaXNSdW5uYWJsZUludGVyZmFjZSkoZGF0YSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBkYXRhU3RyID0gZGF0YS5nZXROYW1lKCk7XG4gICAgICAgICAgICBkYXRhU3RyID0gZGF0YVN0ci5zdGFydHNXaXRoKFwiUnVubmFibGVcIilcbiAgICAgICAgICAgICAgICA/IGRhdGFTdHIuc2xpY2UoXCJSdW5uYWJsZVwiLmxlbmd0aClcbiAgICAgICAgICAgICAgICA6IGRhdGFTdHI7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVN0cjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmdldE5hbWUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRhdGEubmFtZSA/PyBcIlVua25vd25TY2hlbWFcIjtcbiAgICB9XG59XG5mdW5jdGlvbiBub2RlRGF0YUpzb24obm9kZSkge1xuICAgIC8vIGlmIG5vZGUuZGF0YSBpbXBsZW1lbnRzIFJ1bm5hYmxlXG4gICAgaWYgKCgwLCB1dGlsc19qc18xLmlzUnVubmFibGVJbnRlcmZhY2UpKG5vZGUuZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwicnVubmFibGVcIixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBpZDogbm9kZS5kYXRhLmxjX2lkLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5vZGUuZGF0YS5nZXROYW1lKCksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwic2NoZW1hXCIsXG4gICAgICAgICAgICBkYXRhOiB7IC4uLigwLCBqc29uX3NjaGVtYV9qc18xLnRvSnNvblNjaGVtYSkobm9kZS5kYXRhLnNjaGVtYSksIHRpdGxlOiBub2RlLmRhdGEubmFtZSB9LFxuICAgICAgICB9O1xuICAgIH1cbn1cbmNsYXNzIEdyYXBoIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibm9kZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlZGdlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubm9kZXMgPSBwYXJhbXM/Lm5vZGVzID8/IHRoaXMubm9kZXM7XG4gICAgICAgIHRoaXMuZWRnZXMgPSBwYXJhbXM/LmVkZ2VzID8/IHRoaXMuZWRnZXM7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgdGhlIGdyYXBoIHRvIGEgSlNPTi1zZXJpYWxpemFibGUgZm9ybWF0LlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBzdGFibGVOb2RlSWRzID0ge307XG4gICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5ub2RlcykuZm9yRWFjaCgobm9kZSwgaSkgPT4ge1xuICAgICAgICAgICAgc3RhYmxlTm9kZUlkc1tub2RlLmlkXSA9ICgwLCB1dWlkXzEudmFsaWRhdGUpKG5vZGUuaWQpID8gaSA6IG5vZGUuaWQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm9kZXM6IE9iamVjdC52YWx1ZXModGhpcy5ub2RlcykubWFwKChub2RlKSA9PiAoe1xuICAgICAgICAgICAgICAgIGlkOiBzdGFibGVOb2RlSWRzW25vZGUuaWRdLFxuICAgICAgICAgICAgICAgIC4uLm5vZGVEYXRhSnNvbihub2RlKSxcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIGVkZ2VzOiB0aGlzLmVkZ2VzLm1hcCgoZWRnZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc3RhYmxlTm9kZUlkc1tlZGdlLnNvdXJjZV0sXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogc3RhYmxlTm9kZUlkc1tlZGdlLnRhcmdldF0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVkZ2UuZGF0YSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmRhdGEgPSBlZGdlLmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZWRnZS5jb25kaXRpb25hbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmNvbmRpdGlvbmFsID0gZWRnZS5jb25kaXRpb25hbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYWRkTm9kZShkYXRhLCBpZCwgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBtZXRhZGF0YSkge1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm5vZGVzW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vZGUgd2l0aCBpZCAke2lkfSBhbHJlYWR5IGV4aXN0c2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGVJZCA9IGlkID8/ICgwLCB1dWlkXzEudjQpKCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgICAgICBpZDogbm9kZUlkLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIG5hbWU6IG5vZGVEYXRhU3RyKGlkLCBkYXRhKSxcbiAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5vZGVzW25vZGVJZF0gPSBub2RlO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgcmVtb3ZlTm9kZShub2RlKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbm9kZSBmcm9tIHRoZSBub2RlcyBtYXBcbiAgICAgICAgZGVsZXRlIHRoaXMubm9kZXNbbm9kZS5pZF07XG4gICAgICAgIC8vIEZpbHRlciBvdXQgZWRnZXMgY29ubmVjdGVkIHRvIHRoZSBub2RlXG4gICAgICAgIHRoaXMuZWRnZXMgPSB0aGlzLmVkZ2VzLmZpbHRlcigoZWRnZSkgPT4gZWRnZS5zb3VyY2UgIT09IG5vZGUuaWQgJiYgZWRnZS50YXJnZXQgIT09IG5vZGUuaWQpO1xuICAgIH1cbiAgICBhZGRFZGdlKHNvdXJjZSwgdGFyZ2V0LCBkYXRhLCBjb25kaXRpb25hbCkge1xuICAgICAgICBpZiAodGhpcy5ub2Rlc1tzb3VyY2UuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU291cmNlIG5vZGUgJHtzb3VyY2UuaWR9IG5vdCBpbiBncmFwaGApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5vZGVzW3RhcmdldC5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYXJnZXQgbm9kZSAke3RhcmdldC5pZH0gbm90IGluIGdyYXBoYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWRnZSA9IHtcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLmlkLFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQuaWQsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgY29uZGl0aW9uYWwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZWRnZXMucHVzaChlZGdlKTtcbiAgICAgICAgcmV0dXJuIGVkZ2U7XG4gICAgfVxuICAgIGZpcnN0Tm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIF9maXJzdE5vZGUodGhpcyk7XG4gICAgfVxuICAgIGxhc3ROb2RlKCkge1xuICAgICAgICByZXR1cm4gX2xhc3ROb2RlKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYWxsIG5vZGVzIGFuZCBlZGdlcyBmcm9tIGFub3RoZXIgZ3JhcGguXG4gICAgICogTm90ZSB0aGlzIGRvZXNuJ3QgY2hlY2sgZm9yIGR1cGxpY2F0ZXMsIG5vciBkb2VzIGl0IGNvbm5lY3QgdGhlIGdyYXBocy5cbiAgICAgKi9cbiAgICBleHRlbmQoZ3JhcGgsIHByZWZpeCA9IFwiXCIpIHtcbiAgICAgICAgbGV0IGZpbmFsUHJlZml4ID0gcHJlZml4O1xuICAgICAgICBjb25zdCBub2RlSWRzID0gT2JqZWN0LnZhbHVlcyhncmFwaC5ub2RlcykubWFwKChub2RlKSA9PiBub2RlLmlkKTtcbiAgICAgICAgaWYgKG5vZGVJZHMuZXZlcnkodXVpZF8xLnZhbGlkYXRlKSkge1xuICAgICAgICAgICAgZmluYWxQcmVmaXggPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZWZpeGVkID0gKGlkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZmluYWxQcmVmaXggPyBgJHtmaW5hbFByZWZpeH06JHtpZH1gIDogaWQ7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGdyYXBoLm5vZGVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIHRoaXMubm9kZXNbcHJlZml4ZWQoa2V5KV0gPSB7IC4uLnZhbHVlLCBpZDogcHJlZml4ZWQoa2V5KSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbmV3RWRnZXMgPSBncmFwaC5lZGdlcy5tYXAoKGVkZ2UpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uZWRnZSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHByZWZpeGVkKGVkZ2Uuc291cmNlKSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHByZWZpeGVkKGVkZ2UudGFyZ2V0KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBZGQgYWxsIGVkZ2VzIGZyb20gdGhlIG90aGVyIGdyYXBoXG4gICAgICAgIHRoaXMuZWRnZXMgPSBbLi4udGhpcy5lZGdlcywgLi4ubmV3RWRnZXNdO1xuICAgICAgICBjb25zdCBmaXJzdCA9IGdyYXBoLmZpcnN0Tm9kZSgpO1xuICAgICAgICBjb25zdCBsYXN0ID0gZ3JhcGgubGFzdE5vZGUoKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGZpcnN0ID8geyBpZDogcHJlZml4ZWQoZmlyc3QuaWQpLCBkYXRhOiBmaXJzdC5kYXRhIH0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBsYXN0ID8geyBpZDogcHJlZml4ZWQobGFzdC5pZCksIGRhdGE6IGxhc3QuZGF0YSB9IDogdW5kZWZpbmVkLFxuICAgICAgICBdO1xuICAgIH1cbiAgICB0cmltRmlyc3ROb2RlKCkge1xuICAgICAgICBjb25zdCBmaXJzdE5vZGUgPSB0aGlzLmZpcnN0Tm9kZSgpO1xuICAgICAgICBpZiAoZmlyc3ROb2RlICYmIF9maXJzdE5vZGUodGhpcywgW2ZpcnN0Tm9kZS5pZF0pKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGUoZmlyc3ROb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmltTGFzdE5vZGUoKSB7XG4gICAgICAgIGNvbnN0IGxhc3ROb2RlID0gdGhpcy5sYXN0Tm9kZSgpO1xuICAgICAgICBpZiAobGFzdE5vZGUgJiYgX2xhc3ROb2RlKHRoaXMsIFtsYXN0Tm9kZS5pZF0pKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGUobGFzdE5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBncmFwaCB3aXRoIGFsbCBub2RlcyByZS1pZGVudGlmaWVkLFxuICAgICAqIHVzaW5nIHRoZWlyIHVuaXF1ZSwgcmVhZGFibGUgbmFtZXMgd2hlcmUgcG9zc2libGUuXG4gICAgICovXG4gICAgcmVpZCgpIHtcbiAgICAgICAgY29uc3Qgbm9kZUxhYmVscyA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QudmFsdWVzKHRoaXMubm9kZXMpLm1hcCgobm9kZSkgPT4gW25vZGUuaWQsIG5vZGUubmFtZV0pKTtcbiAgICAgICAgY29uc3Qgbm9kZUxhYmVsQ291bnRzID0gbmV3IE1hcCgpO1xuICAgICAgICBPYmplY3QudmFsdWVzKG5vZGVMYWJlbHMpLmZvckVhY2goKGxhYmVsKSA9PiB7XG4gICAgICAgICAgICBub2RlTGFiZWxDb3VudHMuc2V0KGxhYmVsLCAobm9kZUxhYmVsQ291bnRzLmdldChsYWJlbCkgfHwgMCkgKyAxKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGdldE5vZGVJZCA9IChub2RlSWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gbm9kZUxhYmVsc1tub2RlSWRdO1xuICAgICAgICAgICAgaWYgKCgwLCB1dWlkXzEudmFsaWRhdGUpKG5vZGVJZCkgJiYgbm9kZUxhYmVsQ291bnRzLmdldChsYWJlbCkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZUlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IEdyYXBoKHtcbiAgICAgICAgICAgIG5vZGVzOiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXModGhpcy5ub2RlcykubWFwKChbaWQsIG5vZGVdKSA9PiBbXG4gICAgICAgICAgICAgICAgZ2V0Tm9kZUlkKGlkKSxcbiAgICAgICAgICAgICAgICB7IC4uLm5vZGUsIGlkOiBnZXROb2RlSWQoaWQpIH0sXG4gICAgICAgICAgICBdKSksXG4gICAgICAgICAgICBlZGdlczogdGhpcy5lZGdlcy5tYXAoKGVkZ2UpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4uZWRnZSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IGdldE5vZGVJZChlZGdlLnNvdXJjZSksXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBnZXROb2RlSWQoZWRnZS50YXJnZXQpLFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZHJhd01lcm1haWQocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHsgd2l0aFN0eWxlcywgY3VydmVTdHlsZSwgbm9kZUNvbG9ycyA9IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IFwiZmlsbDojZjJmMGZmLGxpbmUtaGVpZ2h0OjEuMlwiLFxuICAgICAgICAgICAgZmlyc3Q6IFwiZmlsbC1vcGFjaXR5OjBcIixcbiAgICAgICAgICAgIGxhc3Q6IFwiZmlsbDojYmZiNmZjXCIsXG4gICAgICAgIH0sIHdyYXBMYWJlbE5Xb3JkcywgfSA9IHBhcmFtcyA/PyB7fTtcbiAgICAgICAgY29uc3QgZ3JhcGggPSB0aGlzLnJlaWQoKTtcbiAgICAgICAgY29uc3QgZmlyc3ROb2RlID0gZ3JhcGguZmlyc3ROb2RlKCk7XG4gICAgICAgIGNvbnN0IGxhc3ROb2RlID0gZ3JhcGgubGFzdE5vZGUoKTtcbiAgICAgICAgcmV0dXJuICgwLCBncmFwaF9tZXJtYWlkX2pzXzEuZHJhd01lcm1haWQpKGdyYXBoLm5vZGVzLCBncmFwaC5lZGdlcywge1xuICAgICAgICAgICAgZmlyc3ROb2RlOiBmaXJzdE5vZGU/LmlkLFxuICAgICAgICAgICAgbGFzdE5vZGU6IGxhc3ROb2RlPy5pZCxcbiAgICAgICAgICAgIHdpdGhTdHlsZXMsXG4gICAgICAgICAgICBjdXJ2ZVN0eWxlLFxuICAgICAgICAgICAgbm9kZUNvbG9ycyxcbiAgICAgICAgICAgIHdyYXBMYWJlbE5Xb3JkcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGRyYXdNZXJtYWlkUG5nKHBhcmFtcykge1xuICAgICAgICBjb25zdCBtZXJtYWlkU3ludGF4ID0gdGhpcy5kcmF3TWVybWFpZChwYXJhbXMpO1xuICAgICAgICByZXR1cm4gKDAsIGdyYXBoX21lcm1haWRfanNfMS5kcmF3TWVybWFpZFBuZykobWVybWFpZFN5bnRheCwge1xuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBwYXJhbXM/LmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5HcmFwaCA9IEdyYXBoO1xuLyoqXG4gKiBGaW5kIHRoZSBzaW5nbGUgbm9kZSB0aGF0IGlzIG5vdCBhIHRhcmdldCBvZiBhbnkgZWRnZS5cbiAqIEV4Y2x1ZGUgbm9kZXMvc291cmNlcyB3aXRoIGlkcyBpbiB0aGUgZXhjbHVkZSBsaXN0LlxuICogSWYgdGhlcmUgaXMgbm8gc3VjaCBub2RlLCBvciB0aGVyZSBhcmUgbXVsdGlwbGUsIHJldHVybiB1bmRlZmluZWQuXG4gKiBXaGVuIGRyYXdpbmcgdGhlIGdyYXBoLCB0aGlzIG5vZGUgd291bGQgYmUgdGhlIG9yaWdpbi5cbiAqL1xuZnVuY3Rpb24gX2ZpcnN0Tm9kZShncmFwaCwgZXhjbHVkZSA9IFtdKSB7XG4gICAgY29uc3QgdGFyZ2V0cyA9IG5ldyBTZXQoZ3JhcGguZWRnZXNcbiAgICAgICAgLmZpbHRlcigoZWRnZSkgPT4gIWV4Y2x1ZGUuaW5jbHVkZXMoZWRnZS5zb3VyY2UpKVxuICAgICAgICAubWFwKChlZGdlKSA9PiBlZGdlLnRhcmdldCkpO1xuICAgIGNvbnN0IGZvdW5kID0gW107XG4gICAgZm9yIChjb25zdCBub2RlIG9mIE9iamVjdC52YWx1ZXMoZ3JhcGgubm9kZXMpKSB7XG4gICAgICAgIGlmICghZXhjbHVkZS5pbmNsdWRlcyhub2RlLmlkKSAmJiAhdGFyZ2V0cy5oYXMobm9kZS5pZCkpIHtcbiAgICAgICAgICAgIGZvdW5kLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kLmxlbmd0aCA9PT0gMSA/IGZvdW5kWzBdIDogdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBGaW5kIHRoZSBzaW5nbGUgbm9kZSB0aGF0IGlzIG5vdCBhIHNvdXJjZSBvZiBhbnkgZWRnZS5cbiAqIEV4Y2x1ZGUgbm9kZXMvdGFyZ2V0cyB3aXRoIGlkcyBpbiB0aGUgZXhjbHVkZSBsaXN0LlxuICogSWYgdGhlcmUgaXMgbm8gc3VjaCBub2RlLCBvciB0aGVyZSBhcmUgbXVsdGlwbGUsIHJldHVybiB1bmRlZmluZWQuXG4gKiBXaGVuIGRyYXdpbmcgdGhlIGdyYXBoLCB0aGlzIG5vZGUgd291bGQgYmUgdGhlIGRlc3RpbmF0aW9uLlxuICovXG5mdW5jdGlvbiBfbGFzdE5vZGUoZ3JhcGgsIGV4Y2x1ZGUgPSBbXSkge1xuICAgIGNvbnN0IHNvdXJjZXMgPSBuZXcgU2V0KGdyYXBoLmVkZ2VzXG4gICAgICAgIC5maWx0ZXIoKGVkZ2UpID0+ICFleGNsdWRlLmluY2x1ZGVzKGVkZ2UudGFyZ2V0KSlcbiAgICAgICAgLm1hcCgoZWRnZSkgPT4gZWRnZS5zb3VyY2UpKTtcbiAgICBjb25zdCBmb3VuZCA9IFtdO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBPYmplY3QudmFsdWVzKGdyYXBoLm5vZGVzKSkge1xuICAgICAgICBpZiAoIWV4Y2x1ZGUuaW5jbHVkZXMobm9kZS5pZCkgJiYgIXNvdXJjZXMuaGFzKG5vZGUuaWQpKSB7XG4gICAgICAgICAgICBmb3VuZC5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZC5sZW5ndGggPT09IDEgPyBmb3VuZFswXSA6IHVuZGVmaW5lZDtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/graph.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/graph_mermaid.cjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/graph_mermaid.cjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.drawMermaid = drawMermaid;\nexports.drawMermaidPng = drawMermaidPng;\nexports.drawMermaidImage = drawMermaidImage;\nfunction _escapeNodeLabel(nodeLabel) {\n    // Escapes the node label for Mermaid syntax.\n    return nodeLabel.replace(/[^a-zA-Z-_0-9]/g, \"_\");\n}\nconst MARKDOWN_SPECIAL_CHARS = [\"*\", \"_\", \"`\"];\nfunction _generateMermaidGraphStyles(nodeColors) {\n    let styles = \"\";\n    for (const [className, color] of Object.entries(nodeColors)) {\n        styles += `\\tclassDef ${className} ${color};\\n`;\n    }\n    return styles;\n}\n/**\n * Draws a Mermaid graph using the provided graph data\n */\nfunction drawMermaid(nodes, edges, config) {\n    const { firstNode, lastNode, nodeColors, withStyles = true, curveStyle = \"linear\", wrapLabelNWords = 9, } = config ?? {};\n    // Initialize Mermaid graph configuration\n    let mermaidGraph = withStyles\n        ? `%%{init: {'flowchart': {'curve': '${curveStyle}'}}}%%\\ngraph TD;\\n`\n        : \"graph TD;\\n\";\n    if (withStyles) {\n        // Node formatting templates\n        const defaultClassLabel = \"default\";\n        const formatDict = {\n            [defaultClassLabel]: \"{0}({1})\",\n        };\n        if (firstNode !== undefined) {\n            formatDict[firstNode] = \"{0}([{1}]):::first\";\n        }\n        if (lastNode !== undefined) {\n            formatDict[lastNode] = \"{0}([{1}]):::last\";\n        }\n        // Add nodes to the graph\n        for (const [key, node] of Object.entries(nodes)) {\n            const nodeName = node.name.split(\":\").pop() ?? \"\";\n            const label = MARKDOWN_SPECIAL_CHARS.some((char) => nodeName.startsWith(char) && nodeName.endsWith(char))\n                ? `<p>${nodeName}</p>`\n                : nodeName;\n            let finalLabel = label;\n            if (Object.keys(node.metadata ?? {}).length) {\n                finalLabel += `<hr/><small><em>${Object.entries(node.metadata ?? {})\n                    .map(([k, v]) => `${k} = ${v}`)\n                    .join(\"\\n\")}</em></small>`;\n            }\n            const nodeLabel = (formatDict[key] ?? formatDict[defaultClassLabel])\n                .replace(\"{0}\", _escapeNodeLabel(key))\n                .replace(\"{1}\", finalLabel);\n            mermaidGraph += `\\t${nodeLabel}\\n`;\n        }\n    }\n    // Group edges by their common prefixes\n    const edgeGroups = {};\n    for (const edge of edges) {\n        const srcParts = edge.source.split(\":\");\n        const tgtParts = edge.target.split(\":\");\n        const commonPrefix = srcParts\n            .filter((src, i) => src === tgtParts[i])\n            .join(\":\");\n        if (!edgeGroups[commonPrefix]) {\n            edgeGroups[commonPrefix] = [];\n        }\n        edgeGroups[commonPrefix].push(edge);\n    }\n    const seenSubgraphs = new Set();\n    function addSubgraph(edges, prefix) {\n        const selfLoop = edges.length === 1 && edges[0].source === edges[0].target;\n        if (prefix && !selfLoop) {\n            const subgraph = prefix.split(\":\").pop();\n            if (seenSubgraphs.has(subgraph)) {\n                throw new Error(`Found duplicate subgraph '${subgraph}' -- this likely means that ` +\n                    \"you're reusing a subgraph node with the same name. \" +\n                    \"Please adjust your graph to have subgraph nodes with unique names.\");\n            }\n            seenSubgraphs.add(subgraph);\n            mermaidGraph += `\\tsubgraph ${subgraph}\\n`;\n        }\n        for (const edge of edges) {\n            const { source, target, data, conditional } = edge;\n            let edgeLabel = \"\";\n            if (data !== undefined) {\n                let edgeData = data;\n                const words = edgeData.split(\" \");\n                if (words.length > wrapLabelNWords) {\n                    edgeData = Array.from({ length: Math.ceil(words.length / wrapLabelNWords) }, (_, i) => words\n                        .slice(i * wrapLabelNWords, (i + 1) * wrapLabelNWords)\n                        .join(\" \")).join(\"&nbsp;<br>&nbsp;\");\n                }\n                edgeLabel = conditional\n                    ? ` -. &nbsp;${edgeData}&nbsp; .-> `\n                    : ` -- &nbsp;${edgeData}&nbsp; --> `;\n            }\n            else {\n                edgeLabel = conditional ? \" -.-> \" : \" --> \";\n            }\n            mermaidGraph += `\\t${_escapeNodeLabel(source)}${edgeLabel}${_escapeNodeLabel(target)};\\n`;\n        }\n        // Recursively add nested subgraphs\n        for (const nestedPrefix in edgeGroups) {\n            if (nestedPrefix.startsWith(`${prefix}:`) && nestedPrefix !== prefix) {\n                addSubgraph(edgeGroups[nestedPrefix], nestedPrefix);\n            }\n        }\n        if (prefix && !selfLoop) {\n            mermaidGraph += \"\\tend\\n\";\n        }\n    }\n    // Start with the top-level edges (no common prefix)\n    addSubgraph(edgeGroups[\"\"] ?? [], \"\");\n    // Add remaining subgraphs\n    for (const prefix in edgeGroups) {\n        if (!prefix.includes(\":\") && prefix !== \"\") {\n            addSubgraph(edgeGroups[prefix], prefix);\n        }\n    }\n    // Add custom styles for nodes\n    if (withStyles) {\n        mermaidGraph += _generateMermaidGraphStyles(nodeColors ?? {});\n    }\n    return mermaidGraph;\n}\n/**\n * @deprecated Use `drawMermaidImage` instead.\n */\nasync function drawMermaidPng(mermaidSyntax, config) {\n    return drawMermaidImage(mermaidSyntax, {\n        ...config,\n        imageType: \"png\",\n    });\n}\n/**\n * Renders Mermaid graph using the Mermaid.INK API.\n *\n * @example\n * ```javascript\n * const image = await drawMermaidImage(mermaidSyntax, {\n *   backgroundColor: \"white\",\n *   imageType: \"png\",\n * });\n * fs.writeFileSync(\"image.png\", image);\n * ```\n *\n * @param mermaidSyntax - The Mermaid syntax to render.\n * @param config - The configuration for the image.\n * @returns The image as a Blob.\n */\nasync function drawMermaidImage(mermaidSyntax, config) {\n    let backgroundColor = config?.backgroundColor ?? \"white\";\n    const imageType = config?.imageType ?? \"png\";\n    // Use btoa for compatibility, assume ASCII\n    const mermaidSyntaxEncoded = btoa(mermaidSyntax);\n    // Check if the background color is a hexadecimal color code using regex\n    if (backgroundColor !== undefined) {\n        const hexColorPattern = /^#(?:[0-9a-fA-F]{3}){1,2}$/;\n        if (!hexColorPattern.test(backgroundColor)) {\n            backgroundColor = `!${backgroundColor}`;\n        }\n    }\n    const imageUrl = `https://mermaid.ink/img/${mermaidSyntaxEncoded}?bgColor=${backgroundColor}&type=${imageType}`;\n    const res = await fetch(imageUrl);\n    if (!res.ok) {\n        throw new Error([\n            `Failed to render the graph using the Mermaid.INK API.`,\n            `Status code: ${res.status}`,\n            `Status text: ${res.statusText}`,\n        ].join(\"\\n\"));\n    }\n    const content = await res.blob();\n    return content;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2dyYXBoX21lcm1haWQuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQixzQkFBc0I7QUFDdEIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVyxFQUFFLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtHQUFrRztBQUM5RztBQUNBO0FBQ0EsY0FBYyxPQUFPLGNBQWMsWUFBWSxXQUFXLElBQUksYUFBYTtBQUMzRSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsRUFBRSxFQUFFLEVBQUU7QUFDekM7QUFDQTtBQUNBLHNDQUFzQyxFQUFFLEdBQUcsRUFBRTtBQUM3QztBQUNBO0FBQ0EscUNBQXFDLEVBQUUsR0FBRyxFQUFFO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLGlEQUFpRCxrQ0FBa0M7QUFDbkYsd0NBQXdDLEdBQUcsSUFBSSxFQUFFO0FBQ2pELGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsMkJBQTJCLEVBQUU7QUFDN0IsMkJBQTJCLEVBQUU7QUFDN0IsaUNBQWlDLFVBQVU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFNBQVM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0Esb0JBQW9CLG9DQUFvQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG1EQUFtRDtBQUMvRjtBQUNBLGdEQUFnRCxVQUFVO0FBQzFEO0FBQ0E7QUFDQSxpQ0FBaUMsRUFBRSxTQUFTLE9BQU87QUFDbkQsaUNBQWlDLEVBQUUsU0FBUyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlCQUF5QixFQUFFLFVBQVUsRUFBRSwwQkFBMEI7QUFDbEc7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxFQUFFLEVBQUUsSUFBSTtBQUMxRDtBQUNBLGtDQUFrQyxnQkFBZ0I7QUFDbEQ7QUFDQTtBQUNBLGdEQUFnRCxxQkFBcUIsV0FBVyxnQkFBZ0IsUUFBUSxVQUFVO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkMsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3J1bm5hYmxlcy9ncmFwaF9tZXJtYWlkLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZHJhd01lcm1haWQgPSBkcmF3TWVybWFpZDtcbmV4cG9ydHMuZHJhd01lcm1haWRQbmcgPSBkcmF3TWVybWFpZFBuZztcbmV4cG9ydHMuZHJhd01lcm1haWRJbWFnZSA9IGRyYXdNZXJtYWlkSW1hZ2U7XG5mdW5jdGlvbiBfZXNjYXBlTm9kZUxhYmVsKG5vZGVMYWJlbCkge1xuICAgIC8vIEVzY2FwZXMgdGhlIG5vZGUgbGFiZWwgZm9yIE1lcm1haWQgc3ludGF4LlxuICAgIHJldHVybiBub2RlTGFiZWwucmVwbGFjZSgvW15hLXpBLVotXzAtOV0vZywgXCJfXCIpO1xufVxuY29uc3QgTUFSS0RPV05fU1BFQ0lBTF9DSEFSUyA9IFtcIipcIiwgXCJfXCIsIFwiYFwiXTtcbmZ1bmN0aW9uIF9nZW5lcmF0ZU1lcm1haWRHcmFwaFN0eWxlcyhub2RlQ29sb3JzKSB7XG4gICAgbGV0IHN0eWxlcyA9IFwiXCI7XG4gICAgZm9yIChjb25zdCBbY2xhc3NOYW1lLCBjb2xvcl0gb2YgT2JqZWN0LmVudHJpZXMobm9kZUNvbG9ycykpIHtcbiAgICAgICAgc3R5bGVzICs9IGBcXHRjbGFzc0RlZiAke2NsYXNzTmFtZX0gJHtjb2xvcn07XFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlcztcbn1cbi8qKlxuICogRHJhd3MgYSBNZXJtYWlkIGdyYXBoIHVzaW5nIHRoZSBwcm92aWRlZCBncmFwaCBkYXRhXG4gKi9cbmZ1bmN0aW9uIGRyYXdNZXJtYWlkKG5vZGVzLCBlZGdlcywgY29uZmlnKSB7XG4gICAgY29uc3QgeyBmaXJzdE5vZGUsIGxhc3ROb2RlLCBub2RlQ29sb3JzLCB3aXRoU3R5bGVzID0gdHJ1ZSwgY3VydmVTdHlsZSA9IFwibGluZWFyXCIsIHdyYXBMYWJlbE5Xb3JkcyA9IDksIH0gPSBjb25maWcgPz8ge307XG4gICAgLy8gSW5pdGlhbGl6ZSBNZXJtYWlkIGdyYXBoIGNvbmZpZ3VyYXRpb25cbiAgICBsZXQgbWVybWFpZEdyYXBoID0gd2l0aFN0eWxlc1xuICAgICAgICA/IGAlJXtpbml0OiB7J2Zsb3djaGFydCc6IHsnY3VydmUnOiAnJHtjdXJ2ZVN0eWxlfSd9fX0lJVxcbmdyYXBoIFREO1xcbmBcbiAgICAgICAgOiBcImdyYXBoIFREO1xcblwiO1xuICAgIGlmICh3aXRoU3R5bGVzKSB7XG4gICAgICAgIC8vIE5vZGUgZm9ybWF0dGluZyB0ZW1wbGF0ZXNcbiAgICAgICAgY29uc3QgZGVmYXVsdENsYXNzTGFiZWwgPSBcImRlZmF1bHRcIjtcbiAgICAgICAgY29uc3QgZm9ybWF0RGljdCA9IHtcbiAgICAgICAgICAgIFtkZWZhdWx0Q2xhc3NMYWJlbF06IFwiezB9KHsxfSlcIixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGZpcnN0Tm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3JtYXREaWN0W2ZpcnN0Tm9kZV0gPSBcInswfShbezF9XSk6OjpmaXJzdFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0Tm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3JtYXREaWN0W2xhc3ROb2RlXSA9IFwiezB9KFt7MX1dKTo6Omxhc3RcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgbm9kZXMgdG8gdGhlIGdyYXBoXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgbm9kZV0gb2YgT2JqZWN0LmVudHJpZXMobm9kZXMpKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlTmFtZSA9IG5vZGUubmFtZS5zcGxpdChcIjpcIikucG9wKCkgPz8gXCJcIjtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gTUFSS0RPV05fU1BFQ0lBTF9DSEFSUy5zb21lKChjaGFyKSA9PiBub2RlTmFtZS5zdGFydHNXaXRoKGNoYXIpICYmIG5vZGVOYW1lLmVuZHNXaXRoKGNoYXIpKVxuICAgICAgICAgICAgICAgID8gYDxwPiR7bm9kZU5hbWV9PC9wPmBcbiAgICAgICAgICAgICAgICA6IG5vZGVOYW1lO1xuICAgICAgICAgICAgbGV0IGZpbmFsTGFiZWwgPSBsYWJlbDtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhub2RlLm1ldGFkYXRhID8/IHt9KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmaW5hbExhYmVsICs9IGA8aHIvPjxzbWFsbD48ZW0+JHtPYmplY3QuZW50cmllcyhub2RlLm1ldGFkYXRhID8/IHt9KVxuICAgICAgICAgICAgICAgICAgICAubWFwKChbaywgdl0pID0+IGAke2t9ID0gJHt2fWApXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKFwiXFxuXCIpfTwvZW0+PC9zbWFsbD5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm9kZUxhYmVsID0gKGZvcm1hdERpY3Rba2V5XSA/PyBmb3JtYXREaWN0W2RlZmF1bHRDbGFzc0xhYmVsXSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShcInswfVwiLCBfZXNjYXBlTm9kZUxhYmVsKGtleSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoXCJ7MX1cIiwgZmluYWxMYWJlbCk7XG4gICAgICAgICAgICBtZXJtYWlkR3JhcGggKz0gYFxcdCR7bm9kZUxhYmVsfVxcbmA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gR3JvdXAgZWRnZXMgYnkgdGhlaXIgY29tbW9uIHByZWZpeGVzXG4gICAgY29uc3QgZWRnZUdyb3VwcyA9IHt9O1xuICAgIGZvciAoY29uc3QgZWRnZSBvZiBlZGdlcykge1xuICAgICAgICBjb25zdCBzcmNQYXJ0cyA9IGVkZ2Uuc291cmNlLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgY29uc3QgdGd0UGFydHMgPSBlZGdlLnRhcmdldC5zcGxpdChcIjpcIik7XG4gICAgICAgIGNvbnN0IGNvbW1vblByZWZpeCA9IHNyY1BhcnRzXG4gICAgICAgICAgICAuZmlsdGVyKChzcmMsIGkpID0+IHNyYyA9PT0gdGd0UGFydHNbaV0pXG4gICAgICAgICAgICAuam9pbihcIjpcIik7XG4gICAgICAgIGlmICghZWRnZUdyb3Vwc1tjb21tb25QcmVmaXhdKSB7XG4gICAgICAgICAgICBlZGdlR3JvdXBzW2NvbW1vblByZWZpeF0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlZGdlR3JvdXBzW2NvbW1vblByZWZpeF0ucHVzaChlZGdlKTtcbiAgICB9XG4gICAgY29uc3Qgc2VlblN1YmdyYXBocyA9IG5ldyBTZXQoKTtcbiAgICBmdW5jdGlvbiBhZGRTdWJncmFwaChlZGdlcywgcHJlZml4KSB7XG4gICAgICAgIGNvbnN0IHNlbGZMb29wID0gZWRnZXMubGVuZ3RoID09PSAxICYmIGVkZ2VzWzBdLnNvdXJjZSA9PT0gZWRnZXNbMF0udGFyZ2V0O1xuICAgICAgICBpZiAocHJlZml4ICYmICFzZWxmTG9vcCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViZ3JhcGggPSBwcmVmaXguc3BsaXQoXCI6XCIpLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHNlZW5TdWJncmFwaHMuaGFzKHN1YmdyYXBoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRm91bmQgZHVwbGljYXRlIHN1YmdyYXBoICcke3N1YmdyYXBofScgLS0gdGhpcyBsaWtlbHkgbWVhbnMgdGhhdCBgICtcbiAgICAgICAgICAgICAgICAgICAgXCJ5b3UncmUgcmV1c2luZyBhIHN1YmdyYXBoIG5vZGUgd2l0aCB0aGUgc2FtZSBuYW1lLiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiUGxlYXNlIGFkanVzdCB5b3VyIGdyYXBoIHRvIGhhdmUgc3ViZ3JhcGggbm9kZXMgd2l0aCB1bmlxdWUgbmFtZXMuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VlblN1YmdyYXBocy5hZGQoc3ViZ3JhcGgpO1xuICAgICAgICAgICAgbWVybWFpZEdyYXBoICs9IGBcXHRzdWJncmFwaCAke3N1YmdyYXBofVxcbmA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBlZGdlIG9mIGVkZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNvdXJjZSwgdGFyZ2V0LCBkYXRhLCBjb25kaXRpb25hbCB9ID0gZWRnZTtcbiAgICAgICAgICAgIGxldCBlZGdlTGFiZWwgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxldCBlZGdlRGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgY29uc3Qgd29yZHMgPSBlZGdlRGF0YS5zcGxpdChcIiBcIik7XG4gICAgICAgICAgICAgICAgaWYgKHdvcmRzLmxlbmd0aCA+IHdyYXBMYWJlbE5Xb3Jkcykge1xuICAgICAgICAgICAgICAgICAgICBlZGdlRGF0YSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IE1hdGguY2VpbCh3b3Jkcy5sZW5ndGggLyB3cmFwTGFiZWxOV29yZHMpIH0sIChfLCBpKSA9PiB3b3Jkc1xuICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKGkgKiB3cmFwTGFiZWxOV29yZHMsIChpICsgMSkgKiB3cmFwTGFiZWxOV29yZHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbihcIiBcIikpLmpvaW4oXCImbmJzcDs8YnI+Jm5ic3A7XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlZGdlTGFiZWwgPSBjb25kaXRpb25hbFxuICAgICAgICAgICAgICAgICAgICA/IGAgLS4gJm5ic3A7JHtlZGdlRGF0YX0mbmJzcDsgLi0+IGBcbiAgICAgICAgICAgICAgICAgICAgOiBgIC0tICZuYnNwOyR7ZWRnZURhdGF9Jm5ic3A7IC0tPiBgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWRnZUxhYmVsID0gY29uZGl0aW9uYWwgPyBcIiAtLi0+IFwiIDogXCIgLS0+IFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVybWFpZEdyYXBoICs9IGBcXHQke19lc2NhcGVOb2RlTGFiZWwoc291cmNlKX0ke2VkZ2VMYWJlbH0ke19lc2NhcGVOb2RlTGFiZWwodGFyZ2V0KX07XFxuYDtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBhZGQgbmVzdGVkIHN1YmdyYXBoc1xuICAgICAgICBmb3IgKGNvbnN0IG5lc3RlZFByZWZpeCBpbiBlZGdlR3JvdXBzKSB7XG4gICAgICAgICAgICBpZiAobmVzdGVkUHJlZml4LnN0YXJ0c1dpdGgoYCR7cHJlZml4fTpgKSAmJiBuZXN0ZWRQcmVmaXggIT09IHByZWZpeCkge1xuICAgICAgICAgICAgICAgIGFkZFN1YmdyYXBoKGVkZ2VHcm91cHNbbmVzdGVkUHJlZml4XSwgbmVzdGVkUHJlZml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlZml4ICYmICFzZWxmTG9vcCkge1xuICAgICAgICAgICAgbWVybWFpZEdyYXBoICs9IFwiXFx0ZW5kXFxuXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU3RhcnQgd2l0aCB0aGUgdG9wLWxldmVsIGVkZ2VzIChubyBjb21tb24gcHJlZml4KVxuICAgIGFkZFN1YmdyYXBoKGVkZ2VHcm91cHNbXCJcIl0gPz8gW10sIFwiXCIpO1xuICAgIC8vIEFkZCByZW1haW5pbmcgc3ViZ3JhcGhzXG4gICAgZm9yIChjb25zdCBwcmVmaXggaW4gZWRnZUdyb3Vwcykge1xuICAgICAgICBpZiAoIXByZWZpeC5pbmNsdWRlcyhcIjpcIikgJiYgcHJlZml4ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBhZGRTdWJncmFwaChlZGdlR3JvdXBzW3ByZWZpeF0sIHByZWZpeCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQWRkIGN1c3RvbSBzdHlsZXMgZm9yIG5vZGVzXG4gICAgaWYgKHdpdGhTdHlsZXMpIHtcbiAgICAgICAgbWVybWFpZEdyYXBoICs9IF9nZW5lcmF0ZU1lcm1haWRHcmFwaFN0eWxlcyhub2RlQ29sb3JzID8/IHt9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcm1haWRHcmFwaDtcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBkcmF3TWVybWFpZEltYWdlYCBpbnN0ZWFkLlxuICovXG5hc3luYyBmdW5jdGlvbiBkcmF3TWVybWFpZFBuZyhtZXJtYWlkU3ludGF4LCBjb25maWcpIHtcbiAgICByZXR1cm4gZHJhd01lcm1haWRJbWFnZShtZXJtYWlkU3ludGF4LCB7XG4gICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgaW1hZ2VUeXBlOiBcInBuZ1wiLFxuICAgIH0pO1xufVxuLyoqXG4gKiBSZW5kZXJzIE1lcm1haWQgZ3JhcGggdXNpbmcgdGhlIE1lcm1haWQuSU5LIEFQSS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgaW1hZ2UgPSBhd2FpdCBkcmF3TWVybWFpZEltYWdlKG1lcm1haWRTeW50YXgsIHtcbiAqICAgYmFja2dyb3VuZENvbG9yOiBcIndoaXRlXCIsXG4gKiAgIGltYWdlVHlwZTogXCJwbmdcIixcbiAqIH0pO1xuICogZnMud3JpdGVGaWxlU3luYyhcImltYWdlLnBuZ1wiLCBpbWFnZSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbWVybWFpZFN5bnRheCAtIFRoZSBNZXJtYWlkIHN5bnRheCB0byByZW5kZXIuXG4gKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBpbWFnZS5cbiAqIEByZXR1cm5zIFRoZSBpbWFnZSBhcyBhIEJsb2IuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRyYXdNZXJtYWlkSW1hZ2UobWVybWFpZFN5bnRheCwgY29uZmlnKSB7XG4gICAgbGV0IGJhY2tncm91bmRDb2xvciA9IGNvbmZpZz8uYmFja2dyb3VuZENvbG9yID8/IFwid2hpdGVcIjtcbiAgICBjb25zdCBpbWFnZVR5cGUgPSBjb25maWc/LmltYWdlVHlwZSA/PyBcInBuZ1wiO1xuICAgIC8vIFVzZSBidG9hIGZvciBjb21wYXRpYmlsaXR5LCBhc3N1bWUgQVNDSUlcbiAgICBjb25zdCBtZXJtYWlkU3ludGF4RW5jb2RlZCA9IGJ0b2EobWVybWFpZFN5bnRheCk7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGJhY2tncm91bmQgY29sb3IgaXMgYSBoZXhhZGVjaW1hbCBjb2xvciBjb2RlIHVzaW5nIHJlZ2V4XG4gICAgaWYgKGJhY2tncm91bmRDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGhleENvbG9yUGF0dGVybiA9IC9eIyg/OlswLTlhLWZBLUZdezN9KXsxLDJ9JC87XG4gICAgICAgIGlmICghaGV4Q29sb3JQYXR0ZXJuLnRlc3QoYmFja2dyb3VuZENvbG9yKSkge1xuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yID0gYCEke2JhY2tncm91bmRDb2xvcn1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGltYWdlVXJsID0gYGh0dHBzOi8vbWVybWFpZC5pbmsvaW1nLyR7bWVybWFpZFN5bnRheEVuY29kZWR9P2JnQ29sb3I9JHtiYWNrZ3JvdW5kQ29sb3J9JnR5cGU9JHtpbWFnZVR5cGV9YDtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChpbWFnZVVybCk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gcmVuZGVyIHRoZSBncmFwaCB1c2luZyB0aGUgTWVybWFpZC5JTksgQVBJLmAsXG4gICAgICAgICAgICBgU3RhdHVzIGNvZGU6ICR7cmVzLnN0YXR1c31gLFxuICAgICAgICAgICAgYFN0YXR1cyB0ZXh0OiAke3Jlcy5zdGF0dXNUZXh0fWAsXG4gICAgICAgIF0uam9pbihcIlxcblwiKSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCByZXMuYmxvYigpO1xuICAgIHJldHVybiBjb250ZW50O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/graph_mermaid.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/history.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/history.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RunnableWithMessageHistory = void 0;\nconst index_js_1 = __webpack_require__(/*! ../messages/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/index.cjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nconst passthrough_js_1 = __webpack_require__(/*! ./passthrough.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/passthrough.cjs\");\n/**\n * Wraps a LCEL chain and manages history. It appends input messages\n * and chain outputs as history, and adds the current history messages to\n * the chain input.\n * @example\n * ```typescript\n * // yarn add @langchain/anthropic @langchain/community @upstash/redis\n *\n * import {\n *   ChatPromptTemplate,\n *   MessagesPlaceholder,\n * } from \"@langchain/core/prompts\";\n * import { ChatAnthropic } from \"@langchain/anthropic\";\n * import { UpstashRedisChatMessageHistory } from \"@langchain/community/stores/message/upstash_redis\";\n * // For demos, you can also use an in-memory store:\n * // import { ChatMessageHistory } from \"langchain/stores/message/in_memory\";\n *\n * const prompt = ChatPromptTemplate.fromMessages([\n *   [\"system\", \"You're an assistant who's good at {ability}\"],\n *   new MessagesPlaceholder(\"history\"),\n *   [\"human\", \"{question}\"],\n * ]);\n *\n * const chain = prompt.pipe(new ChatAnthropic({}));\n *\n * const chainWithHistory = new RunnableWithMessageHistory({\n *   runnable: chain,\n *   getMessageHistory: (sessionId) =>\n *     new UpstashRedisChatMessageHistory({\n *       sessionId,\n *       config: {\n *         url: process.env.UPSTASH_REDIS_REST_URL!,\n *         token: process.env.UPSTASH_REDIS_REST_TOKEN!,\n *       },\n *     }),\n *   inputMessagesKey: \"question\",\n *   historyMessagesKey: \"history\",\n * });\n *\n * const result = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What does cosine mean?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n *\n * const result2 = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What's its inverse?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n * ```\n */\nclass RunnableWithMessageHistory extends base_js_1.RunnableBinding {\n    constructor(fields) {\n        let historyChain = base_js_1.RunnableLambda.from((input, options) => this._enterHistory(input, options ?? {})).withConfig({ runName: \"loadHistory\" });\n        const messagesKey = fields.historyMessagesKey ?? fields.inputMessagesKey;\n        if (messagesKey) {\n            historyChain = passthrough_js_1.RunnablePassthrough.assign({\n                [messagesKey]: historyChain,\n            }).withConfig({ runName: \"insertHistory\" });\n        }\n        const bound = historyChain\n            .pipe(fields.runnable.withListeners({\n            onEnd: (run, config) => this._exitHistory(run, config ?? {}),\n        }))\n            .withConfig({ runName: \"RunnableWithMessageHistory\" });\n        const config = fields.config ?? {};\n        super({\n            ...fields,\n            config,\n            bound,\n        });\n        Object.defineProperty(this, \"runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"historyMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"getMessageHistory\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnable = fields.runnable;\n        this.getMessageHistory = fields.getMessageHistory;\n        this.inputMessagesKey = fields.inputMessagesKey;\n        this.outputMessagesKey = fields.outputMessagesKey;\n        this.historyMessagesKey = fields.historyMessagesKey;\n    }\n    _getInputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    inputValue) {\n        let parsedInputValue;\n        if (typeof inputValue === \"object\" &&\n            !Array.isArray(inputValue) &&\n            !(0, index_js_1.isBaseMessage)(inputValue)) {\n            let key;\n            if (this.inputMessagesKey) {\n                key = this.inputMessagesKey;\n            }\n            else if (Object.keys(inputValue).length === 1) {\n                key = Object.keys(inputValue)[0];\n            }\n            else {\n                key = \"input\";\n            }\n            if (Array.isArray(inputValue[key]) && Array.isArray(inputValue[key][0])) {\n                parsedInputValue = inputValue[key][0];\n            }\n            else {\n                parsedInputValue = inputValue[key];\n            }\n        }\n        else {\n            parsedInputValue = inputValue;\n        }\n        if (typeof parsedInputValue === \"string\") {\n            return [new index_js_1.HumanMessage(parsedInputValue)];\n        }\n        else if (Array.isArray(parsedInputValue)) {\n            return parsedInputValue;\n        }\n        else if ((0, index_js_1.isBaseMessage)(parsedInputValue)) {\n            return [parsedInputValue];\n        }\n        else {\n            throw new Error(`Expected a string, BaseMessage, or array of BaseMessages.\\nGot ${JSON.stringify(parsedInputValue, null, 2)}`);\n        }\n    }\n    _getOutputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    outputValue) {\n        let parsedOutputValue;\n        if (!Array.isArray(outputValue) &&\n            !(0, index_js_1.isBaseMessage)(outputValue) &&\n            typeof outputValue !== \"string\") {\n            let key;\n            if (this.outputMessagesKey !== undefined) {\n                key = this.outputMessagesKey;\n            }\n            else if (Object.keys(outputValue).length === 1) {\n                key = Object.keys(outputValue)[0];\n            }\n            else {\n                key = \"output\";\n            }\n            // If you are wrapping a chat model directly\n            // The output is actually this weird generations object\n            if (outputValue.generations !== undefined) {\n                parsedOutputValue = outputValue.generations[0][0].message;\n            }\n            else {\n                parsedOutputValue = outputValue[key];\n            }\n        }\n        else {\n            parsedOutputValue = outputValue;\n        }\n        if (typeof parsedOutputValue === \"string\") {\n            return [new index_js_1.AIMessage(parsedOutputValue)];\n        }\n        else if (Array.isArray(parsedOutputValue)) {\n            return parsedOutputValue;\n        }\n        else if ((0, index_js_1.isBaseMessage)(parsedOutputValue)) {\n            return [parsedOutputValue];\n        }\n        else {\n            throw new Error(`Expected a string, BaseMessage, or array of BaseMessages. Received: ${JSON.stringify(parsedOutputValue, null, 2)}`);\n        }\n    }\n    async _enterHistory(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    input, kwargs) {\n        const history = kwargs?.configurable?.messageHistory;\n        const messages = await history.getMessages();\n        if (this.historyMessagesKey === undefined) {\n            return messages.concat(this._getInputMessages(input));\n        }\n        return messages;\n    }\n    async _exitHistory(run, config) {\n        const history = config.configurable?.messageHistory;\n        // Get input messages\n        let inputs;\n        // Chat model inputs are nested arrays\n        if (Array.isArray(run.inputs) && Array.isArray(run.inputs[0])) {\n            inputs = run.inputs[0];\n        }\n        else {\n            inputs = run.inputs;\n        }\n        let inputMessages = this._getInputMessages(inputs);\n        // If historic messages were prepended to the input messages, remove them to\n        // avoid adding duplicate messages to history.\n        if (this.historyMessagesKey === undefined) {\n            const existingMessages = await history.getMessages();\n            inputMessages = inputMessages.slice(existingMessages.length);\n        }\n        // Get output messages\n        const outputValue = run.outputs;\n        if (!outputValue) {\n            throw new Error(`Output values from 'Run' undefined. Run: ${JSON.stringify(run, null, 2)}`);\n        }\n        const outputMessages = this._getOutputMessages(outputValue);\n        await history.addMessages([...inputMessages, ...outputMessages]);\n    }\n    async _mergeConfig(...configs) {\n        const config = await super._mergeConfig(...configs);\n        // Extract sessionId\n        if (!config.configurable || !config.configurable.sessionId) {\n            const exampleInput = {\n                [this.inputMessagesKey ?? \"input\"]: \"foo\",\n            };\n            const exampleConfig = { configurable: { sessionId: \"123\" } };\n            throw new Error(`sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()\\n` +\n                `eg. chain.invoke(${JSON.stringify(exampleInput)}, ${JSON.stringify(exampleConfig)})`);\n        }\n        // attach messageHistory\n        const { sessionId } = config.configurable;\n        config.configurable.messageHistory = await this.getMessageHistory(sessionId);\n        return config;\n    }\n}\nexports.RunnableWithMessageHistory = RunnableWithMessageHistory;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2hpc3RvcnkuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtDQUFrQztBQUNsQyxtQkFBbUIsbUJBQU8sQ0FBQywyRkFBdUI7QUFDbEQsa0JBQWtCLG1CQUFPLENBQUMsZ0ZBQVk7QUFDdEMseUJBQXlCLG1CQUFPLENBQUMsOEZBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxnQkFBZ0I7QUFDNUIsWUFBWSxpQ0FBaUM7QUFDN0M7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0hBQW9ILGdCQUFnQix3QkFBd0I7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWUsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RSxTQUFTO0FBQ1QsMEJBQTBCLHVDQUF1QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RiwwQ0FBMEM7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRywyQ0FBMkM7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLDZCQUE2QjtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBLG9DQUFvQyw2QkFBNkIsSUFBSSw4QkFBOEI7QUFDbkc7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2hpc3RvcnkuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SdW5uYWJsZVdpdGhNZXNzYWdlSGlzdG9yeSA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vbWVzc2FnZXMvaW5kZXguY2pzXCIpO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG5jb25zdCBwYXNzdGhyb3VnaF9qc18xID0gcmVxdWlyZShcIi4vcGFzc3Rocm91Z2guY2pzXCIpO1xuLyoqXG4gKiBXcmFwcyBhIExDRUwgY2hhaW4gYW5kIG1hbmFnZXMgaGlzdG9yeS4gSXQgYXBwZW5kcyBpbnB1dCBtZXNzYWdlc1xuICogYW5kIGNoYWluIG91dHB1dHMgYXMgaGlzdG9yeSwgYW5kIGFkZHMgdGhlIGN1cnJlbnQgaGlzdG9yeSBtZXNzYWdlcyB0b1xuICogdGhlIGNoYWluIGlucHV0LlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIC8vIHlhcm4gYWRkIEBsYW5nY2hhaW4vYW50aHJvcGljIEBsYW5nY2hhaW4vY29tbXVuaXR5IEB1cHN0YXNoL3JlZGlzXG4gKlxuICogaW1wb3J0IHtcbiAqICAgQ2hhdFByb21wdFRlbXBsYXRlLFxuICogICBNZXNzYWdlc1BsYWNlaG9sZGVyLFxuICogfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3Byb21wdHNcIjtcbiAqIGltcG9ydCB7IENoYXRBbnRocm9waWMgfSBmcm9tIFwiQGxhbmdjaGFpbi9hbnRocm9waWNcIjtcbiAqIGltcG9ydCB7IFVwc3Rhc2hSZWRpc0NoYXRNZXNzYWdlSGlzdG9yeSB9IGZyb20gXCJAbGFuZ2NoYWluL2NvbW11bml0eS9zdG9yZXMvbWVzc2FnZS91cHN0YXNoX3JlZGlzXCI7XG4gKiAvLyBGb3IgZGVtb3MsIHlvdSBjYW4gYWxzbyB1c2UgYW4gaW4tbWVtb3J5IHN0b3JlOlxuICogLy8gaW1wb3J0IHsgQ2hhdE1lc3NhZ2VIaXN0b3J5IH0gZnJvbSBcImxhbmdjaGFpbi9zdG9yZXMvbWVzc2FnZS9pbl9tZW1vcnlcIjtcbiAqXG4gKiBjb25zdCBwcm9tcHQgPSBDaGF0UHJvbXB0VGVtcGxhdGUuZnJvbU1lc3NhZ2VzKFtcbiAqICAgW1wic3lzdGVtXCIsIFwiWW91J3JlIGFuIGFzc2lzdGFudCB3aG8ncyBnb29kIGF0IHthYmlsaXR5fVwiXSxcbiAqICAgbmV3IE1lc3NhZ2VzUGxhY2Vob2xkZXIoXCJoaXN0b3J5XCIpLFxuICogICBbXCJodW1hblwiLCBcIntxdWVzdGlvbn1cIl0sXG4gKiBdKTtcbiAqXG4gKiBjb25zdCBjaGFpbiA9IHByb21wdC5waXBlKG5ldyBDaGF0QW50aHJvcGljKHt9KSk7XG4gKlxuICogY29uc3QgY2hhaW5XaXRoSGlzdG9yeSA9IG5ldyBSdW5uYWJsZVdpdGhNZXNzYWdlSGlzdG9yeSh7XG4gKiAgIHJ1bm5hYmxlOiBjaGFpbixcbiAqICAgZ2V0TWVzc2FnZUhpc3Rvcnk6IChzZXNzaW9uSWQpID0+XG4gKiAgICAgbmV3IFVwc3Rhc2hSZWRpc0NoYXRNZXNzYWdlSGlzdG9yeSh7XG4gKiAgICAgICBzZXNzaW9uSWQsXG4gKiAgICAgICBjb25maWc6IHtcbiAqICAgICAgICAgdXJsOiBwcm9jZXNzLmVudi5VUFNUQVNIX1JFRElTX1JFU1RfVVJMISxcbiAqICAgICAgICAgdG9rZW46IHByb2Nlc3MuZW52LlVQU1RBU0hfUkVESVNfUkVTVF9UT0tFTiEsXG4gKiAgICAgICB9LFxuICogICAgIH0pLFxuICogICBpbnB1dE1lc3NhZ2VzS2V5OiBcInF1ZXN0aW9uXCIsXG4gKiAgIGhpc3RvcnlNZXNzYWdlc0tleTogXCJoaXN0b3J5XCIsXG4gKiB9KTtcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBjaGFpbldpdGhIaXN0b3J5Lmludm9rZShcbiAqICAge1xuICogICAgIGFiaWxpdHk6IFwibWF0aFwiLFxuICogICAgIHF1ZXN0aW9uOiBcIldoYXQgZG9lcyBjb3NpbmUgbWVhbj9cIixcbiAqICAgfSxcbiAqICAge1xuICogICAgIGNvbmZpZ3VyYWJsZToge1xuICogICAgICAgc2Vzc2lvbklkOiBcInNvbWVfc3RyaW5nX2lkZW50aWZ5aW5nX2FfdXNlclwiLFxuICogICAgIH0sXG4gKiAgIH1cbiAqICk7XG4gKlxuICogY29uc3QgcmVzdWx0MiA9IGF3YWl0IGNoYWluV2l0aEhpc3RvcnkuaW52b2tlKFxuICogICB7XG4gKiAgICAgYWJpbGl0eTogXCJtYXRoXCIsXG4gKiAgICAgcXVlc3Rpb246IFwiV2hhdCdzIGl0cyBpbnZlcnNlP1wiLFxuICogICB9LFxuICogICB7XG4gKiAgICAgY29uZmlndXJhYmxlOiB7XG4gKiAgICAgICBzZXNzaW9uSWQ6IFwic29tZV9zdHJpbmdfaWRlbnRpZnlpbmdfYV91c2VyXCIsXG4gKiAgICAgfSxcbiAqICAgfVxuICogKTtcbiAqIGBgYFxuICovXG5jbGFzcyBSdW5uYWJsZVdpdGhNZXNzYWdlSGlzdG9yeSBleHRlbmRzIGJhc2VfanNfMS5SdW5uYWJsZUJpbmRpbmcge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBsZXQgaGlzdG9yeUNoYWluID0gYmFzZV9qc18xLlJ1bm5hYmxlTGFtYmRhLmZyb20oKGlucHV0LCBvcHRpb25zKSA9PiB0aGlzLl9lbnRlckhpc3RvcnkoaW5wdXQsIG9wdGlvbnMgPz8ge30pKS53aXRoQ29uZmlnKHsgcnVuTmFtZTogXCJsb2FkSGlzdG9yeVwiIH0pO1xuICAgICAgICBjb25zdCBtZXNzYWdlc0tleSA9IGZpZWxkcy5oaXN0b3J5TWVzc2FnZXNLZXkgPz8gZmllbGRzLmlucHV0TWVzc2FnZXNLZXk7XG4gICAgICAgIGlmIChtZXNzYWdlc0tleSkge1xuICAgICAgICAgICAgaGlzdG9yeUNoYWluID0gcGFzc3Rocm91Z2hfanNfMS5SdW5uYWJsZVBhc3N0aHJvdWdoLmFzc2lnbih7XG4gICAgICAgICAgICAgICAgW21lc3NhZ2VzS2V5XTogaGlzdG9yeUNoYWluLFxuICAgICAgICAgICAgfSkud2l0aENvbmZpZyh7IHJ1bk5hbWU6IFwiaW5zZXJ0SGlzdG9yeVwiIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvdW5kID0gaGlzdG9yeUNoYWluXG4gICAgICAgICAgICAucGlwZShmaWVsZHMucnVubmFibGUud2l0aExpc3RlbmVycyh7XG4gICAgICAgICAgICBvbkVuZDogKHJ1biwgY29uZmlnKSA9PiB0aGlzLl9leGl0SGlzdG9yeShydW4sIGNvbmZpZyA/PyB7fSksXG4gICAgICAgIH0pKVxuICAgICAgICAgICAgLndpdGhDb25maWcoeyBydW5OYW1lOiBcIlJ1bm5hYmxlV2l0aE1lc3NhZ2VIaXN0b3J5XCIgfSk7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGZpZWxkcy5jb25maWcgPz8ge307XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGJvdW5kLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicnVubmFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5wdXRNZXNzYWdlc0tleVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvdXRwdXRNZXNzYWdlc0tleVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoaXN0b3J5TWVzc2FnZXNLZXlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0TWVzc2FnZUhpc3RvcnlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ydW5uYWJsZSA9IGZpZWxkcy5ydW5uYWJsZTtcbiAgICAgICAgdGhpcy5nZXRNZXNzYWdlSGlzdG9yeSA9IGZpZWxkcy5nZXRNZXNzYWdlSGlzdG9yeTtcbiAgICAgICAgdGhpcy5pbnB1dE1lc3NhZ2VzS2V5ID0gZmllbGRzLmlucHV0TWVzc2FnZXNLZXk7XG4gICAgICAgIHRoaXMub3V0cHV0TWVzc2FnZXNLZXkgPSBmaWVsZHMub3V0cHV0TWVzc2FnZXNLZXk7XG4gICAgICAgIHRoaXMuaGlzdG9yeU1lc3NhZ2VzS2V5ID0gZmllbGRzLmhpc3RvcnlNZXNzYWdlc0tleTtcbiAgICB9XG4gICAgX2dldElucHV0TWVzc2FnZXMoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBpbnB1dFZhbHVlKSB7XG4gICAgICAgIGxldCBwYXJzZWRJbnB1dFZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0VmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICFBcnJheS5pc0FycmF5KGlucHV0VmFsdWUpICYmXG4gICAgICAgICAgICAhKDAsIGluZGV4X2pzXzEuaXNCYXNlTWVzc2FnZSkoaW5wdXRWYWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCBrZXk7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnB1dE1lc3NhZ2VzS2V5KSB7XG4gICAgICAgICAgICAgICAga2V5ID0gdGhpcy5pbnB1dE1lc3NhZ2VzS2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoT2JqZWN0LmtleXMoaW5wdXRWYWx1ZSkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gT2JqZWN0LmtleXMoaW5wdXRWYWx1ZSlbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBcImlucHV0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dFZhbHVlW2tleV0pICYmIEFycmF5LmlzQXJyYXkoaW5wdXRWYWx1ZVtrZXldWzBdKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlZElucHV0VmFsdWUgPSBpbnB1dFZhbHVlW2tleV1bMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJzZWRJbnB1dFZhbHVlID0gaW5wdXRWYWx1ZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VkSW5wdXRWYWx1ZSA9IGlucHV0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWRJbnB1dFZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBpbmRleF9qc18xLkh1bWFuTWVzc2FnZShwYXJzZWRJbnB1dFZhbHVlKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRJbnB1dFZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZElucHV0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKDAsIGluZGV4X2pzXzEuaXNCYXNlTWVzc2FnZSkocGFyc2VkSW5wdXRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbcGFyc2VkSW5wdXRWYWx1ZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgc3RyaW5nLCBCYXNlTWVzc2FnZSwgb3IgYXJyYXkgb2YgQmFzZU1lc3NhZ2VzLlxcbkdvdCAke0pTT04uc3RyaW5naWZ5KHBhcnNlZElucHV0VmFsdWUsIG51bGwsIDIpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9nZXRPdXRwdXRNZXNzYWdlcyhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIG91dHB1dFZhbHVlKSB7XG4gICAgICAgIGxldCBwYXJzZWRPdXRwdXRWYWx1ZTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG91dHB1dFZhbHVlKSAmJlxuICAgICAgICAgICAgISgwLCBpbmRleF9qc18xLmlzQmFzZU1lc3NhZ2UpKG91dHB1dFZhbHVlKSAmJlxuICAgICAgICAgICAgdHlwZW9mIG91dHB1dFZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsZXQga2V5O1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0TWVzc2FnZXNLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGtleSA9IHRoaXMub3V0cHV0TWVzc2FnZXNLZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChPYmplY3Qua2V5cyhvdXRwdXRWYWx1ZSkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gT2JqZWN0LmtleXMob3V0cHV0VmFsdWUpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAga2V5ID0gXCJvdXRwdXRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHlvdSBhcmUgd3JhcHBpbmcgYSBjaGF0IG1vZGVsIGRpcmVjdGx5XG4gICAgICAgICAgICAvLyBUaGUgb3V0cHV0IGlzIGFjdHVhbGx5IHRoaXMgd2VpcmQgZ2VuZXJhdGlvbnMgb2JqZWN0XG4gICAgICAgICAgICBpZiAob3V0cHV0VmFsdWUuZ2VuZXJhdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhcnNlZE91dHB1dFZhbHVlID0gb3V0cHV0VmFsdWUuZ2VuZXJhdGlvbnNbMF1bMF0ubWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnNlZE91dHB1dFZhbHVlID0gb3V0cHV0VmFsdWVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlZE91dHB1dFZhbHVlID0gb3V0cHV0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWRPdXRwdXRWYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgaW5kZXhfanNfMS5BSU1lc3NhZ2UocGFyc2VkT3V0cHV0VmFsdWUpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZE91dHB1dFZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZE91dHB1dFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCBpbmRleF9qc18xLmlzQmFzZU1lc3NhZ2UpKHBhcnNlZE91dHB1dFZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtwYXJzZWRPdXRwdXRWYWx1ZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgc3RyaW5nLCBCYXNlTWVzc2FnZSwgb3IgYXJyYXkgb2YgQmFzZU1lc3NhZ2VzLiBSZWNlaXZlZDogJHtKU09OLnN0cmluZ2lmeShwYXJzZWRPdXRwdXRWYWx1ZSwgbnVsbCwgMil9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2VudGVySGlzdG9yeShcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGlucHV0LCBrd2FyZ3MpIHtcbiAgICAgICAgY29uc3QgaGlzdG9yeSA9IGt3YXJncz8uY29uZmlndXJhYmxlPy5tZXNzYWdlSGlzdG9yeTtcbiAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBhd2FpdCBoaXN0b3J5LmdldE1lc3NhZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLmhpc3RvcnlNZXNzYWdlc0tleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZXMuY29uY2F0KHRoaXMuX2dldElucHV0TWVzc2FnZXMoaW5wdXQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZXM7XG4gICAgfVxuICAgIGFzeW5jIF9leGl0SGlzdG9yeShydW4sIGNvbmZpZykge1xuICAgICAgICBjb25zdCBoaXN0b3J5ID0gY29uZmlnLmNvbmZpZ3VyYWJsZT8ubWVzc2FnZUhpc3Rvcnk7XG4gICAgICAgIC8vIEdldCBpbnB1dCBtZXNzYWdlc1xuICAgICAgICBsZXQgaW5wdXRzO1xuICAgICAgICAvLyBDaGF0IG1vZGVsIGlucHV0cyBhcmUgbmVzdGVkIGFycmF5c1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShydW4uaW5wdXRzKSAmJiBBcnJheS5pc0FycmF5KHJ1bi5pbnB1dHNbMF0pKSB7XG4gICAgICAgICAgICBpbnB1dHMgPSBydW4uaW5wdXRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRzID0gcnVuLmlucHV0cztcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5wdXRNZXNzYWdlcyA9IHRoaXMuX2dldElucHV0TWVzc2FnZXMoaW5wdXRzKTtcbiAgICAgICAgLy8gSWYgaGlzdG9yaWMgbWVzc2FnZXMgd2VyZSBwcmVwZW5kZWQgdG8gdGhlIGlucHV0IG1lc3NhZ2VzLCByZW1vdmUgdGhlbSB0b1xuICAgICAgICAvLyBhdm9pZCBhZGRpbmcgZHVwbGljYXRlIG1lc3NhZ2VzIHRvIGhpc3RvcnkuXG4gICAgICAgIGlmICh0aGlzLmhpc3RvcnlNZXNzYWdlc0tleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ01lc3NhZ2VzID0gYXdhaXQgaGlzdG9yeS5nZXRNZXNzYWdlcygpO1xuICAgICAgICAgICAgaW5wdXRNZXNzYWdlcyA9IGlucHV0TWVzc2FnZXMuc2xpY2UoZXhpc3RpbmdNZXNzYWdlcy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBvdXRwdXQgbWVzc2FnZXNcbiAgICAgICAgY29uc3Qgb3V0cHV0VmFsdWUgPSBydW4ub3V0cHV0cztcbiAgICAgICAgaWYgKCFvdXRwdXRWYWx1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPdXRwdXQgdmFsdWVzIGZyb20gJ1J1bicgdW5kZWZpbmVkLiBSdW46ICR7SlNPTi5zdHJpbmdpZnkocnVuLCBudWxsLCAyKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdXRwdXRNZXNzYWdlcyA9IHRoaXMuX2dldE91dHB1dE1lc3NhZ2VzKG91dHB1dFZhbHVlKTtcbiAgICAgICAgYXdhaXQgaGlzdG9yeS5hZGRNZXNzYWdlcyhbLi4uaW5wdXRNZXNzYWdlcywgLi4ub3V0cHV0TWVzc2FnZXNdKTtcbiAgICB9XG4gICAgYXN5bmMgX21lcmdlQ29uZmlnKC4uLmNvbmZpZ3MpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gYXdhaXQgc3VwZXIuX21lcmdlQ29uZmlnKC4uLmNvbmZpZ3MpO1xuICAgICAgICAvLyBFeHRyYWN0IHNlc3Npb25JZFxuICAgICAgICBpZiAoIWNvbmZpZy5jb25maWd1cmFibGUgfHwgIWNvbmZpZy5jb25maWd1cmFibGUuc2Vzc2lvbklkKSB7XG4gICAgICAgICAgICBjb25zdCBleGFtcGxlSW5wdXQgPSB7XG4gICAgICAgICAgICAgICAgW3RoaXMuaW5wdXRNZXNzYWdlc0tleSA/PyBcImlucHV0XCJdOiBcImZvb1wiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGVDb25maWcgPSB7IGNvbmZpZ3VyYWJsZTogeyBzZXNzaW9uSWQ6IFwiMTIzXCIgfSB9O1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzZXNzaW9uSWQgaXMgcmVxdWlyZWQuIFBhc3MgaXQgaW4gYXMgcGFydCBvZiB0aGUgY29uZmlnIGFyZ3VtZW50IHRvIC5pbnZva2UoKSBvciAuc3RyZWFtKClcXG5gICtcbiAgICAgICAgICAgICAgICBgZWcuIGNoYWluLmludm9rZSgke0pTT04uc3RyaW5naWZ5KGV4YW1wbGVJbnB1dCl9LCAke0pTT04uc3RyaW5naWZ5KGV4YW1wbGVDb25maWcpfSlgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhdHRhY2ggbWVzc2FnZUhpc3RvcnlcbiAgICAgICAgY29uc3QgeyBzZXNzaW9uSWQgfSA9IGNvbmZpZy5jb25maWd1cmFibGU7XG4gICAgICAgIGNvbmZpZy5jb25maWd1cmFibGUubWVzc2FnZUhpc3RvcnkgPSBhd2FpdCB0aGlzLmdldE1lc3NhZ2VIaXN0b3J5KHNlc3Npb25JZCk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5uYWJsZVdpdGhNZXNzYWdlSGlzdG9yeSA9IFJ1bm5hYmxlV2l0aE1lc3NhZ2VIaXN0b3J5O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/history.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/index.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/index.cjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RunnableWithMessageHistory = exports.RunnableBranch = exports.RouterRunnable = exports.RunnablePassthrough = exports.pickRunnableConfigKeys = exports.mergeConfigs = exports.ensureConfig = exports.patchConfig = exports.getCallbackManagerForConfig = exports.RunnableToolLike = exports._coerceToRunnable = exports.RunnablePick = exports.RunnableAssign = exports.RunnableWithFallbacks = exports.RunnableLambda = exports.RunnableParallel = exports.RunnableMap = exports.RunnableSequence = exports.RunnableRetry = exports.RunnableEach = exports.RunnableBinding = exports.Runnable = void 0;\nvar base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nObject.defineProperty(exports, \"Runnable\", ({ enumerable: true, get: function () { return base_js_1.Runnable; } }));\nObject.defineProperty(exports, \"RunnableBinding\", ({ enumerable: true, get: function () { return base_js_1.RunnableBinding; } }));\nObject.defineProperty(exports, \"RunnableEach\", ({ enumerable: true, get: function () { return base_js_1.RunnableEach; } }));\nObject.defineProperty(exports, \"RunnableRetry\", ({ enumerable: true, get: function () { return base_js_1.RunnableRetry; } }));\nObject.defineProperty(exports, \"RunnableSequence\", ({ enumerable: true, get: function () { return base_js_1.RunnableSequence; } }));\nObject.defineProperty(exports, \"RunnableMap\", ({ enumerable: true, get: function () { return base_js_1.RunnableMap; } }));\nObject.defineProperty(exports, \"RunnableParallel\", ({ enumerable: true, get: function () { return base_js_1.RunnableParallel; } }));\nObject.defineProperty(exports, \"RunnableLambda\", ({ enumerable: true, get: function () { return base_js_1.RunnableLambda; } }));\nObject.defineProperty(exports, \"RunnableWithFallbacks\", ({ enumerable: true, get: function () { return base_js_1.RunnableWithFallbacks; } }));\nObject.defineProperty(exports, \"RunnableAssign\", ({ enumerable: true, get: function () { return base_js_1.RunnableAssign; } }));\nObject.defineProperty(exports, \"RunnablePick\", ({ enumerable: true, get: function () { return base_js_1.RunnablePick; } }));\nObject.defineProperty(exports, \"_coerceToRunnable\", ({ enumerable: true, get: function () { return base_js_1._coerceToRunnable; } }));\nObject.defineProperty(exports, \"RunnableToolLike\", ({ enumerable: true, get: function () { return base_js_1.RunnableToolLike; } }));\nvar config_js_1 = __webpack_require__(/*! ./config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\nObject.defineProperty(exports, \"getCallbackManagerForConfig\", ({ enumerable: true, get: function () { return config_js_1.getCallbackManagerForConfig; } }));\nObject.defineProperty(exports, \"patchConfig\", ({ enumerable: true, get: function () { return config_js_1.patchConfig; } }));\nObject.defineProperty(exports, \"ensureConfig\", ({ enumerable: true, get: function () { return config_js_1.ensureConfig; } }));\nObject.defineProperty(exports, \"mergeConfigs\", ({ enumerable: true, get: function () { return config_js_1.mergeConfigs; } }));\nObject.defineProperty(exports, \"pickRunnableConfigKeys\", ({ enumerable: true, get: function () { return config_js_1.pickRunnableConfigKeys; } }));\nvar passthrough_js_1 = __webpack_require__(/*! ./passthrough.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/passthrough.cjs\");\nObject.defineProperty(exports, \"RunnablePassthrough\", ({ enumerable: true, get: function () { return passthrough_js_1.RunnablePassthrough; } }));\nvar router_js_1 = __webpack_require__(/*! ./router.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/router.cjs\");\nObject.defineProperty(exports, \"RouterRunnable\", ({ enumerable: true, get: function () { return router_js_1.RouterRunnable; } }));\nvar branch_js_1 = __webpack_require__(/*! ./branch.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/branch.cjs\");\nObject.defineProperty(exports, \"RunnableBranch\", ({ enumerable: true, get: function () { return branch_js_1.RunnableBranch; } }));\nvar history_js_1 = __webpack_require__(/*! ./history.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/history.cjs\");\nObject.defineProperty(exports, \"RunnableWithMessageHistory\", ({ enumerable: true, get: function () { return history_js_1.RunnableWithMessageHistory; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQ0FBa0MsR0FBRyxzQkFBc0IsR0FBRyxzQkFBc0IsR0FBRywyQkFBMkIsR0FBRyw4QkFBOEIsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyxtQkFBbUIsR0FBRyxtQ0FBbUMsR0FBRyx3QkFBd0IsR0FBRyx5QkFBeUIsR0FBRyxvQkFBb0IsR0FBRyxzQkFBc0IsR0FBRyw2QkFBNkIsR0FBRyxzQkFBc0IsR0FBRyx3QkFBd0IsR0FBRyxtQkFBbUIsR0FBRyx3QkFBd0IsR0FBRyxxQkFBcUIsR0FBRyxvQkFBb0IsR0FBRyx1QkFBdUIsR0FBRyxnQkFBZ0I7QUFDcmtCLGdCQUFnQixtQkFBTyxDQUFDLGdGQUFZO0FBQ3BDLDRDQUEyQyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNqSCxtREFBa0QsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDL0gsZ0RBQStDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3pILGlEQUFnRCxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUMzSCxvREFBbUQsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDakksK0NBQThDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3ZILG9EQUFtRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUNqSSxrREFBaUQsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDN0gseURBQXdELEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQzNJLGtEQUFpRCxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUM3SCxnREFBK0MsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDekgscURBQW9ELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ25JLG9EQUFtRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUNqSSxrQkFBa0IsbUJBQU8sQ0FBQyxvRkFBYztBQUN4QywrREFBOEQsRUFBRSxxQ0FBcUMsbURBQW1ELEVBQUM7QUFDekosK0NBQThDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQ3pILGdEQUErQyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUMzSCxnREFBK0MsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDM0gsMERBQXlELEVBQUUscUNBQXFDLDhDQUE4QyxFQUFDO0FBQy9JLHVCQUF1QixtQkFBTyxDQUFDLDhGQUFtQjtBQUNsRCx1REFBc0QsRUFBRSxxQ0FBcUMsZ0RBQWdELEVBQUM7QUFDOUksa0JBQWtCLG1CQUFPLENBQUMsb0ZBQWM7QUFDeEMsa0RBQWlELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQy9ILGtCQUFrQixtQkFBTyxDQUFDLG9GQUFjO0FBQ3hDLGtEQUFpRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUMvSCxtQkFBbUIsbUJBQU8sQ0FBQyxzRkFBZTtBQUMxQyw4REFBNkQsRUFBRSxxQ0FBcUMsbURBQW1ELEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9ydW5uYWJsZXMvaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SdW5uYWJsZVdpdGhNZXNzYWdlSGlzdG9yeSA9IGV4cG9ydHMuUnVubmFibGVCcmFuY2ggPSBleHBvcnRzLlJvdXRlclJ1bm5hYmxlID0gZXhwb3J0cy5SdW5uYWJsZVBhc3N0aHJvdWdoID0gZXhwb3J0cy5waWNrUnVubmFibGVDb25maWdLZXlzID0gZXhwb3J0cy5tZXJnZUNvbmZpZ3MgPSBleHBvcnRzLmVuc3VyZUNvbmZpZyA9IGV4cG9ydHMucGF0Y2hDb25maWcgPSBleHBvcnRzLmdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZyA9IGV4cG9ydHMuUnVubmFibGVUb29sTGlrZSA9IGV4cG9ydHMuX2NvZXJjZVRvUnVubmFibGUgPSBleHBvcnRzLlJ1bm5hYmxlUGljayA9IGV4cG9ydHMuUnVubmFibGVBc3NpZ24gPSBleHBvcnRzLlJ1bm5hYmxlV2l0aEZhbGxiYWNrcyA9IGV4cG9ydHMuUnVubmFibGVMYW1iZGEgPSBleHBvcnRzLlJ1bm5hYmxlUGFyYWxsZWwgPSBleHBvcnRzLlJ1bm5hYmxlTWFwID0gZXhwb3J0cy5SdW5uYWJsZVNlcXVlbmNlID0gZXhwb3J0cy5SdW5uYWJsZVJldHJ5ID0gZXhwb3J0cy5SdW5uYWJsZUVhY2ggPSBleHBvcnRzLlJ1bm5hYmxlQmluZGluZyA9IGV4cG9ydHMuUnVubmFibGUgPSB2b2lkIDA7XG52YXIgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSdW5uYWJsZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZV9qc18xLlJ1bm5hYmxlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUnVubmFibGVCaW5kaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlX2pzXzEuUnVubmFibGVCaW5kaW5nOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUnVubmFibGVFYWNoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlX2pzXzEuUnVubmFibGVFYWNoOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUnVubmFibGVSZXRyeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZV9qc18xLlJ1bm5hYmxlUmV0cnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSdW5uYWJsZVNlcXVlbmNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlX2pzXzEuUnVubmFibGVTZXF1ZW5jZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJ1bm5hYmxlTWFwXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlX2pzXzEuUnVubmFibGVNYXA7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSdW5uYWJsZVBhcmFsbGVsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlX2pzXzEuUnVubmFibGVQYXJhbGxlbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJ1bm5hYmxlTGFtYmRhXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlX2pzXzEuUnVubmFibGVMYW1iZGE7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSdW5uYWJsZVdpdGhGYWxsYmFja3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2VfanNfMS5SdW5uYWJsZVdpdGhGYWxsYmFja3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSdW5uYWJsZUFzc2lnblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZV9qc18xLlJ1bm5hYmxlQXNzaWduOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUnVubmFibGVQaWNrXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlX2pzXzEuUnVubmFibGVQaWNrOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX2NvZXJjZVRvUnVubmFibGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2VfanNfMS5fY29lcmNlVG9SdW5uYWJsZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJ1bm5hYmxlVG9vbExpa2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2VfanNfMS5SdW5uYWJsZVRvb2xMaWtlOyB9IH0pO1xudmFyIGNvbmZpZ19qc18xID0gcmVxdWlyZShcIi4vY29uZmlnLmNqc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnX2pzXzEuZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGF0Y2hDb25maWdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZ19qc18xLnBhdGNoQ29uZmlnOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5zdXJlQ29uZmlnXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWdfanNfMS5lbnN1cmVDb25maWc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtZXJnZUNvbmZpZ3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZ19qc18xLm1lcmdlQ29uZmlnczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBpY2tSdW5uYWJsZUNvbmZpZ0tleXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZ19qc18xLnBpY2tSdW5uYWJsZUNvbmZpZ0tleXM7IH0gfSk7XG52YXIgcGFzc3Rocm91Z2hfanNfMSA9IHJlcXVpcmUoXCIuL3Bhc3N0aHJvdWdoLmNqc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJ1bm5hYmxlUGFzc3Rocm91Z2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhc3N0aHJvdWdoX2pzXzEuUnVubmFibGVQYXNzdGhyb3VnaDsgfSB9KTtcbnZhciByb3V0ZXJfanNfMSA9IHJlcXVpcmUoXCIuL3JvdXRlci5janNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSb3V0ZXJSdW5uYWJsZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyX2pzXzEuUm91dGVyUnVubmFibGU7IH0gfSk7XG52YXIgYnJhbmNoX2pzXzEgPSByZXF1aXJlKFwiLi9icmFuY2guY2pzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUnVubmFibGVCcmFuY2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJyYW5jaF9qc18xLlJ1bm5hYmxlQnJhbmNoOyB9IH0pO1xudmFyIGhpc3RvcnlfanNfMSA9IHJlcXVpcmUoXCIuL2hpc3RvcnkuY2pzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUnVubmFibGVXaXRoTWVzc2FnZUhpc3RvcnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhpc3RvcnlfanNfMS5SdW5uYWJsZVdpdGhNZXNzYWdlSGlzdG9yeTsgfSB9KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/iter.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/iter.cjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isIterator = void 0;\nexports.isIterableIterator = isIterableIterator;\nexports.isAsyncIterable = isAsyncIterable;\nexports.consumeIteratorInContext = consumeIteratorInContext;\nexports.consumeAsyncIterableInContext = consumeAsyncIterableInContext;\nconst index_js_1 = __webpack_require__(/*! ../singletons/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/index.cjs\");\nconst config_js_1 = __webpack_require__(/*! ./config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\nfunction isIterableIterator(thing) {\n    return (typeof thing === \"object\" &&\n        thing !== null &&\n        typeof thing[Symbol.iterator] === \"function\" &&\n        // avoid detecting array/set as iterator\n        typeof thing.next === \"function\");\n}\nconst isIterator = (x) => x != null &&\n    typeof x === \"object\" &&\n    \"next\" in x &&\n    typeof x.next === \"function\";\nexports.isIterator = isIterator;\nfunction isAsyncIterable(thing) {\n    return (typeof thing === \"object\" &&\n        thing !== null &&\n        typeof thing[Symbol.asyncIterator] ===\n            \"function\");\n}\nfunction* consumeIteratorInContext(context, iter) {\n    while (true) {\n        const { value, done } = index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig((0, config_js_1.pickRunnableConfigKeys)(context), iter.next.bind(iter), true);\n        if (done) {\n            break;\n        }\n        else {\n            yield value;\n        }\n    }\n}\nasync function* consumeAsyncIterableInContext(context, iter) {\n    const iterator = iter[Symbol.asyncIterator]();\n    while (true) {\n        const { value, done } = await index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig((0, config_js_1.pickRunnableConfigKeys)(context), iterator.next.bind(iter), true);\n        if (done) {\n            break;\n        }\n        else {\n            yield value;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2l0ZXIuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQiwwQkFBMEI7QUFDMUIsdUJBQXVCO0FBQ3ZCLGdDQUFnQztBQUNoQyxxQ0FBcUM7QUFDckMsbUJBQW1CLG1CQUFPLENBQUMsK0ZBQXlCO0FBQ3BELG9CQUFvQixtQkFBTyxDQUFDLG9GQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2l0ZXIuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0l0ZXJhdG9yID0gdm9pZCAwO1xuZXhwb3J0cy5pc0l0ZXJhYmxlSXRlcmF0b3IgPSBpc0l0ZXJhYmxlSXRlcmF0b3I7XG5leHBvcnRzLmlzQXN5bmNJdGVyYWJsZSA9IGlzQXN5bmNJdGVyYWJsZTtcbmV4cG9ydHMuY29uc3VtZUl0ZXJhdG9ySW5Db250ZXh0ID0gY29uc3VtZUl0ZXJhdG9ySW5Db250ZXh0O1xuZXhwb3J0cy5jb25zdW1lQXN5bmNJdGVyYWJsZUluQ29udGV4dCA9IGNvbnN1bWVBc3luY0l0ZXJhYmxlSW5Db250ZXh0O1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9zaW5nbGV0b25zL2luZGV4LmNqc1wiKTtcbmNvbnN0IGNvbmZpZ19qc18xID0gcmVxdWlyZShcIi4vY29uZmlnLmNqc1wiKTtcbmZ1bmN0aW9uIGlzSXRlcmFibGVJdGVyYXRvcih0aGluZykge1xuICAgIHJldHVybiAodHlwZW9mIHRoaW5nID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHRoaW5nICE9PSBudWxsICYmXG4gICAgICAgIHR5cGVvZiB0aGluZ1tTeW1ib2wuaXRlcmF0b3JdID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgLy8gYXZvaWQgZGV0ZWN0aW5nIGFycmF5L3NldCBhcyBpdGVyYXRvclxuICAgICAgICB0eXBlb2YgdGhpbmcubmV4dCA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmNvbnN0IGlzSXRlcmF0b3IgPSAoeCkgPT4geCAhPSBudWxsICYmXG4gICAgdHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiZcbiAgICBcIm5leHRcIiBpbiB4ICYmXG4gICAgdHlwZW9mIHgubmV4dCA9PT0gXCJmdW5jdGlvblwiO1xuZXhwb3J0cy5pc0l0ZXJhdG9yID0gaXNJdGVyYXRvcjtcbmZ1bmN0aW9uIGlzQXN5bmNJdGVyYWJsZSh0aGluZykge1xuICAgIHJldHVybiAodHlwZW9mIHRoaW5nID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHRoaW5nICE9PSBudWxsICYmXG4gICAgICAgIHR5cGVvZiB0aGluZ1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24qIGNvbnN1bWVJdGVyYXRvckluQ29udGV4dChjb250ZXh0LCBpdGVyKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gaW5kZXhfanNfMS5Bc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uLnJ1bldpdGhDb25maWcoKDAsIGNvbmZpZ19qc18xLnBpY2tSdW5uYWJsZUNvbmZpZ0tleXMpKGNvbnRleHQpLCBpdGVyLm5leHQuYmluZChpdGVyKSwgdHJ1ZSk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHlpZWxkIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24qIGNvbnN1bWVBc3luY0l0ZXJhYmxlSW5Db250ZXh0KGNvbnRleHQsIGl0ZXIpIHtcbiAgICBjb25zdCBpdGVyYXRvciA9IGl0ZXJbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaW5kZXhfanNfMS5Bc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uLnJ1bldpdGhDb25maWcoKDAsIGNvbmZpZ19qc18xLnBpY2tSdW5uYWJsZUNvbmZpZ0tleXMpKGNvbnRleHQpLCBpdGVyYXRvci5uZXh0LmJpbmQoaXRlciksIHRydWUpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/iter.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/passthrough.cjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/passthrough.cjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RunnablePassthrough = void 0;\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nconst config_js_1 = __webpack_require__(/*! ./config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\n/**\n * A runnable to passthrough inputs unchanged or with additional keys.\n *\n * This runnable behaves almost like the identity function, except that it\n * can be configured to add additional keys to the output, if the input is\n * an object.\n *\n * The example below demonstrates how to use `RunnablePassthrough to\n * passthrough the input from the `.invoke()`\n *\n * @example\n * ```typescript\n * const chain = RunnableSequence.from([\n *   {\n *     question: new RunnablePassthrough(),\n *     context: async () => loadContextFromStore(),\n *   },\n *   prompt,\n *   llm,\n *   outputParser,\n * ]);\n * const response = await chain.invoke(\n *   \"I can pass a single string instead of an object since I'm using `RunnablePassthrough`.\"\n * );\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass RunnablePassthrough extends base_js_1.Runnable {\n    static lc_name() {\n        return \"RunnablePassthrough\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (fields) {\n            this.func = fields.func;\n        }\n    }\n    async invoke(input, options) {\n        const config = (0, config_js_1.ensureConfig)(options);\n        if (this.func) {\n            await this.func(input, config);\n        }\n        return this._callWithConfig((input) => Promise.resolve(input), input, config);\n    }\n    async *transform(generator, options) {\n        const config = (0, config_js_1.ensureConfig)(options);\n        let finalOutput;\n        let finalOutputSupported = true;\n        for await (const chunk of this._transformStreamWithConfig(generator, (input) => input, config)) {\n            yield chunk;\n            if (finalOutputSupported) {\n                if (finalOutput === undefined) {\n                    finalOutput = chunk;\n                }\n                else {\n                    try {\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        finalOutput = (0, stream_js_1.concat)(finalOutput, chunk);\n                    }\n                    catch {\n                        finalOutput = undefined;\n                        finalOutputSupported = false;\n                    }\n                }\n            }\n        }\n        if (this.func && finalOutput !== undefined) {\n            await this.func(finalOutput, config);\n        }\n    }\n    /**\n     * A runnable that assigns key-value pairs to the input.\n     *\n     * The example below shows how you could use it with an inline function.\n     *\n     * @example\n     * ```typescript\n     * const prompt =\n     *   PromptTemplate.fromTemplate(`Write a SQL query to answer the question using the following schema: {schema}\n     * Question: {question}\n     * SQL Query:`);\n     *\n     * // The `RunnablePassthrough.assign()` is used here to passthrough the input from the `.invoke()`\n     * // call (in this example it's the question), along with any inputs passed to the `.assign()` method.\n     * // In this case, we're passing the schema.\n     * const sqlQueryGeneratorChain = RunnableSequence.from([\n     *   RunnablePassthrough.assign({\n     *     schema: async () => db.getTableInfo(),\n     *   }),\n     *   prompt,\n     *   new ChatOpenAI({ model: \"gpt-4o-mini\" }).withConfig({ stop: [\"\\nSQLResult:\"] }),\n     *   new StringOutputParser(),\n     * ]);\n     * const result = await sqlQueryGeneratorChain.invoke({\n     *   question: \"How many employees are there?\",\n     * });\n     * ```\n     */\n    static assign(mapping) {\n        return new base_js_1.RunnableAssign(new base_js_1.RunnableMap({ steps: mapping }));\n    }\n}\nexports.RunnablePassthrough = RunnablePassthrough;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL3Bhc3N0aHJvdWdoLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0Isb0JBQW9CLG1CQUFPLENBQUMsdUZBQXFCO0FBQ2pELGtCQUFrQixtQkFBTyxDQUFDLGdGQUFZO0FBQ3RDLG9CQUFvQixtQkFBTyxDQUFDLG9GQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsMEJBQTBCLHNCQUFzQixlQUFlLHdCQUF3QjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsZ0JBQWdCO0FBQ3hGO0FBQ0E7QUFDQSwyQkFBMkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9ydW5uYWJsZXMvcGFzc3Rocm91Z2guY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SdW5uYWJsZVBhc3N0aHJvdWdoID0gdm9pZCAwO1xuY29uc3Qgc3RyZWFtX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvc3RyZWFtLmNqc1wiKTtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2UuY2pzXCIpO1xuY29uc3QgY29uZmlnX2pzXzEgPSByZXF1aXJlKFwiLi9jb25maWcuY2pzXCIpO1xuLyoqXG4gKiBBIHJ1bm5hYmxlIHRvIHBhc3N0aHJvdWdoIGlucHV0cyB1bmNoYW5nZWQgb3Igd2l0aCBhZGRpdGlvbmFsIGtleXMuXG4gKlxuICogVGhpcyBydW5uYWJsZSBiZWhhdmVzIGFsbW9zdCBsaWtlIHRoZSBpZGVudGl0eSBmdW5jdGlvbiwgZXhjZXB0IHRoYXQgaXRcbiAqIGNhbiBiZSBjb25maWd1cmVkIHRvIGFkZCBhZGRpdGlvbmFsIGtleXMgdG8gdGhlIG91dHB1dCwgaWYgdGhlIGlucHV0IGlzXG4gKiBhbiBvYmplY3QuXG4gKlxuICogVGhlIGV4YW1wbGUgYmVsb3cgZGVtb25zdHJhdGVzIGhvdyB0byB1c2UgYFJ1bm5hYmxlUGFzc3Rocm91Z2ggdG9cbiAqIHBhc3N0aHJvdWdoIHRoZSBpbnB1dCBmcm9tIHRoZSBgLmludm9rZSgpYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBjaGFpbiA9IFJ1bm5hYmxlU2VxdWVuY2UuZnJvbShbXG4gKiAgIHtcbiAqICAgICBxdWVzdGlvbjogbmV3IFJ1bm5hYmxlUGFzc3Rocm91Z2goKSxcbiAqICAgICBjb250ZXh0OiBhc3luYyAoKSA9PiBsb2FkQ29udGV4dEZyb21TdG9yZSgpLFxuICogICB9LFxuICogICBwcm9tcHQsXG4gKiAgIGxsbSxcbiAqICAgb3V0cHV0UGFyc2VyLFxuICogXSk7XG4gKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNoYWluLmludm9rZShcbiAqICAgXCJJIGNhbiBwYXNzIGEgc2luZ2xlIHN0cmluZyBpbnN0ZWFkIG9mIGFuIG9iamVjdCBzaW5jZSBJJ20gdXNpbmcgYFJ1bm5hYmxlUGFzc3Rocm91Z2hgLlwiXG4gKiApO1xuICogYGBgXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jbGFzcyBSdW5uYWJsZVBhc3N0aHJvdWdoIGV4dGVuZHMgYmFzZV9qc18xLlJ1bm5hYmxlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVQYXNzdGhyb3VnaFwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmdW5jXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmaWVsZHMpIHtcbiAgICAgICAgICAgIHRoaXMuZnVuYyA9IGZpZWxkcy5mdW5jO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb25maWcgPSAoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShvcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuZnVuYykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5mdW5jKGlucHV0LCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsV2l0aENvbmZpZygoaW5wdXQpID0+IFByb21pc2UucmVzb2x2ZShpbnB1dCksIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgICBhc3luYyAqdHJhbnNmb3JtKGdlbmVyYXRvciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb25maWcgPSAoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShvcHRpb25zKTtcbiAgICAgICAgbGV0IGZpbmFsT3V0cHV0O1xuICAgICAgICBsZXQgZmluYWxPdXRwdXRTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHRoaXMuX3RyYW5zZm9ybVN0cmVhbVdpdGhDb25maWcoZ2VuZXJhdG9yLCAoaW5wdXQpID0+IGlucHV0LCBjb25maWcpKSB7XG4gICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgICAgIGlmIChmaW5hbE91dHB1dFN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIGlmIChmaW5hbE91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gKDAsIHN0cmVhbV9qc18xLmNvbmNhdCkoZmluYWxPdXRwdXQsIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZnVuYyAmJiBmaW5hbE91dHB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmZ1bmMoZmluYWxPdXRwdXQsIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBydW5uYWJsZSB0aGF0IGFzc2lnbnMga2V5LXZhbHVlIHBhaXJzIHRvIHRoZSBpbnB1dC5cbiAgICAgKlxuICAgICAqIFRoZSBleGFtcGxlIGJlbG93IHNob3dzIGhvdyB5b3UgY291bGQgdXNlIGl0IHdpdGggYW4gaW5saW5lIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgcHJvbXB0ID1cbiAgICAgKiAgIFByb21wdFRlbXBsYXRlLmZyb21UZW1wbGF0ZShgV3JpdGUgYSBTUUwgcXVlcnkgdG8gYW5zd2VyIHRoZSBxdWVzdGlvbiB1c2luZyB0aGUgZm9sbG93aW5nIHNjaGVtYToge3NjaGVtYX1cbiAgICAgKiBRdWVzdGlvbjoge3F1ZXN0aW9ufVxuICAgICAqIFNRTCBRdWVyeTpgKTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgUnVubmFibGVQYXNzdGhyb3VnaC5hc3NpZ24oKWAgaXMgdXNlZCBoZXJlIHRvIHBhc3N0aHJvdWdoIHRoZSBpbnB1dCBmcm9tIHRoZSBgLmludm9rZSgpYFxuICAgICAqIC8vIGNhbGwgKGluIHRoaXMgZXhhbXBsZSBpdCdzIHRoZSBxdWVzdGlvbiksIGFsb25nIHdpdGggYW55IGlucHV0cyBwYXNzZWQgdG8gdGhlIGAuYXNzaWduKClgIG1ldGhvZC5cbiAgICAgKiAvLyBJbiB0aGlzIGNhc2UsIHdlJ3JlIHBhc3NpbmcgdGhlIHNjaGVtYS5cbiAgICAgKiBjb25zdCBzcWxRdWVyeUdlbmVyYXRvckNoYWluID0gUnVubmFibGVTZXF1ZW5jZS5mcm9tKFtcbiAgICAgKiAgIFJ1bm5hYmxlUGFzc3Rocm91Z2guYXNzaWduKHtcbiAgICAgKiAgICAgc2NoZW1hOiBhc3luYyAoKSA9PiBkYi5nZXRUYWJsZUluZm8oKSxcbiAgICAgKiAgIH0pLFxuICAgICAqICAgcHJvbXB0LFxuICAgICAqICAgbmV3IENoYXRPcGVuQUkoeyBtb2RlbDogXCJncHQtNG8tbWluaVwiIH0pLndpdGhDb25maWcoeyBzdG9wOiBbXCJcXG5TUUxSZXN1bHQ6XCJdIH0pLFxuICAgICAqICAgbmV3IFN0cmluZ091dHB1dFBhcnNlcigpLFxuICAgICAqIF0pO1xuICAgICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNxbFF1ZXJ5R2VuZXJhdG9yQ2hhaW4uaW52b2tlKHtcbiAgICAgKiAgIHF1ZXN0aW9uOiBcIkhvdyBtYW55IGVtcGxveWVlcyBhcmUgdGhlcmU/XCIsXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc3RhdGljIGFzc2lnbihtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgYmFzZV9qc18xLlJ1bm5hYmxlQXNzaWduKG5ldyBiYXNlX2pzXzEuUnVubmFibGVNYXAoeyBzdGVwczogbWFwcGluZyB9KSk7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5uYWJsZVBhc3N0aHJvdWdoID0gUnVubmFibGVQYXNzdGhyb3VnaDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/passthrough.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/remote.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/remote.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RemoteRunnable = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nconst config_js_1 = __webpack_require__(/*! ./config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\nconst index_js_1 = __webpack_require__(/*! ../documents/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/documents/index.cjs\");\nconst prompt_values_js_1 = __webpack_require__(/*! ../prompt_values.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/prompt_values.cjs\");\nconst log_stream_js_1 = __webpack_require__(/*! ../tracers/log_stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/log_stream.cjs\");\nconst index_js_2 = __webpack_require__(/*! ../messages/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/index.cjs\");\nconst outputs_js_1 = __webpack_require__(/*! ../outputs.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/outputs.cjs\");\nconst event_source_parse_js_1 = __webpack_require__(/*! ../utils/event_source_parse.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/event_source_parse.cjs\");\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\nfunction isSuperset(set, subset) {\n    for (const elem of subset) {\n        if (!set.has(elem)) {\n            return false;\n        }\n    }\n    return true;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction revive(obj) {\n    if (Array.isArray(obj))\n        return obj.map(revive);\n    if (typeof obj === \"object\") {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (!obj || obj instanceof Date) {\n            return obj;\n        }\n        const keysArr = Object.keys(obj);\n        const keys = new Set(keysArr);\n        if (isSuperset(keys, new Set([\"page_content\", \"metadata\"]))) {\n            return new index_js_1.Document({\n                pageContent: obj.page_content,\n                metadata: obj.metadata,\n            });\n        }\n        if (isSuperset(keys, new Set([\"content\", \"type\", \"additional_kwargs\"]))) {\n            if (obj.type === \"HumanMessage\" || obj.type === \"human\") {\n                return new index_js_2.HumanMessage({\n                    content: obj.content,\n                });\n            }\n            if (obj.type === \"SystemMessage\" || obj.type === \"system\") {\n                return new index_js_2.SystemMessage({\n                    content: obj.content,\n                });\n            }\n            if (obj.type === \"ChatMessage\" || obj.type === \"generic\") {\n                return new index_js_2.ChatMessage({\n                    content: obj.content,\n                    role: obj.role,\n                });\n            }\n            if (obj.type === \"FunctionMessage\" || obj.type === \"function\") {\n                return new index_js_2.FunctionMessage({\n                    content: obj.content,\n                    name: obj.name,\n                });\n            }\n            if (obj.type === \"ToolMessage\" || obj.type === \"tool\") {\n                return new index_js_2.ToolMessage({\n                    content: obj.content,\n                    tool_call_id: obj.tool_call_id,\n                    status: obj.status,\n                    artifact: obj.artifact,\n                });\n            }\n            if (obj.type === \"AIMessage\" || obj.type === \"ai\") {\n                return new index_js_2.AIMessage({\n                    content: obj.content,\n                });\n            }\n            if (obj.type === \"HumanMessageChunk\") {\n                return new index_js_2.HumanMessageChunk({\n                    content: obj.content,\n                });\n            }\n            if (obj.type === \"SystemMessageChunk\") {\n                return new index_js_2.SystemMessageChunk({\n                    content: obj.content,\n                });\n            }\n            if (obj.type === \"ChatMessageChunk\") {\n                return new index_js_2.ChatMessageChunk({\n                    content: obj.content,\n                    role: obj.role,\n                });\n            }\n            if (obj.type === \"FunctionMessageChunk\") {\n                return new index_js_2.FunctionMessageChunk({\n                    content: obj.content,\n                    name: obj.name,\n                });\n            }\n            if (obj.type === \"ToolMessageChunk\") {\n                return new index_js_2.ToolMessageChunk({\n                    content: obj.content,\n                    tool_call_id: obj.tool_call_id,\n                    status: obj.status,\n                    artifact: obj.artifact,\n                });\n            }\n            if (obj.type === \"AIMessageChunk\") {\n                return new index_js_2.AIMessageChunk({\n                    content: obj.content,\n                });\n            }\n        }\n        if (isSuperset(keys, new Set([\"text\", \"generation_info\", \"type\"]))) {\n            if (obj.type === \"ChatGenerationChunk\") {\n                return new outputs_js_1.ChatGenerationChunk({\n                    message: revive(obj.message),\n                    text: obj.text,\n                    generationInfo: obj.generation_info,\n                });\n            }\n            else if (obj.type === \"ChatGeneration\") {\n                return {\n                    message: revive(obj.message),\n                    text: obj.text,\n                    generationInfo: obj.generation_info,\n                };\n            }\n            else if (obj.type === \"GenerationChunk\") {\n                return new outputs_js_1.GenerationChunk({\n                    text: obj.text,\n                    generationInfo: obj.generation_info,\n                });\n            }\n            else if (obj.type === \"Generation\") {\n                return {\n                    text: obj.text,\n                    generationInfo: obj.generation_info,\n                };\n            }\n        }\n        if (isSuperset(keys, new Set([\"tool\", \"tool_input\", \"log\", \"type\"]))) {\n            if (obj.type === \"AgentAction\") {\n                return {\n                    tool: obj.tool,\n                    toolInput: obj.tool_input,\n                    log: obj.log,\n                };\n            }\n        }\n        if (isSuperset(keys, new Set([\"return_values\", \"log\", \"type\"]))) {\n            if (obj.type === \"AgentFinish\") {\n                return {\n                    returnValues: obj.return_values,\n                    log: obj.log,\n                };\n            }\n        }\n        if (isSuperset(keys, new Set([\"generations\", \"run\", \"type\"]))) {\n            if (obj.type === \"LLMResult\") {\n                return {\n                    generations: revive(obj.generations),\n                    llmOutput: obj.llm_output,\n                    [outputs_js_1.RUN_KEY]: obj.run,\n                };\n            }\n        }\n        if (isSuperset(keys, new Set([\"messages\"]))) {\n            // TODO: Start checking for type: ChatPromptValue and ChatPromptValueConcrete\n            // when LangServe bug is fixed\n            return new prompt_values_js_1.ChatPromptValue({\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                messages: obj.messages.map((msg) => revive(msg)),\n            });\n        }\n        if (isSuperset(keys, new Set([\"text\"]))) {\n            // TODO: Start checking for type: StringPromptValue\n            // when LangServe bug is fixed\n            return new prompt_values_js_1.StringPromptValue(obj.text);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const innerRevive = (key) => [\n            key,\n            revive(obj[key]),\n        ];\n        const rtn = Object.fromEntries(keysArr.map(innerRevive));\n        return rtn;\n    }\n    return obj;\n}\nfunction deserialize(str) {\n    const obj = JSON.parse(str);\n    return revive(obj);\n}\nfunction removeCallbacksAndSignal(options) {\n    const rest = { ...options };\n    delete rest.callbacks;\n    delete rest.signal;\n    return rest;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction serialize(input) {\n    if (Array.isArray(input))\n        return input.map(serialize);\n    if ((0, index_js_2.isBaseMessage)(input)) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const serializedMessage = {\n            content: input.content,\n            type: input._getType(),\n            additional_kwargs: input.additional_kwargs,\n            name: input.name,\n            example: false,\n        };\n        if (index_js_2.ToolMessage.isInstance(input)) {\n            serializedMessage.tool_call_id = input.tool_call_id;\n        }\n        else if (index_js_2.ChatMessage.isInstance(input)) {\n            serializedMessage.role = input.role;\n        }\n        return serializedMessage;\n    }\n    if (typeof input === \"object\") {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (!input || input instanceof Date) {\n            return input;\n        }\n        const keysArr = Object.keys(input);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const innerSerialize = (key) => [\n            key,\n            serialize(input[key]),\n        ];\n        const rtn = Object.fromEntries(keysArr.map(innerSerialize));\n        return rtn;\n    }\n    return input;\n}\n/**\n * Client for interacting with LangChain runnables\n * that are hosted as LangServe endpoints.\n *\n * Allows you to interact with hosted runnables using the standard\n * `.invoke()`, `.stream()`, `.streamEvents()`, etc. methods that\n * other runnables support.\n *\n * @deprecated LangServe is no longer actively developed - please consider using LangGraph Platform.\n *\n * @param url - The base URL of the LangServe endpoint.\n * @param options - Optional configuration for the remote runnable, including timeout and headers.\n * @param fetch - Optional custom fetch implementation.\n * @param fetchRequestOptions - Optional additional options for fetch requests.\n */\nclass RemoteRunnable extends base_js_1.Runnable {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"url\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"options\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // Wrap the default fetch call due to issues with illegal invocations\n        // from the browser:\n        // https://stackoverflow.com/questions/69876859/why-does-bind-fix-failed-to-execute-fetch-on-window-illegal-invocation-err\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"fetchImplementation\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: (...args) => \n            // @ts-expect-error Broad typing to support a range of fetch implementations\n            fetch(...args)\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"fetchRequestOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"schema\", \"runnable\", \"remote\"]\n        });\n        const { url, options, fetch: fetchImplementation, fetchRequestOptions, } = fields;\n        this.url = url.replace(/\\/$/, \"\"); // remove trailing slash\n        this.options = options;\n        this.fetchImplementation = fetchImplementation ?? this.fetchImplementation;\n        this.fetchRequestOptions = fetchRequestOptions;\n    }\n    async post(path, body, signal) {\n        return this.fetchImplementation(`${this.url}${path}`, {\n            method: \"POST\",\n            body: JSON.stringify(serialize(body)),\n            signal: signal ?? AbortSignal.timeout(this.options?.timeout ?? 60000),\n            ...this.fetchRequestOptions,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...this.fetchRequestOptions?.headers,\n                ...this.options?.headers,\n            },\n        });\n    }\n    async _invoke(input, options, _) {\n        const [config, kwargs] = this._separateRunnableConfigFromCallOptions(options);\n        const response = await this.post(\"/invoke\", {\n            input,\n            config: removeCallbacksAndSignal(config),\n            kwargs: kwargs ?? {},\n        }, config.signal);\n        if (!response.ok) {\n            throw new Error(`${response.status} Error: ${await response.text()}`);\n        }\n        return revive((await response.json()).output);\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(this._invoke, input, options);\n    }\n    async _batch(inputs, options, _, batchOptions) {\n        if (batchOptions?.returnExceptions) {\n            throw new Error(\"returnExceptions is not supported for remote clients\");\n        }\n        const configsAndKwargsArray = options?.map((opts) => this._separateRunnableConfigFromCallOptions(opts));\n        const [configs, kwargs] = configsAndKwargsArray?.reduce(([pc, pk], [c, k]) => [\n            [...pc, c],\n            [...pk, k],\n        ], [[], []]) ?? [undefined, undefined];\n        const response = await this.post(\"/batch\", {\n            inputs,\n            config: (configs ?? [])\n                .map(removeCallbacksAndSignal)\n                .map((config) => ({ ...config, ...batchOptions })),\n            kwargs,\n        }, options?.[0]?.signal);\n        if (!response.ok) {\n            throw new Error(`${response.status} Error: ${await response.text()}`);\n        }\n        const body = await response.json();\n        if (!body.output)\n            throw new Error(\"Invalid response from remote runnable\");\n        return revive(body.output);\n    }\n    async batch(inputs, options, batchOptions) {\n        if (batchOptions?.returnExceptions) {\n            throw Error(\"returnExceptions is not supported for remote clients\");\n        }\n        return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);\n    }\n    async *_streamIterator(input, options) {\n        const [config, kwargs] = this._separateRunnableConfigFromCallOptions(options);\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(options);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), (0, base_js_1._coerceToDict)(input, \"input\"), config.runId, undefined, undefined, undefined, config.runName);\n        delete config.runId;\n        let finalOutput;\n        let finalOutputSupported = true;\n        try {\n            const response = await this.post(\"/stream\", {\n                input,\n                config: removeCallbacksAndSignal(config),\n                kwargs,\n            }, config.signal);\n            if (!response.ok) {\n                const json = await response.json();\n                const error = new Error(`RemoteRunnable call failed with status code ${response.status}: ${json.message}`);\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                error.response = response;\n                throw error;\n            }\n            const { body } = response;\n            if (!body) {\n                throw new Error(\"Could not begin remote stream. Please check the given URL and try again.\");\n            }\n            const runnableStream = (0, event_source_parse_js_1.convertEventStreamToIterableReadableDataStream)(body);\n            for await (const chunk of runnableStream) {\n                const deserializedChunk = deserialize(chunk);\n                yield deserializedChunk;\n                if (finalOutputSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = deserializedChunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalOutput = (0, stream_js_1.concat)(finalOutput, deserializedChunk);\n                        }\n                        catch {\n                            finalOutput = undefined;\n                            finalOutputSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (err) {\n            await runManager?.handleChainError(err);\n            throw err;\n        }\n        await runManager?.handleChainEnd(finalOutput ?? {});\n    }\n    async *streamLog(input, options, streamOptions) {\n        const [config, kwargs] = this._separateRunnableConfigFromCallOptions(options);\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(options);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), (0, base_js_1._coerceToDict)(input, \"input\"), config.runId, undefined, undefined, undefined, config.runName);\n        delete config.runId;\n        // The type is in camelCase but the API only accepts snake_case.\n        const camelCaseStreamOptions = {\n            include_names: streamOptions?.includeNames,\n            include_types: streamOptions?.includeTypes,\n            include_tags: streamOptions?.includeTags,\n            exclude_names: streamOptions?.excludeNames,\n            exclude_types: streamOptions?.excludeTypes,\n            exclude_tags: streamOptions?.excludeTags,\n        };\n        let runLog;\n        try {\n            const response = await this.post(\"/stream_log\", {\n                input,\n                config: removeCallbacksAndSignal(config),\n                kwargs,\n                ...camelCaseStreamOptions,\n                diff: false,\n            }, config.signal);\n            const { body, ok } = response;\n            if (!ok) {\n                throw new Error(`${response.status} Error: ${await response.text()}`);\n            }\n            if (!body) {\n                throw new Error(\"Could not begin remote stream log. Please check the given URL and try again.\");\n            }\n            const runnableStream = (0, event_source_parse_js_1.convertEventStreamToIterableReadableDataStream)(body);\n            for await (const log of runnableStream) {\n                const chunk = revive(JSON.parse(log));\n                const logPatch = new log_stream_js_1.RunLogPatch({ ops: chunk.ops });\n                yield logPatch;\n                if (runLog === undefined) {\n                    runLog = log_stream_js_1.RunLog.fromRunLogPatch(logPatch);\n                }\n                else {\n                    runLog = runLog.concat(logPatch);\n                }\n            }\n        }\n        catch (err) {\n            await runManager?.handleChainError(err);\n            throw err;\n        }\n        await runManager?.handleChainEnd(runLog?.state.final_output);\n    }\n    _streamEvents(input, options, streamOptions) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const outerThis = this;\n        const generator = async function* () {\n            const [config, kwargs] = outerThis._separateRunnableConfigFromCallOptions(options);\n            const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(options);\n            const runManager = await callbackManager_?.handleChainStart(outerThis.toJSON(), (0, base_js_1._coerceToDict)(input, \"input\"), config.runId, undefined, undefined, undefined, config.runName);\n            delete config.runId;\n            // The type is in camelCase but the API only accepts snake_case.\n            const camelCaseStreamOptions = {\n                include_names: streamOptions?.includeNames,\n                include_types: streamOptions?.includeTypes,\n                include_tags: streamOptions?.includeTags,\n                exclude_names: streamOptions?.excludeNames,\n                exclude_types: streamOptions?.excludeTypes,\n                exclude_tags: streamOptions?.excludeTags,\n            };\n            const events = [];\n            try {\n                const response = await outerThis.post(\"/stream_events\", {\n                    input,\n                    config: removeCallbacksAndSignal(config),\n                    kwargs,\n                    ...camelCaseStreamOptions,\n                    diff: false,\n                }, config.signal);\n                const { body, ok } = response;\n                if (!ok) {\n                    throw new Error(`${response.status} Error: ${await response.text()}`);\n                }\n                if (!body) {\n                    throw new Error(\"Could not begin remote stream events. Please check the given URL and try again.\");\n                }\n                const runnableStream = (0, event_source_parse_js_1.convertEventStreamToIterableReadableDataStream)(body);\n                for await (const log of runnableStream) {\n                    const chunk = revive(JSON.parse(log));\n                    const event = {\n                        event: chunk.event,\n                        name: chunk.name,\n                        run_id: chunk.run_id,\n                        tags: chunk.tags,\n                        metadata: chunk.metadata,\n                        data: chunk.data,\n                    };\n                    yield event;\n                    events.push(event);\n                }\n            }\n            catch (err) {\n                await runManager?.handleChainError(err);\n                throw err;\n            }\n            await runManager?.handleChainEnd(events);\n        };\n        return generator();\n    }\n    streamEvents(input, options, streamOptions) {\n        if (options.version !== \"v1\" && options.version !== \"v2\") {\n            throw new Error(`Only versions \"v1\" and \"v2\" of the events schema is currently supported.`);\n        }\n        if (options.encoding !== undefined) {\n            throw new Error(\"Special encodings are not supported for this runnable.\");\n        }\n        const eventStream = this._streamEvents(input, options, streamOptions);\n        return stream_js_1.IterableReadableStream.fromAsyncGenerator(eventStream);\n    }\n}\nexports.RemoteRunnable = RemoteRunnable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL3JlbW90ZS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCLGtCQUFrQixtQkFBTyxDQUFDLGdGQUFZO0FBQ3RDLG9CQUFvQixtQkFBTyxDQUFDLG9GQUFjO0FBQzFDLG1CQUFtQixtQkFBTyxDQUFDLDZGQUF3QjtBQUNuRCwyQkFBMkIsbUJBQU8sQ0FBQyx5RkFBc0I7QUFDekQsd0JBQXdCLG1CQUFPLENBQUMsbUdBQTJCO0FBQzNELG1CQUFtQixtQkFBTyxDQUFDLDJGQUF1QjtBQUNsRCxxQkFBcUIsbUJBQU8sQ0FBQyw2RUFBZ0I7QUFDN0MsZ0NBQWdDLG1CQUFPLENBQUMsK0dBQWlDO0FBQ3pFLG9CQUFvQixtQkFBTyxDQUFDLHVGQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdCQUFnQixpRUFBaUU7QUFDakYsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUyxFQUFFLEtBQUs7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLFNBQVM7QUFDVDtBQUNBLCtCQUErQixpQkFBaUIsU0FBUyxzQkFBc0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNEJBQTRCO0FBQ2hFO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0JBQStCLGlCQUFpQixTQUFTLHNCQUFzQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHVGQUF1RixnQkFBZ0IsSUFBSSxhQUFhO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixvQkFBb0IsV0FBVztBQUMvQjtBQUNBLG1DQUFtQyxpQkFBaUIsU0FBUyxzQkFBc0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsZ0JBQWdCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0EsdUNBQXVDLGlCQUFpQixTQUFTLHNCQUFzQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL3JlbW90ZS5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlbW90ZVJ1bm5hYmxlID0gdm9pZCAwO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG5jb25zdCBjb25maWdfanNfMSA9IHJlcXVpcmUoXCIuL2NvbmZpZy5janNcIik7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2RvY3VtZW50cy9pbmRleC5janNcIik7XG5jb25zdCBwcm9tcHRfdmFsdWVzX2pzXzEgPSByZXF1aXJlKFwiLi4vcHJvbXB0X3ZhbHVlcy5janNcIik7XG5jb25zdCBsb2dfc3RyZWFtX2pzXzEgPSByZXF1aXJlKFwiLi4vdHJhY2Vycy9sb2dfc3RyZWFtLmNqc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vbWVzc2FnZXMvaW5kZXguY2pzXCIpO1xuY29uc3Qgb3V0cHV0c19qc18xID0gcmVxdWlyZShcIi4uL291dHB1dHMuY2pzXCIpO1xuY29uc3QgZXZlbnRfc291cmNlX3BhcnNlX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvZXZlbnRfc291cmNlX3BhcnNlLmNqc1wiKTtcbmNvbnN0IHN0cmVhbV9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL3N0cmVhbS5janNcIik7XG5mdW5jdGlvbiBpc1N1cGVyc2V0KHNldCwgc3Vic2V0KSB7XG4gICAgZm9yIChjb25zdCBlbGVtIG9mIHN1YnNldCkge1xuICAgICAgICBpZiAoIXNldC5oYXMoZWxlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiByZXZpdmUob2JqKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSlcbiAgICAgICAgcmV0dXJuIG9iai5tYXAocmV2aXZlKTtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgIGlmICghb2JqIHx8IG9iaiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5c0FyciA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KGtleXNBcnIpO1xuICAgICAgICBpZiAoaXNTdXBlcnNldChrZXlzLCBuZXcgU2V0KFtcInBhZ2VfY29udGVudFwiLCBcIm1ldGFkYXRhXCJdKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfanNfMS5Eb2N1bWVudCh7XG4gICAgICAgICAgICAgICAgcGFnZUNvbnRlbnQ6IG9iai5wYWdlX2NvbnRlbnQsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG9iai5tZXRhZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N1cGVyc2V0KGtleXMsIG5ldyBTZXQoW1wiY29udGVudFwiLCBcInR5cGVcIiwgXCJhZGRpdGlvbmFsX2t3YXJnc1wiXSkpKSB7XG4gICAgICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwiSHVtYW5NZXNzYWdlXCIgfHwgb2JqLnR5cGUgPT09IFwiaHVtYW5cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfanNfMi5IdW1hbk1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBvYmouY29udGVudCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJTeXN0ZW1NZXNzYWdlXCIgfHwgb2JqLnR5cGUgPT09IFwic3lzdGVtXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4X2pzXzIuU3lzdGVtTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG9iai5jb250ZW50LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iai50eXBlID09PSBcIkNoYXRNZXNzYWdlXCIgfHwgb2JqLnR5cGUgPT09IFwiZ2VuZXJpY1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF9qc18yLkNoYXRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogb2JqLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHJvbGU6IG9iai5yb2xlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iai50eXBlID09PSBcIkZ1bmN0aW9uTWVzc2FnZVwiIHx8IG9iai50eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4X2pzXzIuRnVuY3Rpb25NZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogb2JqLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG9iai5uYW1lLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iai50eXBlID09PSBcIlRvb2xNZXNzYWdlXCIgfHwgb2JqLnR5cGUgPT09IFwidG9vbFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF9qc18yLlRvb2xNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogb2JqLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHRvb2xfY2FsbF9pZDogb2JqLnRvb2xfY2FsbF9pZCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBvYmouc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBhcnRpZmFjdDogb2JqLmFydGlmYWN0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iai50eXBlID09PSBcIkFJTWVzc2FnZVwiIHx8IG9iai50eXBlID09PSBcImFpXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4X2pzXzIuQUlNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogb2JqLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwiSHVtYW5NZXNzYWdlQ2h1bmtcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfanNfMi5IdW1hbk1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG9iai5jb250ZW50LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iai50eXBlID09PSBcIlN5c3RlbU1lc3NhZ2VDaHVua1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF9qc18yLlN5c3RlbU1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG9iai5jb250ZW50LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iai50eXBlID09PSBcIkNoYXRNZXNzYWdlQ2h1bmtcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfanNfMi5DaGF0TWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogb2JqLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHJvbGU6IG9iai5yb2xlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iai50eXBlID09PSBcIkZ1bmN0aW9uTWVzc2FnZUNodW5rXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4X2pzXzIuRnVuY3Rpb25NZXNzYWdlQ2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBvYmouY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogb2JqLm5hbWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwiVG9vbE1lc3NhZ2VDaHVua1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF9qc18yLlRvb2xNZXNzYWdlQ2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBvYmouY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgdG9vbF9jYWxsX2lkOiBvYmoudG9vbF9jYWxsX2lkLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IG9iai5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIGFydGlmYWN0OiBvYmouYXJ0aWZhY3QsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwiQUlNZXNzYWdlQ2h1bmtcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfanNfMi5BSU1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG9iai5jb250ZW50LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N1cGVyc2V0KGtleXMsIG5ldyBTZXQoW1widGV4dFwiLCBcImdlbmVyYXRpb25faW5mb1wiLCBcInR5cGVcIl0pKSkge1xuICAgICAgICAgICAgaWYgKG9iai50eXBlID09PSBcIkNoYXRHZW5lcmF0aW9uQ2h1bmtcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgb3V0cHV0c19qc18xLkNoYXRHZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiByZXZpdmUob2JqLm1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBvYmoudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbkluZm86IG9iai5nZW5lcmF0aW9uX2luZm8sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvYmoudHlwZSA9PT0gXCJDaGF0R2VuZXJhdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogcmV2aXZlKG9iai5tZXNzYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogb2JqLnRleHQsXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb25JbmZvOiBvYmouZ2VuZXJhdGlvbl9pbmZvLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvYmoudHlwZSA9PT0gXCJHZW5lcmF0aW9uQ2h1bmtcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgb3V0cHV0c19qc18xLkdlbmVyYXRpb25DaHVuayh7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IG9iai50ZXh0LFxuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uSW5mbzogb2JqLmdlbmVyYXRpb25faW5mbyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9iai50eXBlID09PSBcIkdlbmVyYXRpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IG9iai50ZXh0LFxuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uSW5mbzogb2JqLmdlbmVyYXRpb25faW5mbyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N1cGVyc2V0KGtleXMsIG5ldyBTZXQoW1widG9vbFwiLCBcInRvb2xfaW5wdXRcIiwgXCJsb2dcIiwgXCJ0eXBlXCJdKSkpIHtcbiAgICAgICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJBZ2VudEFjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbDogb2JqLnRvb2wsXG4gICAgICAgICAgICAgICAgICAgIHRvb2xJbnB1dDogb2JqLnRvb2xfaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIGxvZzogb2JqLmxvZyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N1cGVyc2V0KGtleXMsIG5ldyBTZXQoW1wicmV0dXJuX3ZhbHVlc1wiLCBcImxvZ1wiLCBcInR5cGVcIl0pKSkge1xuICAgICAgICAgICAgaWYgKG9iai50eXBlID09PSBcIkFnZW50RmluaXNoXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZXM6IG9iai5yZXR1cm5fdmFsdWVzLFxuICAgICAgICAgICAgICAgICAgICBsb2c6IG9iai5sb2csXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdXBlcnNldChrZXlzLCBuZXcgU2V0KFtcImdlbmVyYXRpb25zXCIsIFwicnVuXCIsIFwidHlwZVwiXSkpKSB7XG4gICAgICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwiTExNUmVzdWx0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uczogcmV2aXZlKG9iai5nZW5lcmF0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgIGxsbU91dHB1dDogb2JqLmxsbV9vdXRwdXQsXG4gICAgICAgICAgICAgICAgICAgIFtvdXRwdXRzX2pzXzEuUlVOX0tFWV06IG9iai5ydW4sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdXBlcnNldChrZXlzLCBuZXcgU2V0KFtcIm1lc3NhZ2VzXCJdKSkpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFN0YXJ0IGNoZWNraW5nIGZvciB0eXBlOiBDaGF0UHJvbXB0VmFsdWUgYW5kIENoYXRQcm9tcHRWYWx1ZUNvbmNyZXRlXG4gICAgICAgICAgICAvLyB3aGVuIExhbmdTZXJ2ZSBidWcgaXMgZml4ZWRcbiAgICAgICAgICAgIHJldHVybiBuZXcgcHJvbXB0X3ZhbHVlc19qc18xLkNoYXRQcm9tcHRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBtZXNzYWdlczogb2JqLm1lc3NhZ2VzLm1hcCgobXNnKSA9PiByZXZpdmUobXNnKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdXBlcnNldChrZXlzLCBuZXcgU2V0KFtcInRleHRcIl0pKSkge1xuICAgICAgICAgICAgLy8gVE9ETzogU3RhcnQgY2hlY2tpbmcgZm9yIHR5cGU6IFN0cmluZ1Byb21wdFZhbHVlXG4gICAgICAgICAgICAvLyB3aGVuIExhbmdTZXJ2ZSBidWcgaXMgZml4ZWRcbiAgICAgICAgICAgIHJldHVybiBuZXcgcHJvbXB0X3ZhbHVlc19qc18xLlN0cmluZ1Byb21wdFZhbHVlKG9iai50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBpbm5lclJldml2ZSA9IChrZXkpID0+IFtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHJldml2ZShvYmpba2V5XSksXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHJ0biA9IE9iamVjdC5mcm9tRW50cmllcyhrZXlzQXJyLm1hcChpbm5lclJldml2ZSkpO1xuICAgICAgICByZXR1cm4gcnRuO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemUoc3RyKSB7XG4gICAgY29uc3Qgb2JqID0gSlNPTi5wYXJzZShzdHIpO1xuICAgIHJldHVybiByZXZpdmUob2JqKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUNhbGxiYWNrc0FuZFNpZ25hbChvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdCA9IHsgLi4ub3B0aW9ucyB9O1xuICAgIGRlbGV0ZSByZXN0LmNhbGxiYWNrcztcbiAgICBkZWxldGUgcmVzdC5zaWduYWw7XG4gICAgcmV0dXJuIHJlc3Q7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gc2VyaWFsaXplKGlucHV0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKVxuICAgICAgICByZXR1cm4gaW5wdXQubWFwKHNlcmlhbGl6ZSk7XG4gICAgaWYgKCgwLCBpbmRleF9qc18yLmlzQmFzZU1lc3NhZ2UpKGlucHV0KSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBzZXJpYWxpemVkTWVzc2FnZSA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IGlucHV0LmNvbnRlbnQsXG4gICAgICAgICAgICB0eXBlOiBpbnB1dC5fZ2V0VHlwZSgpLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IGlucHV0LmFkZGl0aW9uYWxfa3dhcmdzLFxuICAgICAgICAgICAgbmFtZTogaW5wdXQubmFtZSxcbiAgICAgICAgICAgIGV4YW1wbGU6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaW5kZXhfanNfMi5Ub29sTWVzc2FnZS5pc0luc3RhbmNlKGlucHV0KSkge1xuICAgICAgICAgICAgc2VyaWFsaXplZE1lc3NhZ2UudG9vbF9jYWxsX2lkID0gaW5wdXQudG9vbF9jYWxsX2lkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluZGV4X2pzXzIuQ2hhdE1lc3NhZ2UuaXNJbnN0YW5jZShpbnB1dCkpIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRNZXNzYWdlLnJvbGUgPSBpbnB1dC5yb2xlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVkTWVzc2FnZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgIGlmICghaW5wdXQgfHwgaW5wdXQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5c0FyciA9IE9iamVjdC5rZXlzKGlucHV0KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgaW5uZXJTZXJpYWxpemUgPSAoa2V5KSA9PiBbXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBzZXJpYWxpemUoaW5wdXRba2V5XSksXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHJ0biA9IE9iamVjdC5mcm9tRW50cmllcyhrZXlzQXJyLm1hcChpbm5lclNlcmlhbGl6ZSkpO1xuICAgICAgICByZXR1cm4gcnRuO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXQ7XG59XG4vKipcbiAqIENsaWVudCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBMYW5nQ2hhaW4gcnVubmFibGVzXG4gKiB0aGF0IGFyZSBob3N0ZWQgYXMgTGFuZ1NlcnZlIGVuZHBvaW50cy5cbiAqXG4gKiBBbGxvd3MgeW91IHRvIGludGVyYWN0IHdpdGggaG9zdGVkIHJ1bm5hYmxlcyB1c2luZyB0aGUgc3RhbmRhcmRcbiAqIGAuaW52b2tlKClgLCBgLnN0cmVhbSgpYCwgYC5zdHJlYW1FdmVudHMoKWAsIGV0Yy4gbWV0aG9kcyB0aGF0XG4gKiBvdGhlciBydW5uYWJsZXMgc3VwcG9ydC5cbiAqXG4gKiBAZGVwcmVjYXRlZCBMYW5nU2VydmUgaXMgbm8gbG9uZ2VyIGFjdGl2ZWx5IGRldmVsb3BlZCAtIHBsZWFzZSBjb25zaWRlciB1c2luZyBMYW5nR3JhcGggUGxhdGZvcm0uXG4gKlxuICogQHBhcmFtIHVybCAtIFRoZSBiYXNlIFVSTCBvZiB0aGUgTGFuZ1NlcnZlIGVuZHBvaW50LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIGZvciB0aGUgcmVtb3RlIHJ1bm5hYmxlLCBpbmNsdWRpbmcgdGltZW91dCBhbmQgaGVhZGVycy5cbiAqIEBwYXJhbSBmZXRjaCAtIE9wdGlvbmFsIGN1c3RvbSBmZXRjaCBpbXBsZW1lbnRhdGlvbi5cbiAqIEBwYXJhbSBmZXRjaFJlcXVlc3RPcHRpb25zIC0gT3B0aW9uYWwgYWRkaXRpb25hbCBvcHRpb25zIGZvciBmZXRjaCByZXF1ZXN0cy5cbiAqL1xuY2xhc3MgUmVtb3RlUnVubmFibGUgZXh0ZW5kcyBiYXNlX2pzXzEuUnVubmFibGUge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1cmxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3B0aW9uc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXcmFwIHRoZSBkZWZhdWx0IGZldGNoIGNhbGwgZHVlIHRvIGlzc3VlcyB3aXRoIGlsbGVnYWwgaW52b2NhdGlvbnNcbiAgICAgICAgLy8gZnJvbSB0aGUgYnJvd3NlcjpcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjk4NzY4NTkvd2h5LWRvZXMtYmluZC1maXgtZmFpbGVkLXRvLWV4ZWN1dGUtZmV0Y2gtb24td2luZG93LWlsbGVnYWwtaW52b2NhdGlvbi1lcnJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmV0Y2hJbXBsZW1lbnRhdGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogKC4uLmFyZ3MpID0+IFxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBCcm9hZCB0eXBpbmcgdG8gc3VwcG9ydCBhIHJhbmdlIG9mIGZldGNoIGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgICAgZmV0Y2goLi4uYXJncylcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZldGNoUmVxdWVzdE9wdGlvbnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5cIiwgXCJzY2hlbWFcIiwgXCJydW5uYWJsZVwiLCBcInJlbW90ZVwiXVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyB1cmwsIG9wdGlvbnMsIGZldGNoOiBmZXRjaEltcGxlbWVudGF0aW9uLCBmZXRjaFJlcXVlc3RPcHRpb25zLCB9ID0gZmllbGRzO1xuICAgICAgICB0aGlzLnVybCA9IHVybC5yZXBsYWNlKC9cXC8kLywgXCJcIik7IC8vIHJlbW92ZSB0cmFpbGluZyBzbGFzaFxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmZldGNoSW1wbGVtZW50YXRpb24gPSBmZXRjaEltcGxlbWVudGF0aW9uID8/IHRoaXMuZmV0Y2hJbXBsZW1lbnRhdGlvbjtcbiAgICAgICAgdGhpcy5mZXRjaFJlcXVlc3RPcHRpb25zID0gZmV0Y2hSZXF1ZXN0T3B0aW9ucztcbiAgICB9XG4gICAgYXN5bmMgcG9zdChwYXRoLCBib2R5LCBzaWduYWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hJbXBsZW1lbnRhdGlvbihgJHt0aGlzLnVybH0ke3BhdGh9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHNlcmlhbGl6ZShib2R5KSksXG4gICAgICAgICAgICBzaWduYWw6IHNpZ25hbCA/PyBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMub3B0aW9ucz8udGltZW91dCA/PyA2MDAwMCksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaFJlcXVlc3RPcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucz8uaGVhZGVycyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfaW52b2tlKGlucHV0LCBvcHRpb25zLCBfKSB7XG4gICAgICAgIGNvbnN0IFtjb25maWcsIGt3YXJnc10gPSB0aGlzLl9zZXBhcmF0ZVJ1bm5hYmxlQ29uZmlnRnJvbUNhbGxPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucG9zdChcIi9pbnZva2VcIiwge1xuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBjb25maWc6IHJlbW92ZUNhbGxiYWNrc0FuZFNpZ25hbChjb25maWcpLFxuICAgICAgICAgICAga3dhcmdzOiBrd2FyZ3MgPz8ge30sXG4gICAgICAgIH0sIGNvbmZpZy5zaWduYWwpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVzcG9uc2Uuc3RhdHVzfSBFcnJvcjogJHthd2FpdCByZXNwb25zZS50ZXh0KCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldml2ZSgoYXdhaXQgcmVzcG9uc2UuanNvbigpKS5vdXRwdXQpO1xuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxXaXRoQ29uZmlnKHRoaXMuX2ludm9rZSwgaW5wdXQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBfYmF0Y2goaW5wdXRzLCBvcHRpb25zLCBfLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGJhdGNoT3B0aW9ucz8ucmV0dXJuRXhjZXB0aW9ucykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmV0dXJuRXhjZXB0aW9ucyBpcyBub3Qgc3VwcG9ydGVkIGZvciByZW1vdGUgY2xpZW50c1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWdzQW5kS3dhcmdzQXJyYXkgPSBvcHRpb25zPy5tYXAoKG9wdHMpID0+IHRoaXMuX3NlcGFyYXRlUnVubmFibGVDb25maWdGcm9tQ2FsbE9wdGlvbnMob3B0cykpO1xuICAgICAgICBjb25zdCBbY29uZmlncywga3dhcmdzXSA9IGNvbmZpZ3NBbmRLd2FyZ3NBcnJheT8ucmVkdWNlKChbcGMsIHBrXSwgW2MsIGtdKSA9PiBbXG4gICAgICAgICAgICBbLi4ucGMsIGNdLFxuICAgICAgICAgICAgWy4uLnBrLCBrXSxcbiAgICAgICAgXSwgW1tdLCBbXV0pID8/IFt1bmRlZmluZWQsIHVuZGVmaW5lZF07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wb3N0KFwiL2JhdGNoXCIsIHtcbiAgICAgICAgICAgIGlucHV0cyxcbiAgICAgICAgICAgIGNvbmZpZzogKGNvbmZpZ3MgPz8gW10pXG4gICAgICAgICAgICAgICAgLm1hcChyZW1vdmVDYWxsYmFja3NBbmRTaWduYWwpXG4gICAgICAgICAgICAgICAgLm1hcCgoY29uZmlnKSA9PiAoeyAuLi5jb25maWcsIC4uLmJhdGNoT3B0aW9ucyB9KSksXG4gICAgICAgICAgICBrd2FyZ3MsXG4gICAgICAgIH0sIG9wdGlvbnM/LlswXT8uc2lnbmFsKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3Jlc3BvbnNlLnN0YXR1c30gRXJyb3I6ICR7YXdhaXQgcmVzcG9uc2UudGV4dCgpfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmICghYm9keS5vdXRwdXQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIGZyb20gcmVtb3RlIHJ1bm5hYmxlXCIpO1xuICAgICAgICByZXR1cm4gcmV2aXZlKGJvZHkub3V0cHV0KTtcbiAgICB9XG4gICAgYXN5bmMgYmF0Y2goaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGJhdGNoT3B0aW9ucz8ucmV0dXJuRXhjZXB0aW9ucykge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJyZXR1cm5FeGNlcHRpb25zIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHJlbW90ZSBjbGllbnRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9iYXRjaFdpdGhDb25maWcodGhpcy5fYmF0Y2guYmluZCh0aGlzKSwgaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IFtjb25maWcsIGt3YXJnc10gPSB0aGlzLl9zZXBhcmF0ZVJ1bm5hYmxlQ29uZmlnRnJvbUNhbGxPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgKDAsIGNvbmZpZ19qc18xLmdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZykob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksICgwLCBiYXNlX2pzXzEuX2NvZXJjZVRvRGljdCkoaW5wdXQsIFwiaW5wdXRcIiksIGNvbmZpZy5ydW5JZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29uZmlnLnJ1bk5hbWUpO1xuICAgICAgICBkZWxldGUgY29uZmlnLnJ1bklkO1xuICAgICAgICBsZXQgZmluYWxPdXRwdXQ7XG4gICAgICAgIGxldCBmaW5hbE91dHB1dFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucG9zdChcIi9zdHJlYW1cIiwge1xuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGNvbmZpZzogcmVtb3ZlQ2FsbGJhY2tzQW5kU2lnbmFsKGNvbmZpZyksXG4gICAgICAgICAgICAgICAga3dhcmdzLFxuICAgICAgICAgICAgfSwgY29uZmlnLnNpZ25hbCk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgUmVtb3RlUnVubmFibGUgY2FsbCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAke3Jlc3BvbnNlLnN0YXR1c306ICR7anNvbi5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgYm9keSB9ID0gcmVzcG9uc2U7XG4gICAgICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgYmVnaW4gcmVtb3RlIHN0cmVhbS4gUGxlYXNlIGNoZWNrIHRoZSBnaXZlbiBVUkwgYW5kIHRyeSBhZ2Fpbi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBydW5uYWJsZVN0cmVhbSA9ICgwLCBldmVudF9zb3VyY2VfcGFyc2VfanNfMS5jb252ZXJ0RXZlbnRTdHJlYW1Ub0l0ZXJhYmxlUmVhZGFibGVEYXRhU3RyZWFtKShib2R5KTtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcnVubmFibGVTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZWRDaHVuayA9IGRlc2VyaWFsaXplKGNodW5rKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBkZXNlcmlhbGl6ZWRDaHVuaztcbiAgICAgICAgICAgICAgICBpZiAoZmluYWxPdXRwdXRTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsT3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gZGVzZXJpYWxpemVkQ2h1bms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSAoMCwgc3RyZWFtX2pzXzEuY29uY2F0KShmaW5hbE91dHB1dCwgZGVzZXJpYWxpemVkQ2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlcnIpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKGZpbmFsT3V0cHV0ID8/IHt9KTtcbiAgICB9XG4gICAgYXN5bmMgKnN0cmVhbUxvZyhpbnB1dCwgb3B0aW9ucywgc3RyZWFtT3B0aW9ucykge1xuICAgICAgICBjb25zdCBbY29uZmlnLCBrd2FyZ3NdID0gdGhpcy5fc2VwYXJhdGVSdW5uYWJsZUNvbmZpZ0Zyb21DYWxsT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0ICgwLCBjb25maWdfanNfMS5nZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcpKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VyID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCAoMCwgYmFzZV9qc18xLl9jb2VyY2VUb0RpY3QpKGlucHV0LCBcImlucHV0XCIpLCBjb25maWcucnVuSWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbmZpZy5ydW5OYW1lKTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5ydW5JZDtcbiAgICAgICAgLy8gVGhlIHR5cGUgaXMgaW4gY2FtZWxDYXNlIGJ1dCB0aGUgQVBJIG9ubHkgYWNjZXB0cyBzbmFrZV9jYXNlLlxuICAgICAgICBjb25zdCBjYW1lbENhc2VTdHJlYW1PcHRpb25zID0ge1xuICAgICAgICAgICAgaW5jbHVkZV9uYW1lczogc3RyZWFtT3B0aW9ucz8uaW5jbHVkZU5hbWVzLFxuICAgICAgICAgICAgaW5jbHVkZV90eXBlczogc3RyZWFtT3B0aW9ucz8uaW5jbHVkZVR5cGVzLFxuICAgICAgICAgICAgaW5jbHVkZV90YWdzOiBzdHJlYW1PcHRpb25zPy5pbmNsdWRlVGFncyxcbiAgICAgICAgICAgIGV4Y2x1ZGVfbmFtZXM6IHN0cmVhbU9wdGlvbnM/LmV4Y2x1ZGVOYW1lcyxcbiAgICAgICAgICAgIGV4Y2x1ZGVfdHlwZXM6IHN0cmVhbU9wdGlvbnM/LmV4Y2x1ZGVUeXBlcyxcbiAgICAgICAgICAgIGV4Y2x1ZGVfdGFnczogc3RyZWFtT3B0aW9ucz8uZXhjbHVkZVRhZ3MsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBydW5Mb2c7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucG9zdChcIi9zdHJlYW1fbG9nXCIsIHtcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBjb25maWc6IHJlbW92ZUNhbGxiYWNrc0FuZFNpZ25hbChjb25maWcpLFxuICAgICAgICAgICAgICAgIGt3YXJncyxcbiAgICAgICAgICAgICAgICAuLi5jYW1lbENhc2VTdHJlYW1PcHRpb25zLFxuICAgICAgICAgICAgICAgIGRpZmY6IGZhbHNlLFxuICAgICAgICAgICAgfSwgY29uZmlnLnNpZ25hbCk7XG4gICAgICAgICAgICBjb25zdCB7IGJvZHksIG9rIH0gPSByZXNwb25zZTtcbiAgICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVzcG9uc2Uuc3RhdHVzfSBFcnJvcjogJHthd2FpdCByZXNwb25zZS50ZXh0KCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgYmVnaW4gcmVtb3RlIHN0cmVhbSBsb2cuIFBsZWFzZSBjaGVjayB0aGUgZ2l2ZW4gVVJMIGFuZCB0cnkgYWdhaW4uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcnVubmFibGVTdHJlYW0gPSAoMCwgZXZlbnRfc291cmNlX3BhcnNlX2pzXzEuY29udmVydEV2ZW50U3RyZWFtVG9JdGVyYWJsZVJlYWRhYmxlRGF0YVN0cmVhbSkoYm9keSk7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGxvZyBvZiBydW5uYWJsZVN0cmVhbSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gcmV2aXZlKEpTT04ucGFyc2UobG9nKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9nUGF0Y2ggPSBuZXcgbG9nX3N0cmVhbV9qc18xLlJ1bkxvZ1BhdGNoKHsgb3BzOiBjaHVuay5vcHMgfSk7XG4gICAgICAgICAgICAgICAgeWllbGQgbG9nUGF0Y2g7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bkxvZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bkxvZyA9IGxvZ19zdHJlYW1fanNfMS5SdW5Mb2cuZnJvbVJ1bkxvZ1BhdGNoKGxvZ1BhdGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bkxvZyA9IHJ1bkxvZy5jb25jYXQobG9nUGF0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGVycik7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQocnVuTG9nPy5zdGF0ZS5maW5hbF9vdXRwdXQpO1xuICAgIH1cbiAgICBfc3RyZWFtRXZlbnRzKGlucHV0LCBvcHRpb25zLCBzdHJlYW1PcHRpb25zKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICBjb25zdCBvdXRlclRoaXMgPSB0aGlzO1xuICAgICAgICBjb25zdCBnZW5lcmF0b3IgPSBhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgW2NvbmZpZywga3dhcmdzXSA9IG91dGVyVGhpcy5fc2VwYXJhdGVSdW5uYWJsZUNvbmZpZ0Zyb21DYWxsT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCAoMCwgY29uZmlnX2pzXzEuZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKShvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KG91dGVyVGhpcy50b0pTT04oKSwgKDAsIGJhc2VfanNfMS5fY29lcmNlVG9EaWN0KShpbnB1dCwgXCJpbnB1dFwiKSwgY29uZmlnLnJ1bklkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb25maWcucnVuTmFtZSk7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLnJ1bklkO1xuICAgICAgICAgICAgLy8gVGhlIHR5cGUgaXMgaW4gY2FtZWxDYXNlIGJ1dCB0aGUgQVBJIG9ubHkgYWNjZXB0cyBzbmFrZV9jYXNlLlxuICAgICAgICAgICAgY29uc3QgY2FtZWxDYXNlU3RyZWFtT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBpbmNsdWRlX25hbWVzOiBzdHJlYW1PcHRpb25zPy5pbmNsdWRlTmFtZXMsXG4gICAgICAgICAgICAgICAgaW5jbHVkZV90eXBlczogc3RyZWFtT3B0aW9ucz8uaW5jbHVkZVR5cGVzLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVfdGFnczogc3RyZWFtT3B0aW9ucz8uaW5jbHVkZVRhZ3MsXG4gICAgICAgICAgICAgICAgZXhjbHVkZV9uYW1lczogc3RyZWFtT3B0aW9ucz8uZXhjbHVkZU5hbWVzLFxuICAgICAgICAgICAgICAgIGV4Y2x1ZGVfdHlwZXM6IHN0cmVhbU9wdGlvbnM/LmV4Y2x1ZGVUeXBlcyxcbiAgICAgICAgICAgICAgICBleGNsdWRlX3RhZ3M6IHN0cmVhbU9wdGlvbnM/LmV4Y2x1ZGVUYWdzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IFtdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG91dGVyVGhpcy5wb3N0KFwiL3N0cmVhbV9ldmVudHNcIiwge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnOiByZW1vdmVDYWxsYmFja3NBbmRTaWduYWwoY29uZmlnKSxcbiAgICAgICAgICAgICAgICAgICAga3dhcmdzLFxuICAgICAgICAgICAgICAgICAgICAuLi5jYW1lbENhc2VTdHJlYW1PcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBkaWZmOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LCBjb25maWcuc2lnbmFsKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGJvZHksIG9rIH0gPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtyZXNwb25zZS5zdGF0dXN9IEVycm9yOiAke2F3YWl0IHJlc3BvbnNlLnRleHQoKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBiZWdpbiByZW1vdGUgc3RyZWFtIGV2ZW50cy4gUGxlYXNlIGNoZWNrIHRoZSBnaXZlbiBVUkwgYW5kIHRyeSBhZ2Fpbi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bm5hYmxlU3RyZWFtID0gKDAsIGV2ZW50X3NvdXJjZV9wYXJzZV9qc18xLmNvbnZlcnRFdmVudFN0cmVhbVRvSXRlcmFibGVSZWFkYWJsZURhdGFTdHJlYW0pKGJvZHkpO1xuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgbG9nIG9mIHJ1bm5hYmxlU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gcmV2aXZlKEpTT04ucGFyc2UobG9nKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGNodW5rLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogY2h1bmsubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bl9pZDogY2h1bmsucnVuX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnczogY2h1bmsudGFncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBjaHVuay5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGNodW5rLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICBldmVudHMucHVzaChldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChldmVudHMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZ2VuZXJhdG9yKCk7XG4gICAgfVxuICAgIHN0cmVhbUV2ZW50cyhpbnB1dCwgb3B0aW9ucywgc3RyZWFtT3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy52ZXJzaW9uICE9PSBcInYxXCIgJiYgb3B0aW9ucy52ZXJzaW9uICE9PSBcInYyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT25seSB2ZXJzaW9ucyBcInYxXCIgYW5kIFwidjJcIiBvZiB0aGUgZXZlbnRzIHNjaGVtYSBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNwZWNpYWwgZW5jb2RpbmdzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciB0aGlzIHJ1bm5hYmxlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmVudFN0cmVhbSA9IHRoaXMuX3N0cmVhbUV2ZW50cyhpbnB1dCwgb3B0aW9ucywgc3RyZWFtT3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBzdHJlYW1fanNfMS5JdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21Bc3luY0dlbmVyYXRvcihldmVudFN0cmVhbSk7XG4gICAgfVxufVxuZXhwb3J0cy5SZW1vdGVSdW5uYWJsZSA9IFJlbW90ZVJ1bm5hYmxlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/remote.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/router.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/router.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RouterRunnable = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nconst config_js_1 = __webpack_require__(/*! ./config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\n/**\n * A runnable that routes to a set of runnables based on Input['key'].\n * Returns the output of the selected runnable.\n * @example\n * ```typescript\n * import { RouterRunnable, RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const router = new RouterRunnable({\n *   runnables: {\n *     toUpperCase: RunnableLambda.from((text: string) => text.toUpperCase()),\n *     reverseText: RunnableLambda.from((text: string) =>\n *       text.split(\"\").reverse().join(\"\")\n *     ),\n *   },\n * });\n *\n * // Invoke the 'reverseText' runnable\n * const result1 = router.invoke({ key: \"reverseText\", input: \"Hello World\" });\n *\n * // \"dlroW olleH\"\n *\n * // Invoke the 'toUpperCase' runnable\n * const result2 = router.invoke({ key: \"toUpperCase\", input: \"Hello World\" });\n *\n * // \"HELLO WORLD\"\n * ```\n */\nclass RouterRunnable extends base_js_1.Runnable {\n    static lc_name() {\n        return \"RouterRunnable\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"runnables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnables = fields.runnables;\n    }\n    async invoke(input, options) {\n        const { key, input: actualInput } = input;\n        const runnable = this.runnables[key];\n        if (runnable === undefined) {\n            throw new Error(`No runnable associated with key \"${key}\".`);\n        }\n        return runnable.invoke(actualInput, (0, config_js_1.ensureConfig)(options));\n    }\n    async batch(inputs, options, batchOptions) {\n        const keys = inputs.map((input) => input.key);\n        const actualInputs = inputs.map((input) => input.input);\n        const missingKey = keys.find((key) => this.runnables[key] === undefined);\n        if (missingKey !== undefined) {\n            throw new Error(`One or more keys do not have a corresponding runnable.`);\n        }\n        const runnables = keys.map((key) => this.runnables[key]);\n        const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n        const maxConcurrency = optionsList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n        const batchSize = maxConcurrency && maxConcurrency > 0 ? maxConcurrency : inputs.length;\n        const batchResults = [];\n        for (let i = 0; i < actualInputs.length; i += batchSize) {\n            const batchPromises = actualInputs\n                .slice(i, i + batchSize)\n                .map((actualInput, i) => runnables[i].invoke(actualInput, optionsList[i]));\n            const batchResult = await Promise.all(batchPromises);\n            batchResults.push(batchResult);\n        }\n        return batchResults.flat();\n    }\n    async stream(input, options) {\n        const { key, input: actualInput } = input;\n        const runnable = this.runnables[key];\n        if (runnable === undefined) {\n            throw new Error(`No runnable associated with key \"${key}\".`);\n        }\n        return runnable.stream(actualInput, options);\n    }\n}\nexports.RouterRunnable = RouterRunnable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL3JvdXRlci5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCLGtCQUFrQixtQkFBTyxDQUFDLGdGQUFZO0FBQ3RDLG9CQUFvQixtQkFBTyxDQUFDLG9GQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlDQUFpQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBLG1DQUFtQywwQ0FBMEM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMENBQTBDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBCQUEwQjtBQUMxQztBQUNBO0FBQ0EsZ0VBQWdFLElBQUk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQTtBQUNBLGdFQUFnRSxJQUFJO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL3JvdXRlci5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJvdXRlclJ1bm5hYmxlID0gdm9pZCAwO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG5jb25zdCBjb25maWdfanNfMSA9IHJlcXVpcmUoXCIuL2NvbmZpZy5janNcIik7XG4vKipcbiAqIEEgcnVubmFibGUgdGhhdCByb3V0ZXMgdG8gYSBzZXQgb2YgcnVubmFibGVzIGJhc2VkIG9uIElucHV0WydrZXknXS5cbiAqIFJldHVybnMgdGhlIG91dHB1dCBvZiB0aGUgc2VsZWN0ZWQgcnVubmFibGUuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgUm91dGVyUnVubmFibGUsIFJ1bm5hYmxlTGFtYmRhIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXNcIjtcbiAqXG4gKiBjb25zdCByb3V0ZXIgPSBuZXcgUm91dGVyUnVubmFibGUoe1xuICogICBydW5uYWJsZXM6IHtcbiAqICAgICB0b1VwcGVyQ2FzZTogUnVubmFibGVMYW1iZGEuZnJvbSgodGV4dDogc3RyaW5nKSA9PiB0ZXh0LnRvVXBwZXJDYXNlKCkpLFxuICogICAgIHJldmVyc2VUZXh0OiBSdW5uYWJsZUxhbWJkYS5mcm9tKCh0ZXh0OiBzdHJpbmcpID0+XG4gKiAgICAgICB0ZXh0LnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpXG4gKiAgICAgKSxcbiAqICAgfSxcbiAqIH0pO1xuICpcbiAqIC8vIEludm9rZSB0aGUgJ3JldmVyc2VUZXh0JyBydW5uYWJsZVxuICogY29uc3QgcmVzdWx0MSA9IHJvdXRlci5pbnZva2UoeyBrZXk6IFwicmV2ZXJzZVRleHRcIiwgaW5wdXQ6IFwiSGVsbG8gV29ybGRcIiB9KTtcbiAqXG4gKiAvLyBcImRscm9XIG9sbGVIXCJcbiAqXG4gKiAvLyBJbnZva2UgdGhlICd0b1VwcGVyQ2FzZScgcnVubmFibGVcbiAqIGNvbnN0IHJlc3VsdDIgPSByb3V0ZXIuaW52b2tlKHsga2V5OiBcInRvVXBwZXJDYXNlXCIsIGlucHV0OiBcIkhlbGxvIFdvcmxkXCIgfSk7XG4gKlxuICogLy8gXCJIRUxMTyBXT1JMRFwiXG4gKiBgYGBcbiAqL1xuY2xhc3MgUm91dGVyUnVubmFibGUgZXh0ZW5kcyBiYXNlX2pzXzEuUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSb3V0ZXJSdW5uYWJsZVwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5uYWJsZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ydW5uYWJsZXMgPSBmaWVsZHMucnVubmFibGVzO1xuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBrZXksIGlucHV0OiBhY3R1YWxJbnB1dCB9ID0gaW5wdXQ7XG4gICAgICAgIGNvbnN0IHJ1bm5hYmxlID0gdGhpcy5ydW5uYWJsZXNba2V5XTtcbiAgICAgICAgaWYgKHJ1bm5hYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcnVubmFibGUgYXNzb2NpYXRlZCB3aXRoIGtleSBcIiR7a2V5fVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW5uYWJsZS5pbnZva2UoYWN0dWFsSW5wdXQsICgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpKTtcbiAgICB9XG4gICAgYXN5bmMgYmF0Y2goaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IGlucHV0cy5tYXAoKGlucHV0KSA9PiBpbnB1dC5rZXkpO1xuICAgICAgICBjb25zdCBhY3R1YWxJbnB1dHMgPSBpbnB1dHMubWFwKChpbnB1dCkgPT4gaW5wdXQuaW5wdXQpO1xuICAgICAgICBjb25zdCBtaXNzaW5nS2V5ID0ga2V5cy5maW5kKChrZXkpID0+IHRoaXMucnVubmFibGVzW2tleV0gPT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChtaXNzaW5nS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT25lIG9yIG1vcmUga2V5cyBkbyBub3QgaGF2ZSBhIGNvcnJlc3BvbmRpbmcgcnVubmFibGUuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVubmFibGVzID0ga2V5cy5tYXAoKGtleSkgPT4gdGhpcy5ydW5uYWJsZXNba2V5XSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnNMaXN0ID0gdGhpcy5fZ2V0T3B0aW9uc0xpc3Qob3B0aW9ucyA/PyB7fSwgaW5wdXRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IG1heENvbmN1cnJlbmN5ID0gb3B0aW9uc0xpc3RbMF0/Lm1heENvbmN1cnJlbmN5ID8/IGJhdGNoT3B0aW9ucz8ubWF4Q29uY3VycmVuY3k7XG4gICAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IG1heENvbmN1cnJlbmN5ICYmIG1heENvbmN1cnJlbmN5ID4gMCA/IG1heENvbmN1cnJlbmN5IDogaW5wdXRzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgYmF0Y2hSZXN1bHRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0dWFsSW5wdXRzLmxlbmd0aDsgaSArPSBiYXRjaFNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoUHJvbWlzZXMgPSBhY3R1YWxJbnB1dHNcbiAgICAgICAgICAgICAgICAuc2xpY2UoaSwgaSArIGJhdGNoU2l6ZSlcbiAgICAgICAgICAgICAgICAubWFwKChhY3R1YWxJbnB1dCwgaSkgPT4gcnVubmFibGVzW2ldLmludm9rZShhY3R1YWxJbnB1dCwgb3B0aW9uc0xpc3RbaV0pKTtcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoUmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwoYmF0Y2hQcm9taXNlcyk7XG4gICAgICAgICAgICBiYXRjaFJlc3VsdHMucHVzaChiYXRjaFJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhdGNoUmVzdWx0cy5mbGF0KCk7XG4gICAgfVxuICAgIGFzeW5jIHN0cmVhbShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGtleSwgaW5wdXQ6IGFjdHVhbElucHV0IH0gPSBpbnB1dDtcbiAgICAgICAgY29uc3QgcnVubmFibGUgPSB0aGlzLnJ1bm5hYmxlc1trZXldO1xuICAgICAgICBpZiAocnVubmFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBydW5uYWJsZSBhc3NvY2lhdGVkIHdpdGgga2V5IFwiJHtrZXl9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bm5hYmxlLnN0cmVhbShhY3R1YWxJbnB1dCwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5Sb3V0ZXJSdW5uYWJsZSA9IFJvdXRlclJ1bm5hYmxlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/router.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/utils.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/utils.cjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports._RootEventFilter = void 0;\nexports.isRunnableInterface = isRunnableInterface;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isRunnableInterface(thing) {\n    return thing ? thing.lc_runnable : false;\n}\n/**\n * Utility to filter the root event in the streamEvents implementation.\n * This is simply binding the arguments to the namespace to make save on\n * a bit of typing in the streamEvents implementation.\n *\n * TODO: Refactor and remove.\n */\nclass _RootEventFilter {\n    constructor(fields) {\n        Object.defineProperty(this, \"includeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.includeNames = fields.includeNames;\n        this.includeTypes = fields.includeTypes;\n        this.includeTags = fields.includeTags;\n        this.excludeNames = fields.excludeNames;\n        this.excludeTypes = fields.excludeTypes;\n        this.excludeTags = fields.excludeTags;\n    }\n    includeEvent(event, rootType) {\n        let include = this.includeNames === undefined &&\n            this.includeTypes === undefined &&\n            this.includeTags === undefined;\n        const eventTags = event.tags ?? [];\n        if (this.includeNames !== undefined) {\n            include = include || this.includeNames.includes(event.name);\n        }\n        if (this.includeTypes !== undefined) {\n            include = include || this.includeTypes.includes(rootType);\n        }\n        if (this.includeTags !== undefined) {\n            include =\n                include || eventTags.some((tag) => this.includeTags?.includes(tag));\n        }\n        if (this.excludeNames !== undefined) {\n            include = include && !this.excludeNames.includes(event.name);\n        }\n        if (this.excludeTypes !== undefined) {\n            include = include && !this.excludeTypes.includes(rootType);\n        }\n        if (this.excludeTags !== undefined) {\n            include =\n                include && eventTags.every((tag) => !this.excludeTags?.includes(tag));\n        }\n        return include;\n    }\n}\nexports._RootEventFilter = _RootEventFilter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL3V0aWxzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3J1bm5hYmxlcy91dGlscy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLl9Sb290RXZlbnRGaWx0ZXIgPSB2b2lkIDA7XG5leHBvcnRzLmlzUnVubmFibGVJbnRlcmZhY2UgPSBpc1J1bm5hYmxlSW50ZXJmYWNlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGlzUnVubmFibGVJbnRlcmZhY2UodGhpbmcpIHtcbiAgICByZXR1cm4gdGhpbmcgPyB0aGluZy5sY19ydW5uYWJsZSA6IGZhbHNlO1xufVxuLyoqXG4gKiBVdGlsaXR5IHRvIGZpbHRlciB0aGUgcm9vdCBldmVudCBpbiB0aGUgc3RyZWFtRXZlbnRzIGltcGxlbWVudGF0aW9uLlxuICogVGhpcyBpcyBzaW1wbHkgYmluZGluZyB0aGUgYXJndW1lbnRzIHRvIHRoZSBuYW1lc3BhY2UgdG8gbWFrZSBzYXZlIG9uXG4gKiBhIGJpdCBvZiB0eXBpbmcgaW4gdGhlIHN0cmVhbUV2ZW50cyBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBUT0RPOiBSZWZhY3RvciBhbmQgcmVtb3ZlLlxuICovXG5jbGFzcyBfUm9vdEV2ZW50RmlsdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5jbHVkZU5hbWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluY2x1ZGVUeXBlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmNsdWRlVGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGNsdWRlTmFtZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhjbHVkZVR5cGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4Y2x1ZGVUYWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5jbHVkZU5hbWVzID0gZmllbGRzLmluY2x1ZGVOYW1lcztcbiAgICAgICAgdGhpcy5pbmNsdWRlVHlwZXMgPSBmaWVsZHMuaW5jbHVkZVR5cGVzO1xuICAgICAgICB0aGlzLmluY2x1ZGVUYWdzID0gZmllbGRzLmluY2x1ZGVUYWdzO1xuICAgICAgICB0aGlzLmV4Y2x1ZGVOYW1lcyA9IGZpZWxkcy5leGNsdWRlTmFtZXM7XG4gICAgICAgIHRoaXMuZXhjbHVkZVR5cGVzID0gZmllbGRzLmV4Y2x1ZGVUeXBlcztcbiAgICAgICAgdGhpcy5leGNsdWRlVGFncyA9IGZpZWxkcy5leGNsdWRlVGFncztcbiAgICB9XG4gICAgaW5jbHVkZUV2ZW50KGV2ZW50LCByb290VHlwZSkge1xuICAgICAgICBsZXQgaW5jbHVkZSA9IHRoaXMuaW5jbHVkZU5hbWVzID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZVR5cGVzID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZVRhZ3MgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZXZlbnRUYWdzID0gZXZlbnQudGFncyA/PyBbXTtcbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZU5hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlIHx8IHRoaXMuaW5jbHVkZU5hbWVzLmluY2x1ZGVzKGV2ZW50Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSB8fCB0aGlzLmluY2x1ZGVUeXBlcy5pbmNsdWRlcyhyb290VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZVRhZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9XG4gICAgICAgICAgICAgICAgaW5jbHVkZSB8fCBldmVudFRhZ3Muc29tZSgodGFnKSA9PiB0aGlzLmluY2x1ZGVUYWdzPy5pbmNsdWRlcyh0YWcpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leGNsdWRlTmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGluY2x1ZGUgJiYgIXRoaXMuZXhjbHVkZU5hbWVzLmluY2x1ZGVzKGV2ZW50Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSAmJiAhdGhpcy5leGNsdWRlVHlwZXMuaW5jbHVkZXMocm9vdFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVUYWdzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPVxuICAgICAgICAgICAgICAgIGluY2x1ZGUgJiYgZXZlbnRUYWdzLmV2ZXJ5KCh0YWcpID0+ICF0aGlzLmV4Y2x1ZGVUYWdzPy5pbmNsdWRlcyh0YWcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5jbHVkZTtcbiAgICB9XG59XG5leHBvcnRzLl9Sb290RXZlbnRGaWx0ZXIgPSBfUm9vdEV2ZW50RmlsdGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/utils.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/wrappers.cjs":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/wrappers.cjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.convertToHttpEventStream = convertToHttpEventStream;\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\nfunction convertToHttpEventStream(stream) {\n    const encoder = new TextEncoder();\n    const finalStream = new ReadableStream({\n        async start(controller) {\n            for await (const chunk of stream) {\n                controller.enqueue(encoder.encode(`event: data\\ndata: ${JSON.stringify(chunk)}\\n\\n`));\n            }\n            controller.enqueue(encoder.encode(\"event: end\\n\\n\"));\n            controller.close();\n        },\n    });\n    return stream_js_1.IterableReadableStream.fromReadableStream(finalStream);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL3dyYXBwZXJzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0M7QUFDaEMsb0JBQW9CLG1CQUFPLENBQUMsdUZBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0Usc0JBQXNCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3J1bm5hYmxlcy93cmFwcGVycy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbnZlcnRUb0h0dHBFdmVudFN0cmVhbSA9IGNvbnZlcnRUb0h0dHBFdmVudFN0cmVhbTtcbmNvbnN0IHN0cmVhbV9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL3N0cmVhbS5janNcIik7XG5mdW5jdGlvbiBjb252ZXJ0VG9IdHRwRXZlbnRTdHJlYW0oc3RyZWFtKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGZpbmFsU3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoYGV2ZW50OiBkYXRhXFxuZGF0YTogJHtKU09OLnN0cmluZ2lmeShjaHVuayl9XFxuXFxuYCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZXIuZW5jb2RlKFwiZXZlbnQ6IGVuZFxcblxcblwiKSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cmVhbV9qc18xLkl0ZXJhYmxlUmVhZGFibGVTdHJlYW0uZnJvbVJlYWRhYmxlU3RyZWFtKGZpbmFsU3RyZWFtKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/wrappers.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/context.cjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/singletons/async_local_storage/context.cjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.registerConfigureHook = exports._getConfigureHooks = void 0;\nexports.setContextVariable = setContextVariable;\nexports.getContextVariable = getContextVariable;\nconst run_trees_1 = __webpack_require__(/*! langsmith/run_trees */ \"(rsc)/./node_modules/langsmith/run_trees.cjs\");\nconst globals_js_1 = __webpack_require__(/*! ./globals.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/globals.cjs\");\n/**\n * Set a context variable. Context variables are scoped to any\n * child runnables called by the current runnable, or globally if set outside\n * of any runnable.\n *\n * @remarks\n * This function is only supported in environments that support AsyncLocalStorage,\n * including Node.js, Deno, and Cloudflare Workers.\n *\n * @example\n * ```ts\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n * import {\n *   getContextVariable,\n *   setContextVariable\n * } from \"@langchain/core/context\";\n *\n * const nested = RunnableLambda.from(() => {\n *   // \"bar\" because it was set by a parent\n *   console.log(getContextVariable(\"foo\"));\n *\n *   // Override to \"baz\", but only for child runnables\n *   setContextVariable(\"foo\", \"baz\");\n *\n *   // Now \"baz\", but only for child runnables\n *   return getContextVariable(\"foo\");\n * });\n *\n * const runnable = RunnableLambda.from(async () => {\n *   // Set a context variable named \"foo\"\n *   setContextVariable(\"foo\", \"bar\");\n *\n *   const res = await nested.invoke({});\n *\n *   // Still \"bar\" since child changes do not affect parents\n *   console.log(getContextVariable(\"foo\"));\n *\n *   return res;\n * });\n *\n * // undefined, because context variable has not been set yet\n * console.log(getContextVariable(\"foo\"));\n *\n * // Final return value is \"baz\"\n * const result = await runnable.invoke({});\n * ```\n *\n * @param name The name of the context variable.\n * @param value The value to set.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setContextVariable(name, value) {\n    // Avoid using global singleton due to circuluar dependency issues\n    const asyncLocalStorageInstance = (0, globals_js_1.getGlobalAsyncLocalStorageInstance)();\n    if (asyncLocalStorageInstance === undefined) {\n        throw new Error(`Internal error: Global shared async local storage instance has not been initialized.`);\n    }\n    const runTree = asyncLocalStorageInstance.getStore();\n    const contextVars = { ...runTree?.[globals_js_1._CONTEXT_VARIABLES_KEY] };\n    contextVars[name] = value;\n    let newValue = {};\n    if ((0, run_trees_1.isRunTree)(runTree)) {\n        newValue = new run_trees_1.RunTree(runTree);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    newValue[globals_js_1._CONTEXT_VARIABLES_KEY] = contextVars;\n    asyncLocalStorageInstance.enterWith(newValue);\n}\n/**\n * Get the value of a previously set context variable. Context variables\n * are scoped to any child runnables called by the current runnable,\n * or globally if set outside of any runnable.\n *\n * @remarks\n * This function is only supported in environments that support AsyncLocalStorage,\n * including Node.js, Deno, and Cloudflare Workers.\n *\n * @example\n * ```ts\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n * import {\n *   getContextVariable,\n *   setContextVariable\n * } from \"@langchain/core/context\";\n *\n * const nested = RunnableLambda.from(() => {\n *   // \"bar\" because it was set by a parent\n *   console.log(getContextVariable(\"foo\"));\n *\n *   // Override to \"baz\", but only for child runnables\n *   setContextVariable(\"foo\", \"baz\");\n *\n *   // Now \"baz\", but only for child runnables\n *   return getContextVariable(\"foo\");\n * });\n *\n * const runnable = RunnableLambda.from(async () => {\n *   // Set a context variable named \"foo\"\n *   setContextVariable(\"foo\", \"bar\");\n *\n *   const res = await nested.invoke({});\n *\n *   // Still \"bar\" since child changes do not affect parents\n *   console.log(getContextVariable(\"foo\"));\n *\n *   return res;\n * });\n *\n * // undefined, because context variable has not been set yet\n * console.log(getContextVariable(\"foo\"));\n *\n * // Final return value is \"baz\"\n * const result = await runnable.invoke({});\n * ```\n *\n * @param name The name of the context variable.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getContextVariable(name) {\n    // Avoid using global singleton due to circuluar dependency issues\n    const asyncLocalStorageInstance = (0, globals_js_1.getGlobalAsyncLocalStorageInstance)();\n    if (asyncLocalStorageInstance === undefined) {\n        return undefined;\n    }\n    const runTree = asyncLocalStorageInstance.getStore();\n    return runTree?.[globals_js_1._CONTEXT_VARIABLES_KEY]?.[name];\n}\nconst LC_CONFIGURE_HOOKS_KEY = Symbol(\"lc:configure_hooks\");\nconst _getConfigureHooks = () => getContextVariable(LC_CONFIGURE_HOOKS_KEY) || [];\nexports._getConfigureHooks = _getConfigureHooks;\n/**\n * Register a callback configure hook to automatically add callback handlers to all runs.\n *\n * There are two ways to use this:\n *\n * 1. Using a context variable:\n *    - Set `contextVar` to specify the variable name\n *    - Use `setContextVariable()` to store your handler instance\n *\n * 2. Using an environment variable:\n *    - Set both `envVar` and `handlerClass`\n *    - The handler will be instantiated when the env var is set to \"true\".\n *\n * @example\n * ```typescript\n * // Method 1: Using context variable\n * import {\n *   registerConfigureHook,\n *   setContextVariable\n * } from \"@langchain/core/context\";\n *\n * const tracer = new MyCallbackHandler();\n * registerConfigureHook({\n *   contextVar: \"my_tracer\",\n * });\n * setContextVariable(\"my_tracer\", tracer);\n *\n * // ...run code here\n *\n * // Method 2: Using environment variable\n * registerConfigureHook({\n *   handlerClass: MyCallbackHandler,\n *   envVar: \"MY_TRACER_ENABLED\",\n * });\n * process.env.MY_TRACER_ENABLED = \"true\";\n *\n * // ...run code here\n * ```\n *\n * @param config Configuration object for the hook\n * @param config.contextVar Name of the context variable containing the handler instance\n * @param config.inheritable Whether child runs should inherit this handler\n * @param config.handlerClass Optional callback handler class (required if using envVar)\n * @param config.envVar Optional environment variable name to control handler activation\n */\nconst registerConfigureHook = (config) => {\n    if (config.envVar && !config.handlerClass) {\n        throw new Error(\"If envVar is set, handlerClass must also be set to a non-None value.\");\n    }\n    setContextVariable(LC_CONFIGURE_HOOKS_KEY, [...(0, exports._getConfigureHooks)(), config]);\n};\nexports.registerConfigureHook = registerConfigureHook;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc2luZ2xldG9ucy9hc3luY19sb2NhbF9zdG9yYWdlL2NvbnRleHQuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QixHQUFHLDBCQUEwQjtBQUMxRCwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLG9CQUFvQixtQkFBTyxDQUFDLHlFQUFxQjtBQUNqRCxxQkFBcUIsbUJBQU8sQ0FBQywyR0FBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc2luZ2xldG9ucy9hc3luY19sb2NhbF9zdG9yYWdlL2NvbnRleHQuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWdpc3RlckNvbmZpZ3VyZUhvb2sgPSBleHBvcnRzLl9nZXRDb25maWd1cmVIb29rcyA9IHZvaWQgMDtcbmV4cG9ydHMuc2V0Q29udGV4dFZhcmlhYmxlID0gc2V0Q29udGV4dFZhcmlhYmxlO1xuZXhwb3J0cy5nZXRDb250ZXh0VmFyaWFibGUgPSBnZXRDb250ZXh0VmFyaWFibGU7XG5jb25zdCBydW5fdHJlZXNfMSA9IHJlcXVpcmUoXCJsYW5nc21pdGgvcnVuX3RyZWVzXCIpO1xuY29uc3QgZ2xvYmFsc19qc18xID0gcmVxdWlyZShcIi4vZ2xvYmFscy5janNcIik7XG4vKipcbiAqIFNldCBhIGNvbnRleHQgdmFyaWFibGUuIENvbnRleHQgdmFyaWFibGVzIGFyZSBzY29wZWQgdG8gYW55XG4gKiBjaGlsZCBydW5uYWJsZXMgY2FsbGVkIGJ5IHRoZSBjdXJyZW50IHJ1bm5hYmxlLCBvciBnbG9iYWxseSBpZiBzZXQgb3V0c2lkZVxuICogb2YgYW55IHJ1bm5hYmxlLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGluIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgQXN5bmNMb2NhbFN0b3JhZ2UsXG4gKiBpbmNsdWRpbmcgTm9kZS5qcywgRGVubywgYW5kIENsb3VkZmxhcmUgV29ya2Vycy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IFJ1bm5hYmxlTGFtYmRhIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXNcIjtcbiAqIGltcG9ydCB7XG4gKiAgIGdldENvbnRleHRWYXJpYWJsZSxcbiAqICAgc2V0Q29udGV4dFZhcmlhYmxlXG4gKiB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvY29udGV4dFwiO1xuICpcbiAqIGNvbnN0IG5lc3RlZCA9IFJ1bm5hYmxlTGFtYmRhLmZyb20oKCkgPT4ge1xuICogICAvLyBcImJhclwiIGJlY2F1c2UgaXQgd2FzIHNldCBieSBhIHBhcmVudFxuICogICBjb25zb2xlLmxvZyhnZXRDb250ZXh0VmFyaWFibGUoXCJmb29cIikpO1xuICpcbiAqICAgLy8gT3ZlcnJpZGUgdG8gXCJiYXpcIiwgYnV0IG9ubHkgZm9yIGNoaWxkIHJ1bm5hYmxlc1xuICogICBzZXRDb250ZXh0VmFyaWFibGUoXCJmb29cIiwgXCJiYXpcIik7XG4gKlxuICogICAvLyBOb3cgXCJiYXpcIiwgYnV0IG9ubHkgZm9yIGNoaWxkIHJ1bm5hYmxlc1xuICogICByZXR1cm4gZ2V0Q29udGV4dFZhcmlhYmxlKFwiZm9vXCIpO1xuICogfSk7XG4gKlxuICogY29uc3QgcnVubmFibGUgPSBSdW5uYWJsZUxhbWJkYS5mcm9tKGFzeW5jICgpID0+IHtcbiAqICAgLy8gU2V0IGEgY29udGV4dCB2YXJpYWJsZSBuYW1lZCBcImZvb1wiXG4gKiAgIHNldENvbnRleHRWYXJpYWJsZShcImZvb1wiLCBcImJhclwiKTtcbiAqXG4gKiAgIGNvbnN0IHJlcyA9IGF3YWl0IG5lc3RlZC5pbnZva2Uoe30pO1xuICpcbiAqICAgLy8gU3RpbGwgXCJiYXJcIiBzaW5jZSBjaGlsZCBjaGFuZ2VzIGRvIG5vdCBhZmZlY3QgcGFyZW50c1xuICogICBjb25zb2xlLmxvZyhnZXRDb250ZXh0VmFyaWFibGUoXCJmb29cIikpO1xuICpcbiAqICAgcmV0dXJuIHJlcztcbiAqIH0pO1xuICpcbiAqIC8vIHVuZGVmaW5lZCwgYmVjYXVzZSBjb250ZXh0IHZhcmlhYmxlIGhhcyBub3QgYmVlbiBzZXQgeWV0XG4gKiBjb25zb2xlLmxvZyhnZXRDb250ZXh0VmFyaWFibGUoXCJmb29cIikpO1xuICpcbiAqIC8vIEZpbmFsIHJldHVybiB2YWx1ZSBpcyBcImJhelwiXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBydW5uYWJsZS5pbnZva2Uoe30pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvbnRleHQgdmFyaWFibGUuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHNldENvbnRleHRWYXJpYWJsZShuYW1lLCB2YWx1ZSkge1xuICAgIC8vIEF2b2lkIHVzaW5nIGdsb2JhbCBzaW5nbGV0b24gZHVlIHRvIGNpcmN1bHVhciBkZXBlbmRlbmN5IGlzc3Vlc1xuICAgIGNvbnN0IGFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UgPSAoMCwgZ2xvYmFsc19qc18xLmdldEdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UpKCk7XG4gICAgaWYgKGFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIGVycm9yOiBHbG9iYWwgc2hhcmVkIGFzeW5jIGxvY2FsIHN0b3JhZ2UgaW5zdGFuY2UgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkLmApO1xuICAgIH1cbiAgICBjb25zdCBydW5UcmVlID0gYXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZS5nZXRTdG9yZSgpO1xuICAgIGNvbnN0IGNvbnRleHRWYXJzID0geyAuLi5ydW5UcmVlPy5bZ2xvYmFsc19qc18xLl9DT05URVhUX1ZBUklBQkxFU19LRVldIH07XG4gICAgY29udGV4dFZhcnNbbmFtZV0gPSB2YWx1ZTtcbiAgICBsZXQgbmV3VmFsdWUgPSB7fTtcbiAgICBpZiAoKDAsIHJ1bl90cmVlc18xLmlzUnVuVHJlZSkocnVuVHJlZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBuZXcgcnVuX3RyZWVzXzEuUnVuVHJlZShydW5UcmVlKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBuZXdWYWx1ZVtnbG9iYWxzX2pzXzEuX0NPTlRFWFRfVkFSSUFCTEVTX0tFWV0gPSBjb250ZXh0VmFycztcbiAgICBhc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlLmVudGVyV2l0aChuZXdWYWx1ZSk7XG59XG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYSBwcmV2aW91c2x5IHNldCBjb250ZXh0IHZhcmlhYmxlLiBDb250ZXh0IHZhcmlhYmxlc1xuICogYXJlIHNjb3BlZCB0byBhbnkgY2hpbGQgcnVubmFibGVzIGNhbGxlZCBieSB0aGUgY3VycmVudCBydW5uYWJsZSxcbiAqIG9yIGdsb2JhbGx5IGlmIHNldCBvdXRzaWRlIG9mIGFueSBydW5uYWJsZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBmdW5jdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBpbiBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IEFzeW5jTG9jYWxTdG9yYWdlLFxuICogaW5jbHVkaW5nIE5vZGUuanMsIERlbm8sIGFuZCBDbG91ZGZsYXJlIFdvcmtlcnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBSdW5uYWJsZUxhbWJkYSB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG4gKiBpbXBvcnQge1xuICogICBnZXRDb250ZXh0VmFyaWFibGUsXG4gKiAgIHNldENvbnRleHRWYXJpYWJsZVxuICogfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL2NvbnRleHRcIjtcbiAqXG4gKiBjb25zdCBuZXN0ZWQgPSBSdW5uYWJsZUxhbWJkYS5mcm9tKCgpID0+IHtcbiAqICAgLy8gXCJiYXJcIiBiZWNhdXNlIGl0IHdhcyBzZXQgYnkgYSBwYXJlbnRcbiAqICAgY29uc29sZS5sb2coZ2V0Q29udGV4dFZhcmlhYmxlKFwiZm9vXCIpKTtcbiAqXG4gKiAgIC8vIE92ZXJyaWRlIHRvIFwiYmF6XCIsIGJ1dCBvbmx5IGZvciBjaGlsZCBydW5uYWJsZXNcbiAqICAgc2V0Q29udGV4dFZhcmlhYmxlKFwiZm9vXCIsIFwiYmF6XCIpO1xuICpcbiAqICAgLy8gTm93IFwiYmF6XCIsIGJ1dCBvbmx5IGZvciBjaGlsZCBydW5uYWJsZXNcbiAqICAgcmV0dXJuIGdldENvbnRleHRWYXJpYWJsZShcImZvb1wiKTtcbiAqIH0pO1xuICpcbiAqIGNvbnN0IHJ1bm5hYmxlID0gUnVubmFibGVMYW1iZGEuZnJvbShhc3luYyAoKSA9PiB7XG4gKiAgIC8vIFNldCBhIGNvbnRleHQgdmFyaWFibGUgbmFtZWQgXCJmb29cIlxuICogICBzZXRDb250ZXh0VmFyaWFibGUoXCJmb29cIiwgXCJiYXJcIik7XG4gKlxuICogICBjb25zdCByZXMgPSBhd2FpdCBuZXN0ZWQuaW52b2tlKHt9KTtcbiAqXG4gKiAgIC8vIFN0aWxsIFwiYmFyXCIgc2luY2UgY2hpbGQgY2hhbmdlcyBkbyBub3QgYWZmZWN0IHBhcmVudHNcbiAqICAgY29uc29sZS5sb2coZ2V0Q29udGV4dFZhcmlhYmxlKFwiZm9vXCIpKTtcbiAqXG4gKiAgIHJldHVybiByZXM7XG4gKiB9KTtcbiAqXG4gKiAvLyB1bmRlZmluZWQsIGJlY2F1c2UgY29udGV4dCB2YXJpYWJsZSBoYXMgbm90IGJlZW4gc2V0IHlldFxuICogY29uc29sZS5sb2coZ2V0Q29udGV4dFZhcmlhYmxlKFwiZm9vXCIpKTtcbiAqXG4gKiAvLyBGaW5hbCByZXR1cm4gdmFsdWUgaXMgXCJiYXpcIlxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgcnVubmFibGUuaW52b2tlKHt9KTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjb250ZXh0IHZhcmlhYmxlLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gZ2V0Q29udGV4dFZhcmlhYmxlKG5hbWUpIHtcbiAgICAvLyBBdm9pZCB1c2luZyBnbG9iYWwgc2luZ2xldG9uIGR1ZSB0byBjaXJjdWx1YXIgZGVwZW5kZW5jeSBpc3N1ZXNcbiAgICBjb25zdCBhc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlID0gKDAsIGdsb2JhbHNfanNfMS5nZXRHbG9iYWxBc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlKSgpO1xuICAgIGlmIChhc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgcnVuVHJlZSA9IGFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UuZ2V0U3RvcmUoKTtcbiAgICByZXR1cm4gcnVuVHJlZT8uW2dsb2JhbHNfanNfMS5fQ09OVEVYVF9WQVJJQUJMRVNfS0VZXT8uW25hbWVdO1xufVxuY29uc3QgTENfQ09ORklHVVJFX0hPT0tTX0tFWSA9IFN5bWJvbChcImxjOmNvbmZpZ3VyZV9ob29rc1wiKTtcbmNvbnN0IF9nZXRDb25maWd1cmVIb29rcyA9ICgpID0+IGdldENvbnRleHRWYXJpYWJsZShMQ19DT05GSUdVUkVfSE9PS1NfS0VZKSB8fCBbXTtcbmV4cG9ydHMuX2dldENvbmZpZ3VyZUhvb2tzID0gX2dldENvbmZpZ3VyZUhvb2tzO1xuLyoqXG4gKiBSZWdpc3RlciBhIGNhbGxiYWNrIGNvbmZpZ3VyZSBob29rIHRvIGF1dG9tYXRpY2FsbHkgYWRkIGNhbGxiYWNrIGhhbmRsZXJzIHRvIGFsbCBydW5zLlxuICpcbiAqIFRoZXJlIGFyZSB0d28gd2F5cyB0byB1c2UgdGhpczpcbiAqXG4gKiAxLiBVc2luZyBhIGNvbnRleHQgdmFyaWFibGU6XG4gKiAgICAtIFNldCBgY29udGV4dFZhcmAgdG8gc3BlY2lmeSB0aGUgdmFyaWFibGUgbmFtZVxuICogICAgLSBVc2UgYHNldENvbnRleHRWYXJpYWJsZSgpYCB0byBzdG9yZSB5b3VyIGhhbmRsZXIgaW5zdGFuY2VcbiAqXG4gKiAyLiBVc2luZyBhbiBlbnZpcm9ubWVudCB2YXJpYWJsZTpcbiAqICAgIC0gU2V0IGJvdGggYGVudlZhcmAgYW5kIGBoYW5kbGVyQ2xhc3NgXG4gKiAgICAtIFRoZSBoYW5kbGVyIHdpbGwgYmUgaW5zdGFudGlhdGVkIHdoZW4gdGhlIGVudiB2YXIgaXMgc2V0IHRvIFwidHJ1ZVwiLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAvLyBNZXRob2QgMTogVXNpbmcgY29udGV4dCB2YXJpYWJsZVxuICogaW1wb3J0IHtcbiAqICAgcmVnaXN0ZXJDb25maWd1cmVIb29rLFxuICogICBzZXRDb250ZXh0VmFyaWFibGVcbiAqIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9jb250ZXh0XCI7XG4gKlxuICogY29uc3QgdHJhY2VyID0gbmV3IE15Q2FsbGJhY2tIYW5kbGVyKCk7XG4gKiByZWdpc3RlckNvbmZpZ3VyZUhvb2soe1xuICogICBjb250ZXh0VmFyOiBcIm15X3RyYWNlclwiLFxuICogfSk7XG4gKiBzZXRDb250ZXh0VmFyaWFibGUoXCJteV90cmFjZXJcIiwgdHJhY2VyKTtcbiAqXG4gKiAvLyAuLi5ydW4gY29kZSBoZXJlXG4gKlxuICogLy8gTWV0aG9kIDI6IFVzaW5nIGVudmlyb25tZW50IHZhcmlhYmxlXG4gKiByZWdpc3RlckNvbmZpZ3VyZUhvb2soe1xuICogICBoYW5kbGVyQ2xhc3M6IE15Q2FsbGJhY2tIYW5kbGVyLFxuICogICBlbnZWYXI6IFwiTVlfVFJBQ0VSX0VOQUJMRURcIixcbiAqIH0pO1xuICogcHJvY2Vzcy5lbnYuTVlfVFJBQ0VSX0VOQUJMRUQgPSBcInRydWVcIjtcbiAqXG4gKiAvLyAuLi5ydW4gY29kZSBoZXJlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gY29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgaG9va1xuICogQHBhcmFtIGNvbmZpZy5jb250ZXh0VmFyIE5hbWUgb2YgdGhlIGNvbnRleHQgdmFyaWFibGUgY29udGFpbmluZyB0aGUgaGFuZGxlciBpbnN0YW5jZVxuICogQHBhcmFtIGNvbmZpZy5pbmhlcml0YWJsZSBXaGV0aGVyIGNoaWxkIHJ1bnMgc2hvdWxkIGluaGVyaXQgdGhpcyBoYW5kbGVyXG4gKiBAcGFyYW0gY29uZmlnLmhhbmRsZXJDbGFzcyBPcHRpb25hbCBjYWxsYmFjayBoYW5kbGVyIGNsYXNzIChyZXF1aXJlZCBpZiB1c2luZyBlbnZWYXIpXG4gKiBAcGFyYW0gY29uZmlnLmVudlZhciBPcHRpb25hbCBlbnZpcm9ubWVudCB2YXJpYWJsZSBuYW1lIHRvIGNvbnRyb2wgaGFuZGxlciBhY3RpdmF0aW9uXG4gKi9cbmNvbnN0IHJlZ2lzdGVyQ29uZmlndXJlSG9vayA9IChjb25maWcpID0+IHtcbiAgICBpZiAoY29uZmlnLmVudlZhciAmJiAhY29uZmlnLmhhbmRsZXJDbGFzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJZiBlbnZWYXIgaXMgc2V0LCBoYW5kbGVyQ2xhc3MgbXVzdCBhbHNvIGJlIHNldCB0byBhIG5vbi1Ob25lIHZhbHVlLlwiKTtcbiAgICB9XG4gICAgc2V0Q29udGV4dFZhcmlhYmxlKExDX0NPTkZJR1VSRV9IT09LU19LRVksIFsuLi4oMCwgZXhwb3J0cy5fZ2V0Q29uZmlndXJlSG9va3MpKCksIGNvbmZpZ10pO1xufTtcbmV4cG9ydHMucmVnaXN0ZXJDb25maWd1cmVIb29rID0gcmVnaXN0ZXJDb25maWd1cmVIb29rO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/context.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/globals.cjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/singletons/async_local_storage/globals.cjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getGlobalAsyncLocalStorageInstance = exports.setGlobalAsyncLocalStorageInstance = exports._CONTEXT_VARIABLES_KEY = exports.TRACING_ALS_KEY = void 0;\nexports.TRACING_ALS_KEY = Symbol.for(\"ls:tracing_async_local_storage\");\nexports._CONTEXT_VARIABLES_KEY = Symbol.for(\"lc:context_variables\");\nconst setGlobalAsyncLocalStorageInstance = (instance) => {\n    globalThis[exports.TRACING_ALS_KEY] = instance;\n};\nexports.setGlobalAsyncLocalStorageInstance = setGlobalAsyncLocalStorageInstance;\nconst getGlobalAsyncLocalStorageInstance = () => {\n    return globalThis[exports.TRACING_ALS_KEY];\n};\nexports.getGlobalAsyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc2luZ2xldG9ucy9hc3luY19sb2NhbF9zdG9yYWdlL2dsb2JhbHMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBDQUEwQyxHQUFHLDBDQUEwQyxHQUFHLDhCQUE4QixHQUFHLHVCQUF1QjtBQUNsSix1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9zaW5nbGV0b25zL2FzeW5jX2xvY2FsX3N0b3JhZ2UvZ2xvYmFscy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UgPSBleHBvcnRzLnNldEdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UgPSBleHBvcnRzLl9DT05URVhUX1ZBUklBQkxFU19LRVkgPSBleHBvcnRzLlRSQUNJTkdfQUxTX0tFWSA9IHZvaWQgMDtcbmV4cG9ydHMuVFJBQ0lOR19BTFNfS0VZID0gU3ltYm9sLmZvcihcImxzOnRyYWNpbmdfYXN5bmNfbG9jYWxfc3RvcmFnZVwiKTtcbmV4cG9ydHMuX0NPTlRFWFRfVkFSSUFCTEVTX0tFWSA9IFN5bWJvbC5mb3IoXCJsYzpjb250ZXh0X3ZhcmlhYmxlc1wiKTtcbmNvbnN0IHNldEdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UgPSAoaW5zdGFuY2UpID0+IHtcbiAgICBnbG9iYWxUaGlzW2V4cG9ydHMuVFJBQ0lOR19BTFNfS0VZXSA9IGluc3RhbmNlO1xufTtcbmV4cG9ydHMuc2V0R2xvYmFsQXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZSA9IHNldEdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2U7XG5jb25zdCBnZXRHbG9iYWxBc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlID0gKCkgPT4ge1xuICAgIHJldHVybiBnbG9iYWxUaGlzW2V4cG9ydHMuVFJBQ0lOR19BTFNfS0VZXTtcbn07XG5leHBvcnRzLmdldEdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UgPSBnZXRHbG9iYWxBc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/globals.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/index.cjs":
/*!************************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/singletons/async_local_storage/index.cjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsyncLocalStorageProviderSingleton = exports.MockAsyncLocalStorage = void 0;\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst langsmith_1 = __webpack_require__(/*! langsmith */ \"(rsc)/./node_modules/langsmith/index.cjs\");\nconst globals_js_1 = __webpack_require__(/*! ./globals.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/globals.cjs\");\nconst manager_js_1 = __webpack_require__(/*! ../../callbacks/manager.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.cjs\");\nclass MockAsyncLocalStorage {\n    getStore() {\n        return undefined;\n    }\n    run(_store, callback) {\n        return callback();\n    }\n    enterWith(_store) {\n        return undefined;\n    }\n}\nexports.MockAsyncLocalStorage = MockAsyncLocalStorage;\nconst mockAsyncLocalStorage = new MockAsyncLocalStorage();\nconst LC_CHILD_KEY = Symbol.for(\"lc:child_config\");\nclass AsyncLocalStorageProvider {\n    getInstance() {\n        return (0, globals_js_1.getGlobalAsyncLocalStorageInstance)() ?? mockAsyncLocalStorage;\n    }\n    getRunnableConfig() {\n        const storage = this.getInstance();\n        // this has the runnable config\n        // which means that we should also have an instance of a LangChainTracer\n        // with the run map prepopulated\n        return storage.getStore()?.extra?.[LC_CHILD_KEY];\n    }\n    runWithConfig(config, callback, avoidCreatingRootRunTree) {\n        const callbackManager = manager_js_1.CallbackManager._configureSync(config?.callbacks, undefined, config?.tags, undefined, config?.metadata);\n        const storage = this.getInstance();\n        const previousValue = storage.getStore();\n        const parentRunId = callbackManager?.getParentRunId();\n        const langChainTracer = callbackManager?.handlers?.find((handler) => handler?.name === \"langchain_tracer\");\n        let runTree;\n        if (langChainTracer && parentRunId) {\n            runTree = langChainTracer.getRunTreeWithTracingConfig(parentRunId);\n        }\n        else if (!avoidCreatingRootRunTree) {\n            runTree = new langsmith_1.RunTree({\n                name: \"<runnable_lambda>\",\n                tracingEnabled: false,\n            });\n        }\n        if (runTree) {\n            runTree.extra = { ...runTree.extra, [LC_CHILD_KEY]: config };\n        }\n        if (previousValue !== undefined &&\n            previousValue[globals_js_1._CONTEXT_VARIABLES_KEY] !== undefined) {\n            if (runTree === undefined) {\n                runTree = {};\n            }\n            runTree[globals_js_1._CONTEXT_VARIABLES_KEY] =\n                previousValue[globals_js_1._CONTEXT_VARIABLES_KEY];\n        }\n        return storage.run(runTree, callback);\n    }\n    initializeGlobalInstance(instance) {\n        if ((0, globals_js_1.getGlobalAsyncLocalStorageInstance)() === undefined) {\n            (0, globals_js_1.setGlobalAsyncLocalStorageInstance)(instance);\n        }\n    }\n}\nconst AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();\nexports.AsyncLocalStorageProviderSingleton = AsyncLocalStorageProviderSingleton;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc2luZ2xldG9ucy9hc3luY19sb2NhbF9zdG9yYWdlL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQ0FBMEMsR0FBRyw2QkFBNkI7QUFDMUU7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQywyREFBVztBQUN2QyxxQkFBcUIsbUJBQU8sQ0FBQywyR0FBZTtBQUM1QyxxQkFBcUIsbUJBQU8sQ0FBQyxvR0FBNkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9zaW5nbGV0b25zL2FzeW5jX2xvY2FsX3N0b3JhZ2UvaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uID0gZXhwb3J0cy5Nb2NrQXN5bmNMb2NhbFN0b3JhZ2UgPSB2b2lkIDA7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5jb25zdCBsYW5nc21pdGhfMSA9IHJlcXVpcmUoXCJsYW5nc21pdGhcIik7XG5jb25zdCBnbG9iYWxzX2pzXzEgPSByZXF1aXJlKFwiLi9nbG9iYWxzLmNqc1wiKTtcbmNvbnN0IG1hbmFnZXJfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jYWxsYmFja3MvbWFuYWdlci5janNcIik7XG5jbGFzcyBNb2NrQXN5bmNMb2NhbFN0b3JhZ2Uge1xuICAgIGdldFN0b3JlKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBydW4oX3N0b3JlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgZW50ZXJXaXRoKF9zdG9yZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydHMuTW9ja0FzeW5jTG9jYWxTdG9yYWdlID0gTW9ja0FzeW5jTG9jYWxTdG9yYWdlO1xuY29uc3QgbW9ja0FzeW5jTG9jYWxTdG9yYWdlID0gbmV3IE1vY2tBc3luY0xvY2FsU3RvcmFnZSgpO1xuY29uc3QgTENfQ0hJTERfS0VZID0gU3ltYm9sLmZvcihcImxjOmNoaWxkX2NvbmZpZ1wiKTtcbmNsYXNzIEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXIge1xuICAgIGdldEluc3RhbmNlKCkge1xuICAgICAgICByZXR1cm4gKDAsIGdsb2JhbHNfanNfMS5nZXRHbG9iYWxBc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlKSgpID8/IG1vY2tBc3luY0xvY2FsU3RvcmFnZTtcbiAgICB9XG4gICAgZ2V0UnVubmFibGVDb25maWcoKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmdldEluc3RhbmNlKCk7XG4gICAgICAgIC8vIHRoaXMgaGFzIHRoZSBydW5uYWJsZSBjb25maWdcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgdGhhdCB3ZSBzaG91bGQgYWxzbyBoYXZlIGFuIGluc3RhbmNlIG9mIGEgTGFuZ0NoYWluVHJhY2VyXG4gICAgICAgIC8vIHdpdGggdGhlIHJ1biBtYXAgcHJlcG9wdWxhdGVkXG4gICAgICAgIHJldHVybiBzdG9yYWdlLmdldFN0b3JlKCk/LmV4dHJhPy5bTENfQ0hJTERfS0VZXTtcbiAgICB9XG4gICAgcnVuV2l0aENvbmZpZyhjb25maWcsIGNhbGxiYWNrLCBhdm9pZENyZWF0aW5nUm9vdFJ1blRyZWUpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyID0gbWFuYWdlcl9qc18xLkNhbGxiYWNrTWFuYWdlci5fY29uZmlndXJlU3luYyhjb25maWc/LmNhbGxiYWNrcywgdW5kZWZpbmVkLCBjb25maWc/LnRhZ3MsIHVuZGVmaW5lZCwgY29uZmlnPy5tZXRhZGF0YSk7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmdldEluc3RhbmNlKCk7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSBzdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgICAgIGNvbnN0IHBhcmVudFJ1bklkID0gY2FsbGJhY2tNYW5hZ2VyPy5nZXRQYXJlbnRSdW5JZCgpO1xuICAgICAgICBjb25zdCBsYW5nQ2hhaW5UcmFjZXIgPSBjYWxsYmFja01hbmFnZXI/LmhhbmRsZXJzPy5maW5kKChoYW5kbGVyKSA9PiBoYW5kbGVyPy5uYW1lID09PSBcImxhbmdjaGFpbl90cmFjZXJcIik7XG4gICAgICAgIGxldCBydW5UcmVlO1xuICAgICAgICBpZiAobGFuZ0NoYWluVHJhY2VyICYmIHBhcmVudFJ1bklkKSB7XG4gICAgICAgICAgICBydW5UcmVlID0gbGFuZ0NoYWluVHJhY2VyLmdldFJ1blRyZWVXaXRoVHJhY2luZ0NvbmZpZyhwYXJlbnRSdW5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWF2b2lkQ3JlYXRpbmdSb290UnVuVHJlZSkge1xuICAgICAgICAgICAgcnVuVHJlZSA9IG5ldyBsYW5nc21pdGhfMS5SdW5UcmVlKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIjxydW5uYWJsZV9sYW1iZGE+XCIsXG4gICAgICAgICAgICAgICAgdHJhY2luZ0VuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1blRyZWUpIHtcbiAgICAgICAgICAgIHJ1blRyZWUuZXh0cmEgPSB7IC4uLnJ1blRyZWUuZXh0cmEsIFtMQ19DSElMRF9LRVldOiBjb25maWcgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldmlvdXNWYWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBwcmV2aW91c1ZhbHVlW2dsb2JhbHNfanNfMS5fQ09OVEVYVF9WQVJJQUJMRVNfS0VZXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAocnVuVHJlZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcnVuVHJlZSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVuVHJlZVtnbG9iYWxzX2pzXzEuX0NPTlRFWFRfVkFSSUFCTEVTX0tFWV0gPVxuICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWVbZ2xvYmFsc19qc18xLl9DT05URVhUX1ZBUklBQkxFU19LRVldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdG9yYWdlLnJ1bihydW5UcmVlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGluaXRpYWxpemVHbG9iYWxJbnN0YW5jZShpbnN0YW5jZSkge1xuICAgICAgICBpZiAoKDAsIGdsb2JhbHNfanNfMS5nZXRHbG9iYWxBc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlKSgpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICgwLCBnbG9iYWxzX2pzXzEuc2V0R2xvYmFsQXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZSkoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbiA9IG5ldyBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyKCk7XG5leHBvcnRzLkFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24gPSBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/singletons/callbacks.cjs":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/singletons/callbacks.cjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/* eslint-disable @typescript-eslint/no-explicit-any */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getQueue = getQueue;\nexports.consumeCallback = consumeCallback;\nexports.awaitAllCallbacks = awaitAllCallbacks;\nconst p_queue_1 = __importDefault(__webpack_require__(/*! p-queue */ \"(rsc)/./node_modules/p-queue/dist/index.js\"));\nconst globals_js_1 = __webpack_require__(/*! ./async_local_storage/globals.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/globals.cjs\");\nconst tracer_js_1 = __webpack_require__(/*! ./tracer.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/tracer.cjs\");\nlet queue;\n/**\n * Creates a queue using the p-queue library. The queue is configured to\n * auto-start and has a concurrency of 1, meaning it will process tasks\n * one at a time.\n */\nfunction createQueue() {\n    const PQueue = \"default\" in p_queue_1.default ? p_queue_1.default.default : p_queue_1.default;\n    return new PQueue({\n        autoStart: true,\n        concurrency: 1,\n    });\n}\nfunction getQueue() {\n    if (typeof queue === \"undefined\") {\n        queue = createQueue();\n    }\n    return queue;\n}\n/**\n * Consume a promise, either adding it to the queue or waiting for it to resolve\n * @param promiseFn Promise to consume\n * @param wait Whether to wait for the promise to resolve or resolve immediately\n */\nasync function consumeCallback(promiseFn, wait) {\n    if (wait === true) {\n        // Clear config since callbacks are not part of the root run\n        // Avoid using global singleton due to circuluar dependency issues\n        const asyncLocalStorageInstance = (0, globals_js_1.getGlobalAsyncLocalStorageInstance)();\n        if (asyncLocalStorageInstance !== undefined) {\n            await asyncLocalStorageInstance.run(undefined, async () => promiseFn());\n        }\n        else {\n            await promiseFn();\n        }\n    }\n    else {\n        queue = getQueue();\n        void queue.add(async () => {\n            const asyncLocalStorageInstance = (0, globals_js_1.getGlobalAsyncLocalStorageInstance)();\n            if (asyncLocalStorageInstance !== undefined) {\n                await asyncLocalStorageInstance.run(undefined, async () => promiseFn());\n            }\n            else {\n                await promiseFn();\n            }\n        });\n    }\n}\n/**\n * Waits for all promises in the queue to resolve. If the queue is\n * undefined, it immediately resolves a promise.\n */\nasync function awaitAllCallbacks() {\n    const defaultClient = (0, tracer_js_1.getDefaultLangChainClientSingleton)();\n    await Promise.allSettled([\n        typeof queue !== \"undefined\" ? queue.onIdle() : Promise.resolve(),\n        defaultClient.awaitPendingTraceBatches(),\n    ]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc2luZ2xldG9ucy9jYWxsYmFja3MuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsdUJBQXVCO0FBQ3ZCLHlCQUF5QjtBQUN6QixrQ0FBa0MsbUJBQU8sQ0FBQywyREFBUztBQUNuRCxxQkFBcUIsbUJBQU8sQ0FBQywrSEFBbUM7QUFDaEUsb0JBQW9CLG1CQUFPLENBQUMscUZBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3NpbmdsZXRvbnMvY2FsbGJhY2tzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0UXVldWUgPSBnZXRRdWV1ZTtcbmV4cG9ydHMuY29uc3VtZUNhbGxiYWNrID0gY29uc3VtZUNhbGxiYWNrO1xuZXhwb3J0cy5hd2FpdEFsbENhbGxiYWNrcyA9IGF3YWl0QWxsQ2FsbGJhY2tzO1xuY29uc3QgcF9xdWV1ZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwLXF1ZXVlXCIpKTtcbmNvbnN0IGdsb2JhbHNfanNfMSA9IHJlcXVpcmUoXCIuL2FzeW5jX2xvY2FsX3N0b3JhZ2UvZ2xvYmFscy5janNcIik7XG5jb25zdCB0cmFjZXJfanNfMSA9IHJlcXVpcmUoXCIuL3RyYWNlci5janNcIik7XG5sZXQgcXVldWU7XG4vKipcbiAqIENyZWF0ZXMgYSBxdWV1ZSB1c2luZyB0aGUgcC1xdWV1ZSBsaWJyYXJ5LiBUaGUgcXVldWUgaXMgY29uZmlndXJlZCB0b1xuICogYXV0by1zdGFydCBhbmQgaGFzIGEgY29uY3VycmVuY3kgb2YgMSwgbWVhbmluZyBpdCB3aWxsIHByb2Nlc3MgdGFza3NcbiAqIG9uZSBhdCBhIHRpbWUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVF1ZXVlKCkge1xuICAgIGNvbnN0IFBRdWV1ZSA9IFwiZGVmYXVsdFwiIGluIHBfcXVldWVfMS5kZWZhdWx0ID8gcF9xdWV1ZV8xLmRlZmF1bHQuZGVmYXVsdCA6IHBfcXVldWVfMS5kZWZhdWx0O1xuICAgIHJldHVybiBuZXcgUFF1ZXVlKHtcbiAgICAgICAgYXV0b1N0YXJ0OiB0cnVlLFxuICAgICAgICBjb25jdXJyZW5jeTogMSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFF1ZXVlKCkge1xuICAgIGlmICh0eXBlb2YgcXVldWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcXVldWUgPSBjcmVhdGVRdWV1ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcXVldWU7XG59XG4vKipcbiAqIENvbnN1bWUgYSBwcm9taXNlLCBlaXRoZXIgYWRkaW5nIGl0IHRvIHRoZSBxdWV1ZSBvciB3YWl0aW5nIGZvciBpdCB0byByZXNvbHZlXG4gKiBAcGFyYW0gcHJvbWlzZUZuIFByb21pc2UgdG8gY29uc3VtZVxuICogQHBhcmFtIHdhaXQgV2hldGhlciB0byB3YWl0IGZvciB0aGUgcHJvbWlzZSB0byByZXNvbHZlIG9yIHJlc29sdmUgaW1tZWRpYXRlbHlcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY29uc3VtZUNhbGxiYWNrKHByb21pc2VGbiwgd2FpdCkge1xuICAgIGlmICh3YWl0ID09PSB0cnVlKSB7XG4gICAgICAgIC8vIENsZWFyIGNvbmZpZyBzaW5jZSBjYWxsYmFja3MgYXJlIG5vdCBwYXJ0IG9mIHRoZSByb290IHJ1blxuICAgICAgICAvLyBBdm9pZCB1c2luZyBnbG9iYWwgc2luZ2xldG9uIGR1ZSB0byBjaXJjdWx1YXIgZGVwZW5kZW5jeSBpc3N1ZXNcbiAgICAgICAgY29uc3QgYXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZSA9ICgwLCBnbG9iYWxzX2pzXzEuZ2V0R2xvYmFsQXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZSkoKTtcbiAgICAgICAgaWYgKGFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXdhaXQgYXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZS5ydW4odW5kZWZpbmVkLCBhc3luYyAoKSA9PiBwcm9taXNlRm4oKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBwcm9taXNlRm4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcXVldWUgPSBnZXRRdWV1ZSgpO1xuICAgICAgICB2b2lkIHF1ZXVlLmFkZChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlID0gKDAsIGdsb2JhbHNfanNfMS5nZXRHbG9iYWxBc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlKSgpO1xuICAgICAgICAgICAgaWYgKGFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UucnVuKHVuZGVmaW5lZCwgYXN5bmMgKCkgPT4gcHJvbWlzZUZuKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcHJvbWlzZUZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogV2FpdHMgZm9yIGFsbCBwcm9taXNlcyBpbiB0aGUgcXVldWUgdG8gcmVzb2x2ZS4gSWYgdGhlIHF1ZXVlIGlzXG4gKiB1bmRlZmluZWQsIGl0IGltbWVkaWF0ZWx5IHJlc29sdmVzIGEgcHJvbWlzZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gYXdhaXRBbGxDYWxsYmFja3MoKSB7XG4gICAgY29uc3QgZGVmYXVsdENsaWVudCA9ICgwLCB0cmFjZXJfanNfMS5nZXREZWZhdWx0TGFuZ0NoYWluQ2xpZW50U2luZ2xldG9uKSgpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChbXG4gICAgICAgIHR5cGVvZiBxdWV1ZSAhPT0gXCJ1bmRlZmluZWRcIiA/IHF1ZXVlLm9uSWRsZSgpIDogUHJvbWlzZS5yZXNvbHZlKCksXG4gICAgICAgIGRlZmF1bHRDbGllbnQuYXdhaXRQZW5kaW5nVHJhY2VCYXRjaGVzKCksXG4gICAgXSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/singletons/callbacks.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/singletons/index.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/singletons/index.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports._CONTEXT_VARIABLES_KEY = exports.MockAsyncLocalStorage = exports.AsyncLocalStorageProviderSingleton = void 0;\nconst index_js_1 = __webpack_require__(/*! ./async_local_storage/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/index.cjs\");\nObject.defineProperty(exports, \"AsyncLocalStorageProviderSingleton\", ({ enumerable: true, get: function () { return index_js_1.AsyncLocalStorageProviderSingleton; } }));\nObject.defineProperty(exports, \"MockAsyncLocalStorage\", ({ enumerable: true, get: function () { return index_js_1.MockAsyncLocalStorage; } }));\nconst globals_js_1 = __webpack_require__(/*! ./async_local_storage/globals.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/globals.cjs\");\nObject.defineProperty(exports, \"_CONTEXT_VARIABLES_KEY\", ({ enumerable: true, get: function () { return globals_js_1._CONTEXT_VARIABLES_KEY; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc2luZ2xldG9ucy9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsOEJBQThCLEdBQUcsNkJBQTZCLEdBQUcsMENBQTBDO0FBQzNHLG1CQUFtQixtQkFBTyxDQUFDLDJIQUFpQztBQUM1RCxzRUFBcUUsRUFBRSxxQ0FBcUMseURBQXlELEVBQUM7QUFDdEsseURBQXdELEVBQUUscUNBQXFDLDRDQUE0QyxFQUFDO0FBQzVJLHFCQUFxQixtQkFBTyxDQUFDLCtIQUFtQztBQUNoRSwwREFBeUQsRUFBRSxxQ0FBcUMsK0NBQStDLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9zaW5nbGV0b25zL2luZGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuX0NPTlRFWFRfVkFSSUFCTEVTX0tFWSA9IGV4cG9ydHMuTW9ja0FzeW5jTG9jYWxTdG9yYWdlID0gZXhwb3J0cy5Bc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuL2FzeW5jX2xvY2FsX3N0b3JhZ2UvaW5kZXguY2pzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMS5Bc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTW9ja0FzeW5jTG9jYWxTdG9yYWdlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLk1vY2tBc3luY0xvY2FsU3RvcmFnZTsgfSB9KTtcbmNvbnN0IGdsb2JhbHNfanNfMSA9IHJlcXVpcmUoXCIuL2FzeW5jX2xvY2FsX3N0b3JhZ2UvZ2xvYmFscy5janNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfQ09OVEVYVF9WQVJJQUJMRVNfS0VZXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBnbG9iYWxzX2pzXzEuX0NPTlRFWFRfVkFSSUFCTEVTX0tFWTsgfSB9KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/singletons/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/singletons/tracer.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/singletons/tracer.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setDefaultLangChainClientSingleton = exports.getDefaultLangChainClientSingleton = void 0;\nconst langsmith_1 = __webpack_require__(/*! langsmith */ \"(rsc)/./node_modules/langsmith/index.cjs\");\nconst env_js_1 = __webpack_require__(/*! ../utils/env.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/env.cjs\");\nlet client;\nconst getDefaultLangChainClientSingleton = () => {\n    if (client === undefined) {\n        const clientParams = (0, env_js_1.getEnvironmentVariable)(\"LANGCHAIN_CALLBACKS_BACKGROUND\") === \"false\"\n            ? {\n                // LangSmith has its own backgrounding system\n                blockOnRootRunFinalization: true,\n            }\n            : {};\n        client = new langsmith_1.Client(clientParams);\n    }\n    return client;\n};\nexports.getDefaultLangChainClientSingleton = getDefaultLangChainClientSingleton;\nconst setDefaultLangChainClientSingleton = (newClient) => {\n    client = newClient;\n};\nexports.setDefaultLangChainClientSingleton = setDefaultLangChainClientSingleton;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc2luZ2xldG9ucy90cmFjZXIuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBDQUEwQyxHQUFHLDBDQUEwQztBQUN2RixvQkFBb0IsbUJBQU8sQ0FBQywyREFBVztBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyxpRkFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsMENBQTBDIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc2luZ2xldG9ucy90cmFjZXIuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXREZWZhdWx0TGFuZ0NoYWluQ2xpZW50U2luZ2xldG9uID0gZXhwb3J0cy5nZXREZWZhdWx0TGFuZ0NoYWluQ2xpZW50U2luZ2xldG9uID0gdm9pZCAwO1xuY29uc3QgbGFuZ3NtaXRoXzEgPSByZXF1aXJlKFwibGFuZ3NtaXRoXCIpO1xuY29uc3QgZW52X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvZW52LmNqc1wiKTtcbmxldCBjbGllbnQ7XG5jb25zdCBnZXREZWZhdWx0TGFuZ0NoYWluQ2xpZW50U2luZ2xldG9uID0gKCkgPT4ge1xuICAgIGlmIChjbGllbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBjbGllbnRQYXJhbXMgPSAoMCwgZW52X2pzXzEuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSkoXCJMQU5HQ0hBSU5fQ0FMTEJBQ0tTX0JBQ0tHUk9VTkRcIikgPT09IFwiZmFsc2VcIlxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgLy8gTGFuZ1NtaXRoIGhhcyBpdHMgb3duIGJhY2tncm91bmRpbmcgc3lzdGVtXG4gICAgICAgICAgICAgICAgYmxvY2tPblJvb3RSdW5GaW5hbGl6YXRpb246IHRydWUsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHt9O1xuICAgICAgICBjbGllbnQgPSBuZXcgbGFuZ3NtaXRoXzEuQ2xpZW50KGNsaWVudFBhcmFtcyk7XG4gICAgfVxuICAgIHJldHVybiBjbGllbnQ7XG59O1xuZXhwb3J0cy5nZXREZWZhdWx0TGFuZ0NoYWluQ2xpZW50U2luZ2xldG9uID0gZ2V0RGVmYXVsdExhbmdDaGFpbkNsaWVudFNpbmdsZXRvbjtcbmNvbnN0IHNldERlZmF1bHRMYW5nQ2hhaW5DbGllbnRTaW5nbGV0b24gPSAobmV3Q2xpZW50KSA9PiB7XG4gICAgY2xpZW50ID0gbmV3Q2xpZW50O1xufTtcbmV4cG9ydHMuc2V0RGVmYXVsdExhbmdDaGFpbkNsaWVudFNpbmdsZXRvbiA9IHNldERlZmF1bHRMYW5nQ2hhaW5DbGllbnRTaW5nbGV0b247XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/singletons/tracer.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/stores.cjs":
/*!******************************************************!*\
  !*** ./node_modules/@langchain/core/dist/stores.cjs ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InMemoryStore = exports.BaseStore = void 0;\nconst serializable_js_1 = __webpack_require__(/*! ./load/serializable.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.cjs\");\n/**\n * Abstract interface for a key-value store.\n */\nclass BaseStore extends serializable_js_1.Serializable {\n}\nexports.BaseStore = BaseStore;\n/**\n * In-memory implementation of the BaseStore using a dictionary. Used for\n * storing key-value pairs in memory.\n * @example\n * ```typescript\n * const store = new InMemoryStore<BaseMessage>();\n * await store.mset(\n *   Array.from({ length: 5 }).map((_, index) => [\n *     `message:id:${index}`,\n *     index % 2 === 0\n *       ? new AIMessage(\"ai stuff...\")\n *       : new HumanMessage(\"human stuff...\"),\n *   ]),\n * );\n *\n * const retrievedMessages = await store.mget([\"message:id:0\", \"message:id:1\"]);\n * await store.mdelete(await store.yieldKeys(\"message:id:\").toArray());\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass InMemoryStore extends BaseStore {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"storage\"]\n        });\n        Object.defineProperty(this, \"store\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n    }\n    /**\n     * Retrieves the values associated with the given keys from the store.\n     * @param keys Keys to retrieve values for.\n     * @returns Array of values associated with the given keys.\n     */\n    async mget(keys) {\n        return keys.map((key) => this.store[key]);\n    }\n    /**\n     * Sets the values for the given keys in the store.\n     * @param keyValuePairs Array of key-value pairs to set in the store.\n     * @returns Promise that resolves when all key-value pairs have been set.\n     */\n    async mset(keyValuePairs) {\n        for (const [key, value] of keyValuePairs) {\n            this.store[key] = value;\n        }\n    }\n    /**\n     * Deletes the given keys and their associated values from the store.\n     * @param keys Keys to delete from the store.\n     * @returns Promise that resolves when all keys have been deleted.\n     */\n    async mdelete(keys) {\n        for (const key of keys) {\n            delete this.store[key];\n        }\n    }\n    /**\n     * Asynchronous generator that yields keys from the store. If a prefix is\n     * provided, it only yields keys that start with the prefix.\n     * @param prefix Optional prefix to filter keys.\n     * @returns AsyncGenerator that yields keys from the store.\n     */\n    async *yieldKeys(prefix) {\n        const keys = Object.keys(this.store);\n        for (const key of keys) {\n            if (prefix === undefined || key.startsWith(prefix)) {\n                yield key;\n            }\n        }\n    }\n}\nexports.InMemoryStore = InMemoryStore;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc3RvcmVzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyxpQkFBaUI7QUFDekMsMEJBQTBCLG1CQUFPLENBQUMsZ0dBQXlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVztBQUM3QixxQkFBcUIsTUFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9zdG9yZXMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jbk1lbW9yeVN0b3JlID0gZXhwb3J0cy5CYXNlU3RvcmUgPSB2b2lkIDA7XG5jb25zdCBzZXJpYWxpemFibGVfanNfMSA9IHJlcXVpcmUoXCIuL2xvYWQvc2VyaWFsaXphYmxlLmNqc1wiKTtcbi8qKlxuICogQWJzdHJhY3QgaW50ZXJmYWNlIGZvciBhIGtleS12YWx1ZSBzdG9yZS5cbiAqL1xuY2xhc3MgQmFzZVN0b3JlIGV4dGVuZHMgc2VyaWFsaXphYmxlX2pzXzEuU2VyaWFsaXphYmxlIHtcbn1cbmV4cG9ydHMuQmFzZVN0b3JlID0gQmFzZVN0b3JlO1xuLyoqXG4gKiBJbi1tZW1vcnkgaW1wbGVtZW50YXRpb24gb2YgdGhlIEJhc2VTdG9yZSB1c2luZyBhIGRpY3Rpb25hcnkuIFVzZWQgZm9yXG4gKiBzdG9yaW5nIGtleS12YWx1ZSBwYWlycyBpbiBtZW1vcnkuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3Qgc3RvcmUgPSBuZXcgSW5NZW1vcnlTdG9yZTxCYXNlTWVzc2FnZT4oKTtcbiAqIGF3YWl0IHN0b3JlLm1zZXQoXG4gKiAgIEFycmF5LmZyb20oeyBsZW5ndGg6IDUgfSkubWFwKChfLCBpbmRleCkgPT4gW1xuICogICAgIGBtZXNzYWdlOmlkOiR7aW5kZXh9YCxcbiAqICAgICBpbmRleCAlIDIgPT09IDBcbiAqICAgICAgID8gbmV3IEFJTWVzc2FnZShcImFpIHN0dWZmLi4uXCIpXG4gKiAgICAgICA6IG5ldyBIdW1hbk1lc3NhZ2UoXCJodW1hbiBzdHVmZi4uLlwiKSxcbiAqICAgXSksXG4gKiApO1xuICpcbiAqIGNvbnN0IHJldHJpZXZlZE1lc3NhZ2VzID0gYXdhaXQgc3RvcmUubWdldChbXCJtZXNzYWdlOmlkOjBcIiwgXCJtZXNzYWdlOmlkOjFcIl0pO1xuICogYXdhaXQgc3RvcmUubWRlbGV0ZShhd2FpdCBzdG9yZS55aWVsZEtleXMoXCJtZXNzYWdlOmlkOlwiKS50b0FycmF5KCkpO1xuICogYGBgXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jbGFzcyBJbk1lbW9yeVN0b3JlIGV4dGVuZHMgQmFzZVN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5cIiwgXCJzdG9yYWdlXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9yZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4ga2V5cyBmcm9tIHRoZSBzdG9yZS5cbiAgICAgKiBAcGFyYW0ga2V5cyBLZXlzIHRvIHJldHJpZXZlIHZhbHVlcyBmb3IuXG4gICAgICogQHJldHVybnMgQXJyYXkgb2YgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4ga2V5cy5cbiAgICAgKi9cbiAgICBhc3luYyBtZ2V0KGtleXMpIHtcbiAgICAgICAgcmV0dXJuIGtleXMubWFwKChrZXkpID0+IHRoaXMuc3RvcmVba2V5XSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGtleXMgaW4gdGhlIHN0b3JlLlxuICAgICAqIEBwYXJhbSBrZXlWYWx1ZVBhaXJzIEFycmF5IG9mIGtleS12YWx1ZSBwYWlycyB0byBzZXQgaW4gdGhlIHN0b3JlLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGFsbCBrZXktdmFsdWUgcGFpcnMgaGF2ZSBiZWVuIHNldC5cbiAgICAgKi9cbiAgICBhc3luYyBtc2V0KGtleVZhbHVlUGFpcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Yga2V5VmFsdWVQYWlycykge1xuICAgICAgICAgICAgdGhpcy5zdG9yZVtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgZ2l2ZW4ga2V5cyBhbmQgdGhlaXIgYXNzb2NpYXRlZCB2YWx1ZXMgZnJvbSB0aGUgc3RvcmUuXG4gICAgICogQHBhcmFtIGtleXMgS2V5cyB0byBkZWxldGUgZnJvbSB0aGUgc3RvcmUuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIGtleXMgaGF2ZSBiZWVuIGRlbGV0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgbWRlbGV0ZShrZXlzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0b3JlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXN5bmNocm9ub3VzIGdlbmVyYXRvciB0aGF0IHlpZWxkcyBrZXlzIGZyb20gdGhlIHN0b3JlLiBJZiBhIHByZWZpeCBpc1xuICAgICAqIHByb3ZpZGVkLCBpdCBvbmx5IHlpZWxkcyBrZXlzIHRoYXQgc3RhcnQgd2l0aCB0aGUgcHJlZml4LlxuICAgICAqIEBwYXJhbSBwcmVmaXggT3B0aW9uYWwgcHJlZml4IHRvIGZpbHRlciBrZXlzLlxuICAgICAqIEByZXR1cm5zIEFzeW5jR2VuZXJhdG9yIHRoYXQgeWllbGRzIGtleXMgZnJvbSB0aGUgc3RvcmUuXG4gICAgICovXG4gICAgYXN5bmMgKnlpZWxkS2V5cyhwcmVmaXgpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuc3RvcmUpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgICAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQgfHwga2V5LnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuSW5NZW1vcnlTdG9yZSA9IEluTWVtb3J5U3RvcmU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/stores.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tools/index.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tools/index.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseToolkit = exports.DynamicStructuredTool = exports.DynamicTool = exports.Tool = exports.StructuredTool = exports.ToolInputParsingException = exports.isStructuredToolParams = exports.isStructuredTool = exports.isRunnableToolLike = exports.isLangChainTool = void 0;\nexports.tool = tool;\nconst v3_1 = __webpack_require__(/*! zod/v3 */ \"(rsc)/./node_modules/zod/v3/index.cjs\");\nconst json_schema_1 = __webpack_require__(/*! @cfworker/json-schema */ \"(rsc)/./node_modules/@cfworker/json-schema/dist/commonjs/index.js\");\nconst manager_js_1 = __webpack_require__(/*! ../callbacks/manager.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.cjs\");\nconst base_js_1 = __webpack_require__(/*! ../language_models/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/language_models/base.cjs\");\nconst config_js_1 = __webpack_require__(/*! ../runnables/config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\nconst tool_js_1 = __webpack_require__(/*! ../messages/tool.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/tool.cjs\");\nconst index_js_1 = __webpack_require__(/*! ../singletons/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/index.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tools/utils.cjs\");\nObject.defineProperty(exports, \"ToolInputParsingException\", ({ enumerable: true, get: function () { return utils_js_1.ToolInputParsingException; } }));\nconst zod_js_1 = __webpack_require__(/*! ../utils/types/zod.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.cjs\");\nconst json_schema_js_1 = __webpack_require__(/*! ../utils/json_schema.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_schema.cjs\");\nvar types_js_1 = __webpack_require__(/*! ./types.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tools/types.cjs\");\nObject.defineProperty(exports, \"isLangChainTool\", ({ enumerable: true, get: function () { return types_js_1.isLangChainTool; } }));\nObject.defineProperty(exports, \"isRunnableToolLike\", ({ enumerable: true, get: function () { return types_js_1.isRunnableToolLike; } }));\nObject.defineProperty(exports, \"isStructuredTool\", ({ enumerable: true, get: function () { return types_js_1.isStructuredTool; } }));\nObject.defineProperty(exports, \"isStructuredToolParams\", ({ enumerable: true, get: function () { return types_js_1.isStructuredToolParams; } }));\n/**\n * Base class for Tools that accept input of any shape defined by a Zod schema.\n */\nclass StructuredTool extends base_js_1.BaseLangChain {\n    get lc_namespace() {\n        return [\"langchain\", \"tools\"];\n    }\n    constructor(fields) {\n        super(fields ?? {});\n        /**\n         * Whether to return the tool's output directly.\n         *\n         * Setting this to true means that after the tool is called,\n         * an agent should stop looping.\n         */\n        Object.defineProperty(this, \"returnDirect\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"verboseParsingErrors\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        /**\n         * The tool response format.\n         *\n         * If \"content\" then the output of the tool is interpreted as the contents of a\n         * ToolMessage. If \"content_and_artifact\" then the output is expected to be a\n         * two-tuple corresponding to the (content, artifact) of a ToolMessage.\n         *\n         * @default \"content\"\n         */\n        Object.defineProperty(this, \"responseFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"content\"\n        });\n        /**\n         * Default config object for the tool runnable.\n         */\n        Object.defineProperty(this, \"defaultConfig\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.verboseParsingErrors =\n            fields?.verboseParsingErrors ?? this.verboseParsingErrors;\n        this.responseFormat = fields?.responseFormat ?? this.responseFormat;\n        this.defaultConfig = fields?.defaultConfig ?? this.defaultConfig;\n        this.metadata = fields?.metadata ?? this.metadata;\n    }\n    /**\n     * Invokes the tool with the provided input and configuration.\n     * @param input The input for the tool.\n     * @param config Optional configuration for the tool.\n     * @returns A Promise that resolves with the tool's output.\n     */\n    async invoke(input, config) {\n        let toolInput;\n        let enrichedConfig = (0, config_js_1.ensureConfig)((0, config_js_1.mergeConfigs)(this.defaultConfig, config));\n        if ((0, utils_js_1._isToolCall)(input)) {\n            toolInput = input.args;\n            enrichedConfig = {\n                ...enrichedConfig,\n                toolCall: input,\n            };\n        }\n        else {\n            toolInput = input;\n        }\n        return this.call(toolInput, enrichedConfig);\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     *\n     * Calls the tool with the provided argument, configuration, and tags. It\n     * parses the input according to the schema, handles any errors, and\n     * manages callbacks.\n     * @param arg The input argument for the tool.\n     * @param configArg Optional configuration or callbacks for the tool.\n     * @param tags Optional tags for the tool.\n     * @returns A Promise that resolves with a string.\n     */\n    async call(arg, configArg, \n    /** @deprecated */\n    tags) {\n        // Determine the actual input that needs parsing/validation.\n        // If arg is a ToolCall, use its args; otherwise, use arg directly.\n        const inputForValidation = (0, utils_js_1._isToolCall)(arg) ? arg.args : arg;\n        let parsed; // This will hold the successfully parsed input of the expected output type.\n        if ((0, zod_js_1.isInteropZodSchema)(this.schema)) {\n            try {\n                // Validate the inputForValidation - TS needs help here as it can't exclude ToolCall based on the check\n                parsed = await (0, zod_js_1.interopParseAsync)(this.schema, inputForValidation);\n            }\n            catch (e) {\n                let message = `Received tool input did not match expected schema`;\n                if (this.verboseParsingErrors) {\n                    message = `${message}\\nDetails: ${e.message}`;\n                }\n                // Pass the original raw input arg to the exception\n                throw new utils_js_1.ToolInputParsingException(message, JSON.stringify(arg));\n            }\n        }\n        else {\n            const result = (0, json_schema_1.validate)(inputForValidation, this.schema);\n            if (!result.valid) {\n                let message = `Received tool input did not match expected schema`;\n                if (this.verboseParsingErrors) {\n                    message = `${message}\\nDetails: ${result.errors\n                        .map((e) => `${e.keywordLocation}: ${e.error}`)\n                        .join(\"\\n\")}`;\n                }\n                // Pass the original raw input arg to the exception\n                throw new utils_js_1.ToolInputParsingException(message, JSON.stringify(arg));\n            }\n            // Assign the validated input to parsed\n            // We cast here because validate() doesn't narrow the type sufficiently for TS, but we know it's valid.\n            parsed = inputForValidation;\n        }\n        const config = (0, manager_js_1.parseCallbackConfigArg)(configArg);\n        const callbackManager_ = manager_js_1.CallbackManager.configure(config.callbacks, this.callbacks, config.tags || tags, this.tags, config.metadata, this.metadata, { verbose: this.verbose });\n        const runManager = await callbackManager_?.handleToolStart(this.toJSON(), \n        // Log the original raw input arg\n        typeof arg === \"string\" ? arg : JSON.stringify(arg), config.runId, undefined, undefined, undefined, config.runName);\n        delete config.runId;\n        let result;\n        try {\n            // Pass the correctly typed parsed input to _call\n            result = await this._call(parsed, runManager, config);\n        }\n        catch (e) {\n            await runManager?.handleToolError(e);\n            throw e;\n        }\n        let content;\n        let artifact;\n        if (this.responseFormat === \"content_and_artifact\") {\n            if (Array.isArray(result) && result.length === 2) {\n                [content, artifact] = result;\n            }\n            else {\n                throw new Error(`Tool response format is \"content_and_artifact\" but the output was not a two-tuple.\\nResult: ${JSON.stringify(result)}`);\n            }\n        }\n        else {\n            content = result;\n        }\n        let toolCallId;\n        // Extract toolCallId ONLY if the original arg was a ToolCall\n        if ((0, utils_js_1._isToolCall)(arg)) {\n            toolCallId = arg.id;\n        }\n        // Or if it was provided in the config's toolCall property\n        if (!toolCallId && (0, utils_js_1._configHasToolCallId)(config)) {\n            toolCallId = config.toolCall.id;\n        }\n        const formattedOutput = _formatToolOutput({\n            content,\n            artifact,\n            toolCallId,\n            name: this.name,\n            metadata: this.metadata,\n        });\n        await runManager?.handleToolEnd(formattedOutput);\n        return formattedOutput;\n    }\n}\nexports.StructuredTool = StructuredTool;\n/**\n * Base class for Tools that accept input as a string.\n */\nclass Tool extends StructuredTool {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: v3_1.z\n                .object({ input: v3_1.z.string().optional() })\n                .transform((obj) => obj.input)\n        });\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     *\n     * Calls the tool with the provided argument and callbacks. It handles\n     * string inputs specifically.\n     * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.\n     * @param callbacks Optional callbacks for the tool.\n     * @returns A Promise that resolves with a string.\n     */\n    // Match the base class signature including the generics and conditional return type\n    call(arg, callbacks) {\n        // Prepare the input for the base class call method.\n        // If arg is string or undefined, wrap it; otherwise, pass ToolCall or { input: ... } directly.\n        const structuredArg = typeof arg === \"string\" || arg == null ? { input: arg } : arg;\n        // Ensure TConfig is passed to super.call\n        return super.call(structuredArg, callbacks);\n    }\n}\nexports.Tool = Tool;\n/**\n * A tool that can be created dynamically from a function, name, and description.\n */\nclass DynamicTool extends Tool {\n    static lc_name() {\n        return \"DynamicTool\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.description = fields.description;\n        this.func = fields.func;\n        this.returnDirect = fields.returnDirect ?? this.returnDirect;\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     */\n    async call(arg, configArg) {\n        const config = (0, manager_js_1.parseCallbackConfigArg)(configArg);\n        if (config.runName === undefined) {\n            config.runName = this.name;\n        }\n        // Call the Tool class's call method, passing generics through\n        // Cast config to TConfig to satisfy the super.call signature\n        return super.call(arg, config);\n    }\n    /** @ignore */\n    async _call(input, // DynamicTool's _call specifically expects a string after schema transformation\n    runManager, parentConfig) {\n        return this.func(input, runManager, parentConfig);\n    }\n}\nexports.DynamicTool = DynamicTool;\n/**\n * A tool that can be created dynamically from a function, name, and\n * description, designed to work with structured data. It extends the\n * StructuredTool class and overrides the _call method to execute the\n * provided function when the tool is called.\n *\n * Schema can be passed as Zod or JSON schema. The tool will not validate\n * input if JSON schema is passed.\n */\nclass DynamicStructuredTool extends StructuredTool {\n    static lc_name() {\n        return \"DynamicStructuredTool\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.description = fields.description;\n        this.func = fields.func;\n        this.returnDirect = fields.returnDirect ?? this.returnDirect;\n        this.schema = fields.schema;\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     */\n    // Match the base class signature\n    async call(arg, configArg, \n    /** @deprecated */\n    tags) {\n        const config = (0, manager_js_1.parseCallbackConfigArg)(configArg);\n        if (config.runName === undefined) {\n            config.runName = this.name;\n        }\n        // Call the base class method, passing generics through\n        // Cast config to TConfig to satisfy the super.call signature\n        return super.call(arg, config, tags);\n    }\n    _call(arg, runManager, parentConfig) {\n        return this.func(arg, runManager, parentConfig);\n    }\n}\nexports.DynamicStructuredTool = DynamicStructuredTool;\n/**\n * Abstract base class for toolkits in LangChain. Toolkits are collections\n * of tools that agents can use. Subclasses must implement the `tools`\n * property to provide the specific tools for the toolkit.\n */\nclass BaseToolkit {\n    getTools() {\n        return this.tools;\n    }\n}\nexports.BaseToolkit = BaseToolkit;\nfunction tool(func, fields) {\n    const isSimpleStringSchema = (0, zod_js_1.isSimpleStringZodSchema)(fields.schema);\n    const isStringJSONSchema = (0, json_schema_js_1.validatesOnlyStrings)(fields.schema);\n    // If the schema is not provided, or it's a simple string schema, create a DynamicTool\n    if (!fields.schema || isSimpleStringSchema || isStringJSONSchema) {\n        return new DynamicTool({\n            ...fields,\n            description: fields.description ??\n                (fields.schema && (0, zod_js_1.getSchemaDescription)(fields.schema)) ??\n                `${fields.name} tool`,\n            func: async (input, runManager, config) => {\n                return new Promise((resolve, reject) => {\n                    const childConfig = (0, config_js_1.patchConfig)(config, {\n                        callbacks: runManager?.getChild(),\n                    });\n                    void index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig((0, config_js_1.pickRunnableConfigKeys)(childConfig), async () => {\n                        try {\n                            // TS doesn't restrict the type here based on the guard above\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            resolve(func(input, childConfig));\n                        }\n                        catch (e) {\n                            reject(e);\n                        }\n                    });\n                });\n            },\n        });\n    }\n    const schema = fields.schema;\n    const description = fields.description ??\n        fields.schema.description ??\n        `${fields.name} tool`;\n    return new DynamicStructuredTool({\n        ...fields,\n        description,\n        schema,\n        func: async (input, runManager, config) => {\n            return new Promise((resolve, reject) => {\n                const childConfig = (0, config_js_1.patchConfig)(config, {\n                    callbacks: runManager?.getChild(),\n                });\n                void index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig((0, config_js_1.pickRunnableConfigKeys)(childConfig), async () => {\n                    try {\n                        resolve(func(input, childConfig));\n                    }\n                    catch (e) {\n                        reject(e);\n                    }\n                });\n            });\n        },\n    });\n}\nfunction _formatToolOutput(params) {\n    const { content, artifact, toolCallId, metadata } = params;\n    if (toolCallId && !(0, tool_js_1.isDirectToolOutput)(content)) {\n        if (typeof content === \"string\" ||\n            (Array.isArray(content) &&\n                content.every((item) => typeof item === \"object\"))) {\n            return new tool_js_1.ToolMessage({\n                status: \"success\",\n                content,\n                artifact,\n                tool_call_id: toolCallId,\n                name: params.name,\n                metadata,\n            });\n        }\n        else {\n            return new tool_js_1.ToolMessage({\n                status: \"success\",\n                content: _stringify(content),\n                artifact,\n                tool_call_id: toolCallId,\n                name: params.name,\n                metadata,\n            });\n        }\n    }\n    else {\n        return content;\n    }\n}\nfunction _stringify(content) {\n    try {\n        return JSON.stringify(content, null, 2) ?? \"\";\n    }\n    catch (_noOp) {\n        return `${content}`;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdG9vbHMvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLDZCQUE2QixHQUFHLG1CQUFtQixHQUFHLFlBQVksR0FBRyxzQkFBc0IsR0FBRyxpQ0FBaUMsR0FBRyw4QkFBOEIsR0FBRyx3QkFBd0IsR0FBRywwQkFBMEIsR0FBRyx1QkFBdUI7QUFDeFEsWUFBWTtBQUNaLGFBQWEsbUJBQU8sQ0FBQyxxREFBUTtBQUM3QixzQkFBc0IsbUJBQU8sQ0FBQyxnR0FBdUI7QUFDckQscUJBQXFCLG1CQUFPLENBQUMsaUdBQTBCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLHVHQUE2QjtBQUN2RCxvQkFBb0IsbUJBQU8sQ0FBQywrRkFBeUI7QUFDckQsa0JBQWtCLG1CQUFPLENBQUMseUZBQXNCO0FBQ2hELG1CQUFtQixtQkFBTyxDQUFDLCtGQUF5QjtBQUNwRCxtQkFBbUIsbUJBQU8sQ0FBQyw4RUFBYTtBQUN4Qyw2REFBNEQsRUFBRSxxQ0FBcUMsZ0RBQWdELEVBQUM7QUFDcEosaUJBQWlCLG1CQUFPLENBQUMsNkZBQXdCO0FBQ2pELHlCQUF5QixtQkFBTyxDQUFDLGlHQUEwQjtBQUMzRCxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBYTtBQUN0QyxtREFBa0QsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDaEksc0RBQXFELEVBQUUscUNBQXFDLHlDQUF5QyxFQUFDO0FBQ3RJLG9EQUFtRCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUNsSSwwREFBeUQsRUFBRSxxQ0FBcUMsNkNBQTZDLEVBQUM7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVEsYUFBYSxVQUFVO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVEsYUFBYTtBQUN0RCx1Q0FBdUMsa0JBQWtCLElBQUksUUFBUTtBQUNyRSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEtBQTRLLHVCQUF1QjtBQUNuTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0hBQStILHVCQUF1QjtBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUNBQW1DO0FBQzdEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDhCQUE4QixhQUFhO0FBQzlGLHlFQUF5RSxhQUFhO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSwwQ0FBMEM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC90b29scy9pbmRleC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhc2VUb29sa2l0ID0gZXhwb3J0cy5EeW5hbWljU3RydWN0dXJlZFRvb2wgPSBleHBvcnRzLkR5bmFtaWNUb29sID0gZXhwb3J0cy5Ub29sID0gZXhwb3J0cy5TdHJ1Y3R1cmVkVG9vbCA9IGV4cG9ydHMuVG9vbElucHV0UGFyc2luZ0V4Y2VwdGlvbiA9IGV4cG9ydHMuaXNTdHJ1Y3R1cmVkVG9vbFBhcmFtcyA9IGV4cG9ydHMuaXNTdHJ1Y3R1cmVkVG9vbCA9IGV4cG9ydHMuaXNSdW5uYWJsZVRvb2xMaWtlID0gZXhwb3J0cy5pc0xhbmdDaGFpblRvb2wgPSB2b2lkIDA7XG5leHBvcnRzLnRvb2wgPSB0b29sO1xuY29uc3QgdjNfMSA9IHJlcXVpcmUoXCJ6b2QvdjNcIik7XG5jb25zdCBqc29uX3NjaGVtYV8xID0gcmVxdWlyZShcIkBjZndvcmtlci9qc29uLXNjaGVtYVwiKTtcbmNvbnN0IG1hbmFnZXJfanNfMSA9IHJlcXVpcmUoXCIuLi9jYWxsYmFja3MvbWFuYWdlci5janNcIik7XG5jb25zdCBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi4vbGFuZ3VhZ2VfbW9kZWxzL2Jhc2UuY2pzXCIpO1xuY29uc3QgY29uZmlnX2pzXzEgPSByZXF1aXJlKFwiLi4vcnVubmFibGVzL2NvbmZpZy5janNcIik7XG5jb25zdCB0b29sX2pzXzEgPSByZXF1aXJlKFwiLi4vbWVzc2FnZXMvdG9vbC5janNcIik7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3NpbmdsZXRvbnMvaW5kZXguY2pzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmNqc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRvb2xJbnB1dFBhcnNpbmdFeGNlcHRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzX2pzXzEuVG9vbElucHV0UGFyc2luZ0V4Y2VwdGlvbjsgfSB9KTtcbmNvbnN0IHpvZF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL3R5cGVzL3pvZC5janNcIik7XG5jb25zdCBqc29uX3NjaGVtYV9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2pzb25fc2NoZW1hLmNqc1wiKTtcbnZhciB0eXBlc19qc18xID0gcmVxdWlyZShcIi4vdHlwZXMuY2pzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNMYW5nQ2hhaW5Ub29sXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc19qc18xLmlzTGFuZ0NoYWluVG9vbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzUnVubmFibGVUb29sTGlrZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfanNfMS5pc1J1bm5hYmxlVG9vbExpa2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1N0cnVjdHVyZWRUb29sXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc19qc18xLmlzU3RydWN0dXJlZFRvb2w7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1N0cnVjdHVyZWRUb29sUGFyYW1zXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc19qc18xLmlzU3RydWN0dXJlZFRvb2xQYXJhbXM7IH0gfSk7XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFRvb2xzIHRoYXQgYWNjZXB0IGlucHV0IG9mIGFueSBzaGFwZSBkZWZpbmVkIGJ5IGEgWm9kIHNjaGVtYS5cbiAqL1xuY2xhc3MgU3RydWN0dXJlZFRvb2wgZXh0ZW5kcyBiYXNlX2pzXzEuQmFzZUxhbmdDaGFpbiB7XG4gICAgZ2V0IGxjX25hbWVzcGFjZSgpIHtcbiAgICAgICAgcmV0dXJuIFtcImxhbmdjaGFpblwiLCBcInRvb2xzXCJdO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzID8/IHt9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdG8gcmV0dXJuIHRoZSB0b29sJ3Mgb3V0cHV0IGRpcmVjdGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZXR0aW5nIHRoaXMgdG8gdHJ1ZSBtZWFucyB0aGF0IGFmdGVyIHRoZSB0b29sIGlzIGNhbGxlZCxcbiAgICAgICAgICogYW4gYWdlbnQgc2hvdWxkIHN0b3AgbG9vcGluZy5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJldHVybkRpcmVjdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcmJvc2VQYXJzaW5nRXJyb3JzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0b29sIHJlc3BvbnNlIGZvcm1hdC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgXCJjb250ZW50XCIgdGhlbiB0aGUgb3V0cHV0IG9mIHRoZSB0b29sIGlzIGludGVycHJldGVkIGFzIHRoZSBjb250ZW50cyBvZiBhXG4gICAgICAgICAqIFRvb2xNZXNzYWdlLiBJZiBcImNvbnRlbnRfYW5kX2FydGlmYWN0XCIgdGhlbiB0aGUgb3V0cHV0IGlzIGV4cGVjdGVkIHRvIGJlIGFcbiAgICAgICAgICogdHdvLXR1cGxlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIChjb250ZW50LCBhcnRpZmFjdCkgb2YgYSBUb29sTWVzc2FnZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgXCJjb250ZW50XCJcbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc3BvbnNlRm9ybWF0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImNvbnRlbnRcIlxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmF1bHQgY29uZmlnIG9iamVjdCBmb3IgdGhlIHRvb2wgcnVubmFibGUuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWZhdWx0Q29uZmlnXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmVyYm9zZVBhcnNpbmdFcnJvcnMgPVxuICAgICAgICAgICAgZmllbGRzPy52ZXJib3NlUGFyc2luZ0Vycm9ycyA/PyB0aGlzLnZlcmJvc2VQYXJzaW5nRXJyb3JzO1xuICAgICAgICB0aGlzLnJlc3BvbnNlRm9ybWF0ID0gZmllbGRzPy5yZXNwb25zZUZvcm1hdCA/PyB0aGlzLnJlc3BvbnNlRm9ybWF0O1xuICAgICAgICB0aGlzLmRlZmF1bHRDb25maWcgPSBmaWVsZHM/LmRlZmF1bHRDb25maWcgPz8gdGhpcy5kZWZhdWx0Q29uZmlnO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gZmllbGRzPy5tZXRhZGF0YSA/PyB0aGlzLm1ldGFkYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSB0b29sIHdpdGggdGhlIHByb3ZpZGVkIGlucHV0IGFuZCBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgZm9yIHRoZSB0b29sLlxuICAgICAqIEBwYXJhbSBjb25maWcgT3B0aW9uYWwgY29uZmlndXJhdGlvbiBmb3IgdGhlIHRvb2wuXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgdG9vbCdzIG91dHB1dC5cbiAgICAgKi9cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgICBsZXQgdG9vbElucHV0O1xuICAgICAgICBsZXQgZW5yaWNoZWRDb25maWcgPSAoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKSgoMCwgY29uZmlnX2pzXzEubWVyZ2VDb25maWdzKSh0aGlzLmRlZmF1bHRDb25maWcsIGNvbmZpZykpO1xuICAgICAgICBpZiAoKDAsIHV0aWxzX2pzXzEuX2lzVG9vbENhbGwpKGlucHV0KSkge1xuICAgICAgICAgICAgdG9vbElucHV0ID0gaW5wdXQuYXJncztcbiAgICAgICAgICAgIGVucmljaGVkQ29uZmlnID0ge1xuICAgICAgICAgICAgICAgIC4uLmVucmljaGVkQ29uZmlnLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsOiBpbnB1dCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b29sSW5wdXQgPSBpbnB1dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsKHRvb2xJbnB1dCwgZW5yaWNoZWRDb25maWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgLmludm9rZSgpIGluc3RlYWQuIFdpbGwgYmUgcmVtb3ZlZCBpbiAwLjMuMC5cbiAgICAgKlxuICAgICAqIENhbGxzIHRoZSB0b29sIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50LCBjb25maWd1cmF0aW9uLCBhbmQgdGFncy4gSXRcbiAgICAgKiBwYXJzZXMgdGhlIGlucHV0IGFjY29yZGluZyB0byB0aGUgc2NoZW1hLCBoYW5kbGVzIGFueSBlcnJvcnMsIGFuZFxuICAgICAqIG1hbmFnZXMgY2FsbGJhY2tzLlxuICAgICAqIEBwYXJhbSBhcmcgVGhlIGlucHV0IGFyZ3VtZW50IGZvciB0aGUgdG9vbC5cbiAgICAgKiBAcGFyYW0gY29uZmlnQXJnIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3IgY2FsbGJhY2tzIGZvciB0aGUgdG9vbC5cbiAgICAgKiBAcGFyYW0gdGFncyBPcHRpb25hbCB0YWdzIGZvciB0aGUgdG9vbC5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGEgc3RyaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIGNhbGwoYXJnLCBjb25maWdBcmcsIFxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIHRhZ3MpIHtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBhY3R1YWwgaW5wdXQgdGhhdCBuZWVkcyBwYXJzaW5nL3ZhbGlkYXRpb24uXG4gICAgICAgIC8vIElmIGFyZyBpcyBhIFRvb2xDYWxsLCB1c2UgaXRzIGFyZ3M7IG90aGVyd2lzZSwgdXNlIGFyZyBkaXJlY3RseS5cbiAgICAgICAgY29uc3QgaW5wdXRGb3JWYWxpZGF0aW9uID0gKDAsIHV0aWxzX2pzXzEuX2lzVG9vbENhbGwpKGFyZykgPyBhcmcuYXJncyA6IGFyZztcbiAgICAgICAgbGV0IHBhcnNlZDsgLy8gVGhpcyB3aWxsIGhvbGQgdGhlIHN1Y2Nlc3NmdWxseSBwYXJzZWQgaW5wdXQgb2YgdGhlIGV4cGVjdGVkIG91dHB1dCB0eXBlLlxuICAgICAgICBpZiAoKDAsIHpvZF9qc18xLmlzSW50ZXJvcFpvZFNjaGVtYSkodGhpcy5zY2hlbWEpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIFZhbGlkYXRlIHRoZSBpbnB1dEZvclZhbGlkYXRpb24gLSBUUyBuZWVkcyBoZWxwIGhlcmUgYXMgaXQgY2FuJ3QgZXhjbHVkZSBUb29sQ2FsbCBiYXNlZCBvbiB0aGUgY2hlY2tcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSBhd2FpdCAoMCwgem9kX2pzXzEuaW50ZXJvcFBhcnNlQXN5bmMpKHRoaXMuc2NoZW1hLCBpbnB1dEZvclZhbGlkYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IGBSZWNlaXZlZCB0b29sIGlucHV0IGRpZCBub3QgbWF0Y2ggZXhwZWN0ZWQgc2NoZW1hYDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52ZXJib3NlUGFyc2luZ0Vycm9ycykge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYCR7bWVzc2FnZX1cXG5EZXRhaWxzOiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQYXNzIHRoZSBvcmlnaW5hbCByYXcgaW5wdXQgYXJnIHRvIHRoZSBleGNlcHRpb25cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgdXRpbHNfanNfMS5Ub29sSW5wdXRQYXJzaW5nRXhjZXB0aW9uKG1lc3NhZ2UsIEpTT04uc3RyaW5naWZ5KGFyZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gKDAsIGpzb25fc2NoZW1hXzEudmFsaWRhdGUpKGlucHV0Rm9yVmFsaWRhdGlvbiwgdGhpcy5zY2hlbWEpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQudmFsaWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IGBSZWNlaXZlZCB0b29sIGlucHV0IGRpZCBub3QgbWF0Y2ggZXhwZWN0ZWQgc2NoZW1hYDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52ZXJib3NlUGFyc2luZ0Vycm9ycykge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYCR7bWVzc2FnZX1cXG5EZXRhaWxzOiAke3Jlc3VsdC5lcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKGUpID0+IGAke2Uua2V5d29yZExvY2F0aW9ufTogJHtlLmVycm9yfWApXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbihcIlxcblwiKX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQYXNzIHRoZSBvcmlnaW5hbCByYXcgaW5wdXQgYXJnIHRvIHRoZSBleGNlcHRpb25cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgdXRpbHNfanNfMS5Ub29sSW5wdXRQYXJzaW5nRXhjZXB0aW9uKG1lc3NhZ2UsIEpTT04uc3RyaW5naWZ5KGFyZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXNzaWduIHRoZSB2YWxpZGF0ZWQgaW5wdXQgdG8gcGFyc2VkXG4gICAgICAgICAgICAvLyBXZSBjYXN0IGhlcmUgYmVjYXVzZSB2YWxpZGF0ZSgpIGRvZXNuJ3QgbmFycm93IHRoZSB0eXBlIHN1ZmZpY2llbnRseSBmb3IgVFMsIGJ1dCB3ZSBrbm93IGl0J3MgdmFsaWQuXG4gICAgICAgICAgICBwYXJzZWQgPSBpbnB1dEZvclZhbGlkYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlnID0gKDAsIG1hbmFnZXJfanNfMS5wYXJzZUNhbGxiYWNrQ29uZmlnQXJnKShjb25maWdBcmcpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gbWFuYWdlcl9qc18xLkNhbGxiYWNrTWFuYWdlci5jb25maWd1cmUoY29uZmlnLmNhbGxiYWNrcywgdGhpcy5jYWxsYmFja3MsIGNvbmZpZy50YWdzIHx8IHRhZ3MsIHRoaXMudGFncywgY29uZmlnLm1ldGFkYXRhLCB0aGlzLm1ldGFkYXRhLCB7IHZlcmJvc2U6IHRoaXMudmVyYm9zZSB9KTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlciA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZVRvb2xTdGFydCh0aGlzLnRvSlNPTigpLCBcbiAgICAgICAgLy8gTG9nIHRoZSBvcmlnaW5hbCByYXcgaW5wdXQgYXJnXG4gICAgICAgIHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIgPyBhcmcgOiBKU09OLnN0cmluZ2lmeShhcmcpLCBjb25maWcucnVuSWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbmZpZy5ydW5OYW1lKTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5ydW5JZDtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFBhc3MgdGhlIGNvcnJlY3RseSB0eXBlZCBwYXJzZWQgaW5wdXQgdG8gX2NhbGxcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMuX2NhbGwocGFyc2VkLCBydW5NYW5hZ2VyLCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVUb29sRXJyb3IoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250ZW50O1xuICAgICAgICBsZXQgYXJ0aWZhY3Q7XG4gICAgICAgIGlmICh0aGlzLnJlc3BvbnNlRm9ybWF0ID09PSBcImNvbnRlbnRfYW5kX2FydGlmYWN0XCIpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkgJiYgcmVzdWx0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIFtjb250ZW50LCBhcnRpZmFjdF0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvb2wgcmVzcG9uc2UgZm9ybWF0IGlzIFwiY29udGVudF9hbmRfYXJ0aWZhY3RcIiBidXQgdGhlIG91dHB1dCB3YXMgbm90IGEgdHdvLXR1cGxlLlxcblJlc3VsdDogJHtKU09OLnN0cmluZ2lmeShyZXN1bHQpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGVudCA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9vbENhbGxJZDtcbiAgICAgICAgLy8gRXh0cmFjdCB0b29sQ2FsbElkIE9OTFkgaWYgdGhlIG9yaWdpbmFsIGFyZyB3YXMgYSBUb29sQ2FsbFxuICAgICAgICBpZiAoKDAsIHV0aWxzX2pzXzEuX2lzVG9vbENhbGwpKGFyZykpIHtcbiAgICAgICAgICAgIHRvb2xDYWxsSWQgPSBhcmcuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3IgaWYgaXQgd2FzIHByb3ZpZGVkIGluIHRoZSBjb25maWcncyB0b29sQ2FsbCBwcm9wZXJ0eVxuICAgICAgICBpZiAoIXRvb2xDYWxsSWQgJiYgKDAsIHV0aWxzX2pzXzEuX2NvbmZpZ0hhc1Rvb2xDYWxsSWQpKGNvbmZpZykpIHtcbiAgICAgICAgICAgIHRvb2xDYWxsSWQgPSBjb25maWcudG9vbENhbGwuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9ybWF0dGVkT3V0cHV0ID0gX2Zvcm1hdFRvb2xPdXRwdXQoe1xuICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgIGFydGlmYWN0LFxuICAgICAgICAgICAgdG9vbENhbGxJZCxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB0aGlzLm1ldGFkYXRhLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlVG9vbEVuZChmb3JtYXR0ZWRPdXRwdXQpO1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVkT3V0cHV0O1xuICAgIH1cbn1cbmV4cG9ydHMuU3RydWN0dXJlZFRvb2wgPSBTdHJ1Y3R1cmVkVG9vbDtcbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgVG9vbHMgdGhhdCBhY2NlcHQgaW5wdXQgYXMgYSBzdHJpbmcuXG4gKi9cbmNsYXNzIFRvb2wgZXh0ZW5kcyBTdHJ1Y3R1cmVkVG9vbCB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNjaGVtYVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdjNfMS56XG4gICAgICAgICAgICAgICAgLm9iamVjdCh7IGlucHV0OiB2M18xLnouc3RyaW5nKCkub3B0aW9uYWwoKSB9KVxuICAgICAgICAgICAgICAgIC50cmFuc2Zvcm0oKG9iaikgPT4gb2JqLmlucHV0KVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIC5pbnZva2UoKSBpbnN0ZWFkLiBXaWxsIGJlIHJlbW92ZWQgaW4gMC4zLjAuXG4gICAgICpcbiAgICAgKiBDYWxscyB0aGUgdG9vbCB3aXRoIHRoZSBwcm92aWRlZCBhcmd1bWVudCBhbmQgY2FsbGJhY2tzLiBJdCBoYW5kbGVzXG4gICAgICogc3RyaW5nIGlucHV0cyBzcGVjaWZpY2FsbHkuXG4gICAgICogQHBhcmFtIGFyZyBUaGUgaW5wdXQgYXJndW1lbnQgZm9yIHRoZSB0b29sLCB3aGljaCBjYW4gYmUgYSBzdHJpbmcsIHVuZGVmaW5lZCwgb3IgYW4gaW5wdXQgb2YgdGhlIHRvb2wncyBzY2hlbWEuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyBPcHRpb25hbCBjYWxsYmFja3MgZm9yIHRoZSB0b29sLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYSBzdHJpbmcuXG4gICAgICovXG4gICAgLy8gTWF0Y2ggdGhlIGJhc2UgY2xhc3Mgc2lnbmF0dXJlIGluY2x1ZGluZyB0aGUgZ2VuZXJpY3MgYW5kIGNvbmRpdGlvbmFsIHJldHVybiB0eXBlXG4gICAgY2FsbChhcmcsIGNhbGxiYWNrcykge1xuICAgICAgICAvLyBQcmVwYXJlIHRoZSBpbnB1dCBmb3IgdGhlIGJhc2UgY2xhc3MgY2FsbCBtZXRob2QuXG4gICAgICAgIC8vIElmIGFyZyBpcyBzdHJpbmcgb3IgdW5kZWZpbmVkLCB3cmFwIGl0OyBvdGhlcndpc2UsIHBhc3MgVG9vbENhbGwgb3IgeyBpbnB1dDogLi4uIH0gZGlyZWN0bHkuXG4gICAgICAgIGNvbnN0IHN0cnVjdHVyZWRBcmcgPSB0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiIHx8IGFyZyA9PSBudWxsID8geyBpbnB1dDogYXJnIH0gOiBhcmc7XG4gICAgICAgIC8vIEVuc3VyZSBUQ29uZmlnIGlzIHBhc3NlZCB0byBzdXBlci5jYWxsXG4gICAgICAgIHJldHVybiBzdXBlci5jYWxsKHN0cnVjdHVyZWRBcmcsIGNhbGxiYWNrcyk7XG4gICAgfVxufVxuZXhwb3J0cy5Ub29sID0gVG9vbDtcbi8qKlxuICogQSB0b29sIHRoYXQgY2FuIGJlIGNyZWF0ZWQgZHluYW1pY2FsbHkgZnJvbSBhIGZ1bmN0aW9uLCBuYW1lLCBhbmQgZGVzY3JpcHRpb24uXG4gKi9cbmNsYXNzIER5bmFtaWNUb29sIGV4dGVuZHMgVG9vbCB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkR5bmFtaWNUb29sXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlc2NyaXB0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZ1bmNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gZmllbGRzLm5hbWU7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBmaWVsZHMuZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMuZnVuYyA9IGZpZWxkcy5mdW5jO1xuICAgICAgICB0aGlzLnJldHVybkRpcmVjdCA9IGZpZWxkcy5yZXR1cm5EaXJlY3QgPz8gdGhpcy5yZXR1cm5EaXJlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSAuaW52b2tlKCkgaW5zdGVhZC4gV2lsbCBiZSByZW1vdmVkIGluIDAuMy4wLlxuICAgICAqL1xuICAgIGFzeW5jIGNhbGwoYXJnLCBjb25maWdBcmcpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gKDAsIG1hbmFnZXJfanNfMS5wYXJzZUNhbGxiYWNrQ29uZmlnQXJnKShjb25maWdBcmcpO1xuICAgICAgICBpZiAoY29uZmlnLnJ1bk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uZmlnLnJ1bk5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsbCB0aGUgVG9vbCBjbGFzcydzIGNhbGwgbWV0aG9kLCBwYXNzaW5nIGdlbmVyaWNzIHRocm91Z2hcbiAgICAgICAgLy8gQ2FzdCBjb25maWcgdG8gVENvbmZpZyB0byBzYXRpc2Z5IHRoZSBzdXBlci5jYWxsIHNpZ25hdHVyZVxuICAgICAgICByZXR1cm4gc3VwZXIuY2FsbChhcmcsIGNvbmZpZyk7XG4gICAgfVxuICAgIC8qKiBAaWdub3JlICovXG4gICAgYXN5bmMgX2NhbGwoaW5wdXQsIC8vIER5bmFtaWNUb29sJ3MgX2NhbGwgc3BlY2lmaWNhbGx5IGV4cGVjdHMgYSBzdHJpbmcgYWZ0ZXIgc2NoZW1hIHRyYW5zZm9ybWF0aW9uXG4gICAgcnVuTWFuYWdlciwgcGFyZW50Q29uZmlnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZ1bmMoaW5wdXQsIHJ1bk1hbmFnZXIsIHBhcmVudENvbmZpZyk7XG4gICAgfVxufVxuZXhwb3J0cy5EeW5hbWljVG9vbCA9IER5bmFtaWNUb29sO1xuLyoqXG4gKiBBIHRvb2wgdGhhdCBjYW4gYmUgY3JlYXRlZCBkeW5hbWljYWxseSBmcm9tIGEgZnVuY3Rpb24sIG5hbWUsIGFuZFxuICogZGVzY3JpcHRpb24sIGRlc2lnbmVkIHRvIHdvcmsgd2l0aCBzdHJ1Y3R1cmVkIGRhdGEuIEl0IGV4dGVuZHMgdGhlXG4gKiBTdHJ1Y3R1cmVkVG9vbCBjbGFzcyBhbmQgb3ZlcnJpZGVzIHRoZSBfY2FsbCBtZXRob2QgdG8gZXhlY3V0ZSB0aGVcbiAqIHByb3ZpZGVkIGZ1bmN0aW9uIHdoZW4gdGhlIHRvb2wgaXMgY2FsbGVkLlxuICpcbiAqIFNjaGVtYSBjYW4gYmUgcGFzc2VkIGFzIFpvZCBvciBKU09OIHNjaGVtYS4gVGhlIHRvb2wgd2lsbCBub3QgdmFsaWRhdGVcbiAqIGlucHV0IGlmIEpTT04gc2NoZW1hIGlzIHBhc3NlZC5cbiAqL1xuY2xhc3MgRHluYW1pY1N0cnVjdHVyZWRUb29sIGV4dGVuZHMgU3RydWN0dXJlZFRvb2wge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJEeW5hbWljU3RydWN0dXJlZFRvb2xcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVzY3JpcHRpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZnVuY1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzY2hlbWFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gZmllbGRzLm5hbWU7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBmaWVsZHMuZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMuZnVuYyA9IGZpZWxkcy5mdW5jO1xuICAgICAgICB0aGlzLnJldHVybkRpcmVjdCA9IGZpZWxkcy5yZXR1cm5EaXJlY3QgPz8gdGhpcy5yZXR1cm5EaXJlY3Q7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gZmllbGRzLnNjaGVtYTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIC5pbnZva2UoKSBpbnN0ZWFkLiBXaWxsIGJlIHJlbW92ZWQgaW4gMC4zLjAuXG4gICAgICovXG4gICAgLy8gTWF0Y2ggdGhlIGJhc2UgY2xhc3Mgc2lnbmF0dXJlXG4gICAgYXN5bmMgY2FsbChhcmcsIGNvbmZpZ0FyZywgXG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgdGFncykge1xuICAgICAgICBjb25zdCBjb25maWcgPSAoMCwgbWFuYWdlcl9qc18xLnBhcnNlQ2FsbGJhY2tDb25maWdBcmcpKGNvbmZpZ0FyZyk7XG4gICAgICAgIGlmIChjb25maWcucnVuTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25maWcucnVuTmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxsIHRoZSBiYXNlIGNsYXNzIG1ldGhvZCwgcGFzc2luZyBnZW5lcmljcyB0aHJvdWdoXG4gICAgICAgIC8vIENhc3QgY29uZmlnIHRvIFRDb25maWcgdG8gc2F0aXNmeSB0aGUgc3VwZXIuY2FsbCBzaWduYXR1cmVcbiAgICAgICAgcmV0dXJuIHN1cGVyLmNhbGwoYXJnLCBjb25maWcsIHRhZ3MpO1xuICAgIH1cbiAgICBfY2FsbChhcmcsIHJ1bk1hbmFnZXIsIHBhcmVudENvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jKGFyZywgcnVuTWFuYWdlciwgcGFyZW50Q29uZmlnKTtcbiAgICB9XG59XG5leHBvcnRzLkR5bmFtaWNTdHJ1Y3R1cmVkVG9vbCA9IER5bmFtaWNTdHJ1Y3R1cmVkVG9vbDtcbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgdG9vbGtpdHMgaW4gTGFuZ0NoYWluLiBUb29sa2l0cyBhcmUgY29sbGVjdGlvbnNcbiAqIG9mIHRvb2xzIHRoYXQgYWdlbnRzIGNhbiB1c2UuIFN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnQgdGhlIGB0b29sc2BcbiAqIHByb3BlcnR5IHRvIHByb3ZpZGUgdGhlIHNwZWNpZmljIHRvb2xzIGZvciB0aGUgdG9vbGtpdC5cbiAqL1xuY2xhc3MgQmFzZVRvb2xraXQge1xuICAgIGdldFRvb2xzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b29scztcbiAgICB9XG59XG5leHBvcnRzLkJhc2VUb29sa2l0ID0gQmFzZVRvb2xraXQ7XG5mdW5jdGlvbiB0b29sKGZ1bmMsIGZpZWxkcykge1xuICAgIGNvbnN0IGlzU2ltcGxlU3RyaW5nU2NoZW1hID0gKDAsIHpvZF9qc18xLmlzU2ltcGxlU3RyaW5nWm9kU2NoZW1hKShmaWVsZHMuc2NoZW1hKTtcbiAgICBjb25zdCBpc1N0cmluZ0pTT05TY2hlbWEgPSAoMCwganNvbl9zY2hlbWFfanNfMS52YWxpZGF0ZXNPbmx5U3RyaW5ncykoZmllbGRzLnNjaGVtYSk7XG4gICAgLy8gSWYgdGhlIHNjaGVtYSBpcyBub3QgcHJvdmlkZWQsIG9yIGl0J3MgYSBzaW1wbGUgc3RyaW5nIHNjaGVtYSwgY3JlYXRlIGEgRHluYW1pY1Rvb2xcbiAgICBpZiAoIWZpZWxkcy5zY2hlbWEgfHwgaXNTaW1wbGVTdHJpbmdTY2hlbWEgfHwgaXNTdHJpbmdKU09OU2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBuZXcgRHluYW1pY1Rvb2woe1xuICAgICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGZpZWxkcy5kZXNjcmlwdGlvbiA/P1xuICAgICAgICAgICAgICAgIChmaWVsZHMuc2NoZW1hICYmICgwLCB6b2RfanNfMS5nZXRTY2hlbWFEZXNjcmlwdGlvbikoZmllbGRzLnNjaGVtYSkpID8/XG4gICAgICAgICAgICAgICAgYCR7ZmllbGRzLm5hbWV9IHRvb2xgLFxuICAgICAgICAgICAgZnVuYzogYXN5bmMgKGlucHV0LCBydW5NYW5hZ2VyLCBjb25maWcpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZENvbmZpZyA9ICgwLCBjb25maWdfanNfMS5wYXRjaENvbmZpZykoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKCksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2b2lkIGluZGV4X2pzXzEuQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5ydW5XaXRoQ29uZmlnKCgwLCBjb25maWdfanNfMS5waWNrUnVubmFibGVDb25maWdLZXlzKShjaGlsZENvbmZpZyksIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVFMgZG9lc24ndCByZXN0cmljdCB0aGUgdHlwZSBoZXJlIGJhc2VkIG9uIHRoZSBndWFyZCBhYm92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmdW5jKGlucHV0LCBjaGlsZENvbmZpZykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHNjaGVtYSA9IGZpZWxkcy5zY2hlbWE7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSBmaWVsZHMuZGVzY3JpcHRpb24gPz9cbiAgICAgICAgZmllbGRzLnNjaGVtYS5kZXNjcmlwdGlvbiA/P1xuICAgICAgICBgJHtmaWVsZHMubmFtZX0gdG9vbGA7XG4gICAgcmV0dXJuIG5ldyBEeW5hbWljU3RydWN0dXJlZFRvb2woe1xuICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIGZ1bmM6IGFzeW5jIChpbnB1dCwgcnVuTWFuYWdlciwgY29uZmlnKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ29uZmlnID0gKDAsIGNvbmZpZ19qc18xLnBhdGNoQ29uZmlnKShjb25maWcsIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZCgpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZvaWQgaW5kZXhfanNfMS5Bc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uLnJ1bldpdGhDb25maWcoKDAsIGNvbmZpZ19qc18xLnBpY2tSdW5uYWJsZUNvbmZpZ0tleXMpKGNoaWxkQ29uZmlnKSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmdW5jKGlucHV0LCBjaGlsZENvbmZpZykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuZnVuY3Rpb24gX2Zvcm1hdFRvb2xPdXRwdXQocGFyYW1zKSB7XG4gICAgY29uc3QgeyBjb250ZW50LCBhcnRpZmFjdCwgdG9vbENhbGxJZCwgbWV0YWRhdGEgfSA9IHBhcmFtcztcbiAgICBpZiAodG9vbENhbGxJZCAmJiAhKDAsIHRvb2xfanNfMS5pc0RpcmVjdFRvb2xPdXRwdXQpKGNvbnRlbnQpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIiB8fFxuICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkoY29udGVudCkgJiZcbiAgICAgICAgICAgICAgICBjb250ZW50LmV2ZXJ5KChpdGVtKSA9PiB0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIikpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRvb2xfanNfMS5Ub29sTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgIGFydGlmYWN0LFxuICAgICAgICAgICAgICAgIHRvb2xfY2FsbF9pZDogdG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0b29sX2pzXzEuVG9vbE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHN0YXR1czogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgICAgICAgY29udGVudDogX3N0cmluZ2lmeShjb250ZW50KSxcbiAgICAgICAgICAgICAgICBhcnRpZmFjdCxcbiAgICAgICAgICAgICAgICB0b29sX2NhbGxfaWQ6IHRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgbmFtZTogcGFyYW1zLm5hbWUsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxufVxuZnVuY3Rpb24gX3N0cmluZ2lmeShjb250ZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGNvbnRlbnQsIG51bGwsIDIpID8/IFwiXCI7XG4gICAgfVxuICAgIGNhdGNoIChfbm9PcCkge1xuICAgICAgICByZXR1cm4gYCR7Y29udGVudH1gO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tools/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tools/types.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tools/types.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isStructuredTool = isStructuredTool;\nexports.isRunnableToolLike = isRunnableToolLike;\nexports.isStructuredToolParams = isStructuredToolParams;\nexports.isLangChainTool = isLangChainTool;\nconst base_js_1 = __webpack_require__(/*! ../runnables/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nconst zod_js_1 = __webpack_require__(/*! ../utils/types/zod.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.cjs\");\n/**\n * Confirm whether the inputted tool is an instance of `StructuredToolInterface`.\n *\n * @param {StructuredToolInterface | JSONSchema | undefined} tool The tool to check if it is an instance of `StructuredToolInterface`.\n * @returns {tool is StructuredToolInterface} Whether the inputted tool is an instance of `StructuredToolInterface`.\n */\nfunction isStructuredTool(tool) {\n    return (tool !== undefined &&\n        Array.isArray(tool.lc_namespace));\n}\n/**\n * Confirm whether the inputted tool is an instance of `RunnableToolLike`.\n *\n * @param {unknown | undefined} tool The tool to check if it is an instance of `RunnableToolLike`.\n * @returns {tool is RunnableToolLike} Whether the inputted tool is an instance of `RunnableToolLike`.\n */\nfunction isRunnableToolLike(tool) {\n    return (tool !== undefined &&\n        base_js_1.Runnable.isRunnable(tool) &&\n        \"lc_name\" in tool.constructor &&\n        typeof tool.constructor.lc_name === \"function\" &&\n        tool.constructor.lc_name() === \"RunnableToolLike\");\n}\n/**\n * Confirm whether or not the tool contains the necessary properties to be considered a `StructuredToolParams`.\n *\n * @param {unknown | undefined} tool The object to check if it is a `StructuredToolParams`.\n * @returns {tool is StructuredToolParams} Whether the inputted object is a `StructuredToolParams`.\n */\nfunction isStructuredToolParams(tool) {\n    return (!!tool &&\n        typeof tool === \"object\" &&\n        \"name\" in tool &&\n        \"schema\" in tool &&\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ((0, zod_js_1.isInteropZodSchema)(tool.schema) ||\n            (tool.schema != null &&\n                typeof tool.schema === \"object\" &&\n                \"type\" in tool.schema &&\n                typeof tool.schema.type === \"string\" &&\n                [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"].includes(tool.schema.type))));\n}\n/**\n * Whether or not the tool is one of StructuredTool, RunnableTool or StructuredToolParams.\n * It returns `is StructuredToolParams` since that is the most minimal interface of the three,\n * while still containing the necessary properties to be passed to a LLM for tool calling.\n *\n * @param {unknown | undefined} tool The tool to check if it is a LangChain tool.\n * @returns {tool is StructuredToolParams} Whether the inputted tool is a LangChain tool.\n */\nfunction isLangChainTool(tool) {\n    return (isStructuredToolParams(tool) ||\n        isRunnableToolLike(tool) ||\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        isStructuredTool(tool));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdG9vbHMvdHlwZXMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4QiwwQkFBMEI7QUFDMUIsOEJBQThCO0FBQzlCLHVCQUF1QjtBQUN2QixrQkFBa0IsbUJBQU8sQ0FBQywyRkFBdUI7QUFDakQsaUJBQWlCLG1CQUFPLENBQUMsNkZBQXdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0RBQWtEO0FBQzdELGFBQWEsaUNBQWlDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxhQUFhLDBCQUEwQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsYUFBYSw4QkFBOEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxhQUFhLDhCQUE4QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3Rvb2xzL3R5cGVzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNTdHJ1Y3R1cmVkVG9vbCA9IGlzU3RydWN0dXJlZFRvb2w7XG5leHBvcnRzLmlzUnVubmFibGVUb29sTGlrZSA9IGlzUnVubmFibGVUb29sTGlrZTtcbmV4cG9ydHMuaXNTdHJ1Y3R1cmVkVG9vbFBhcmFtcyA9IGlzU3RydWN0dXJlZFRvb2xQYXJhbXM7XG5leHBvcnRzLmlzTGFuZ0NoYWluVG9vbCA9IGlzTGFuZ0NoYWluVG9vbDtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuLi9ydW5uYWJsZXMvYmFzZS5janNcIik7XG5jb25zdCB6b2RfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy90eXBlcy96b2QuY2pzXCIpO1xuLyoqXG4gKiBDb25maXJtIHdoZXRoZXIgdGhlIGlucHV0dGVkIHRvb2wgaXMgYW4gaW5zdGFuY2Ugb2YgYFN0cnVjdHVyZWRUb29sSW50ZXJmYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cnVjdHVyZWRUb29sSW50ZXJmYWNlIHwgSlNPTlNjaGVtYSB8IHVuZGVmaW5lZH0gdG9vbCBUaGUgdG9vbCB0byBjaGVjayBpZiBpdCBpcyBhbiBpbnN0YW5jZSBvZiBgU3RydWN0dXJlZFRvb2xJbnRlcmZhY2VgLlxuICogQHJldHVybnMge3Rvb2wgaXMgU3RydWN0dXJlZFRvb2xJbnRlcmZhY2V9IFdoZXRoZXIgdGhlIGlucHV0dGVkIHRvb2wgaXMgYW4gaW5zdGFuY2Ugb2YgYFN0cnVjdHVyZWRUb29sSW50ZXJmYWNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJ1Y3R1cmVkVG9vbCh0b29sKSB7XG4gICAgcmV0dXJuICh0b29sICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheSh0b29sLmxjX25hbWVzcGFjZSkpO1xufVxuLyoqXG4gKiBDb25maXJtIHdoZXRoZXIgdGhlIGlucHV0dGVkIHRvb2wgaXMgYW4gaW5zdGFuY2Ugb2YgYFJ1bm5hYmxlVG9vbExpa2VgLlxuICpcbiAqIEBwYXJhbSB7dW5rbm93biB8IHVuZGVmaW5lZH0gdG9vbCBUaGUgdG9vbCB0byBjaGVjayBpZiBpdCBpcyBhbiBpbnN0YW5jZSBvZiBgUnVubmFibGVUb29sTGlrZWAuXG4gKiBAcmV0dXJucyB7dG9vbCBpcyBSdW5uYWJsZVRvb2xMaWtlfSBXaGV0aGVyIHRoZSBpbnB1dHRlZCB0b29sIGlzIGFuIGluc3RhbmNlIG9mIGBSdW5uYWJsZVRvb2xMaWtlYC5cbiAqL1xuZnVuY3Rpb24gaXNSdW5uYWJsZVRvb2xMaWtlKHRvb2wpIHtcbiAgICByZXR1cm4gKHRvb2wgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBiYXNlX2pzXzEuUnVubmFibGUuaXNSdW5uYWJsZSh0b29sKSAmJlxuICAgICAgICBcImxjX25hbWVcIiBpbiB0b29sLmNvbnN0cnVjdG9yICYmXG4gICAgICAgIHR5cGVvZiB0b29sLmNvbnN0cnVjdG9yLmxjX25hbWUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0b29sLmNvbnN0cnVjdG9yLmxjX25hbWUoKSA9PT0gXCJSdW5uYWJsZVRvb2xMaWtlXCIpO1xufVxuLyoqXG4gKiBDb25maXJtIHdoZXRoZXIgb3Igbm90IHRoZSB0b29sIGNvbnRhaW5zIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllcyB0byBiZSBjb25zaWRlcmVkIGEgYFN0cnVjdHVyZWRUb29sUGFyYW1zYC5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd24gfCB1bmRlZmluZWR9IHRvb2wgVGhlIG9iamVjdCB0byBjaGVjayBpZiBpdCBpcyBhIGBTdHJ1Y3R1cmVkVG9vbFBhcmFtc2AuXG4gKiBAcmV0dXJucyB7dG9vbCBpcyBTdHJ1Y3R1cmVkVG9vbFBhcmFtc30gV2hldGhlciB0aGUgaW5wdXR0ZWQgb2JqZWN0IGlzIGEgYFN0cnVjdHVyZWRUb29sUGFyYW1zYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJ1Y3R1cmVkVG9vbFBhcmFtcyh0b29sKSB7XG4gICAgcmV0dXJuICghIXRvb2wgJiZcbiAgICAgICAgdHlwZW9mIHRvb2wgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgXCJuYW1lXCIgaW4gdG9vbCAmJlxuICAgICAgICBcInNjaGVtYVwiIGluIHRvb2wgJiZcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgKCgwLCB6b2RfanNfMS5pc0ludGVyb3Bab2RTY2hlbWEpKHRvb2wuc2NoZW1hKSB8fFxuICAgICAgICAgICAgKHRvb2wuc2NoZW1hICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdG9vbC5zY2hlbWEgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICBcInR5cGVcIiBpbiB0b29sLnNjaGVtYSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB0b29sLnNjaGVtYS50eXBlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgW1wibnVsbFwiLCBcImJvb2xlYW5cIiwgXCJvYmplY3RcIiwgXCJhcnJheVwiLCBcIm51bWJlclwiLCBcInN0cmluZ1wiXS5pbmNsdWRlcyh0b29sLnNjaGVtYS50eXBlKSkpKTtcbn1cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIHRvb2wgaXMgb25lIG9mIFN0cnVjdHVyZWRUb29sLCBSdW5uYWJsZVRvb2wgb3IgU3RydWN0dXJlZFRvb2xQYXJhbXMuXG4gKiBJdCByZXR1cm5zIGBpcyBTdHJ1Y3R1cmVkVG9vbFBhcmFtc2Agc2luY2UgdGhhdCBpcyB0aGUgbW9zdCBtaW5pbWFsIGludGVyZmFjZSBvZiB0aGUgdGhyZWUsXG4gKiB3aGlsZSBzdGlsbCBjb250YWluaW5nIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllcyB0byBiZSBwYXNzZWQgdG8gYSBMTE0gZm9yIHRvb2wgY2FsbGluZy5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd24gfCB1bmRlZmluZWR9IHRvb2wgVGhlIHRvb2wgdG8gY2hlY2sgaWYgaXQgaXMgYSBMYW5nQ2hhaW4gdG9vbC5cbiAqIEByZXR1cm5zIHt0b29sIGlzIFN0cnVjdHVyZWRUb29sUGFyYW1zfSBXaGV0aGVyIHRoZSBpbnB1dHRlZCB0b29sIGlzIGEgTGFuZ0NoYWluIHRvb2wuXG4gKi9cbmZ1bmN0aW9uIGlzTGFuZ0NoYWluVG9vbCh0b29sKSB7XG4gICAgcmV0dXJuIChpc1N0cnVjdHVyZWRUb29sUGFyYW1zKHRvb2wpIHx8XG4gICAgICAgIGlzUnVubmFibGVUb29sTGlrZSh0b29sKSB8fFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBpc1N0cnVjdHVyZWRUb29sKHRvb2wpKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tools/types.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tools/utils.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tools/utils.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ToolInputParsingException = void 0;\nexports._isToolCall = _isToolCall;\nexports._configHasToolCallId = _configHasToolCallId;\nfunction _isToolCall(toolCall) {\n    return !!(toolCall &&\n        typeof toolCall === \"object\" &&\n        \"type\" in toolCall &&\n        toolCall.type === \"tool_call\");\n}\nfunction _configHasToolCallId(config) {\n    return !!(config &&\n        typeof config === \"object\" &&\n        \"toolCall\" in config &&\n        config.toolCall != null &&\n        typeof config.toolCall === \"object\" &&\n        \"id\" in config.toolCall &&\n        typeof config.toolCall.id === \"string\");\n}\n/**\n * Custom error class used to handle exceptions related to tool input parsing.\n * It extends the built-in `Error` class and adds an optional `output`\n * property that can hold the output that caused the exception.\n */\nclass ToolInputParsingException extends Error {\n    constructor(message, output) {\n        super(message);\n        Object.defineProperty(this, \"output\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.output = output;\n    }\n}\nexports.ToolInputParsingException = ToolInputParsingException;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdG9vbHMvdXRpbHMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlDQUFpQztBQUNqQyxtQkFBbUI7QUFDbkIsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3Rvb2xzL3V0aWxzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVG9vbElucHV0UGFyc2luZ0V4Y2VwdGlvbiA9IHZvaWQgMDtcbmV4cG9ydHMuX2lzVG9vbENhbGwgPSBfaXNUb29sQ2FsbDtcbmV4cG9ydHMuX2NvbmZpZ0hhc1Rvb2xDYWxsSWQgPSBfY29uZmlnSGFzVG9vbENhbGxJZDtcbmZ1bmN0aW9uIF9pc1Rvb2xDYWxsKHRvb2xDYWxsKSB7XG4gICAgcmV0dXJuICEhKHRvb2xDYWxsICYmXG4gICAgICAgIHR5cGVvZiB0b29sQ2FsbCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBcInR5cGVcIiBpbiB0b29sQ2FsbCAmJlxuICAgICAgICB0b29sQ2FsbC50eXBlID09PSBcInRvb2xfY2FsbFwiKTtcbn1cbmZ1bmN0aW9uIF9jb25maWdIYXNUb29sQ2FsbElkKGNvbmZpZykge1xuICAgIHJldHVybiAhIShjb25maWcgJiZcbiAgICAgICAgdHlwZW9mIGNvbmZpZyA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBcInRvb2xDYWxsXCIgaW4gY29uZmlnICYmXG4gICAgICAgIGNvbmZpZy50b29sQ2FsbCAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBjb25maWcudG9vbENhbGwgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgXCJpZFwiIGluIGNvbmZpZy50b29sQ2FsbCAmJlxuICAgICAgICB0eXBlb2YgY29uZmlnLnRvb2xDYWxsLmlkID09PSBcInN0cmluZ1wiKTtcbn1cbi8qKlxuICogQ3VzdG9tIGVycm9yIGNsYXNzIHVzZWQgdG8gaGFuZGxlIGV4Y2VwdGlvbnMgcmVsYXRlZCB0byB0b29sIGlucHV0IHBhcnNpbmcuXG4gKiBJdCBleHRlbmRzIHRoZSBidWlsdC1pbiBgRXJyb3JgIGNsYXNzIGFuZCBhZGRzIGFuIG9wdGlvbmFsIGBvdXRwdXRgXG4gKiBwcm9wZXJ0eSB0aGF0IGNhbiBob2xkIHRoZSBvdXRwdXQgdGhhdCBjYXVzZWQgdGhlIGV4Y2VwdGlvbi5cbiAqL1xuY2xhc3MgVG9vbElucHV0UGFyc2luZ0V4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvdXRwdXQpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm91dHB1dFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm91dHB1dCA9IG91dHB1dDtcbiAgICB9XG59XG5leHBvcnRzLlRvb2xJbnB1dFBhcnNpbmdFeGNlcHRpb24gPSBUb29sSW5wdXRQYXJzaW5nRXhjZXB0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tools/utils.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/base.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/base.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseTracer = void 0;\nexports.isBaseTracer = isBaseTracer;\nconst run_trees_1 = __webpack_require__(/*! langsmith/run_trees */ \"(rsc)/./node_modules/langsmith/run_trees.cjs\");\nconst base_js_1 = __webpack_require__(/*! ../callbacks/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/base.cjs\");\nconst env_js_1 = __webpack_require__(/*! ../utils/env.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/env.cjs\");\n// TODO: Remove and just use base LangSmith Run type\nconst convertRunTreeToRun = (runTree) => {\n    if (!runTree) {\n        return undefined;\n    }\n    // Important that we return the raw run tree object since the reference\n    // is mutated in other places.\n    // TODO: Remove places where this is being done.\n    // eslint-disable-next-line no-param-reassign\n    runTree.events = runTree.events ?? [];\n    // eslint-disable-next-line no-param-reassign\n    runTree.child_runs = runTree.child_runs ?? [];\n    // TODO: Remove this cast and just use the LangSmith RunTree type.\n    return runTree;\n};\nfunction convertRunToRunTree(run, parentRun) {\n    if (!run) {\n        return undefined;\n    }\n    return new run_trees_1.RunTree({\n        ...run,\n        start_time: run._serialized_start_time ?? run.start_time,\n        parent_run: convertRunToRunTree(parentRun),\n        child_runs: run.child_runs\n            .map((r) => convertRunToRunTree(r))\n            .filter((r) => r !== undefined),\n        extra: {\n            ...run.extra,\n            runtime: (0, env_js_1.getRuntimeEnvironmentSync)(),\n        },\n        tracingEnabled: false,\n    });\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n    return value && !Array.isArray(value) && typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\nfunction isBaseTracer(x) {\n    return typeof x._addRunToRunMap === \"function\";\n}\nclass BaseTracer extends base_js_1.BaseCallbackHandler {\n    constructor(_fields) {\n        super(...arguments);\n        /** @deprecated Use `runTreeMap` instead. */\n        Object.defineProperty(this, \"runMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"runTreeMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"usesRunTreeMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n    }\n    copy() {\n        return this;\n    }\n    getRunById(runId) {\n        if (runId === undefined) {\n            return undefined;\n        }\n        return this.usesRunTreeMap\n            ? convertRunTreeToRun(this.runTreeMap.get(runId))\n            : this.runMap.get(runId);\n    }\n    stringifyError(error) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (error instanceof Error) {\n            return error.message + (error?.stack ? `\\n\\n${error.stack}` : \"\");\n        }\n        if (typeof error === \"string\") {\n            return error;\n        }\n        return `${error}`;\n    }\n    _addChildRun(parentRun, childRun) {\n        parentRun.child_runs.push(childRun);\n    }\n    _addRunToRunMap(run) {\n        const { dottedOrder: currentDottedOrder, microsecondPrecisionDatestring } = (0, run_trees_1.convertToDottedOrderFormat)(new Date(run.start_time).getTime(), run.id, run.execution_order);\n        const storedRun = { ...run };\n        const parentRun = this.getRunById(storedRun.parent_run_id);\n        if (storedRun.parent_run_id !== undefined) {\n            if (parentRun) {\n                this._addChildRun(parentRun, storedRun);\n                parentRun.child_execution_order = Math.max(parentRun.child_execution_order, storedRun.child_execution_order);\n                storedRun.trace_id = parentRun.trace_id;\n                if (parentRun.dotted_order !== undefined) {\n                    storedRun.dotted_order = [\n                        parentRun.dotted_order,\n                        currentDottedOrder,\n                    ].join(\".\");\n                    storedRun._serialized_start_time = microsecondPrecisionDatestring;\n                }\n                else {\n                    // This can happen naturally for callbacks added within a run\n                    // console.debug(`Parent run with UUID ${storedRun.parent_run_id} has no dotted order.`);\n                }\n            }\n            else {\n                // This can happen naturally for callbacks added within a run\n                // console.debug(\n                //   `Parent run with UUID ${storedRun.parent_run_id} not found.`\n                // );\n            }\n        }\n        else {\n            storedRun.trace_id = storedRun.id;\n            storedRun.dotted_order = currentDottedOrder;\n            storedRun._serialized_start_time = microsecondPrecisionDatestring;\n        }\n        if (this.usesRunTreeMap) {\n            const runTree = convertRunToRunTree(storedRun, parentRun);\n            if (runTree !== undefined) {\n                this.runTreeMap.set(storedRun.id, runTree);\n            }\n        }\n        else {\n            this.runMap.set(storedRun.id, storedRun);\n        }\n        return storedRun;\n    }\n    async _endTrace(run) {\n        const parentRun = run.parent_run_id !== undefined && this.getRunById(run.parent_run_id);\n        if (parentRun) {\n            parentRun.child_execution_order = Math.max(parentRun.child_execution_order, run.child_execution_order);\n        }\n        else {\n            await this.persistRun(run);\n        }\n        await this.onRunUpdate?.(run);\n        if (this.usesRunTreeMap) {\n            this.runTreeMap.delete(run.id);\n        }\n        else {\n            this.runMap.delete(run.id);\n        }\n    }\n    _getExecutionOrder(parentRunId) {\n        const parentRun = parentRunId !== undefined && this.getRunById(parentRunId);\n        // If a run has no parent then execution order is 1\n        if (!parentRun) {\n            return 1;\n        }\n        return parentRun.child_execution_order + 1;\n    }\n    /**\n     * Create and add a run to the run map for LLM start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const finalExtraParams = metadata\n            ? { ...extraParams, metadata }\n            : extraParams;\n        const run = {\n            id: runId,\n            name: name ?? llm.id[llm.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: llm,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { prompts },\n            execution_order,\n            child_runs: [],\n            child_execution_order: execution_order,\n            run_type: \"llm\",\n            extra: finalExtraParams ?? {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {\n        const run = this.getRunById(runId) ??\n            this._createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name);\n        await this.onRunCreate?.(run);\n        await this.onLLMStart?.(run);\n        return run;\n    }\n    /**\n     * Create and add a run to the run map for chat model start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const finalExtraParams = metadata\n            ? { ...extraParams, metadata }\n            : extraParams;\n        const run = {\n            id: runId,\n            name: name ?? llm.id[llm.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: llm,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { messages },\n            execution_order,\n            child_runs: [],\n            child_execution_order: execution_order,\n            run_type: \"llm\",\n            extra: finalExtraParams ?? {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {\n        const run = this.getRunById(runId) ??\n            this._createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name);\n        await this.onRunCreate?.(run);\n        await this.onLLMStart?.(run);\n        return run;\n    }\n    async handleLLMEnd(output, runId, _parentRunId, _tags, extraParams) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            throw new Error(\"No LLM run to end.\");\n        }\n        run.end_time = Date.now();\n        run.outputs = output;\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        run.extra = { ...run.extra, ...extraParams };\n        await this.onLLMEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleLLMError(error, runId, _parentRunId, _tags, extraParams) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            throw new Error(\"No LLM run to end.\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        run.extra = { ...run.extra, ...extraParams };\n        await this.onLLMError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    /**\n     * Create and add a run to the run map for chain start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: name ?? chain.id[chain.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: chain,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs,\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: runType ?? \"chain\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {\n        const run = this.getRunById(runId) ??\n            this._createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name);\n        await this.onRunCreate?.(run);\n        await this.onChainStart?.(run);\n        return run;\n    }\n    async handleChainEnd(outputs, runId, _parentRunId, _tags, kwargs) {\n        const run = this.getRunById(runId);\n        if (!run) {\n            throw new Error(\"No chain run to end.\");\n        }\n        run.end_time = Date.now();\n        run.outputs = _coerceToDict(outputs, \"output\");\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        if (kwargs?.inputs !== undefined) {\n            run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n        }\n        await this.onChainEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleChainError(error, runId, _parentRunId, _tags, kwargs) {\n        const run = this.getRunById(runId);\n        if (!run) {\n            throw new Error(\"No chain run to end.\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        if (kwargs?.inputs !== undefined) {\n            run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n        }\n        await this.onChainError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    /**\n     * Create and add a run to the run map for tool start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: name ?? tool.id[tool.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: tool,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { input },\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: \"tool\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleToolStart(tool, input, runId, parentRunId, tags, metadata, name) {\n        const run = this.getRunById(runId) ??\n            this._createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name);\n        await this.onRunCreate?.(run);\n        await this.onToolStart?.(run);\n        return run;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async handleToolEnd(output, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"tool\") {\n            throw new Error(\"No tool run to end\");\n        }\n        run.end_time = Date.now();\n        run.outputs = { output };\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onToolEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleToolError(error, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"tool\") {\n            throw new Error(\"No tool run to end\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onToolError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleAgentAction(action, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        const agentRun = run;\n        agentRun.actions = agentRun.actions || [];\n        agentRun.actions.push(action);\n        agentRun.events.push({\n            name: \"agent_action\",\n            time: new Date().toISOString(),\n            kwargs: { action },\n        });\n        await this.onAgentAction?.(run);\n    }\n    async handleAgentEnd(action, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        run.events.push({\n            name: \"agent_end\",\n            time: new Date().toISOString(),\n            kwargs: { action },\n        });\n        await this.onAgentEnd?.(run);\n    }\n    /**\n     * Create and add a run to the run map for retriever start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: name ?? retriever.id[retriever.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: retriever,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { query },\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: \"retriever\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {\n        const run = this.getRunById(runId) ??\n            this._createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name);\n        await this.onRunCreate?.(run);\n        await this.onRetrieverStart?.(run);\n        return run;\n    }\n    async handleRetrieverEnd(documents, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"retriever\") {\n            throw new Error(\"No retriever run to end\");\n        }\n        run.end_time = Date.now();\n        run.outputs = { documents };\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onRetrieverEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleRetrieverError(error, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"retriever\") {\n            throw new Error(\"No retriever run to end\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onRetrieverError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleText(text, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        run.events.push({\n            name: \"text\",\n            time: new Date().toISOString(),\n            kwargs: { text },\n        });\n        await this.onText?.(run);\n    }\n    async handleLLMNewToken(token, idx, runId, _parentRunId, _tags, fields) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            throw new Error(`Invalid \"runId\" provided to \"handleLLMNewToken\" callback.`);\n        }\n        run.events.push({\n            name: \"new_token\",\n            time: new Date().toISOString(),\n            kwargs: { token, idx, chunk: fields?.chunk },\n        });\n        await this.onLLMNewToken?.(run, token, { chunk: fields?.chunk });\n        return run;\n    }\n}\nexports.BaseTracer = BaseTracer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9iYXNlLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCLG9CQUFvQixtQkFBTyxDQUFDLHlFQUFxQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQywyRkFBdUI7QUFDakQsaUJBQWlCLG1CQUFPLENBQUMsaUZBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFlBQVk7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtFQUFrRTtBQUNsRiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHlCQUF5QjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHlCQUF5QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVyxJQUFJO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVyxJQUFJO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVcsSUFBSTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNO0FBQzVCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQ0FBa0M7QUFDeEQsU0FBUztBQUNULGlEQUFpRCxzQkFBc0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9iYXNlLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZVRyYWNlciA9IHZvaWQgMDtcbmV4cG9ydHMuaXNCYXNlVHJhY2VyID0gaXNCYXNlVHJhY2VyO1xuY29uc3QgcnVuX3RyZWVzXzEgPSByZXF1aXJlKFwibGFuZ3NtaXRoL3J1bl90cmVlc1wiKTtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuLi9jYWxsYmFja3MvYmFzZS5janNcIik7XG5jb25zdCBlbnZfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9lbnYuY2pzXCIpO1xuLy8gVE9ETzogUmVtb3ZlIGFuZCBqdXN0IHVzZSBiYXNlIExhbmdTbWl0aCBSdW4gdHlwZVxuY29uc3QgY29udmVydFJ1blRyZWVUb1J1biA9IChydW5UcmVlKSA9PiB7XG4gICAgaWYgKCFydW5UcmVlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEltcG9ydGFudCB0aGF0IHdlIHJldHVybiB0aGUgcmF3IHJ1biB0cmVlIG9iamVjdCBzaW5jZSB0aGUgcmVmZXJlbmNlXG4gICAgLy8gaXMgbXV0YXRlZCBpbiBvdGhlciBwbGFjZXMuXG4gICAgLy8gVE9ETzogUmVtb3ZlIHBsYWNlcyB3aGVyZSB0aGlzIGlzIGJlaW5nIGRvbmUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgcnVuVHJlZS5ldmVudHMgPSBydW5UcmVlLmV2ZW50cyA/PyBbXTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBydW5UcmVlLmNoaWxkX3J1bnMgPSBydW5UcmVlLmNoaWxkX3J1bnMgPz8gW107XG4gICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgY2FzdCBhbmQganVzdCB1c2UgdGhlIExhbmdTbWl0aCBSdW5UcmVlIHR5cGUuXG4gICAgcmV0dXJuIHJ1blRyZWU7XG59O1xuZnVuY3Rpb24gY29udmVydFJ1blRvUnVuVHJlZShydW4sIHBhcmVudFJ1bikge1xuICAgIGlmICghcnVuKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgcnVuX3RyZWVzXzEuUnVuVHJlZSh7XG4gICAgICAgIC4uLnJ1bixcbiAgICAgICAgc3RhcnRfdGltZTogcnVuLl9zZXJpYWxpemVkX3N0YXJ0X3RpbWUgPz8gcnVuLnN0YXJ0X3RpbWUsXG4gICAgICAgIHBhcmVudF9ydW46IGNvbnZlcnRSdW5Ub1J1blRyZWUocGFyZW50UnVuKSxcbiAgICAgICAgY2hpbGRfcnVuczogcnVuLmNoaWxkX3J1bnNcbiAgICAgICAgICAgIC5tYXAoKHIpID0+IGNvbnZlcnRSdW5Ub1J1blRyZWUocikpXG4gICAgICAgICAgICAuZmlsdGVyKChyKSA9PiByICE9PSB1bmRlZmluZWQpLFxuICAgICAgICBleHRyYToge1xuICAgICAgICAgICAgLi4ucnVuLmV4dHJhLFxuICAgICAgICAgICAgcnVudGltZTogKDAsIGVudl9qc18xLmdldFJ1bnRpbWVFbnZpcm9ubWVudFN5bmMpKCksXG4gICAgICAgIH0sXG4gICAgICAgIHRyYWNpbmdFbmFibGVkOiBmYWxzZSxcbiAgICB9KTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBfY29lcmNlVG9EaWN0KHZhbHVlLCBkZWZhdWx0S2V5KSB7XG4gICAgcmV0dXJuIHZhbHVlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCJcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IHsgW2RlZmF1bHRLZXldOiB2YWx1ZSB9O1xufVxuZnVuY3Rpb24gaXNCYXNlVHJhY2VyKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHguX2FkZFJ1blRvUnVuTWFwID09PSBcImZ1bmN0aW9uXCI7XG59XG5jbGFzcyBCYXNlVHJhY2VyIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VDYWxsYmFja0hhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKF9maWVsZHMpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLyoqIEBkZXByZWNhdGVkIFVzZSBgcnVuVHJlZU1hcGAgaW5zdGVhZC4gKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicnVuTWFwXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJ1blRyZWVNYXBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidXNlc1J1blRyZWVNYXBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb3B5KCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0UnVuQnlJZChydW5JZCkge1xuICAgICAgICBpZiAocnVuSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy51c2VzUnVuVHJlZU1hcFxuICAgICAgICAgICAgPyBjb252ZXJ0UnVuVHJlZVRvUnVuKHRoaXMucnVuVHJlZU1hcC5nZXQocnVuSWQpKVxuICAgICAgICAgICAgOiB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgIH1cbiAgICBzdHJpbmdpZnlFcnJvcihlcnJvcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZSArIChlcnJvcj8uc3RhY2sgPyBgXFxuXFxuJHtlcnJvci5zdGFja31gIDogXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtlcnJvcn1gO1xuICAgIH1cbiAgICBfYWRkQ2hpbGRSdW4ocGFyZW50UnVuLCBjaGlsZFJ1bikge1xuICAgICAgICBwYXJlbnRSdW4uY2hpbGRfcnVucy5wdXNoKGNoaWxkUnVuKTtcbiAgICB9XG4gICAgX2FkZFJ1blRvUnVuTWFwKHJ1bikge1xuICAgICAgICBjb25zdCB7IGRvdHRlZE9yZGVyOiBjdXJyZW50RG90dGVkT3JkZXIsIG1pY3Jvc2Vjb25kUHJlY2lzaW9uRGF0ZXN0cmluZyB9ID0gKDAsIHJ1bl90cmVlc18xLmNvbnZlcnRUb0RvdHRlZE9yZGVyRm9ybWF0KShuZXcgRGF0ZShydW4uc3RhcnRfdGltZSkuZ2V0VGltZSgpLCBydW4uaWQsIHJ1bi5leGVjdXRpb25fb3JkZXIpO1xuICAgICAgICBjb25zdCBzdG9yZWRSdW4gPSB7IC4uLnJ1biB9O1xuICAgICAgICBjb25zdCBwYXJlbnRSdW4gPSB0aGlzLmdldFJ1bkJ5SWQoc3RvcmVkUnVuLnBhcmVudF9ydW5faWQpO1xuICAgICAgICBpZiAoc3RvcmVkUnVuLnBhcmVudF9ydW5faWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudFJ1bikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZENoaWxkUnVuKHBhcmVudFJ1biwgc3RvcmVkUnVuKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRSdW4uY2hpbGRfZXhlY3V0aW9uX29yZGVyID0gTWF0aC5tYXgocGFyZW50UnVuLmNoaWxkX2V4ZWN1dGlvbl9vcmRlciwgc3RvcmVkUnVuLmNoaWxkX2V4ZWN1dGlvbl9vcmRlcik7XG4gICAgICAgICAgICAgICAgc3RvcmVkUnVuLnRyYWNlX2lkID0gcGFyZW50UnVuLnRyYWNlX2lkO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRSdW4uZG90dGVkX29yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVkUnVuLmRvdHRlZF9vcmRlciA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFJ1bi5kb3R0ZWRfb3JkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RG90dGVkT3JkZXIsXG4gICAgICAgICAgICAgICAgICAgIF0uam9pbihcIi5cIik7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlZFJ1bi5fc2VyaWFsaXplZF9zdGFydF90aW1lID0gbWljcm9zZWNvbmRQcmVjaXNpb25EYXRlc3RyaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIG5hdHVyYWxseSBmb3IgY2FsbGJhY2tzIGFkZGVkIHdpdGhpbiBhIHJ1blxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmRlYnVnKGBQYXJlbnQgcnVuIHdpdGggVVVJRCAke3N0b3JlZFJ1bi5wYXJlbnRfcnVuX2lkfSBoYXMgbm8gZG90dGVkIG9yZGVyLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBuYXR1cmFsbHkgZm9yIGNhbGxiYWNrcyBhZGRlZCB3aXRoaW4gYSBydW5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmRlYnVnKFxuICAgICAgICAgICAgICAgIC8vICAgYFBhcmVudCBydW4gd2l0aCBVVUlEICR7c3RvcmVkUnVuLnBhcmVudF9ydW5faWR9IG5vdCBmb3VuZC5gXG4gICAgICAgICAgICAgICAgLy8gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0b3JlZFJ1bi50cmFjZV9pZCA9IHN0b3JlZFJ1bi5pZDtcbiAgICAgICAgICAgIHN0b3JlZFJ1bi5kb3R0ZWRfb3JkZXIgPSBjdXJyZW50RG90dGVkT3JkZXI7XG4gICAgICAgICAgICBzdG9yZWRSdW4uX3NlcmlhbGl6ZWRfc3RhcnRfdGltZSA9IG1pY3Jvc2Vjb25kUHJlY2lzaW9uRGF0ZXN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51c2VzUnVuVHJlZU1hcCkge1xuICAgICAgICAgICAgY29uc3QgcnVuVHJlZSA9IGNvbnZlcnRSdW5Ub1J1blRyZWUoc3RvcmVkUnVuLCBwYXJlbnRSdW4pO1xuICAgICAgICAgICAgaWYgKHJ1blRyZWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucnVuVHJlZU1hcC5zZXQoc3RvcmVkUnVuLmlkLCBydW5UcmVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucnVuTWFwLnNldChzdG9yZWRSdW4uaWQsIHN0b3JlZFJ1bik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0b3JlZFJ1bjtcbiAgICB9XG4gICAgYXN5bmMgX2VuZFRyYWNlKHJ1bikge1xuICAgICAgICBjb25zdCBwYXJlbnRSdW4gPSBydW4ucGFyZW50X3J1bl9pZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZ2V0UnVuQnlJZChydW4ucGFyZW50X3J1bl9pZCk7XG4gICAgICAgIGlmIChwYXJlbnRSdW4pIHtcbiAgICAgICAgICAgIHBhcmVudFJ1bi5jaGlsZF9leGVjdXRpb25fb3JkZXIgPSBNYXRoLm1heChwYXJlbnRSdW4uY2hpbGRfZXhlY3V0aW9uX29yZGVyLCBydW4uY2hpbGRfZXhlY3V0aW9uX29yZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdFJ1bihydW4pO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMub25SdW5VcGRhdGU/LihydW4pO1xuICAgICAgICBpZiAodGhpcy51c2VzUnVuVHJlZU1hcCkge1xuICAgICAgICAgICAgdGhpcy5ydW5UcmVlTWFwLmRlbGV0ZShydW4uaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ydW5NYXAuZGVsZXRlKHJ1bi5pZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldEV4ZWN1dGlvbk9yZGVyKHBhcmVudFJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFJ1biA9IHBhcmVudFJ1bklkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5nZXRSdW5CeUlkKHBhcmVudFJ1bklkKTtcbiAgICAgICAgLy8gSWYgYSBydW4gaGFzIG5vIHBhcmVudCB0aGVuIGV4ZWN1dGlvbiBvcmRlciBpcyAxXG4gICAgICAgIGlmICghcGFyZW50UnVuKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50UnVuLmNoaWxkX2V4ZWN1dGlvbl9vcmRlciArIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbmQgYWRkIGEgcnVuIHRvIHRoZSBydW4gbWFwIGZvciBMTE0gc3RhcnQgZXZlbnRzLlxuICAgICAqIFRoaXMgbXVzdCBzb21ldGltZXMgYmUgZG9uZSBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAqIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQsIHNvIHdlIGV4cG9zZSBpdCBhcyBhIHNlcGFyYXRlIG1ldGhvZCBoZXJlLlxuICAgICAqL1xuICAgIF9jcmVhdGVSdW5Gb3JMTE1TdGFydChsbG0sIHByb21wdHMsIHJ1bklkLCBwYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGV4ZWN1dGlvbl9vcmRlciA9IHRoaXMuX2dldEV4ZWN1dGlvbk9yZGVyKHBhcmVudFJ1bklkKTtcbiAgICAgICAgY29uc3Qgc3RhcnRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGZpbmFsRXh0cmFQYXJhbXMgPSBtZXRhZGF0YVxuICAgICAgICAgICAgPyB7IC4uLmV4dHJhUGFyYW1zLCBtZXRhZGF0YSB9XG4gICAgICAgICAgICA6IGV4dHJhUGFyYW1zO1xuICAgICAgICBjb25zdCBydW4gPSB7XG4gICAgICAgICAgICBpZDogcnVuSWQsXG4gICAgICAgICAgICBuYW1lOiBuYW1lID8/IGxsbS5pZFtsbG0uaWQubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBwYXJlbnRSdW5JZCxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWUsXG4gICAgICAgICAgICBzZXJpYWxpemVkOiBsbG0sXG4gICAgICAgICAgICBldmVudHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwic3RhcnRcIixcbiAgICAgICAgICAgICAgICAgICAgdGltZTogbmV3IERhdGUoc3RhcnRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGlucHV0czogeyBwcm9tcHRzIH0sXG4gICAgICAgICAgICBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBjaGlsZF9ydW5zOiBbXSxcbiAgICAgICAgICAgIGNoaWxkX2V4ZWN1dGlvbl9vcmRlcjogZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgcnVuX3R5cGU6IFwibGxtXCIsXG4gICAgICAgICAgICBleHRyYTogZmluYWxFeHRyYVBhcmFtcyA/PyB7fSxcbiAgICAgICAgICAgIHRhZ3M6IHRhZ3MgfHwgW10sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRSdW5Ub1J1bk1hcChydW4pO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVMTE1TdGFydChsbG0sIHByb21wdHMsIHJ1bklkLCBwYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMuZ2V0UnVuQnlJZChydW5JZCkgPz9cbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJ1bkZvckxMTVN0YXJ0KGxsbSwgcHJvbXB0cywgcnVuSWQsIHBhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGFncywgbWV0YWRhdGEsIG5hbWUpO1xuICAgICAgICBhd2FpdCB0aGlzLm9uUnVuQ3JlYXRlPy4ocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbkxMTVN0YXJ0Py4ocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCBhZGQgYSBydW4gdG8gdGhlIHJ1biBtYXAgZm9yIGNoYXQgbW9kZWwgc3RhcnQgZXZlbnRzLlxuICAgICAqIFRoaXMgbXVzdCBzb21ldGltZXMgYmUgZG9uZSBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAqIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQsIHNvIHdlIGV4cG9zZSBpdCBhcyBhIHNlcGFyYXRlIG1ldGhvZCBoZXJlLlxuICAgICAqL1xuICAgIF9jcmVhdGVSdW5Gb3JDaGF0TW9kZWxTdGFydChsbG0sIG1lc3NhZ2VzLCBydW5JZCwgcGFyZW50UnVuSWQsIGV4dHJhUGFyYW1zLCB0YWdzLCBtZXRhZGF0YSwgbmFtZSkge1xuICAgICAgICBjb25zdCBleGVjdXRpb25fb3JkZXIgPSB0aGlzLl9nZXRFeGVjdXRpb25PcmRlcihwYXJlbnRSdW5JZCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBmaW5hbEV4dHJhUGFyYW1zID0gbWV0YWRhdGFcbiAgICAgICAgICAgID8geyAuLi5leHRyYVBhcmFtcywgbWV0YWRhdGEgfVxuICAgICAgICAgICAgOiBleHRyYVBhcmFtcztcbiAgICAgICAgY29uc3QgcnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bklkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSA/PyBsbG0uaWRbbGxtLmlkLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgcGFyZW50X3J1bl9pZDogcGFyZW50UnVuSWQsXG4gICAgICAgICAgICBzdGFydF90aW1lLFxuICAgICAgICAgICAgc2VyaWFsaXplZDogbGxtLFxuICAgICAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dHM6IHsgbWVzc2FnZXMgfSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIGNoaWxkX3J1bnM6IFtdLFxuICAgICAgICAgICAgY2hpbGRfZXhlY3V0aW9uX29yZGVyOiBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBydW5fdHlwZTogXCJsbG1cIixcbiAgICAgICAgICAgIGV4dHJhOiBmaW5hbEV4dHJhUGFyYW1zID8/IHt9LFxuICAgICAgICAgICAgdGFnczogdGFncyB8fCBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJ1blRvUnVuTWFwKHJ1bik7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUNoYXRNb2RlbFN0YXJ0KGxsbSwgbWVzc2FnZXMsIHJ1bklkLCBwYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMuZ2V0UnVuQnlJZChydW5JZCkgPz9cbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJ1bkZvckNoYXRNb2RlbFN0YXJ0KGxsbSwgbWVzc2FnZXMsIHJ1bklkLCBwYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblJ1bkNyZWF0ZT8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMub25MTE1TdGFydD8uKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUxMTUVuZChvdXRwdXQsIHJ1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBleHRyYVBhcmFtcykge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLmdldFJ1bkJ5SWQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcImxsbVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBMTE0gcnVuIHRvIGVuZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmVuZF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcnVuLm91dHB1dHMgPSBvdXRwdXQ7XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImVuZFwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUocnVuLmVuZF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgcnVuLmV4dHJhID0geyAuLi5ydW4uZXh0cmEsIC4uLmV4dHJhUGFyYW1zIH07XG4gICAgICAgIGF3YWl0IHRoaXMub25MTE1FbmQ/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVMTE1FcnJvcihlcnJvciwgcnVuSWQsIF9wYXJlbnRSdW5JZCwgX3RhZ3MsIGV4dHJhUGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMuZ2V0UnVuQnlJZChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwibGxtXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIExMTSBydW4gdG8gZW5kLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4uZXJyb3IgPSB0aGlzLnN0cmluZ2lmeUVycm9yKGVycm9yKTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJ1bi5leHRyYSA9IHsgLi4ucnVuLmV4dHJhLCAuLi5leHRyYVBhcmFtcyB9O1xuICAgICAgICBhd2FpdCB0aGlzLm9uTExNRXJyb3I/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIGFkZCBhIHJ1biB0byB0aGUgcnVuIG1hcCBmb3IgY2hhaW4gc3RhcnQgZXZlbnRzLlxuICAgICAqIFRoaXMgbXVzdCBzb21ldGltZXMgYmUgZG9uZSBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAqIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQsIHNvIHdlIGV4cG9zZSBpdCBhcyBhIHNlcGFyYXRlIG1ldGhvZCBoZXJlLlxuICAgICAqL1xuICAgIF9jcmVhdGVSdW5Gb3JDaGFpblN0YXJ0KGNoYWluLCBpbnB1dHMsIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIHJ1blR5cGUsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uX29yZGVyID0gdGhpcy5fZ2V0RXhlY3V0aW9uT3JkZXIocGFyZW50UnVuSWQpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgcnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bklkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSA/PyBjaGFpbi5pZFtjaGFpbi5pZC5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHBhcmVudFJ1bklkLFxuICAgICAgICAgICAgc3RhcnRfdGltZSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IGNoYWluLFxuICAgICAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dHMsXG4gICAgICAgICAgICBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBjaGlsZF9leGVjdXRpb25fb3JkZXI6IGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIHJ1bl90eXBlOiBydW5UeXBlID8/IFwiY2hhaW5cIixcbiAgICAgICAgICAgIGNoaWxkX3J1bnM6IFtdLFxuICAgICAgICAgICAgZXh0cmE6IG1ldGFkYXRhID8geyBtZXRhZGF0YSB9IDoge30sXG4gICAgICAgICAgICB0YWdzOiB0YWdzIHx8IFtdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkUnVuVG9SdW5NYXAocnVuKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQ2hhaW5TdGFydChjaGFpbiwgaW5wdXRzLCBydW5JZCwgcGFyZW50UnVuSWQsIHRhZ3MsIG1ldGFkYXRhLCBydW5UeXBlLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMuZ2V0UnVuQnlJZChydW5JZCkgPz9cbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJ1bkZvckNoYWluU3RhcnQoY2hhaW4sIGlucHV0cywgcnVuSWQsIHBhcmVudFJ1bklkLCB0YWdzLCBtZXRhZGF0YSwgcnVuVHlwZSwgbmFtZSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25SdW5DcmVhdGU/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uQ2hhaW5TdGFydD8uKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUNoYWluRW5kKG91dHB1dHMsIHJ1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBrd2FyZ3MpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5nZXRSdW5CeUlkKHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNoYWluIHJ1biB0byBlbmQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5lbmRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJ1bi5vdXRwdXRzID0gX2NvZXJjZVRvRGljdChvdXRwdXRzLCBcIm91dHB1dFwiKTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZW5kXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoa3dhcmdzPy5pbnB1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcnVuLmlucHV0cyA9IF9jb2VyY2VUb0RpY3Qoa3dhcmdzLmlucHV0cywgXCJpbnB1dFwiKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLm9uQ2hhaW5FbmQ/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGFpbkVycm9yKGVycm9yLCBydW5JZCwgX3BhcmVudFJ1bklkLCBfdGFncywga3dhcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMuZ2V0UnVuQnlJZChydW5JZCk7XG4gICAgICAgIGlmICghcnVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjaGFpbiBydW4gdG8gZW5kLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4uZXJyb3IgPSB0aGlzLnN0cmluZ2lmeUVycm9yKGVycm9yKTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChrd2FyZ3M/LmlucHV0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBydW4uaW5wdXRzID0gX2NvZXJjZVRvRGljdChrd2FyZ3MuaW5wdXRzLCBcImlucHV0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMub25DaGFpbkVycm9yPy4ocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZW5kVHJhY2UocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCBhZGQgYSBydW4gdG8gdGhlIHJ1biBtYXAgZm9yIHRvb2wgc3RhcnQgZXZlbnRzLlxuICAgICAqIFRoaXMgbXVzdCBzb21ldGltZXMgYmUgZG9uZSBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAqIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQsIHNvIHdlIGV4cG9zZSBpdCBhcyBhIHNlcGFyYXRlIG1ldGhvZCBoZXJlLlxuICAgICAqL1xuICAgIF9jcmVhdGVSdW5Gb3JUb29sU3RhcnQodG9vbCwgaW5wdXQsIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uX29yZGVyID0gdGhpcy5fZ2V0RXhlY3V0aW9uT3JkZXIocGFyZW50UnVuSWQpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgcnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bklkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSA/PyB0b29sLmlkW3Rvb2wuaWQubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBwYXJlbnRSdW5JZCxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWUsXG4gICAgICAgICAgICBzZXJpYWxpemVkOiB0b29sLFxuICAgICAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dHM6IHsgaW5wdXQgfSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIGNoaWxkX2V4ZWN1dGlvbl9vcmRlcjogZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgcnVuX3R5cGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgY2hpbGRfcnVuczogW10sXG4gICAgICAgICAgICBleHRyYTogbWV0YWRhdGEgPyB7IG1ldGFkYXRhIH0gOiB7fSxcbiAgICAgICAgICAgIHRhZ3M6IHRhZ3MgfHwgW10sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRSdW5Ub1J1bk1hcChydW4pO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVUb29sU3RhcnQodG9vbCwgaW5wdXQsIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5nZXRSdW5CeUlkKHJ1bklkKSA/P1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlUnVuRm9yVG9vbFN0YXJ0KHRvb2wsIGlucHV0LCBydW5JZCwgcGFyZW50UnVuSWQsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblJ1bkNyZWF0ZT8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMub25Ub29sU3RhcnQ/LihydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGFzeW5jIGhhbmRsZVRvb2xFbmQob3V0cHV0LCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLmdldFJ1bkJ5SWQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcInRvb2xcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdG9vbCBydW4gdG8gZW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5lbmRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJ1bi5vdXRwdXRzID0geyBvdXRwdXQgfTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZW5kXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uVG9vbEVuZD8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRvb2xFcnJvcihlcnJvciwgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5nZXRSdW5CeUlkKHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4gfHwgcnVuPy5ydW5fdHlwZSAhPT0gXCJ0b29sXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHRvb2wgcnVuIHRvIGVuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4uZXJyb3IgPSB0aGlzLnN0cmluZ2lmeUVycm9yKGVycm9yKTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25Ub29sRXJyb3I/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVBZ2VudEFjdGlvbihhY3Rpb24sIHJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMuZ2V0UnVuQnlJZChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwiY2hhaW5cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFnZW50UnVuID0gcnVuO1xuICAgICAgICBhZ2VudFJ1bi5hY3Rpb25zID0gYWdlbnRSdW4uYWN0aW9ucyB8fCBbXTtcbiAgICAgICAgYWdlbnRSdW4uYWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gICAgICAgIGFnZW50UnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWdlbnRfYWN0aW9uXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBrd2FyZ3M6IHsgYWN0aW9uIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uQWdlbnRBY3Rpb24/LihydW4pO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVBZ2VudEVuZChhY3Rpb24sIHJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMuZ2V0UnVuQnlJZChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwiY2hhaW5cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImFnZW50X2VuZFwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAga3dhcmdzOiB7IGFjdGlvbiB9LFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbkFnZW50RW5kPy4ocnVuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCBhZGQgYSBydW4gdG8gdGhlIHJ1biBtYXAgZm9yIHJldHJpZXZlciBzdGFydCBldmVudHMuXG4gICAgICogVGhpcyBtdXN0IHNvbWV0aW1lcyBiZSBkb25lIHN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgICogd2hlbiBjYWxsYmFja3MgYXJlIGJhY2tncm91bmRlZCwgc28gd2UgZXhwb3NlIGl0IGFzIGEgc2VwYXJhdGUgbWV0aG9kIGhlcmUuXG4gICAgICovXG4gICAgX2NyZWF0ZVJ1bkZvclJldHJpZXZlclN0YXJ0KHJldHJpZXZlciwgcXVlcnksIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uX29yZGVyID0gdGhpcy5fZ2V0RXhlY3V0aW9uT3JkZXIocGFyZW50UnVuSWQpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgcnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bklkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSA/PyByZXRyaWV2ZXIuaWRbcmV0cmlldmVyLmlkLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgcGFyZW50X3J1bl9pZDogcGFyZW50UnVuSWQsXG4gICAgICAgICAgICBzdGFydF90aW1lLFxuICAgICAgICAgICAgc2VyaWFsaXplZDogcmV0cmlldmVyLFxuICAgICAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dHM6IHsgcXVlcnkgfSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIGNoaWxkX2V4ZWN1dGlvbl9vcmRlcjogZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgcnVuX3R5cGU6IFwicmV0cmlldmVyXCIsXG4gICAgICAgICAgICBjaGlsZF9ydW5zOiBbXSxcbiAgICAgICAgICAgIGV4dHJhOiBtZXRhZGF0YSA/IHsgbWV0YWRhdGEgfSA6IHt9LFxuICAgICAgICAgICAgdGFnczogdGFncyB8fCBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJ1blRvUnVuTWFwKHJ1bik7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVJldHJpZXZlclN0YXJ0KHJldHJpZXZlciwgcXVlcnksIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5nZXRSdW5CeUlkKHJ1bklkKSA/P1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlUnVuRm9yUmV0cmlldmVyU3RhcnQocmV0cmlldmVyLCBxdWVyeSwgcnVuSWQsIHBhcmVudFJ1bklkLCB0YWdzLCBtZXRhZGF0YSwgbmFtZSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25SdW5DcmVhdGU/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uUmV0cmlldmVyU3RhcnQ/LihydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSZXRyaWV2ZXJFbmQoZG9jdW1lbnRzLCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLmdldFJ1bkJ5SWQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcInJldHJpZXZlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZXRyaWV2ZXIgcnVuIHRvIGVuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4ub3V0cHV0cyA9IHsgZG9jdW1lbnRzIH07XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImVuZFwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUocnVuLmVuZF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblJldHJpZXZlckVuZD8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVJldHJpZXZlckVycm9yKGVycm9yLCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLmdldFJ1bkJ5SWQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcInJldHJpZXZlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZXRyaWV2ZXIgcnVuIHRvIGVuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4uZXJyb3IgPSB0aGlzLnN0cmluZ2lmeUVycm9yKGVycm9yKTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25SZXRyaWV2ZXJFcnJvcj8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRleHQodGV4dCwgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5nZXRSdW5CeUlkKHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4gfHwgcnVuPy5ydW5fdHlwZSAhPT0gXCJjaGFpblwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwidGV4dFwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAga3dhcmdzOiB7IHRleHQgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25UZXh0Py4ocnVuKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTExNTmV3VG9rZW4odG9rZW4sIGlkeCwgcnVuSWQsIF9wYXJlbnRSdW5JZCwgX3RhZ3MsIGZpZWxkcykge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLmdldFJ1bkJ5SWQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcImxsbVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXCJydW5JZFwiIHByb3ZpZGVkIHRvIFwiaGFuZGxlTExNTmV3VG9rZW5cIiBjYWxsYmFjay5gKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJuZXdfdG9rZW5cIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGt3YXJnczogeyB0b2tlbiwgaWR4LCBjaHVuazogZmllbGRzPy5jaHVuayB9LFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbkxMTU5ld1Rva2VuPy4ocnVuLCB0b2tlbiwgeyBjaHVuazogZmllbGRzPy5jaHVuayB9KTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VUcmFjZXIgPSBCYXNlVHJhY2VyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/base.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/console.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/console.cjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConsoleCallbackHandler = void 0;\nconst ansi_styles_1 = __importDefault(__webpack_require__(/*! ansi-styles */ \"(rsc)/./node_modules/ansi-styles/index.js\"));\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.cjs\");\nfunction wrap(style, text) {\n    return `${style.open}${text}${style.close}`;\n}\nfunction tryJsonStringify(obj, fallback) {\n    try {\n        return JSON.stringify(obj, null, 2);\n    }\n    catch (err) {\n        return fallback;\n    }\n}\nfunction formatKVMapItem(value) {\n    if (typeof value === \"string\") {\n        return value.trim();\n    }\n    if (value === null || value === undefined) {\n        return value;\n    }\n    return tryJsonStringify(value, value.toString());\n}\nfunction elapsed(run) {\n    if (!run.end_time)\n        return \"\";\n    const elapsed = run.end_time - run.start_time;\n    if (elapsed < 1000) {\n        return `${elapsed}ms`;\n    }\n    return `${(elapsed / 1000).toFixed(2)}s`;\n}\nconst { color } = ansi_styles_1.default;\n/**\n * A tracer that logs all events to the console. It extends from the\n * `BaseTracer` class and overrides its methods to provide custom logging\n * functionality.\n * @example\n * ```typescript\n *\n * const llm = new ChatAnthropic({\n *   temperature: 0,\n *   tags: [\"example\", \"callbacks\", \"constructor\"],\n *   callbacks: [new ConsoleCallbackHandler()],\n * });\n *\n * ```\n */\nclass ConsoleCallbackHandler extends base_js_1.BaseTracer {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"console_callback_handler\"\n        });\n    }\n    /**\n     * Method used to persist the run. In this case, it simply returns a\n     * resolved promise as there's no persistence logic.\n     * @param _run The run to persist.\n     * @returns A resolved promise.\n     */\n    persistRun(_run) {\n        return Promise.resolve();\n    }\n    // utility methods\n    /**\n     * Method used to get all the parent runs of a given run.\n     * @param run The run whose parents are to be retrieved.\n     * @returns An array of parent runs.\n     */\n    getParents(run) {\n        const parents = [];\n        let currentRun = run;\n        while (currentRun.parent_run_id) {\n            const parent = this.runMap.get(currentRun.parent_run_id);\n            if (parent) {\n                parents.push(parent);\n                currentRun = parent;\n            }\n            else {\n                break;\n            }\n        }\n        return parents;\n    }\n    /**\n     * Method used to get a string representation of the run's lineage, which\n     * is used in logging.\n     * @param run The run whose lineage is to be retrieved.\n     * @returns A string representation of the run's lineage.\n     */\n    getBreadcrumbs(run) {\n        const parents = this.getParents(run).reverse();\n        const string = [...parents, run]\n            .map((parent, i, arr) => {\n            const name = `${parent.execution_order}:${parent.run_type}:${parent.name}`;\n            return i === arr.length - 1 ? wrap(ansi_styles_1.default.bold, name) : name;\n        })\n            .join(\" > \");\n        return wrap(color.grey, string);\n    }\n    // logging methods\n    /**\n     * Method used to log the start of a chain run.\n     * @param run The chain run that has started.\n     * @returns void\n     */\n    onChainStart(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.green, \"[chain/start]\")} [${crumbs}] Entering Chain run with input: ${tryJsonStringify(run.inputs, \"[inputs]\")}`);\n    }\n    /**\n     * Method used to log the end of a chain run.\n     * @param run The chain run that has ended.\n     * @returns void\n     */\n    onChainEnd(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.cyan, \"[chain/end]\")} [${crumbs}] [${elapsed(run)}] Exiting Chain run with output: ${tryJsonStringify(run.outputs, \"[outputs]\")}`);\n    }\n    /**\n     * Method used to log any errors of a chain run.\n     * @param run The chain run that has errored.\n     * @returns void\n     */\n    onChainError(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.red, \"[chain/error]\")} [${crumbs}] [${elapsed(run)}] Chain run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n    }\n    /**\n     * Method used to log the start of an LLM run.\n     * @param run The LLM run that has started.\n     * @returns void\n     */\n    onLLMStart(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        const inputs = \"prompts\" in run.inputs\n            ? { prompts: run.inputs.prompts.map((p) => p.trim()) }\n            : run.inputs;\n        console.log(`${wrap(color.green, \"[llm/start]\")} [${crumbs}] Entering LLM run with input: ${tryJsonStringify(inputs, \"[inputs]\")}`);\n    }\n    /**\n     * Method used to log the end of an LLM run.\n     * @param run The LLM run that has ended.\n     * @returns void\n     */\n    onLLMEnd(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.cyan, \"[llm/end]\")} [${crumbs}] [${elapsed(run)}] Exiting LLM run with output: ${tryJsonStringify(run.outputs, \"[response]\")}`);\n    }\n    /**\n     * Method used to log any errors of an LLM run.\n     * @param run The LLM run that has errored.\n     * @returns void\n     */\n    onLLMError(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.red, \"[llm/error]\")} [${crumbs}] [${elapsed(run)}] LLM run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n    }\n    /**\n     * Method used to log the start of a tool run.\n     * @param run The tool run that has started.\n     * @returns void\n     */\n    onToolStart(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.green, \"[tool/start]\")} [${crumbs}] Entering Tool run with input: \"${formatKVMapItem(run.inputs.input)}\"`);\n    }\n    /**\n     * Method used to log the end of a tool run.\n     * @param run The tool run that has ended.\n     * @returns void\n     */\n    onToolEnd(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.cyan, \"[tool/end]\")} [${crumbs}] [${elapsed(run)}] Exiting Tool run with output: \"${formatKVMapItem(run.outputs?.output)}\"`);\n    }\n    /**\n     * Method used to log any errors of a tool run.\n     * @param run The tool run that has errored.\n     * @returns void\n     */\n    onToolError(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.red, \"[tool/error]\")} [${crumbs}] [${elapsed(run)}] Tool run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n    }\n    /**\n     * Method used to log the start of a retriever run.\n     * @param run The retriever run that has started.\n     * @returns void\n     */\n    onRetrieverStart(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.green, \"[retriever/start]\")} [${crumbs}] Entering Retriever run with input: ${tryJsonStringify(run.inputs, \"[inputs]\")}`);\n    }\n    /**\n     * Method used to log the end of a retriever run.\n     * @param run The retriever run that has ended.\n     * @returns void\n     */\n    onRetrieverEnd(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.cyan, \"[retriever/end]\")} [${crumbs}] [${elapsed(run)}] Exiting Retriever run with output: ${tryJsonStringify(run.outputs, \"[outputs]\")}`);\n    }\n    /**\n     * Method used to log any errors of a retriever run.\n     * @param run The retriever run that has errored.\n     * @returns void\n     */\n    onRetrieverError(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.red, \"[retriever/error]\")} [${crumbs}] [${elapsed(run)}] Retriever run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n    }\n    /**\n     * Method used to log the action selected by the agent.\n     * @param run The run in which the agent action occurred.\n     * @returns void\n     */\n    onAgentAction(run) {\n        const agentRun = run;\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.blue, \"[agent/action]\")} [${crumbs}] Agent selected action: ${tryJsonStringify(agentRun.actions[agentRun.actions.length - 1], \"[action]\")}`);\n    }\n}\nexports.ConsoleCallbackHandler = ConsoleCallbackHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9jb25zb2xlLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QjtBQUM5QixzQ0FBc0MsbUJBQU8sQ0FBQyw4REFBYTtBQUMzRCxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBWTtBQUN0QztBQUNBLGNBQWMsV0FBVyxFQUFFLEtBQUssRUFBRSxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0EsUUFBUSxRQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QixHQUFHLGdCQUFnQixHQUFHLFlBQVk7QUFDckY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQ0FBb0MsR0FBRyxPQUFPLG1DQUFtQyx5Q0FBeUM7QUFDako7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQ0FBaUMsR0FBRyxPQUFPLEtBQUssYUFBYSxtQ0FBbUMsMkNBQTJDO0FBQ2xLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0NBQWtDLEdBQUcsT0FBTyxLQUFLLGFBQWEsa0NBQWtDLHVDQUF1QztBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSx1QkFBdUIsa0NBQWtDLEdBQUcsT0FBTyxpQ0FBaUMscUNBQXFDO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0JBQStCLEdBQUcsT0FBTyxLQUFLLGFBQWEsaUNBQWlDLDRDQUE0QztBQUMvSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdDQUFnQyxHQUFHLE9BQU8sS0FBSyxhQUFhLGdDQUFnQyx1Q0FBdUM7QUFDMUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQ0FBbUMsR0FBRyxPQUFPLG1DQUFtQyxrQ0FBa0M7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQ0FBZ0MsR0FBRyxPQUFPLEtBQUssYUFBYSxtQ0FBbUMscUNBQXFDO0FBQzNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUNBQWlDLEdBQUcsT0FBTyxLQUFLLGFBQWEsaUNBQWlDLHVDQUF1QztBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdDQUF3QyxHQUFHLE9BQU8sdUNBQXVDLHlDQUF5QztBQUN6SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFDQUFxQyxHQUFHLE9BQU8sS0FBSyxhQUFhLHVDQUF1QywyQ0FBMkM7QUFDMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQ0FBc0MsR0FBRyxPQUFPLEtBQUssYUFBYSxzQ0FBc0MsdUNBQXVDO0FBQ3RLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQ0FBb0MsR0FBRyxPQUFPLDJCQUEyQiw0RUFBNEU7QUFDNUs7QUFDQTtBQUNBLDhCQUE4QiIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3RyYWNlcnMvY29uc29sZS5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbnNvbGVDYWxsYmFja0hhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCBhbnNpX3N0eWxlc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhbnNpLXN0eWxlc1wiKSk7XG5jb25zdCBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlLmNqc1wiKTtcbmZ1bmN0aW9uIHdyYXAoc3R5bGUsIHRleHQpIHtcbiAgICByZXR1cm4gYCR7c3R5bGUub3Blbn0ke3RleHR9JHtzdHlsZS5jbG9zZX1gO1xufVxuZnVuY3Rpb24gdHJ5SnNvblN0cmluZ2lmeShvYmosIGZhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgMik7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdEtWTWFwSXRlbSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ5SnNvblN0cmluZ2lmeSh2YWx1ZSwgdmFsdWUudG9TdHJpbmcoKSk7XG59XG5mdW5jdGlvbiBlbGFwc2VkKHJ1bikge1xuICAgIGlmICghcnVuLmVuZF90aW1lKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICBjb25zdCBlbGFwc2VkID0gcnVuLmVuZF90aW1lIC0gcnVuLnN0YXJ0X3RpbWU7XG4gICAgaWYgKGVsYXBzZWQgPCAxMDAwKSB7XG4gICAgICAgIHJldHVybiBgJHtlbGFwc2VkfW1zYDtcbiAgICB9XG4gICAgcmV0dXJuIGAkeyhlbGFwc2VkIC8gMTAwMCkudG9GaXhlZCgyKX1zYDtcbn1cbmNvbnN0IHsgY29sb3IgfSA9IGFuc2lfc3R5bGVzXzEuZGVmYXVsdDtcbi8qKlxuICogQSB0cmFjZXIgdGhhdCBsb2dzIGFsbCBldmVudHMgdG8gdGhlIGNvbnNvbGUuIEl0IGV4dGVuZHMgZnJvbSB0aGVcbiAqIGBCYXNlVHJhY2VyYCBjbGFzcyBhbmQgb3ZlcnJpZGVzIGl0cyBtZXRob2RzIHRvIHByb3ZpZGUgY3VzdG9tIGxvZ2dpbmdcbiAqIGZ1bmN0aW9uYWxpdHkuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICpcbiAqIGNvbnN0IGxsbSA9IG5ldyBDaGF0QW50aHJvcGljKHtcbiAqICAgdGVtcGVyYXR1cmU6IDAsXG4gKiAgIHRhZ3M6IFtcImV4YW1wbGVcIiwgXCJjYWxsYmFja3NcIiwgXCJjb25zdHJ1Y3RvclwiXSxcbiAqICAgY2FsbGJhY2tzOiBbbmV3IENvbnNvbGVDYWxsYmFja0hhbmRsZXIoKV0sXG4gKiB9KTtcbiAqXG4gKiBgYGBcbiAqL1xuY2xhc3MgQ29uc29sZUNhbGxiYWNrSGFuZGxlciBleHRlbmRzIGJhc2VfanNfMS5CYXNlVHJhY2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJjb25zb2xlX2NhbGxiYWNrX2hhbmRsZXJcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gcGVyc2lzdCB0aGUgcnVuLiBJbiB0aGlzIGNhc2UsIGl0IHNpbXBseSByZXR1cm5zIGFcbiAgICAgKiByZXNvbHZlZCBwcm9taXNlIGFzIHRoZXJlJ3Mgbm8gcGVyc2lzdGVuY2UgbG9naWMuXG4gICAgICogQHBhcmFtIF9ydW4gVGhlIHJ1biB0byBwZXJzaXN0LlxuICAgICAqIEByZXR1cm5zIEEgcmVzb2x2ZWQgcHJvbWlzZS5cbiAgICAgKi9cbiAgICBwZXJzaXN0UnVuKF9ydW4pIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICAvLyB1dGlsaXR5IG1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBnZXQgYWxsIHRoZSBwYXJlbnQgcnVucyBvZiBhIGdpdmVuIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBydW4gd2hvc2UgcGFyZW50cyBhcmUgdG8gYmUgcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHBhcmVudCBydW5zLlxuICAgICAqL1xuICAgIGdldFBhcmVudHMocnVuKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnRSdW4gPSBydW47XG4gICAgICAgIHdoaWxlIChjdXJyZW50UnVuLnBhcmVudF9ydW5faWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucnVuTWFwLmdldChjdXJyZW50UnVuLnBhcmVudF9ydW5faWQpO1xuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRSdW4gPSBwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gZ2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBydW4ncyBsaW5lYWdlLCB3aGljaFxuICAgICAqIGlzIHVzZWQgaW4gbG9nZ2luZy5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBydW4gd2hvc2UgbGluZWFnZSBpcyB0byBiZSByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJ1bidzIGxpbmVhZ2UuXG4gICAgICovXG4gICAgZ2V0QnJlYWRjcnVtYnMocnVuKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudHMgPSB0aGlzLmdldFBhcmVudHMocnVuKS5yZXZlcnNlKCk7XG4gICAgICAgIGNvbnN0IHN0cmluZyA9IFsuLi5wYXJlbnRzLCBydW5dXG4gICAgICAgICAgICAubWFwKChwYXJlbnQsIGksIGFycikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGAke3BhcmVudC5leGVjdXRpb25fb3JkZXJ9OiR7cGFyZW50LnJ1bl90eXBlfToke3BhcmVudC5uYW1lfWA7XG4gICAgICAgICAgICByZXR1cm4gaSA9PT0gYXJyLmxlbmd0aCAtIDEgPyB3cmFwKGFuc2lfc3R5bGVzXzEuZGVmYXVsdC5ib2xkLCBuYW1lKSA6IG5hbWU7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbihcIiA+IFwiKTtcbiAgICAgICAgcmV0dXJuIHdyYXAoY29sb3IuZ3JleSwgc3RyaW5nKTtcbiAgICB9XG4gICAgLy8gbG9nZ2luZyBtZXRob2RzXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBzdGFydCBvZiBhIGNoYWluIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBjaGFpbiBydW4gdGhhdCBoYXMgc3RhcnRlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25DaGFpblN0YXJ0KHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuZ3JlZW4sIFwiW2NoYWluL3N0YXJ0XVwiKX0gWyR7Y3J1bWJzfV0gRW50ZXJpbmcgQ2hhaW4gcnVuIHdpdGggaW5wdXQ6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4uaW5wdXRzLCBcIltpbnB1dHNdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIGVuZCBvZiBhIGNoYWluIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBjaGFpbiBydW4gdGhhdCBoYXMgZW5kZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uQ2hhaW5FbmQocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5jeWFuLCBcIltjaGFpbi9lbmRdXCIpfSBbJHtjcnVtYnN9XSBbJHtlbGFwc2VkKHJ1bil9XSBFeGl0aW5nIENoYWluIHJ1biB3aXRoIG91dHB1dDogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5vdXRwdXRzLCBcIltvdXRwdXRzXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIGFueSBlcnJvcnMgb2YgYSBjaGFpbiBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgY2hhaW4gcnVuIHRoYXQgaGFzIGVycm9yZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uQ2hhaW5FcnJvcihydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLnJlZCwgXCJbY2hhaW4vZXJyb3JdXCIpfSBbJHtjcnVtYnN9XSBbJHtlbGFwc2VkKHJ1bil9XSBDaGFpbiBydW4gZXJyb3JlZCB3aXRoIGVycm9yOiAke3RyeUpzb25TdHJpbmdpZnkocnVuLmVycm9yLCBcIltlcnJvcl1cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgc3RhcnQgb2YgYW4gTExNIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBMTE0gcnVuIHRoYXQgaGFzIHN0YXJ0ZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uTExNU3RhcnQocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gXCJwcm9tcHRzXCIgaW4gcnVuLmlucHV0c1xuICAgICAgICAgICAgPyB7IHByb21wdHM6IHJ1bi5pbnB1dHMucHJvbXB0cy5tYXAoKHApID0+IHAudHJpbSgpKSB9XG4gICAgICAgICAgICA6IHJ1bi5pbnB1dHM7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuZ3JlZW4sIFwiW2xsbS9zdGFydF1cIil9IFske2NydW1ic31dIEVudGVyaW5nIExMTSBydW4gd2l0aCBpbnB1dDogJHt0cnlKc29uU3RyaW5naWZ5KGlucHV0cywgXCJbaW5wdXRzXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBlbmQgb2YgYW4gTExNIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBMTE0gcnVuIHRoYXQgaGFzIGVuZGVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvbkxMTUVuZChydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmN5YW4sIFwiW2xsbS9lbmRdXCIpfSBbJHtjcnVtYnN9XSBbJHtlbGFwc2VkKHJ1bil9XSBFeGl0aW5nIExMTSBydW4gd2l0aCBvdXRwdXQ6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4ub3V0cHV0cywgXCJbcmVzcG9uc2VdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgYW55IGVycm9ycyBvZiBhbiBMTE0gcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIExMTSBydW4gdGhhdCBoYXMgZXJyb3JlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25MTE1FcnJvcihydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLnJlZCwgXCJbbGxtL2Vycm9yXVwiKX0gWyR7Y3J1bWJzfV0gWyR7ZWxhcHNlZChydW4pfV0gTExNIHJ1biBlcnJvcmVkIHdpdGggZXJyb3I6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4uZXJyb3IsIFwiW2Vycm9yXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBzdGFydCBvZiBhIHRvb2wgcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHRvb2wgcnVuIHRoYXQgaGFzIHN0YXJ0ZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uVG9vbFN0YXJ0KHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuZ3JlZW4sIFwiW3Rvb2wvc3RhcnRdXCIpfSBbJHtjcnVtYnN9XSBFbnRlcmluZyBUb29sIHJ1biB3aXRoIGlucHV0OiBcIiR7Zm9ybWF0S1ZNYXBJdGVtKHJ1bi5pbnB1dHMuaW5wdXQpfVwiYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgZW5kIG9mIGEgdG9vbCBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgdG9vbCBydW4gdGhhdCBoYXMgZW5kZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uVG9vbEVuZChydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmN5YW4sIFwiW3Rvb2wvZW5kXVwiKX0gWyR7Y3J1bWJzfV0gWyR7ZWxhcHNlZChydW4pfV0gRXhpdGluZyBUb29sIHJ1biB3aXRoIG91dHB1dDogXCIke2Zvcm1hdEtWTWFwSXRlbShydW4ub3V0cHV0cz8ub3V0cHV0KX1cImApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgYW55IGVycm9ycyBvZiBhIHRvb2wgcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHRvb2wgcnVuIHRoYXQgaGFzIGVycm9yZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uVG9vbEVycm9yKHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IucmVkLCBcIlt0b29sL2Vycm9yXVwiKX0gWyR7Y3J1bWJzfV0gWyR7ZWxhcHNlZChydW4pfV0gVG9vbCBydW4gZXJyb3JlZCB3aXRoIGVycm9yOiAke3RyeUpzb25TdHJpbmdpZnkocnVuLmVycm9yLCBcIltlcnJvcl1cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgc3RhcnQgb2YgYSByZXRyaWV2ZXIgcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHJldHJpZXZlciBydW4gdGhhdCBoYXMgc3RhcnRlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25SZXRyaWV2ZXJTdGFydChydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmdyZWVuLCBcIltyZXRyaWV2ZXIvc3RhcnRdXCIpfSBbJHtjcnVtYnN9XSBFbnRlcmluZyBSZXRyaWV2ZXIgcnVuIHdpdGggaW5wdXQ6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4uaW5wdXRzLCBcIltpbnB1dHNdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIGVuZCBvZiBhIHJldHJpZXZlciBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgcmV0cmlldmVyIHJ1biB0aGF0IGhhcyBlbmRlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25SZXRyaWV2ZXJFbmQocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5jeWFuLCBcIltyZXRyaWV2ZXIvZW5kXVwiKX0gWyR7Y3J1bWJzfV0gWyR7ZWxhcHNlZChydW4pfV0gRXhpdGluZyBSZXRyaWV2ZXIgcnVuIHdpdGggb3V0cHV0OiAke3RyeUpzb25TdHJpbmdpZnkocnVuLm91dHB1dHMsIFwiW291dHB1dHNdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgYW55IGVycm9ycyBvZiBhIHJldHJpZXZlciBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgcmV0cmlldmVyIHJ1biB0aGF0IGhhcyBlcnJvcmVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvblJldHJpZXZlckVycm9yKHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IucmVkLCBcIltyZXRyaWV2ZXIvZXJyb3JdXCIpfSBbJHtjcnVtYnN9XSBbJHtlbGFwc2VkKHJ1bil9XSBSZXRyaWV2ZXIgcnVuIGVycm9yZWQgd2l0aCBlcnJvcjogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5lcnJvciwgXCJbZXJyb3JdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIGFjdGlvbiBzZWxlY3RlZCBieSB0aGUgYWdlbnQuXG4gICAgICogQHBhcmFtIHJ1biBUaGUgcnVuIGluIHdoaWNoIHRoZSBhZ2VudCBhY3Rpb24gb2NjdXJyZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uQWdlbnRBY3Rpb24ocnVuKSB7XG4gICAgICAgIGNvbnN0IGFnZW50UnVuID0gcnVuO1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuYmx1ZSwgXCJbYWdlbnQvYWN0aW9uXVwiKX0gWyR7Y3J1bWJzfV0gQWdlbnQgc2VsZWN0ZWQgYWN0aW9uOiAke3RyeUpzb25TdHJpbmdpZnkoYWdlbnRSdW4uYWN0aW9uc1thZ2VudFJ1bi5hY3Rpb25zLmxlbmd0aCAtIDFdLCBcIlthY3Rpb25dXCIpfWApO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29uc29sZUNhbGxiYWNrSGFuZGxlciA9IENvbnNvbGVDYWxsYmFja0hhbmRsZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/console.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/event_stream.cjs":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/event_stream.cjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EventStreamCallbackHandler = exports.isStreamEventsHandler = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.cjs\");\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\nconst ai_js_1 = __webpack_require__(/*! ../messages/ai.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/ai.cjs\");\nconst outputs_js_1 = __webpack_require__(/*! ../outputs.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/outputs.cjs\");\nfunction assignName({ name, serialized, }) {\n    if (name !== undefined) {\n        return name;\n    }\n    if (serialized?.name !== undefined) {\n        return serialized.name;\n    }\n    else if (serialized?.id !== undefined && Array.isArray(serialized?.id)) {\n        return serialized.id[serialized.id.length - 1];\n    }\n    return \"Unnamed\";\n}\nconst isStreamEventsHandler = (handler) => handler.name === \"event_stream_tracer\";\nexports.isStreamEventsHandler = isStreamEventsHandler;\n/**\n * Class that extends the `BaseTracer` class from the\n * `langchain.callbacks.tracers.base` module. It represents a callback\n * handler that logs the execution of runs and emits `RunLog` instances to a\n * `RunLogStream`.\n */\nclass EventStreamCallbackHandler extends base_js_1.BaseTracer {\n    constructor(fields) {\n        super({ _awaitHandler: true, ...fields });\n        Object.defineProperty(this, \"autoClose\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"includeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"runInfoMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"tappedPromises\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"transformStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"writer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"receiveStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"event_stream_tracer\"\n        });\n        Object.defineProperty(this, \"lc_prefer_streaming\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.autoClose = fields?.autoClose ?? true;\n        this.includeNames = fields?.includeNames;\n        this.includeTypes = fields?.includeTypes;\n        this.includeTags = fields?.includeTags;\n        this.excludeNames = fields?.excludeNames;\n        this.excludeTypes = fields?.excludeTypes;\n        this.excludeTags = fields?.excludeTags;\n        this.transformStream = new TransformStream();\n        this.writer = this.transformStream.writable.getWriter();\n        this.receiveStream = stream_js_1.IterableReadableStream.fromReadableStream(this.transformStream.readable);\n    }\n    [Symbol.asyncIterator]() {\n        return this.receiveStream;\n    }\n    async persistRun(_run) {\n        // This is a legacy method only called once for an entire run tree\n        // and is therefore not useful here\n    }\n    _includeRun(run) {\n        const runTags = run.tags ?? [];\n        let include = this.includeNames === undefined &&\n            this.includeTags === undefined &&\n            this.includeTypes === undefined;\n        if (this.includeNames !== undefined) {\n            include = include || this.includeNames.includes(run.name);\n        }\n        if (this.includeTypes !== undefined) {\n            include = include || this.includeTypes.includes(run.runType);\n        }\n        if (this.includeTags !== undefined) {\n            include =\n                include ||\n                    runTags.find((tag) => this.includeTags?.includes(tag)) !== undefined;\n        }\n        if (this.excludeNames !== undefined) {\n            include = include && !this.excludeNames.includes(run.name);\n        }\n        if (this.excludeTypes !== undefined) {\n            include = include && !this.excludeTypes.includes(run.runType);\n        }\n        if (this.excludeTags !== undefined) {\n            include =\n                include && runTags.every((tag) => !this.excludeTags?.includes(tag));\n        }\n        return include;\n    }\n    async *tapOutputIterable(runId, outputStream) {\n        const firstChunk = await outputStream.next();\n        if (firstChunk.done) {\n            return;\n        }\n        const runInfo = this.runInfoMap.get(runId);\n        // Run has finished, don't issue any stream events.\n        // An example of this is for runnables that use the default\n        // implementation of .stream(), which delegates to .invoke()\n        // and calls .onChainEnd() before passing it to the iterator.\n        if (runInfo === undefined) {\n            yield firstChunk.value;\n            return;\n        }\n        // Match format from handlers below\n        function _formatOutputChunk(eventType, data) {\n            if (eventType === \"llm\" && typeof data === \"string\") {\n                return new outputs_js_1.GenerationChunk({ text: data });\n            }\n            return data;\n        }\n        let tappedPromise = this.tappedPromises.get(runId);\n        // if we are the first to tap, issue stream events\n        if (tappedPromise === undefined) {\n            let tappedPromiseResolver;\n            tappedPromise = new Promise((resolve) => {\n                tappedPromiseResolver = resolve;\n            });\n            this.tappedPromises.set(runId, tappedPromise);\n            try {\n                const event = {\n                    event: `on_${runInfo.runType}_stream`,\n                    run_id: runId,\n                    name: runInfo.name,\n                    tags: runInfo.tags,\n                    metadata: runInfo.metadata,\n                    data: {},\n                };\n                await this.send({\n                    ...event,\n                    data: {\n                        chunk: _formatOutputChunk(runInfo.runType, firstChunk.value),\n                    },\n                }, runInfo);\n                yield firstChunk.value;\n                for await (const chunk of outputStream) {\n                    // Don't yield tool and retriever stream events\n                    if (runInfo.runType !== \"tool\" && runInfo.runType !== \"retriever\") {\n                        await this.send({\n                            ...event,\n                            data: {\n                                chunk: _formatOutputChunk(runInfo.runType, chunk),\n                            },\n                        }, runInfo);\n                    }\n                    yield chunk;\n                }\n            }\n            finally {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tappedPromiseResolver();\n                // Don't delete from the promises map to keep track of which runs have been tapped.\n            }\n        }\n        else {\n            // otherwise just pass through\n            yield firstChunk.value;\n            for await (const chunk of outputStream) {\n                yield chunk;\n            }\n        }\n    }\n    async send(payload, run) {\n        if (this._includeRun(run)) {\n            await this.writer.write(payload);\n        }\n    }\n    async sendEndEvent(payload, run) {\n        const tappedPromise = this.tappedPromises.get(payload.run_id);\n        if (tappedPromise !== undefined) {\n            void tappedPromise.then(() => {\n                void this.send(payload, run);\n            });\n        }\n        else {\n            await this.send(payload, run);\n        }\n    }\n    async onLLMStart(run) {\n        const runName = assignName(run);\n        const runType = run.inputs.messages !== undefined ? \"chat_model\" : \"llm\";\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType,\n            inputs: run.inputs,\n        };\n        this.runInfoMap.set(run.id, runInfo);\n        const eventName = `on_${runType}_start`;\n        await this.send({\n            event: eventName,\n            data: {\n                input: run.inputs,\n            },\n            name: runName,\n            tags: run.tags ?? [],\n            run_id: run.id,\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onLLMNewToken(run, token, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    kwargs) {\n        const runInfo = this.runInfoMap.get(run.id);\n        let chunk;\n        let eventName;\n        if (runInfo === undefined) {\n            throw new Error(`onLLMNewToken: Run ID ${run.id} not found in run map.`);\n        }\n        // Top-level streaming events are covered by tapOutputIterable\n        if (this.runInfoMap.size === 1) {\n            return;\n        }\n        if (runInfo.runType === \"chat_model\") {\n            eventName = \"on_chat_model_stream\";\n            if (kwargs?.chunk === undefined) {\n                chunk = new ai_js_1.AIMessageChunk({ content: token, id: `run-${run.id}` });\n            }\n            else {\n                chunk = kwargs.chunk.message;\n            }\n        }\n        else if (runInfo.runType === \"llm\") {\n            eventName = \"on_llm_stream\";\n            if (kwargs?.chunk === undefined) {\n                chunk = new outputs_js_1.GenerationChunk({ text: token });\n            }\n            else {\n                chunk = kwargs.chunk;\n            }\n        }\n        else {\n            throw new Error(`Unexpected run type ${runInfo.runType}`);\n        }\n        await this.send({\n            event: eventName,\n            data: {\n                chunk,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    async onLLMEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        let eventName;\n        if (runInfo === undefined) {\n            throw new Error(`onLLMEnd: Run ID ${run.id} not found in run map.`);\n        }\n        const generations = run.outputs?.generations;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let output;\n        if (runInfo.runType === \"chat_model\") {\n            for (const generation of generations ?? []) {\n                if (output !== undefined) {\n                    break;\n                }\n                output = generation[0]?.message;\n            }\n            eventName = \"on_chat_model_end\";\n        }\n        else if (runInfo.runType === \"llm\") {\n            output = {\n                generations: generations?.map((generation) => {\n                    return generation.map((chunk) => {\n                        return {\n                            text: chunk.text,\n                            generationInfo: chunk.generationInfo,\n                        };\n                    });\n                }),\n                llmOutput: run.outputs?.llmOutput ?? {},\n            };\n            eventName = \"on_llm_end\";\n        }\n        else {\n            throw new Error(`onLLMEnd: Unexpected run type: ${runInfo.runType}`);\n        }\n        await this.sendEndEvent({\n            event: eventName,\n            data: {\n                output,\n                input: runInfo.inputs,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    async onChainStart(run) {\n        const runName = assignName(run);\n        const runType = run.run_type ?? \"chain\";\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType: run.run_type,\n        };\n        let eventData = {};\n        // Workaround Runnable core code not sending input when transform streaming.\n        if (run.inputs.input === \"\" && Object.keys(run.inputs).length === 1) {\n            eventData = {};\n            runInfo.inputs = {};\n        }\n        else if (run.inputs.input !== undefined) {\n            eventData.input = run.inputs.input;\n            runInfo.inputs = run.inputs.input;\n        }\n        else {\n            eventData.input = run.inputs;\n            runInfo.inputs = run.inputs;\n        }\n        this.runInfoMap.set(run.id, runInfo);\n        await this.send({\n            event: `on_${runType}_start`,\n            data: eventData,\n            name: runName,\n            tags: run.tags ?? [],\n            run_id: run.id,\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onChainEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        if (runInfo === undefined) {\n            throw new Error(`onChainEnd: Run ID ${run.id} not found in run map.`);\n        }\n        const eventName = `on_${run.run_type}_end`;\n        const inputs = run.inputs ?? runInfo.inputs ?? {};\n        const outputs = run.outputs?.output ?? run.outputs;\n        const data = {\n            output: outputs,\n            input: inputs,\n        };\n        if (inputs.input && Object.keys(inputs).length === 1) {\n            data.input = inputs.input;\n            runInfo.inputs = inputs.input;\n        }\n        await this.sendEndEvent({\n            event: eventName,\n            data,\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata ?? {},\n        }, runInfo);\n    }\n    async onToolStart(run) {\n        const runName = assignName(run);\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType: \"tool\",\n            inputs: run.inputs ?? {},\n        };\n        this.runInfoMap.set(run.id, runInfo);\n        await this.send({\n            event: \"on_tool_start\",\n            data: {\n                input: run.inputs ?? {},\n            },\n            name: runName,\n            run_id: run.id,\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onToolEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        if (runInfo === undefined) {\n            throw new Error(`onToolEnd: Run ID ${run.id} not found in run map.`);\n        }\n        if (runInfo.inputs === undefined) {\n            throw new Error(`onToolEnd: Run ID ${run.id} is a tool call, and is expected to have traced inputs.`);\n        }\n        const output = run.outputs?.output === undefined ? run.outputs : run.outputs.output;\n        await this.sendEndEvent({\n            event: \"on_tool_end\",\n            data: {\n                output,\n                input: runInfo.inputs,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    async onRetrieverStart(run) {\n        const runName = assignName(run);\n        const runType = \"retriever\";\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType,\n            inputs: {\n                query: run.inputs.query,\n            },\n        };\n        this.runInfoMap.set(run.id, runInfo);\n        await this.send({\n            event: \"on_retriever_start\",\n            data: {\n                input: {\n                    query: run.inputs.query,\n                },\n            },\n            name: runName,\n            tags: run.tags ?? [],\n            run_id: run.id,\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onRetrieverEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        if (runInfo === undefined) {\n            throw new Error(`onRetrieverEnd: Run ID ${run.id} not found in run map.`);\n        }\n        await this.sendEndEvent({\n            event: \"on_retriever_end\",\n            data: {\n                output: run.outputs?.documents ?? run.outputs,\n                input: runInfo.inputs,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async handleCustomEvent(eventName, data, runId) {\n        const runInfo = this.runInfoMap.get(runId);\n        if (runInfo === undefined) {\n            throw new Error(`handleCustomEvent: Run ID ${runId} not found in run map.`);\n        }\n        await this.send({\n            event: \"on_custom_event\",\n            run_id: runId,\n            name: eventName,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n            data,\n        }, runInfo);\n    }\n    async finish() {\n        const pendingPromises = [...this.tappedPromises.values()];\n        void Promise.all(pendingPromises).finally(() => {\n            void this.writer.close();\n        });\n    }\n}\nexports.EventStreamCallbackHandler = EventStreamCallbackHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9ldmVudF9zdHJlYW0uY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtDQUFrQyxHQUFHLDZCQUE2QjtBQUNsRSxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBWTtBQUN0QyxvQkFBb0IsbUJBQU8sQ0FBQyx1RkFBcUI7QUFDakQsZ0JBQWdCLG1CQUFPLENBQUMscUZBQW9CO0FBQzVDLHFCQUFxQixtQkFBTyxDQUFDLDZFQUFnQjtBQUM3QyxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFlBQVk7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsMkJBQTJCLE9BQU8sR0FBRztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGFBQWE7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGdCQUFnQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGdCQUFnQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFFBQVE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsT0FBTztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3RyYWNlcnMvZXZlbnRfc3RyZWFtLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRXZlbnRTdHJlYW1DYWxsYmFja0hhbmRsZXIgPSBleHBvcnRzLmlzU3RyZWFtRXZlbnRzSGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2UuY2pzXCIpO1xuY29uc3Qgc3RyZWFtX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvc3RyZWFtLmNqc1wiKTtcbmNvbnN0IGFpX2pzXzEgPSByZXF1aXJlKFwiLi4vbWVzc2FnZXMvYWkuY2pzXCIpO1xuY29uc3Qgb3V0cHV0c19qc18xID0gcmVxdWlyZShcIi4uL291dHB1dHMuY2pzXCIpO1xuZnVuY3Rpb24gYXNzaWduTmFtZSh7IG5hbWUsIHNlcmlhbGl6ZWQsIH0pIHtcbiAgICBpZiAobmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICBpZiAoc2VyaWFsaXplZD8ubmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVkLm5hbWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlcmlhbGl6ZWQ/LmlkICE9PSB1bmRlZmluZWQgJiYgQXJyYXkuaXNBcnJheShzZXJpYWxpemVkPy5pZCkpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQuaWRbc2VyaWFsaXplZC5pZC5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIFwiVW5uYW1lZFwiO1xufVxuY29uc3QgaXNTdHJlYW1FdmVudHNIYW5kbGVyID0gKGhhbmRsZXIpID0+IGhhbmRsZXIubmFtZSA9PT0gXCJldmVudF9zdHJlYW1fdHJhY2VyXCI7XG5leHBvcnRzLmlzU3RyZWFtRXZlbnRzSGFuZGxlciA9IGlzU3RyZWFtRXZlbnRzSGFuZGxlcjtcbi8qKlxuICogQ2xhc3MgdGhhdCBleHRlbmRzIHRoZSBgQmFzZVRyYWNlcmAgY2xhc3MgZnJvbSB0aGVcbiAqIGBsYW5nY2hhaW4uY2FsbGJhY2tzLnRyYWNlcnMuYmFzZWAgbW9kdWxlLiBJdCByZXByZXNlbnRzIGEgY2FsbGJhY2tcbiAqIGhhbmRsZXIgdGhhdCBsb2dzIHRoZSBleGVjdXRpb24gb2YgcnVucyBhbmQgZW1pdHMgYFJ1bkxvZ2AgaW5zdGFuY2VzIHRvIGFcbiAqIGBSdW5Mb2dTdHJlYW1gLlxuICovXG5jbGFzcyBFdmVudFN0cmVhbUNhbGxiYWNrSGFuZGxlciBleHRlbmRzIGJhc2VfanNfMS5CYXNlVHJhY2VyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoeyBfYXdhaXRIYW5kbGVyOiB0cnVlLCAuLi5maWVsZHMgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9DbG9zZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5jbHVkZU5hbWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluY2x1ZGVUeXBlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmNsdWRlVGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGNsdWRlTmFtZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhjbHVkZVR5cGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4Y2x1ZGVUYWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJ1bkluZm9NYXBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGFwcGVkUHJvbWlzZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhbnNmb3JtU3RyZWFtXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndyaXRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWNlaXZlU3RyZWFtXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiZXZlbnRfc3RyZWFtX3RyYWNlclwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19wcmVmZXJfc3RyZWFtaW5nXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmF1dG9DbG9zZSA9IGZpZWxkcz8uYXV0b0Nsb3NlID8/IHRydWU7XG4gICAgICAgIHRoaXMuaW5jbHVkZU5hbWVzID0gZmllbGRzPy5pbmNsdWRlTmFtZXM7XG4gICAgICAgIHRoaXMuaW5jbHVkZVR5cGVzID0gZmllbGRzPy5pbmNsdWRlVHlwZXM7XG4gICAgICAgIHRoaXMuaW5jbHVkZVRhZ3MgPSBmaWVsZHM/LmluY2x1ZGVUYWdzO1xuICAgICAgICB0aGlzLmV4Y2x1ZGVOYW1lcyA9IGZpZWxkcz8uZXhjbHVkZU5hbWVzO1xuICAgICAgICB0aGlzLmV4Y2x1ZGVUeXBlcyA9IGZpZWxkcz8uZXhjbHVkZVR5cGVzO1xuICAgICAgICB0aGlzLmV4Y2x1ZGVUYWdzID0gZmllbGRzPy5leGNsdWRlVGFncztcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1TdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKCk7XG4gICAgICAgIHRoaXMud3JpdGVyID0gdGhpcy50cmFuc2Zvcm1TdHJlYW0ud3JpdGFibGUuZ2V0V3JpdGVyKCk7XG4gICAgICAgIHRoaXMucmVjZWl2ZVN0cmVhbSA9IHN0cmVhbV9qc18xLkl0ZXJhYmxlUmVhZGFibGVTdHJlYW0uZnJvbVJlYWRhYmxlU3RyZWFtKHRoaXMudHJhbnNmb3JtU3RyZWFtLnJlYWRhYmxlKTtcbiAgICB9XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjZWl2ZVN0cmVhbTtcbiAgICB9XG4gICAgYXN5bmMgcGVyc2lzdFJ1bihfcnVuKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBsZWdhY3kgbWV0aG9kIG9ubHkgY2FsbGVkIG9uY2UgZm9yIGFuIGVudGlyZSBydW4gdHJlZVxuICAgICAgICAvLyBhbmQgaXMgdGhlcmVmb3JlIG5vdCB1c2VmdWwgaGVyZVxuICAgIH1cbiAgICBfaW5jbHVkZVJ1bihydW4pIHtcbiAgICAgICAgY29uc3QgcnVuVGFncyA9IHJ1bi50YWdzID8/IFtdO1xuICAgICAgICBsZXQgaW5jbHVkZSA9IHRoaXMuaW5jbHVkZU5hbWVzID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZVRhZ3MgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy5pbmNsdWRlVHlwZXMgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZU5hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlIHx8IHRoaXMuaW5jbHVkZU5hbWVzLmluY2x1ZGVzKHJ1bi5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmNsdWRlVHlwZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGluY2x1ZGUgfHwgdGhpcy5pbmNsdWRlVHlwZXMuaW5jbHVkZXMocnVuLnJ1blR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVUYWdzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPVxuICAgICAgICAgICAgICAgIGluY2x1ZGUgfHxcbiAgICAgICAgICAgICAgICAgICAgcnVuVGFncy5maW5kKCh0YWcpID0+IHRoaXMuaW5jbHVkZVRhZ3M/LmluY2x1ZGVzKHRhZykpICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhjbHVkZU5hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlICYmICF0aGlzLmV4Y2x1ZGVOYW1lcy5pbmNsdWRlcyhydW4ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhjbHVkZVR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlICYmICF0aGlzLmV4Y2x1ZGVUeXBlcy5pbmNsdWRlcyhydW4ucnVuVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhjbHVkZVRhZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9XG4gICAgICAgICAgICAgICAgaW5jbHVkZSAmJiBydW5UYWdzLmV2ZXJ5KCh0YWcpID0+ICF0aGlzLmV4Y2x1ZGVUYWdzPy5pbmNsdWRlcyh0YWcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5jbHVkZTtcbiAgICB9XG4gICAgYXN5bmMgKnRhcE91dHB1dEl0ZXJhYmxlKHJ1bklkLCBvdXRwdXRTdHJlYW0pIHtcbiAgICAgICAgY29uc3QgZmlyc3RDaHVuayA9IGF3YWl0IG91dHB1dFN0cmVhbS5uZXh0KCk7XG4gICAgICAgIGlmIChmaXJzdENodW5rLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW5JbmZvID0gdGhpcy5ydW5JbmZvTWFwLmdldChydW5JZCk7XG4gICAgICAgIC8vIFJ1biBoYXMgZmluaXNoZWQsIGRvbid0IGlzc3VlIGFueSBzdHJlYW0gZXZlbnRzLlxuICAgICAgICAvLyBBbiBleGFtcGxlIG9mIHRoaXMgaXMgZm9yIHJ1bm5hYmxlcyB0aGF0IHVzZSB0aGUgZGVmYXVsdFxuICAgICAgICAvLyBpbXBsZW1lbnRhdGlvbiBvZiAuc3RyZWFtKCksIHdoaWNoIGRlbGVnYXRlcyB0byAuaW52b2tlKClcbiAgICAgICAgLy8gYW5kIGNhbGxzIC5vbkNoYWluRW5kKCkgYmVmb3JlIHBhc3NpbmcgaXQgdG8gdGhlIGl0ZXJhdG9yLlxuICAgICAgICBpZiAocnVuSW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB5aWVsZCBmaXJzdENodW5rLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1hdGNoIGZvcm1hdCBmcm9tIGhhbmRsZXJzIGJlbG93XG4gICAgICAgIGZ1bmN0aW9uIF9mb3JtYXRPdXRwdXRDaHVuayhldmVudFR5cGUsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChldmVudFR5cGUgPT09IFwibGxtXCIgJiYgdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG91dHB1dHNfanNfMS5HZW5lcmF0aW9uQ2h1bmsoeyB0ZXh0OiBkYXRhIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRhcHBlZFByb21pc2UgPSB0aGlzLnRhcHBlZFByb21pc2VzLmdldChydW5JZCk7XG4gICAgICAgIC8vIGlmIHdlIGFyZSB0aGUgZmlyc3QgdG8gdGFwLCBpc3N1ZSBzdHJlYW0gZXZlbnRzXG4gICAgICAgIGlmICh0YXBwZWRQcm9taXNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCB0YXBwZWRQcm9taXNlUmVzb2x2ZXI7XG4gICAgICAgICAgICB0YXBwZWRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICB0YXBwZWRQcm9taXNlUmVzb2x2ZXIgPSByZXNvbHZlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRhcHBlZFByb21pc2VzLnNldChydW5JZCwgdGFwcGVkUHJvbWlzZSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBldmVudDogYG9uXyR7cnVuSW5mby5ydW5UeXBlfV9zdHJlYW1gLFxuICAgICAgICAgICAgICAgICAgICBydW5faWQ6IHJ1bklkLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBydW5JbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHRhZ3M6IHJ1bkluZm8udGFncyxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bkluZm8ubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHt9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rOiBfZm9ybWF0T3V0cHV0Q2h1bmsocnVuSW5mby5ydW5UeXBlLCBmaXJzdENodW5rLnZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LCBydW5JbmZvKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBmaXJzdENodW5rLnZhbHVlO1xuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygb3V0cHV0U3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHlpZWxkIHRvb2wgYW5kIHJldHJpZXZlciBzdHJlYW0gZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChydW5JbmZvLnJ1blR5cGUgIT09IFwidG9vbFwiICYmIHJ1bkluZm8ucnVuVHlwZSAhPT0gXCJyZXRyaWV2ZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rOiBfZm9ybWF0T3V0cHV0Q2h1bmsocnVuSW5mby5ydW5UeXBlLCBjaHVuayksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJ1bkluZm8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgdGFwcGVkUHJvbWlzZVJlc29sdmVyKCk7XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgZGVsZXRlIGZyb20gdGhlIHByb21pc2VzIG1hcCB0byBrZWVwIHRyYWNrIG9mIHdoaWNoIHJ1bnMgaGF2ZSBiZWVuIHRhcHBlZC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBqdXN0IHBhc3MgdGhyb3VnaFxuICAgICAgICAgICAgeWllbGQgZmlyc3RDaHVuay52YWx1ZTtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygb3V0cHV0U3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2VuZChwYXlsb2FkLCBydW4pIHtcbiAgICAgICAgaWYgKHRoaXMuX2luY2x1ZGVSdW4ocnVuKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0ZXIud3JpdGUocGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2VuZEVuZEV2ZW50KHBheWxvYWQsIHJ1bikge1xuICAgICAgICBjb25zdCB0YXBwZWRQcm9taXNlID0gdGhpcy50YXBwZWRQcm9taXNlcy5nZXQocGF5bG9hZC5ydW5faWQpO1xuICAgICAgICBpZiAodGFwcGVkUHJvbWlzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2b2lkIHRhcHBlZFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLnNlbmQocGF5bG9hZCwgcnVuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZW5kKHBheWxvYWQsIHJ1bik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgb25MTE1TdGFydChydW4pIHtcbiAgICAgICAgY29uc3QgcnVuTmFtZSA9IGFzc2lnbk5hbWUocnVuKTtcbiAgICAgICAgY29uc3QgcnVuVHlwZSA9IHJ1bi5pbnB1dHMubWVzc2FnZXMgIT09IHVuZGVmaW5lZCA/IFwiY2hhdF9tb2RlbFwiIDogXCJsbG1cIjtcbiAgICAgICAgY29uc3QgcnVuSW5mbyA9IHtcbiAgICAgICAgICAgIHRhZ3M6IHJ1bi50YWdzID8/IFtdLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgICAgICBuYW1lOiBydW5OYW1lLFxuICAgICAgICAgICAgcnVuVHlwZSxcbiAgICAgICAgICAgIGlucHV0czogcnVuLmlucHV0cyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydW5JbmZvTWFwLnNldChydW4uaWQsIHJ1bkluZm8pO1xuICAgICAgICBjb25zdCBldmVudE5hbWUgPSBgb25fJHtydW5UeXBlfV9zdGFydGA7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgICAgICBldmVudDogZXZlbnROYW1lLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGlucHV0OiBydW4uaW5wdXRzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IHJ1bk5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW4udGFncyA/PyBbXSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuLmlkLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICBhc3luYyBvbkxMTU5ld1Rva2VuKHJ1biwgdG9rZW4sIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAga3dhcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1bkluZm8gPSB0aGlzLnJ1bkluZm9NYXAuZ2V0KHJ1bi5pZCk7XG4gICAgICAgIGxldCBjaHVuaztcbiAgICAgICAgbGV0IGV2ZW50TmFtZTtcbiAgICAgICAgaWYgKHJ1bkluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvbkxMTU5ld1Rva2VuOiBSdW4gSUQgJHtydW4uaWR9IG5vdCBmb3VuZCBpbiBydW4gbWFwLmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRvcC1sZXZlbCBzdHJlYW1pbmcgZXZlbnRzIGFyZSBjb3ZlcmVkIGJ5IHRhcE91dHB1dEl0ZXJhYmxlXG4gICAgICAgIGlmICh0aGlzLnJ1bkluZm9NYXAuc2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW5JbmZvLnJ1blR5cGUgPT09IFwiY2hhdF9tb2RlbFwiKSB7XG4gICAgICAgICAgICBldmVudE5hbWUgPSBcIm9uX2NoYXRfbW9kZWxfc3RyZWFtXCI7XG4gICAgICAgICAgICBpZiAoa3dhcmdzPy5jaHVuayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBuZXcgYWlfanNfMS5BSU1lc3NhZ2VDaHVuayh7IGNvbnRlbnQ6IHRva2VuLCBpZDogYHJ1bi0ke3J1bi5pZH1gIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBrd2FyZ3MuY2h1bmsubWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChydW5JbmZvLnJ1blR5cGUgPT09IFwibGxtXCIpIHtcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9IFwib25fbGxtX3N0cmVhbVwiO1xuICAgICAgICAgICAgaWYgKGt3YXJncz8uY2h1bmsgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNodW5rID0gbmV3IG91dHB1dHNfanNfMS5HZW5lcmF0aW9uQ2h1bmsoeyB0ZXh0OiB0b2tlbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNodW5rID0ga3dhcmdzLmNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHJ1biB0eXBlICR7cnVuSW5mby5ydW5UeXBlfWApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgICAgICBldmVudDogZXZlbnROYW1lLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGNodW5rLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuLmlkLFxuICAgICAgICAgICAgbmFtZTogcnVuSW5mby5uYW1lLFxuICAgICAgICAgICAgdGFnczogcnVuSW5mby50YWdzLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bkluZm8ubWV0YWRhdGEsXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICBhc3luYyBvbkxMTUVuZChydW4pIHtcbiAgICAgICAgY29uc3QgcnVuSW5mbyA9IHRoaXMucnVuSW5mb01hcC5nZXQocnVuLmlkKTtcbiAgICAgICAgdGhpcy5ydW5JbmZvTWFwLmRlbGV0ZShydW4uaWQpO1xuICAgICAgICBsZXQgZXZlbnROYW1lO1xuICAgICAgICBpZiAocnVuSW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG9uTExNRW5kOiBSdW4gSUQgJHtydW4uaWR9IG5vdCBmb3VuZCBpbiBydW4gbWFwLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdlbmVyYXRpb25zID0gcnVuLm91dHB1dHM/LmdlbmVyYXRpb25zO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBsZXQgb3V0cHV0O1xuICAgICAgICBpZiAocnVuSW5mby5ydW5UeXBlID09PSBcImNoYXRfbW9kZWxcIikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBnZW5lcmF0aW9uIG9mIGdlbmVyYXRpb25zID8/IFtdKSB7XG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBnZW5lcmF0aW9uWzBdPy5tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnROYW1lID0gXCJvbl9jaGF0X21vZGVsX2VuZFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJ1bkluZm8ucnVuVHlwZSA9PT0gXCJsbG1cIikge1xuICAgICAgICAgICAgb3V0cHV0ID0ge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zOiBnZW5lcmF0aW9ucz8ubWFwKChnZW5lcmF0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0aW9uLm1hcCgoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY2h1bmsudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uSW5mbzogY2h1bmsuZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBsbG1PdXRwdXQ6IHJ1bi5vdXRwdXRzPy5sbG1PdXRwdXQgPz8ge30sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXZlbnROYW1lID0gXCJvbl9sbG1fZW5kXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG9uTExNRW5kOiBVbmV4cGVjdGVkIHJ1biB0eXBlOiAke3J1bkluZm8ucnVuVHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFbmRFdmVudCh7XG4gICAgICAgICAgICBldmVudDogZXZlbnROYW1lLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgICAgICBpbnB1dDogcnVuSW5mby5pbnB1dHMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVuX2lkOiBydW4uaWQsXG4gICAgICAgICAgICBuYW1lOiBydW5JbmZvLm5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW5JbmZvLnRhZ3MsXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuSW5mby5tZXRhZGF0YSxcbiAgICAgICAgfSwgcnVuSW5mbyk7XG4gICAgfVxuICAgIGFzeW5jIG9uQ2hhaW5TdGFydChydW4pIHtcbiAgICAgICAgY29uc3QgcnVuTmFtZSA9IGFzc2lnbk5hbWUocnVuKTtcbiAgICAgICAgY29uc3QgcnVuVHlwZSA9IHJ1bi5ydW5fdHlwZSA/PyBcImNoYWluXCI7XG4gICAgICAgIGNvbnN0IHJ1bkluZm8gPSB7XG4gICAgICAgICAgICB0YWdzOiBydW4udGFncyA/PyBbXSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBydW4uZXh0cmE/Lm1ldGFkYXRhID8/IHt9LFxuICAgICAgICAgICAgbmFtZTogcnVuTmFtZSxcbiAgICAgICAgICAgIHJ1blR5cGU6IHJ1bi5ydW5fdHlwZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGV2ZW50RGF0YSA9IHt9O1xuICAgICAgICAvLyBXb3JrYXJvdW5kIFJ1bm5hYmxlIGNvcmUgY29kZSBub3Qgc2VuZGluZyBpbnB1dCB3aGVuIHRyYW5zZm9ybSBzdHJlYW1pbmcuXG4gICAgICAgIGlmIChydW4uaW5wdXRzLmlucHV0ID09PSBcIlwiICYmIE9iamVjdC5rZXlzKHJ1bi5pbnB1dHMpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgZXZlbnREYXRhID0ge307XG4gICAgICAgICAgICBydW5JbmZvLmlucHV0cyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJ1bi5pbnB1dHMuaW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXZlbnREYXRhLmlucHV0ID0gcnVuLmlucHV0cy5pbnB1dDtcbiAgICAgICAgICAgIHJ1bkluZm8uaW5wdXRzID0gcnVuLmlucHV0cy5pbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50RGF0YS5pbnB1dCA9IHJ1bi5pbnB1dHM7XG4gICAgICAgICAgICBydW5JbmZvLmlucHV0cyA9IHJ1bi5pbnB1dHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ydW5JbmZvTWFwLnNldChydW4uaWQsIHJ1bkluZm8pO1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgZXZlbnQ6IGBvbl8ke3J1blR5cGV9X3N0YXJ0YCxcbiAgICAgICAgICAgIGRhdGE6IGV2ZW50RGF0YSxcbiAgICAgICAgICAgIG5hbWU6IHJ1bk5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW4udGFncyA/PyBbXSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuLmlkLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICBhc3luYyBvbkNoYWluRW5kKHJ1bikge1xuICAgICAgICBjb25zdCBydW5JbmZvID0gdGhpcy5ydW5JbmZvTWFwLmdldChydW4uaWQpO1xuICAgICAgICB0aGlzLnJ1bkluZm9NYXAuZGVsZXRlKHJ1bi5pZCk7XG4gICAgICAgIGlmIChydW5JbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb25DaGFpbkVuZDogUnVuIElEICR7cnVuLmlkfSBub3QgZm91bmQgaW4gcnVuIG1hcC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmVudE5hbWUgPSBgb25fJHtydW4ucnVuX3R5cGV9X2VuZGA7XG4gICAgICAgIGNvbnN0IGlucHV0cyA9IHJ1bi5pbnB1dHMgPz8gcnVuSW5mby5pbnB1dHMgPz8ge307XG4gICAgICAgIGNvbnN0IG91dHB1dHMgPSBydW4ub3V0cHV0cz8ub3V0cHV0ID8/IHJ1bi5vdXRwdXRzO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgb3V0cHV0OiBvdXRwdXRzLFxuICAgICAgICAgICAgaW5wdXQ6IGlucHV0cyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlucHV0cy5pbnB1dCAmJiBPYmplY3Qua2V5cyhpbnB1dHMpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgZGF0YS5pbnB1dCA9IGlucHV0cy5pbnB1dDtcbiAgICAgICAgICAgIHJ1bkluZm8uaW5wdXRzID0gaW5wdXRzLmlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVuZEV2ZW50KHtcbiAgICAgICAgICAgIGV2ZW50OiBldmVudE5hbWUsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcnVuX2lkOiBydW4uaWQsXG4gICAgICAgICAgICBuYW1lOiBydW5JbmZvLm5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW5JbmZvLnRhZ3MsXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuSW5mby5tZXRhZGF0YSA/PyB7fSxcbiAgICAgICAgfSwgcnVuSW5mbyk7XG4gICAgfVxuICAgIGFzeW5jIG9uVG9vbFN0YXJ0KHJ1bikge1xuICAgICAgICBjb25zdCBydW5OYW1lID0gYXNzaWduTmFtZShydW4pO1xuICAgICAgICBjb25zdCBydW5JbmZvID0ge1xuICAgICAgICAgICAgdGFnczogcnVuLnRhZ3MgPz8gW10sXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuLmV4dHJhPy5tZXRhZGF0YSA/PyB7fSxcbiAgICAgICAgICAgIG5hbWU6IHJ1bk5hbWUsXG4gICAgICAgICAgICBydW5UeXBlOiBcInRvb2xcIixcbiAgICAgICAgICAgIGlucHV0czogcnVuLmlucHV0cyA/PyB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydW5JbmZvTWFwLnNldChydW4uaWQsIHJ1bkluZm8pO1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgZXZlbnQ6IFwib25fdG9vbF9zdGFydFwiLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGlucHV0OiBydW4uaW5wdXRzID8/IHt9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IHJ1bk5hbWUsXG4gICAgICAgICAgICBydW5faWQ6IHJ1bi5pZCxcbiAgICAgICAgICAgIHRhZ3M6IHJ1bi50YWdzID8/IFtdLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICBhc3luYyBvblRvb2xFbmQocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1bkluZm8gPSB0aGlzLnJ1bkluZm9NYXAuZ2V0KHJ1bi5pZCk7XG4gICAgICAgIHRoaXMucnVuSW5mb01hcC5kZWxldGUocnVuLmlkKTtcbiAgICAgICAgaWYgKHJ1bkluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvblRvb2xFbmQ6IFJ1biBJRCAke3J1bi5pZH0gbm90IGZvdW5kIGluIHJ1biBtYXAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bkluZm8uaW5wdXRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb25Ub29sRW5kOiBSdW4gSUQgJHtydW4uaWR9IGlzIGEgdG9vbCBjYWxsLCBhbmQgaXMgZXhwZWN0ZWQgdG8gaGF2ZSB0cmFjZWQgaW5wdXRzLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHJ1bi5vdXRwdXRzPy5vdXRwdXQgPT09IHVuZGVmaW5lZCA/IHJ1bi5vdXRwdXRzIDogcnVuLm91dHB1dHMub3V0cHV0O1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFbmRFdmVudCh7XG4gICAgICAgICAgICBldmVudDogXCJvbl90b29sX2VuZFwiLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgICAgICBpbnB1dDogcnVuSW5mby5pbnB1dHMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVuX2lkOiBydW4uaWQsXG4gICAgICAgICAgICBuYW1lOiBydW5JbmZvLm5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW5JbmZvLnRhZ3MsXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuSW5mby5tZXRhZGF0YSxcbiAgICAgICAgfSwgcnVuSW5mbyk7XG4gICAgfVxuICAgIGFzeW5jIG9uUmV0cmlldmVyU3RhcnQocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1bk5hbWUgPSBhc3NpZ25OYW1lKHJ1bik7XG4gICAgICAgIGNvbnN0IHJ1blR5cGUgPSBcInJldHJpZXZlclwiO1xuICAgICAgICBjb25zdCBydW5JbmZvID0ge1xuICAgICAgICAgICAgdGFnczogcnVuLnRhZ3MgPz8gW10sXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuLmV4dHJhPy5tZXRhZGF0YSA/PyB7fSxcbiAgICAgICAgICAgIG5hbWU6IHJ1bk5hbWUsXG4gICAgICAgICAgICBydW5UeXBlLFxuICAgICAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICAgICAgcXVlcnk6IHJ1bi5pbnB1dHMucXVlcnksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJ1bkluZm9NYXAuc2V0KHJ1bi5pZCwgcnVuSW5mbyk7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgICAgICBldmVudDogXCJvbl9yZXRyaWV2ZXJfc3RhcnRcIixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBpbnB1dDoge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeTogcnVuLmlucHV0cy5xdWVyeSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IHJ1bk5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW4udGFncyA/PyBbXSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuLmlkLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICBhc3luYyBvblJldHJpZXZlckVuZChydW4pIHtcbiAgICAgICAgY29uc3QgcnVuSW5mbyA9IHRoaXMucnVuSW5mb01hcC5nZXQocnVuLmlkKTtcbiAgICAgICAgdGhpcy5ydW5JbmZvTWFwLmRlbGV0ZShydW4uaWQpO1xuICAgICAgICBpZiAocnVuSW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG9uUmV0cmlldmVyRW5kOiBSdW4gSUQgJHtydW4uaWR9IG5vdCBmb3VuZCBpbiBydW4gbWFwLmApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVuZEV2ZW50KHtcbiAgICAgICAgICAgIGV2ZW50OiBcIm9uX3JldHJpZXZlcl9lbmRcIixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IHJ1bi5vdXRwdXRzPy5kb2N1bWVudHMgPz8gcnVuLm91dHB1dHMsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHJ1bkluZm8uaW5wdXRzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuLmlkLFxuICAgICAgICAgICAgbmFtZTogcnVuSW5mby5uYW1lLFxuICAgICAgICAgICAgdGFnczogcnVuSW5mby50YWdzLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bkluZm8ubWV0YWRhdGEsXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGFzeW5jIGhhbmRsZUN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgZGF0YSwgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuSW5mbyA9IHRoaXMucnVuSW5mb01hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAocnVuSW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGhhbmRsZUN1c3RvbUV2ZW50OiBSdW4gSUQgJHtydW5JZH0gbm90IGZvdW5kIGluIHJ1biBtYXAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kKHtcbiAgICAgICAgICAgIGV2ZW50OiBcIm9uX2N1c3RvbV9ldmVudFwiLFxuICAgICAgICAgICAgcnVuX2lkOiBydW5JZCxcbiAgICAgICAgICAgIG5hbWU6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgIHRhZ3M6IHJ1bkluZm8udGFncyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBydW5JbmZvLm1ldGFkYXRhLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgfSwgcnVuSW5mbyk7XG4gICAgfVxuICAgIGFzeW5jIGZpbmlzaCgpIHtcbiAgICAgICAgY29uc3QgcGVuZGluZ1Byb21pc2VzID0gWy4uLnRoaXMudGFwcGVkUHJvbWlzZXMudmFsdWVzKCldO1xuICAgICAgICB2b2lkIFByb21pc2UuYWxsKHBlbmRpbmdQcm9taXNlcykuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICB2b2lkIHRoaXMud3JpdGVyLmNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuRXZlbnRTdHJlYW1DYWxsYmFja0hhbmRsZXIgPSBFdmVudFN0cmVhbUNhbGxiYWNrSGFuZGxlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/event_stream.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/log_stream.cjs":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/log_stream.cjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LogStreamCallbackHandler = exports.isLogStreamHandler = exports.RunLog = exports.RunLogPatch = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/fast-json-patch/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/index.cjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.cjs\");\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\nconst ai_js_1 = __webpack_require__(/*! ../messages/ai.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/ai.cjs\");\n/**\n * List of jsonpatch JSONPatchOperations, which describe how to create the run state\n * from an empty dict. This is the minimal representation of the log, designed to\n * be serialized as JSON and sent over the wire to reconstruct the log on the other\n * side. Reconstruction of the state can be done with any jsonpatch-compliant library,\n * see https://jsonpatch.com for more information.\n */\nclass RunLogPatch {\n    constructor(fields) {\n        Object.defineProperty(this, \"ops\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.ops = fields.ops ?? [];\n    }\n    concat(other) {\n        const ops = this.ops.concat(other.ops);\n        const states = (0, index_js_1.applyPatch)({}, ops);\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunLog({\n            ops,\n            state: states[states.length - 1].newDocument,\n        });\n    }\n}\nexports.RunLogPatch = RunLogPatch;\nclass RunLog extends RunLogPatch {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"state\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.state = fields.state;\n    }\n    concat(other) {\n        const ops = this.ops.concat(other.ops);\n        const states = (0, index_js_1.applyPatch)(this.state, other.ops);\n        return new RunLog({ ops, state: states[states.length - 1].newDocument });\n    }\n    static fromRunLogPatch(patch) {\n        const states = (0, index_js_1.applyPatch)({}, patch.ops);\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunLog({\n            ops: patch.ops,\n            state: states[states.length - 1].newDocument,\n        });\n    }\n}\nexports.RunLog = RunLog;\nconst isLogStreamHandler = (handler) => handler.name === \"log_stream_tracer\";\nexports.isLogStreamHandler = isLogStreamHandler;\n/**\n * Extract standardized inputs from a run.\n *\n * Standardizes the inputs based on the type of the runnable used.\n *\n * @param run - Run object\n * @param schemaFormat - The schema format to use.\n *\n * @returns Valid inputs are only dict. By conventions, inputs always represented\n * invocation using named arguments.\n * A null means that the input is not yet known!\n */\nasync function _getStandardizedInputs(run, schemaFormat) {\n    if (schemaFormat === \"original\") {\n        throw new Error(\"Do not assign inputs with original schema drop the key for now. \" +\n            \"When inputs are added to streamLog they should be added with \" +\n            \"standardized schema for streaming events.\");\n    }\n    const { inputs } = run;\n    if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n        return inputs;\n    }\n    if (Object.keys(inputs).length === 1 && inputs?.input === \"\") {\n        return undefined;\n    }\n    // new style chains\n    // These nest an additional 'input' key inside the 'inputs' to make sure\n    // the input is always a dict. We need to unpack and user the inner value.\n    // We should try to fix this in Runnables and callbacks/tracers\n    // Runnables should be using a null type here not a placeholder\n    // dict.\n    return inputs.input;\n}\nasync function _getStandardizedOutputs(run, schemaFormat) {\n    const { outputs } = run;\n    if (schemaFormat === \"original\") {\n        // Return the old schema, without standardizing anything\n        return outputs;\n    }\n    if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n        return outputs;\n    }\n    // TODO: Remove this hacky check\n    if (outputs !== undefined &&\n        Object.keys(outputs).length === 1 &&\n        outputs?.output !== undefined) {\n        return outputs.output;\n    }\n    return outputs;\n}\nfunction isChatGenerationChunk(x) {\n    return x !== undefined && x.message !== undefined;\n}\n/**\n * Class that extends the `BaseTracer` class from the\n * `langchain.callbacks.tracers.base` module. It represents a callback\n * handler that logs the execution of runs and emits `RunLog` instances to a\n * `RunLogStream`.\n */\nclass LogStreamCallbackHandler extends base_js_1.BaseTracer {\n    constructor(fields) {\n        super({ _awaitHandler: true, ...fields });\n        Object.defineProperty(this, \"autoClose\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"includeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_schemaFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"original\"\n        });\n        Object.defineProperty(this, \"rootId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"keyMapByRunId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"counterMapByRunName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"transformStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"writer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"receiveStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"log_stream_tracer\"\n        });\n        Object.defineProperty(this, \"lc_prefer_streaming\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.autoClose = fields?.autoClose ?? true;\n        this.includeNames = fields?.includeNames;\n        this.includeTypes = fields?.includeTypes;\n        this.includeTags = fields?.includeTags;\n        this.excludeNames = fields?.excludeNames;\n        this.excludeTypes = fields?.excludeTypes;\n        this.excludeTags = fields?.excludeTags;\n        this._schemaFormat = fields?._schemaFormat ?? this._schemaFormat;\n        this.transformStream = new TransformStream();\n        this.writer = this.transformStream.writable.getWriter();\n        this.receiveStream = stream_js_1.IterableReadableStream.fromReadableStream(this.transformStream.readable);\n    }\n    [Symbol.asyncIterator]() {\n        return this.receiveStream;\n    }\n    async persistRun(_run) {\n        // This is a legacy method only called once for an entire run tree\n        // and is therefore not useful here\n    }\n    _includeRun(run) {\n        if (run.id === this.rootId) {\n            return false;\n        }\n        const runTags = run.tags ?? [];\n        let include = this.includeNames === undefined &&\n            this.includeTags === undefined &&\n            this.includeTypes === undefined;\n        if (this.includeNames !== undefined) {\n            include = include || this.includeNames.includes(run.name);\n        }\n        if (this.includeTypes !== undefined) {\n            include = include || this.includeTypes.includes(run.run_type);\n        }\n        if (this.includeTags !== undefined) {\n            include =\n                include ||\n                    runTags.find((tag) => this.includeTags?.includes(tag)) !== undefined;\n        }\n        if (this.excludeNames !== undefined) {\n            include = include && !this.excludeNames.includes(run.name);\n        }\n        if (this.excludeTypes !== undefined) {\n            include = include && !this.excludeTypes.includes(run.run_type);\n        }\n        if (this.excludeTags !== undefined) {\n            include =\n                include && runTags.every((tag) => !this.excludeTags?.includes(tag));\n        }\n        return include;\n    }\n    async *tapOutputIterable(runId, output) {\n        // Tap an output async iterator to stream its values to the log.\n        for await (const chunk of output) {\n            // root run is handled in .streamLog()\n            if (runId !== this.rootId) {\n                // if we can't find the run silently ignore\n                // eg. because this run wasn't included in the log\n                const key = this.keyMapByRunId[runId];\n                if (key) {\n                    await this.writer.write(new RunLogPatch({\n                        ops: [\n                            {\n                                op: \"add\",\n                                path: `/logs/${key}/streamed_output/-`,\n                                value: chunk,\n                            },\n                        ],\n                    }));\n                }\n            }\n            yield chunk;\n        }\n    }\n    async onRunCreate(run) {\n        if (this.rootId === undefined) {\n            this.rootId = run.id;\n            await this.writer.write(new RunLogPatch({\n                ops: [\n                    {\n                        op: \"replace\",\n                        path: \"\",\n                        value: {\n                            id: run.id,\n                            name: run.name,\n                            type: run.run_type,\n                            streamed_output: [],\n                            final_output: undefined,\n                            logs: {},\n                        },\n                    },\n                ],\n            }));\n        }\n        if (!this._includeRun(run)) {\n            return;\n        }\n        if (this.counterMapByRunName[run.name] === undefined) {\n            this.counterMapByRunName[run.name] = 0;\n        }\n        this.counterMapByRunName[run.name] += 1;\n        const count = this.counterMapByRunName[run.name];\n        this.keyMapByRunId[run.id] =\n            count === 1 ? run.name : `${run.name}:${count}`;\n        const logEntry = {\n            id: run.id,\n            name: run.name,\n            type: run.run_type,\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            start_time: new Date(run.start_time).toISOString(),\n            streamed_output: [],\n            streamed_output_str: [],\n            final_output: undefined,\n            end_time: undefined,\n        };\n        if (this._schemaFormat === \"streaming_events\") {\n            logEntry.inputs = await _getStandardizedInputs(run, this._schemaFormat);\n        }\n        await this.writer.write(new RunLogPatch({\n            ops: [\n                {\n                    op: \"add\",\n                    path: `/logs/${this.keyMapByRunId[run.id]}`,\n                    value: logEntry,\n                },\n            ],\n        }));\n    }\n    async onRunUpdate(run) {\n        try {\n            const runName = this.keyMapByRunId[run.id];\n            if (runName === undefined) {\n                return;\n            }\n            const ops = [];\n            if (this._schemaFormat === \"streaming_events\") {\n                ops.push({\n                    op: \"replace\",\n                    path: `/logs/${runName}/inputs`,\n                    value: await _getStandardizedInputs(run, this._schemaFormat),\n                });\n            }\n            ops.push({\n                op: \"add\",\n                path: `/logs/${runName}/final_output`,\n                value: await _getStandardizedOutputs(run, this._schemaFormat),\n            });\n            if (run.end_time !== undefined) {\n                ops.push({\n                    op: \"add\",\n                    path: `/logs/${runName}/end_time`,\n                    value: new Date(run.end_time).toISOString(),\n                });\n            }\n            const patch = new RunLogPatch({ ops });\n            await this.writer.write(patch);\n        }\n        finally {\n            if (run.id === this.rootId) {\n                const patch = new RunLogPatch({\n                    ops: [\n                        {\n                            op: \"replace\",\n                            path: \"/final_output\",\n                            value: await _getStandardizedOutputs(run, this._schemaFormat),\n                        },\n                    ],\n                });\n                await this.writer.write(patch);\n                if (this.autoClose) {\n                    await this.writer.close();\n                }\n            }\n        }\n    }\n    async onLLMNewToken(run, token, kwargs) {\n        const runName = this.keyMapByRunId[run.id];\n        if (runName === undefined) {\n            return;\n        }\n        // TODO: Remove hack\n        const isChatModel = run.inputs.messages !== undefined;\n        let streamedOutputValue;\n        if (isChatModel) {\n            if (isChatGenerationChunk(kwargs?.chunk)) {\n                streamedOutputValue = kwargs?.chunk;\n            }\n            else {\n                streamedOutputValue = new ai_js_1.AIMessageChunk({\n                    id: `run-${run.id}`,\n                    content: token,\n                });\n            }\n        }\n        else {\n            streamedOutputValue = token;\n        }\n        const patch = new RunLogPatch({\n            ops: [\n                {\n                    op: \"add\",\n                    path: `/logs/${runName}/streamed_output_str/-`,\n                    value: token,\n                },\n                {\n                    op: \"add\",\n                    path: `/logs/${runName}/streamed_output/-`,\n                    value: streamedOutputValue,\n                },\n            ],\n        });\n        await this.writer.write(patch);\n    }\n}\nexports.LogStreamCallbackHandler = LogStreamCallbackHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9sb2dfc3RyZWFtLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsR0FBRywwQkFBMEIsR0FBRyxjQUFjLEdBQUcsbUJBQW1CO0FBQ3BHLG1CQUFtQixtQkFBTyxDQUFDLHFIQUFvQztBQUMvRCxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBWTtBQUN0QyxvQkFBb0IsbUJBQU8sQ0FBQyx1RkFBcUI7QUFDakQsZ0JBQWdCLG1CQUFPLENBQUMscUZBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbURBQW1EO0FBQy9FO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLElBQUk7QUFDbkQ7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTLEdBQUcsTUFBTTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDJCQUEyQjtBQUM5RDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSw0Q0FBNEMsS0FBSztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9sb2dfc3RyZWFtLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyID0gZXhwb3J0cy5pc0xvZ1N0cmVhbUhhbmRsZXIgPSBleHBvcnRzLlJ1bkxvZyA9IGV4cG9ydHMuUnVuTG9nUGF0Y2ggPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2Zhc3QtanNvbi1wYXRjaC9pbmRleC5janNcIik7XG5jb25zdCBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlLmNqc1wiKTtcbmNvbnN0IHN0cmVhbV9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL3N0cmVhbS5janNcIik7XG5jb25zdCBhaV9qc18xID0gcmVxdWlyZShcIi4uL21lc3NhZ2VzL2FpLmNqc1wiKTtcbi8qKlxuICogTGlzdCBvZiBqc29ucGF0Y2ggSlNPTlBhdGNoT3BlcmF0aW9ucywgd2hpY2ggZGVzY3JpYmUgaG93IHRvIGNyZWF0ZSB0aGUgcnVuIHN0YXRlXG4gKiBmcm9tIGFuIGVtcHR5IGRpY3QuIFRoaXMgaXMgdGhlIG1pbmltYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxvZywgZGVzaWduZWQgdG9cbiAqIGJlIHNlcmlhbGl6ZWQgYXMgSlNPTiBhbmQgc2VudCBvdmVyIHRoZSB3aXJlIHRvIHJlY29uc3RydWN0IHRoZSBsb2cgb24gdGhlIG90aGVyXG4gKiBzaWRlLiBSZWNvbnN0cnVjdGlvbiBvZiB0aGUgc3RhdGUgY2FuIGJlIGRvbmUgd2l0aCBhbnkganNvbnBhdGNoLWNvbXBsaWFudCBsaWJyYXJ5LFxuICogc2VlIGh0dHBzOi8vanNvbnBhdGNoLmNvbSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgUnVuTG9nUGF0Y2gge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vcHMgPSBmaWVsZHMub3BzID8/IFtdO1xuICAgIH1cbiAgICBjb25jYXQob3RoZXIpIHtcbiAgICAgICAgY29uc3Qgb3BzID0gdGhpcy5vcHMuY29uY2F0KG90aGVyLm9wcyk7XG4gICAgICAgIGNvbnN0IHN0YXRlcyA9ICgwLCBpbmRleF9qc18xLmFwcGx5UGF0Y2gpKHt9LCBvcHMpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVuTG9nKHtcbiAgICAgICAgICAgIG9wcyxcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZXNbc3RhdGVzLmxlbmd0aCAtIDFdLm5ld0RvY3VtZW50LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlJ1bkxvZ1BhdGNoID0gUnVuTG9nUGF0Y2g7XG5jbGFzcyBSdW5Mb2cgZXh0ZW5kcyBSdW5Mb2dQYXRjaCB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXRlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBmaWVsZHMuc3RhdGU7XG4gICAgfVxuICAgIGNvbmNhdChvdGhlcikge1xuICAgICAgICBjb25zdCBvcHMgPSB0aGlzLm9wcy5jb25jYXQob3RoZXIub3BzKTtcbiAgICAgICAgY29uc3Qgc3RhdGVzID0gKDAsIGluZGV4X2pzXzEuYXBwbHlQYXRjaCkodGhpcy5zdGF0ZSwgb3RoZXIub3BzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5Mb2coeyBvcHMsIHN0YXRlOiBzdGF0ZXNbc3RhdGVzLmxlbmd0aCAtIDFdLm5ld0RvY3VtZW50IH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVJ1bkxvZ1BhdGNoKHBhdGNoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlcyA9ICgwLCBpbmRleF9qc18xLmFwcGx5UGF0Y2gpKHt9LCBwYXRjaC5vcHMpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVuTG9nKHtcbiAgICAgICAgICAgIG9wczogcGF0Y2gub3BzLFxuICAgICAgICAgICAgc3RhdGU6IHN0YXRlc1tzdGF0ZXMubGVuZ3RoIC0gMV0ubmV3RG9jdW1lbnQsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuUnVuTG9nID0gUnVuTG9nO1xuY29uc3QgaXNMb2dTdHJlYW1IYW5kbGVyID0gKGhhbmRsZXIpID0+IGhhbmRsZXIubmFtZSA9PT0gXCJsb2dfc3RyZWFtX3RyYWNlclwiO1xuZXhwb3J0cy5pc0xvZ1N0cmVhbUhhbmRsZXIgPSBpc0xvZ1N0cmVhbUhhbmRsZXI7XG4vKipcbiAqIEV4dHJhY3Qgc3RhbmRhcmRpemVkIGlucHV0cyBmcm9tIGEgcnVuLlxuICpcbiAqIFN0YW5kYXJkaXplcyB0aGUgaW5wdXRzIGJhc2VkIG9uIHRoZSB0eXBlIG9mIHRoZSBydW5uYWJsZSB1c2VkLlxuICpcbiAqIEBwYXJhbSBydW4gLSBSdW4gb2JqZWN0XG4gKiBAcGFyYW0gc2NoZW1hRm9ybWF0IC0gVGhlIHNjaGVtYSBmb3JtYXQgdG8gdXNlLlxuICpcbiAqIEByZXR1cm5zIFZhbGlkIGlucHV0cyBhcmUgb25seSBkaWN0LiBCeSBjb252ZW50aW9ucywgaW5wdXRzIGFsd2F5cyByZXByZXNlbnRlZFxuICogaW52b2NhdGlvbiB1c2luZyBuYW1lZCBhcmd1bWVudHMuXG4gKiBBIG51bGwgbWVhbnMgdGhhdCB0aGUgaW5wdXQgaXMgbm90IHlldCBrbm93biFcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2dldFN0YW5kYXJkaXplZElucHV0cyhydW4sIHNjaGVtYUZvcm1hdCkge1xuICAgIGlmIChzY2hlbWFGb3JtYXQgPT09IFwib3JpZ2luYWxcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEbyBub3QgYXNzaWduIGlucHV0cyB3aXRoIG9yaWdpbmFsIHNjaGVtYSBkcm9wIHRoZSBrZXkgZm9yIG5vdy4gXCIgK1xuICAgICAgICAgICAgXCJXaGVuIGlucHV0cyBhcmUgYWRkZWQgdG8gc3RyZWFtTG9nIHRoZXkgc2hvdWxkIGJlIGFkZGVkIHdpdGggXCIgK1xuICAgICAgICAgICAgXCJzdGFuZGFyZGl6ZWQgc2NoZW1hIGZvciBzdHJlYW1pbmcgZXZlbnRzLlwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBpbnB1dHMgfSA9IHJ1bjtcbiAgICBpZiAoW1wicmV0cmlldmVyXCIsIFwibGxtXCIsIFwicHJvbXB0XCJdLmluY2x1ZGVzKHJ1bi5ydW5fdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0cztcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKGlucHV0cykubGVuZ3RoID09PSAxICYmIGlucHV0cz8uaW5wdXQgPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gbmV3IHN0eWxlIGNoYWluc1xuICAgIC8vIFRoZXNlIG5lc3QgYW4gYWRkaXRpb25hbCAnaW5wdXQnIGtleSBpbnNpZGUgdGhlICdpbnB1dHMnIHRvIG1ha2Ugc3VyZVxuICAgIC8vIHRoZSBpbnB1dCBpcyBhbHdheXMgYSBkaWN0LiBXZSBuZWVkIHRvIHVucGFjayBhbmQgdXNlciB0aGUgaW5uZXIgdmFsdWUuXG4gICAgLy8gV2Ugc2hvdWxkIHRyeSB0byBmaXggdGhpcyBpbiBSdW5uYWJsZXMgYW5kIGNhbGxiYWNrcy90cmFjZXJzXG4gICAgLy8gUnVubmFibGVzIHNob3VsZCBiZSB1c2luZyBhIG51bGwgdHlwZSBoZXJlIG5vdCBhIHBsYWNlaG9sZGVyXG4gICAgLy8gZGljdC5cbiAgICByZXR1cm4gaW5wdXRzLmlucHV0O1xufVxuYXN5bmMgZnVuY3Rpb24gX2dldFN0YW5kYXJkaXplZE91dHB1dHMocnVuLCBzY2hlbWFGb3JtYXQpIHtcbiAgICBjb25zdCB7IG91dHB1dHMgfSA9IHJ1bjtcbiAgICBpZiAoc2NoZW1hRm9ybWF0ID09PSBcIm9yaWdpbmFsXCIpIHtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBvbGQgc2NoZW1hLCB3aXRob3V0IHN0YW5kYXJkaXppbmcgYW55dGhpbmdcbiAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgfVxuICAgIGlmIChbXCJyZXRyaWV2ZXJcIiwgXCJsbG1cIiwgXCJwcm9tcHRcIl0uaW5jbHVkZXMocnVuLnJ1bl90eXBlKSkge1xuICAgICAgICByZXR1cm4gb3V0cHV0cztcbiAgICB9XG4gICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgaGFja3kgY2hlY2tcbiAgICBpZiAob3V0cHV0cyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIE9iamVjdC5rZXlzKG91dHB1dHMpLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBvdXRwdXRzPy5vdXRwdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gb3V0cHV0cy5vdXRwdXQ7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXRzO1xufVxuZnVuY3Rpb24gaXNDaGF0R2VuZXJhdGlvbkNodW5rKHgpIHtcbiAgICByZXR1cm4geCAhPT0gdW5kZWZpbmVkICYmIHgubWVzc2FnZSAhPT0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBDbGFzcyB0aGF0IGV4dGVuZHMgdGhlIGBCYXNlVHJhY2VyYCBjbGFzcyBmcm9tIHRoZVxuICogYGxhbmdjaGFpbi5jYWxsYmFja3MudHJhY2Vycy5iYXNlYCBtb2R1bGUuIEl0IHJlcHJlc2VudHMgYSBjYWxsYmFja1xuICogaGFuZGxlciB0aGF0IGxvZ3MgdGhlIGV4ZWN1dGlvbiBvZiBydW5zIGFuZCBlbWl0cyBgUnVuTG9nYCBpbnN0YW5jZXMgdG8gYVxuICogYFJ1bkxvZ1N0cmVhbWAuXG4gKi9cbmNsYXNzIExvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlciBleHRlbmRzIGJhc2VfanNfMS5CYXNlVHJhY2VyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoeyBfYXdhaXRIYW5kbGVyOiB0cnVlLCAuLi5maWVsZHMgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9DbG9zZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5jbHVkZU5hbWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluY2x1ZGVUeXBlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmNsdWRlVGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGNsdWRlTmFtZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhjbHVkZVR5cGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4Y2x1ZGVUYWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zY2hlbWFGb3JtYXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwib3JpZ2luYWxcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicm9vdElkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImtleU1hcEJ5UnVuSWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb3VudGVyTWFwQnlSdW5OYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhbnNmb3JtU3RyZWFtXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndyaXRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWNlaXZlU3RyZWFtXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwibG9nX3N0cmVhbV90cmFjZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfcHJlZmVyX3N0cmVhbWluZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hdXRvQ2xvc2UgPSBmaWVsZHM/LmF1dG9DbG9zZSA/PyB0cnVlO1xuICAgICAgICB0aGlzLmluY2x1ZGVOYW1lcyA9IGZpZWxkcz8uaW5jbHVkZU5hbWVzO1xuICAgICAgICB0aGlzLmluY2x1ZGVUeXBlcyA9IGZpZWxkcz8uaW5jbHVkZVR5cGVzO1xuICAgICAgICB0aGlzLmluY2x1ZGVUYWdzID0gZmllbGRzPy5pbmNsdWRlVGFncztcbiAgICAgICAgdGhpcy5leGNsdWRlTmFtZXMgPSBmaWVsZHM/LmV4Y2x1ZGVOYW1lcztcbiAgICAgICAgdGhpcy5leGNsdWRlVHlwZXMgPSBmaWVsZHM/LmV4Y2x1ZGVUeXBlcztcbiAgICAgICAgdGhpcy5leGNsdWRlVGFncyA9IGZpZWxkcz8uZXhjbHVkZVRhZ3M7XG4gICAgICAgIHRoaXMuX3NjaGVtYUZvcm1hdCA9IGZpZWxkcz8uX3NjaGVtYUZvcm1hdCA/PyB0aGlzLl9zY2hlbWFGb3JtYXQ7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtU3RyZWFtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSgpO1xuICAgICAgICB0aGlzLndyaXRlciA9IHRoaXMudHJhbnNmb3JtU3RyZWFtLndyaXRhYmxlLmdldFdyaXRlcigpO1xuICAgICAgICB0aGlzLnJlY2VpdmVTdHJlYW0gPSBzdHJlYW1fanNfMS5JdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21SZWFkYWJsZVN0cmVhbSh0aGlzLnRyYW5zZm9ybVN0cmVhbS5yZWFkYWJsZSk7XG4gICAgfVxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVTdHJlYW07XG4gICAgfVxuICAgIGFzeW5jIHBlcnNpc3RSdW4oX3J1bikge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbGVnYWN5IG1ldGhvZCBvbmx5IGNhbGxlZCBvbmNlIGZvciBhbiBlbnRpcmUgcnVuIHRyZWVcbiAgICAgICAgLy8gYW5kIGlzIHRoZXJlZm9yZSBub3QgdXNlZnVsIGhlcmVcbiAgICB9XG4gICAgX2luY2x1ZGVSdW4ocnVuKSB7XG4gICAgICAgIGlmIChydW4uaWQgPT09IHRoaXMucm9vdElkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVuVGFncyA9IHJ1bi50YWdzID8/IFtdO1xuICAgICAgICBsZXQgaW5jbHVkZSA9IHRoaXMuaW5jbHVkZU5hbWVzID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZVRhZ3MgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy5pbmNsdWRlVHlwZXMgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZU5hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlIHx8IHRoaXMuaW5jbHVkZU5hbWVzLmluY2x1ZGVzKHJ1bi5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmNsdWRlVHlwZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGluY2x1ZGUgfHwgdGhpcy5pbmNsdWRlVHlwZXMuaW5jbHVkZXMocnVuLnJ1bl90eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmNsdWRlVGFncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID1cbiAgICAgICAgICAgICAgICBpbmNsdWRlIHx8XG4gICAgICAgICAgICAgICAgICAgIHJ1blRhZ3MuZmluZCgodGFnKSA9PiB0aGlzLmluY2x1ZGVUYWdzPy5pbmNsdWRlcyh0YWcpKSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSAmJiAhdGhpcy5leGNsdWRlTmFtZXMuaW5jbHVkZXMocnVuLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSAmJiAhdGhpcy5leGNsdWRlVHlwZXMuaW5jbHVkZXMocnVuLnJ1bl90eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leGNsdWRlVGFncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID1cbiAgICAgICAgICAgICAgICBpbmNsdWRlICYmIHJ1blRhZ3MuZXZlcnkoKHRhZykgPT4gIXRoaXMuZXhjbHVkZVRhZ3M/LmluY2x1ZGVzKHRhZykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmNsdWRlO1xuICAgIH1cbiAgICBhc3luYyAqdGFwT3V0cHV0SXRlcmFibGUocnVuSWQsIG91dHB1dCkge1xuICAgICAgICAvLyBUYXAgYW4gb3V0cHV0IGFzeW5jIGl0ZXJhdG9yIHRvIHN0cmVhbSBpdHMgdmFsdWVzIHRvIHRoZSBsb2cuXG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygb3V0cHV0KSB7XG4gICAgICAgICAgICAvLyByb290IHJ1biBpcyBoYW5kbGVkIGluIC5zdHJlYW1Mb2coKVxuICAgICAgICAgICAgaWYgKHJ1bklkICE9PSB0aGlzLnJvb3RJZCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGNhbid0IGZpbmQgdGhlIHJ1biBzaWxlbnRseSBpZ25vcmVcbiAgICAgICAgICAgICAgICAvLyBlZy4gYmVjYXVzZSB0aGlzIHJ1biB3YXNuJ3QgaW5jbHVkZWQgaW4gdGhlIGxvZ1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMua2V5TWFwQnlSdW5JZFtydW5JZF07XG4gICAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRlci53cml0ZShuZXcgUnVuTG9nUGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogYC9sb2dzLyR7a2V5fS9zdHJlYW1lZF9vdXRwdXQvLWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG9uUnVuQ3JlYXRlKHJ1bikge1xuICAgICAgICBpZiAodGhpcy5yb290SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5yb290SWQgPSBydW4uaWQ7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRlci53cml0ZShuZXcgUnVuTG9nUGF0Y2goe1xuICAgICAgICAgICAgICAgIG9wczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogcnVuLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHJ1bi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHJ1bi5ydW5fdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1lZF9vdXRwdXQ6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsX291dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ3M6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faW5jbHVkZVJ1bihydW4pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY291bnRlck1hcEJ5UnVuTmFtZVtydW4ubmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb3VudGVyTWFwQnlSdW5OYW1lW3J1bi5uYW1lXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb3VudGVyTWFwQnlSdW5OYW1lW3J1bi5uYW1lXSArPSAxO1xuICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMuY291bnRlck1hcEJ5UnVuTmFtZVtydW4ubmFtZV07XG4gICAgICAgIHRoaXMua2V5TWFwQnlSdW5JZFtydW4uaWRdID1cbiAgICAgICAgICAgIGNvdW50ID09PSAxID8gcnVuLm5hbWUgOiBgJHtydW4ubmFtZX06JHtjb3VudH1gO1xuICAgICAgICBjb25zdCBsb2dFbnRyeSA9IHtcbiAgICAgICAgICAgIGlkOiBydW4uaWQsXG4gICAgICAgICAgICBuYW1lOiBydW4ubmFtZSxcbiAgICAgICAgICAgIHR5cGU6IHJ1bi5ydW5fdHlwZSxcbiAgICAgICAgICAgIHRhZ3M6IHJ1bi50YWdzID8/IFtdLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgICAgICBzdGFydF90aW1lOiBuZXcgRGF0ZShydW4uc3RhcnRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIHN0cmVhbWVkX291dHB1dDogW10sXG4gICAgICAgICAgICBzdHJlYW1lZF9vdXRwdXRfc3RyOiBbXSxcbiAgICAgICAgICAgIGZpbmFsX291dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZW5kX3RpbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX3NjaGVtYUZvcm1hdCA9PT0gXCJzdHJlYW1pbmdfZXZlbnRzXCIpIHtcbiAgICAgICAgICAgIGxvZ0VudHJ5LmlucHV0cyA9IGF3YWl0IF9nZXRTdGFuZGFyZGl6ZWRJbnB1dHMocnVuLCB0aGlzLl9zY2hlbWFGb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLndyaXRlKG5ldyBSdW5Mb2dQYXRjaCh7XG4gICAgICAgICAgICBvcHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBgL2xvZ3MvJHt0aGlzLmtleU1hcEJ5UnVuSWRbcnVuLmlkXX1gLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbG9nRW50cnksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgb25SdW5VcGRhdGUocnVuKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBydW5OYW1lID0gdGhpcy5rZXlNYXBCeVJ1bklkW3J1bi5pZF07XG4gICAgICAgICAgICBpZiAocnVuTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3BzID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5fc2NoZW1hRm9ybWF0ID09PSBcInN0cmVhbWluZ19ldmVudHNcIikge1xuICAgICAgICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwicmVwbGFjZVwiLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBgL2xvZ3MvJHtydW5OYW1lfS9pbnB1dHNgLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYXdhaXQgX2dldFN0YW5kYXJkaXplZElucHV0cyhydW4sIHRoaXMuX3NjaGVtYUZvcm1hdCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgcGF0aDogYC9sb2dzLyR7cnVuTmFtZX0vZmluYWxfb3V0cHV0YCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogYXdhaXQgX2dldFN0YW5kYXJkaXplZE91dHB1dHMocnVuLCB0aGlzLl9zY2hlbWFGb3JtYXQpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocnVuLmVuZF90aW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBgL2xvZ3MvJHtydW5OYW1lfS9lbmRfdGltZWAsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXRjaCA9IG5ldyBSdW5Mb2dQYXRjaCh7IG9wcyB9KTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLndyaXRlKHBhdGNoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChydW4uaWQgPT09IHRoaXMucm9vdElkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0Y2ggPSBuZXcgUnVuTG9nUGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICBvcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogXCIvZmluYWxfb3V0cHV0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGF3YWl0IF9nZXRTdGFuZGFyZGl6ZWRPdXRwdXRzKHJ1biwgdGhpcy5fc2NoZW1hRm9ybWF0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0ZXIud3JpdGUocGF0Y2gpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF1dG9DbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBvbkxMTU5ld1Rva2VuKHJ1biwgdG9rZW4sIGt3YXJncykge1xuICAgICAgICBjb25zdCBydW5OYW1lID0gdGhpcy5rZXlNYXBCeVJ1bklkW3J1bi5pZF07XG4gICAgICAgIGlmIChydW5OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgaGFja1xuICAgICAgICBjb25zdCBpc0NoYXRNb2RlbCA9IHJ1bi5pbnB1dHMubWVzc2FnZXMgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHN0cmVhbWVkT3V0cHV0VmFsdWU7XG4gICAgICAgIGlmIChpc0NoYXRNb2RlbCkge1xuICAgICAgICAgICAgaWYgKGlzQ2hhdEdlbmVyYXRpb25DaHVuayhrd2FyZ3M/LmNodW5rKSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbWVkT3V0cHV0VmFsdWUgPSBrd2FyZ3M/LmNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtZWRPdXRwdXRWYWx1ZSA9IG5ldyBhaV9qc18xLkFJTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGBydW4tJHtydW4uaWR9YCxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogdG9rZW4sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJlYW1lZE91dHB1dFZhbHVlID0gdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF0Y2ggPSBuZXcgUnVuTG9nUGF0Y2goe1xuICAgICAgICAgICAgb3BzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogYC9sb2dzLyR7cnVuTmFtZX0vc3RyZWFtZWRfb3V0cHV0X3N0ci8tYCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRva2VuLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogYC9sb2dzLyR7cnVuTmFtZX0vc3RyZWFtZWRfb3V0cHV0Ly1gLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc3RyZWFtZWRPdXRwdXRWYWx1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLndyaXRlKHBhdGNoKTtcbiAgICB9XG59XG5leHBvcnRzLkxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlciA9IExvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/log_stream.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/root_listener.cjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/root_listener.cjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RootListenersTracer = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.cjs\");\nclass RootListenersTracer extends base_js_1.BaseTracer {\n    constructor({ config, onStart, onEnd, onError, }) {\n        super({ _awaitHandler: true });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"RootListenersTracer\"\n        });\n        /** The Run's ID. Type UUID */\n        Object.defineProperty(this, \"rootId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"argOnStart\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"argOnEnd\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"argOnError\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.config = config;\n        this.argOnStart = onStart;\n        this.argOnEnd = onEnd;\n        this.argOnError = onError;\n    }\n    /**\n     * This is a legacy method only called once for an entire run tree\n     * therefore not useful here\n     * @param {Run} _ Not used\n     */\n    persistRun(_) {\n        return Promise.resolve();\n    }\n    async onRunCreate(run) {\n        if (this.rootId) {\n            return;\n        }\n        this.rootId = run.id;\n        if (this.argOnStart) {\n            await this.argOnStart(run, this.config);\n        }\n    }\n    async onRunUpdate(run) {\n        if (run.id !== this.rootId) {\n            return;\n        }\n        if (!run.error) {\n            if (this.argOnEnd) {\n                await this.argOnEnd(run, this.config);\n            }\n        }\n        else if (this.argOnError) {\n            await this.argOnError(run, this.config);\n        }\n    }\n}\nexports.RootListenersTracer = RootListenersTracer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9yb290X2xpc3RlbmVyLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0Isa0JBQWtCLG1CQUFPLENBQUMsOEVBQVk7QUFDdEM7QUFDQSxrQkFBa0Isa0NBQWtDO0FBQ3BELGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3RyYWNlcnMvcm9vdF9saXN0ZW5lci5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJvb3RMaXN0ZW5lcnNUcmFjZXIgPSB2b2lkIDA7XG5jb25zdCBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlLmNqc1wiKTtcbmNsYXNzIFJvb3RMaXN0ZW5lcnNUcmFjZXIgZXh0ZW5kcyBiYXNlX2pzXzEuQmFzZVRyYWNlciB7XG4gICAgY29uc3RydWN0b3IoeyBjb25maWcsIG9uU3RhcnQsIG9uRW5kLCBvbkVycm9yLCB9KSB7XG4gICAgICAgIHN1cGVyKHsgX2F3YWl0SGFuZGxlcjogdHJ1ZSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJSb290TGlzdGVuZXJzVHJhY2VyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBUaGUgUnVuJ3MgSUQuIFR5cGUgVVVJRCAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyb290SWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29uZmlnXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFyZ09uU3RhcnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXJnT25FbmRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXJnT25FcnJvclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5hcmdPblN0YXJ0ID0gb25TdGFydDtcbiAgICAgICAgdGhpcy5hcmdPbkVuZCA9IG9uRW5kO1xuICAgICAgICB0aGlzLmFyZ09uRXJyb3IgPSBvbkVycm9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGEgbGVnYWN5IG1ldGhvZCBvbmx5IGNhbGxlZCBvbmNlIGZvciBhbiBlbnRpcmUgcnVuIHRyZWVcbiAgICAgKiB0aGVyZWZvcmUgbm90IHVzZWZ1bCBoZXJlXG4gICAgICogQHBhcmFtIHtSdW59IF8gTm90IHVzZWRcbiAgICAgKi9cbiAgICBwZXJzaXN0UnVuKF8pIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBhc3luYyBvblJ1bkNyZWF0ZShydW4pIHtcbiAgICAgICAgaWYgKHRoaXMucm9vdElkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb290SWQgPSBydW4uaWQ7XG4gICAgICAgIGlmICh0aGlzLmFyZ09uU3RhcnQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXJnT25TdGFydChydW4sIHRoaXMuY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBvblJ1blVwZGF0ZShydW4pIHtcbiAgICAgICAgaWYgKHJ1bi5pZCAhPT0gdGhpcy5yb290SWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJ1bi5lcnJvcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXJnT25FbmQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFyZ09uRW5kKHJ1biwgdGhpcy5jb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYXJnT25FcnJvcikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcmdPbkVycm9yKHJ1biwgdGhpcy5jb25maWcpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Sb290TGlzdGVuZXJzVHJhY2VyID0gUm9vdExpc3RlbmVyc1RyYWNlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/root_listener.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/tracer_langchain.cjs":
/*!************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/tracer_langchain.cjs ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LangChainTracer = void 0;\nconst langsmith_1 = __webpack_require__(/*! langsmith */ \"(rsc)/./node_modules/langsmith/index.cjs\");\nconst run_trees_1 = __webpack_require__(/*! langsmith/run_trees */ \"(rsc)/./node_modules/langsmith/run_trees.cjs\");\nconst traceable_1 = __webpack_require__(/*! langsmith/singletons/traceable */ \"(rsc)/./node_modules/langsmith/singletons/traceable.cjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.cjs\");\nconst tracer_js_1 = __webpack_require__(/*! ../singletons/tracer.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/tracer.cjs\");\nclass LangChainTracer extends base_js_1.BaseTracer {\n    constructor(fields = {}) {\n        super(fields);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"langchain_tracer\"\n        });\n        Object.defineProperty(this, \"projectName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"exampleId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"replicas\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"usesRunTreeMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        const { exampleId, projectName, client, replicas } = fields;\n        this.projectName = projectName ?? (0, langsmith_1.getDefaultProjectName)();\n        this.replicas = replicas;\n        this.exampleId = exampleId;\n        this.client = client ?? (0, tracer_js_1.getDefaultLangChainClientSingleton)();\n        const traceableTree = LangChainTracer.getTraceableRunTree();\n        if (traceableTree) {\n            this.updateFromRunTree(traceableTree);\n        }\n    }\n    async persistRun(_run) { }\n    async onRunCreate(run) {\n        const runTree = this.getRunTreeWithTracingConfig(run.id);\n        await runTree?.postRun();\n    }\n    async onRunUpdate(run) {\n        const runTree = this.getRunTreeWithTracingConfig(run.id);\n        await runTree?.patchRun();\n    }\n    getRun(id) {\n        return this.runTreeMap.get(id);\n    }\n    updateFromRunTree(runTree) {\n        this.runTreeMap.set(runTree.id, runTree);\n        let rootRun = runTree;\n        const visited = new Set();\n        while (rootRun.parent_run) {\n            if (visited.has(rootRun.id))\n                break;\n            visited.add(rootRun.id);\n            if (!rootRun.parent_run)\n                break;\n            rootRun = rootRun.parent_run;\n        }\n        visited.clear();\n        const queue = [rootRun];\n        while (queue.length > 0) {\n            const current = queue.shift();\n            if (!current || visited.has(current.id))\n                continue;\n            visited.add(current.id);\n            this.runTreeMap.set(current.id, current);\n            if (current.child_runs) {\n                queue.push(...current.child_runs);\n            }\n        }\n        this.client = runTree.client ?? this.client;\n        this.replicas = runTree.replicas ?? this.replicas;\n        this.projectName = runTree.project_name ?? this.projectName;\n        this.exampleId = runTree.reference_example_id ?? this.exampleId;\n    }\n    getRunTreeWithTracingConfig(id) {\n        const runTree = this.runTreeMap.get(id);\n        if (!runTree)\n            return undefined;\n        return new run_trees_1.RunTree({\n            ...runTree,\n            client: this.client,\n            project_name: this.projectName,\n            replicas: this.replicas,\n            reference_example_id: this.exampleId,\n            tracingEnabled: true,\n        });\n    }\n    static getTraceableRunTree() {\n        try {\n            return (\n            // The type cast here provides forward compatibility. Old versions of LangSmith will just\n            // ignore the permitAbsentRunTree arg.\n            traceable_1.getCurrentRunTree(true));\n        }\n        catch {\n            return undefined;\n        }\n    }\n}\nexports.LangChainTracer = LangChainTracer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy90cmFjZXJfbGFuZ2NoYWluLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUI7QUFDdkIsb0JBQW9CLG1CQUFPLENBQUMsMkRBQVc7QUFDdkMsb0JBQW9CLG1CQUFPLENBQUMseUVBQXFCO0FBQ2pELG9CQUFvQixtQkFBTyxDQUFDLCtGQUFnQztBQUM1RCxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBWTtBQUN0QyxvQkFBb0IsbUJBQU8sQ0FBQyxpR0FBMEI7QUFDdEQ7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsMkNBQTJDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy90cmFjZXJfbGFuZ2NoYWluLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGFuZ0NoYWluVHJhY2VyID0gdm9pZCAwO1xuY29uc3QgbGFuZ3NtaXRoXzEgPSByZXF1aXJlKFwibGFuZ3NtaXRoXCIpO1xuY29uc3QgcnVuX3RyZWVzXzEgPSByZXF1aXJlKFwibGFuZ3NtaXRoL3J1bl90cmVlc1wiKTtcbmNvbnN0IHRyYWNlYWJsZV8xID0gcmVxdWlyZShcImxhbmdzbWl0aC9zaW5nbGV0b25zL3RyYWNlYWJsZVwiKTtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2UuY2pzXCIpO1xuY29uc3QgdHJhY2VyX2pzXzEgPSByZXF1aXJlKFwiLi4vc2luZ2xldG9ucy90cmFjZXIuY2pzXCIpO1xuY2xhc3MgTGFuZ0NoYWluVHJhY2VyIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VUcmFjZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwibGFuZ2NoYWluX3RyYWNlclwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm9qZWN0TmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGFtcGxlSWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2xpZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlcGxpY2FzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVzZXNSdW5UcmVlTWFwXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IGV4YW1wbGVJZCwgcHJvamVjdE5hbWUsIGNsaWVudCwgcmVwbGljYXMgfSA9IGZpZWxkcztcbiAgICAgICAgdGhpcy5wcm9qZWN0TmFtZSA9IHByb2plY3ROYW1lID8/ICgwLCBsYW5nc21pdGhfMS5nZXREZWZhdWx0UHJvamVjdE5hbWUpKCk7XG4gICAgICAgIHRoaXMucmVwbGljYXMgPSByZXBsaWNhcztcbiAgICAgICAgdGhpcy5leGFtcGxlSWQgPSBleGFtcGxlSWQ7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50ID8/ICgwLCB0cmFjZXJfanNfMS5nZXREZWZhdWx0TGFuZ0NoYWluQ2xpZW50U2luZ2xldG9uKSgpO1xuICAgICAgICBjb25zdCB0cmFjZWFibGVUcmVlID0gTGFuZ0NoYWluVHJhY2VyLmdldFRyYWNlYWJsZVJ1blRyZWUoKTtcbiAgICAgICAgaWYgKHRyYWNlYWJsZVRyZWUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRnJvbVJ1blRyZWUodHJhY2VhYmxlVHJlZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcGVyc2lzdFJ1bihfcnVuKSB7IH1cbiAgICBhc3luYyBvblJ1bkNyZWF0ZShydW4pIHtcbiAgICAgICAgY29uc3QgcnVuVHJlZSA9IHRoaXMuZ2V0UnVuVHJlZVdpdGhUcmFjaW5nQ29uZmlnKHJ1bi5pZCk7XG4gICAgICAgIGF3YWl0IHJ1blRyZWU/LnBvc3RSdW4oKTtcbiAgICB9XG4gICAgYXN5bmMgb25SdW5VcGRhdGUocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1blRyZWUgPSB0aGlzLmdldFJ1blRyZWVXaXRoVHJhY2luZ0NvbmZpZyhydW4uaWQpO1xuICAgICAgICBhd2FpdCBydW5UcmVlPy5wYXRjaFJ1bigpO1xuICAgIH1cbiAgICBnZXRSdW4oaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnVuVHJlZU1hcC5nZXQoaWQpO1xuICAgIH1cbiAgICB1cGRhdGVGcm9tUnVuVHJlZShydW5UcmVlKSB7XG4gICAgICAgIHRoaXMucnVuVHJlZU1hcC5zZXQocnVuVHJlZS5pZCwgcnVuVHJlZSk7XG4gICAgICAgIGxldCByb290UnVuID0gcnVuVHJlZTtcbiAgICAgICAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgd2hpbGUgKHJvb3RSdW4ucGFyZW50X3J1bikge1xuICAgICAgICAgICAgaWYgKHZpc2l0ZWQuaGFzKHJvb3RSdW4uaWQpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdmlzaXRlZC5hZGQocm9vdFJ1bi5pZCk7XG4gICAgICAgICAgICBpZiAoIXJvb3RSdW4ucGFyZW50X3J1bilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHJvb3RSdW4gPSByb290UnVuLnBhcmVudF9ydW47XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRlZC5jbGVhcigpO1xuICAgICAgICBjb25zdCBxdWV1ZSA9IFtyb290UnVuXTtcbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50IHx8IHZpc2l0ZWQuaGFzKGN1cnJlbnQuaWQpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmlzaXRlZC5hZGQoY3VycmVudC5pZCk7XG4gICAgICAgICAgICB0aGlzLnJ1blRyZWVNYXAuc2V0KGN1cnJlbnQuaWQsIGN1cnJlbnQpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQuY2hpbGRfcnVucykge1xuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goLi4uY3VycmVudC5jaGlsZF9ydW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsaWVudCA9IHJ1blRyZWUuY2xpZW50ID8/IHRoaXMuY2xpZW50O1xuICAgICAgICB0aGlzLnJlcGxpY2FzID0gcnVuVHJlZS5yZXBsaWNhcyA/PyB0aGlzLnJlcGxpY2FzO1xuICAgICAgICB0aGlzLnByb2plY3ROYW1lID0gcnVuVHJlZS5wcm9qZWN0X25hbWUgPz8gdGhpcy5wcm9qZWN0TmFtZTtcbiAgICAgICAgdGhpcy5leGFtcGxlSWQgPSBydW5UcmVlLnJlZmVyZW5jZV9leGFtcGxlX2lkID8/IHRoaXMuZXhhbXBsZUlkO1xuICAgIH1cbiAgICBnZXRSdW5UcmVlV2l0aFRyYWNpbmdDb25maWcoaWQpIHtcbiAgICAgICAgY29uc3QgcnVuVHJlZSA9IHRoaXMucnVuVHJlZU1hcC5nZXQoaWQpO1xuICAgICAgICBpZiAoIXJ1blRyZWUpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbmV3IHJ1bl90cmVlc18xLlJ1blRyZWUoe1xuICAgICAgICAgICAgLi4ucnVuVHJlZSxcbiAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICBwcm9qZWN0X25hbWU6IHRoaXMucHJvamVjdE5hbWUsXG4gICAgICAgICAgICByZXBsaWNhczogdGhpcy5yZXBsaWNhcyxcbiAgICAgICAgICAgIHJlZmVyZW5jZV9leGFtcGxlX2lkOiB0aGlzLmV4YW1wbGVJZCxcbiAgICAgICAgICAgIHRyYWNpbmdFbmFibGVkOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGdldFRyYWNlYWJsZVJ1blRyZWUoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgLy8gVGhlIHR5cGUgY2FzdCBoZXJlIHByb3ZpZGVzIGZvcndhcmQgY29tcGF0aWJpbGl0eS4gT2xkIHZlcnNpb25zIG9mIExhbmdTbWl0aCB3aWxsIGp1c3RcbiAgICAgICAgICAgIC8vIGlnbm9yZSB0aGUgcGVybWl0QWJzZW50UnVuVHJlZSBhcmcuXG4gICAgICAgICAgICB0cmFjZWFibGVfMS5nZXRDdXJyZW50UnVuVHJlZSh0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTGFuZ0NoYWluVHJhY2VyID0gTGFuZ0NoYWluVHJhY2VyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/tracer_langchain.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.cjs":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/async_caller.cjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsyncCaller = void 0;\nconst p_retry_1 = __importDefault(__webpack_require__(/*! p-retry */ \"(rsc)/./node_modules/p-retry/index.js\"));\nconst p_queue_1 = __importDefault(__webpack_require__(/*! p-queue */ \"(rsc)/./node_modules/p-queue/dist/index.js\"));\nconst STATUS_NO_RETRY = [\n    400, // Bad Request\n    401, // Unauthorized\n    402, // Payment Required\n    403, // Forbidden\n    404, // Not Found\n    405, // Method Not Allowed\n    406, // Not Acceptable\n    407, // Proxy Authentication Required\n    409, // Conflict\n];\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst defaultFailedAttemptHandler = (error) => {\n    if (error.message.startsWith(\"Cancel\") ||\n        error.message.startsWith(\"AbortError\") ||\n        error.name === \"AbortError\") {\n        throw error;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (error?.code === \"ECONNABORTED\") {\n        throw error;\n    }\n    const status = \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    error?.response?.status ?? error?.status;\n    if (status && STATUS_NO_RETRY.includes(+status)) {\n        throw error;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (error?.error?.code === \"insufficient_quota\") {\n        const err = new Error(error?.message);\n        err.name = \"InsufficientQuotaError\";\n        throw err;\n    }\n};\n/**\n * A class that can be used to make async calls with concurrency and retry logic.\n *\n * This is useful for making calls to any kind of \"expensive\" external resource,\n * be it because it's rate-limited, subject to network issues, etc.\n *\n * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n * to `Infinity`. This means that by default, all calls will be made in parallel.\n *\n * Retries are limited by the `maxRetries` parameter, which defaults to 6. This\n * means that by default, each call will be retried up to 6 times, with an\n * exponential backoff between each attempt.\n */\nclass AsyncCaller {\n    constructor(params) {\n        Object.defineProperty(this, \"maxConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxRetries\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onFailedAttempt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxConcurrency = params.maxConcurrency ?? Infinity;\n        this.maxRetries = params.maxRetries ?? 6;\n        this.onFailedAttempt =\n            params.onFailedAttempt ?? defaultFailedAttemptHandler;\n        const PQueue = (\"default\" in p_queue_1.default ? p_queue_1.default.default : p_queue_1.default);\n        this.queue = new PQueue({ concurrency: this.maxConcurrency });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call(callable, ...args) {\n        return this.queue.add(() => (0, p_retry_1.default)(() => callable(...args).catch((error) => {\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (error instanceof Error) {\n                throw error;\n            }\n            else {\n                throw new Error(error);\n            }\n        }), {\n            onFailedAttempt: this.onFailedAttempt,\n            retries: this.maxRetries,\n            randomize: true,\n            // If needed we can change some of the defaults here,\n            // but they're quite sensible.\n        }), { throwOnTimeout: true });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callWithOptions(options, callable, ...args) {\n        // Note this doesn't cancel the underlying request,\n        // when available prefer to use the signal option of the underlying call\n        if (options.signal) {\n            return Promise.race([\n                this.call(callable, ...args),\n                new Promise((_, reject) => {\n                    options.signal?.addEventListener(\"abort\", () => {\n                        reject(new Error(\"AbortError\"));\n                    });\n                }),\n            ]);\n        }\n        return this.call(callable, ...args);\n    }\n    fetch(...args) {\n        return this.call(() => fetch(...args).then((res) => (res.ok ? res : Promise.reject(res))));\n    }\n}\nexports.AsyncCaller = AsyncCaller;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQixrQ0FBa0MsbUJBQU8sQ0FBQyxzREFBUztBQUNuRCxrQ0FBa0MsbUJBQU8sQ0FBQywyREFBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtDQUFrQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQUssc0JBQXNCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9hc3luY19jYWxsZXIuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc3luY0NhbGxlciA9IHZvaWQgMDtcbmNvbnN0IHBfcmV0cnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicC1yZXRyeVwiKSk7XG5jb25zdCBwX3F1ZXVlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInAtcXVldWVcIikpO1xuY29uc3QgU1RBVFVTX05PX1JFVFJZID0gW1xuICAgIDQwMCwgLy8gQmFkIFJlcXVlc3RcbiAgICA0MDEsIC8vIFVuYXV0aG9yaXplZFxuICAgIDQwMiwgLy8gUGF5bWVudCBSZXF1aXJlZFxuICAgIDQwMywgLy8gRm9yYmlkZGVuXG4gICAgNDA0LCAvLyBOb3QgRm91bmRcbiAgICA0MDUsIC8vIE1ldGhvZCBOb3QgQWxsb3dlZFxuICAgIDQwNiwgLy8gTm90IEFjY2VwdGFibGVcbiAgICA0MDcsIC8vIFByb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkXG4gICAgNDA5LCAvLyBDb25mbGljdFxuXTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBkZWZhdWx0RmFpbGVkQXR0ZW1wdEhhbmRsZXIgPSAoZXJyb3IpID0+IHtcbiAgICBpZiAoZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiQ2FuY2VsXCIpIHx8XG4gICAgICAgIGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIkFib3J0RXJyb3JcIikgfHxcbiAgICAgICAgZXJyb3IubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgaWYgKGVycm9yPy5jb2RlID09PSBcIkVDT05OQUJPUlRFRFwiKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjb25zdCBzdGF0dXMgPSBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGVycm9yPy5yZXNwb25zZT8uc3RhdHVzID8/IGVycm9yPy5zdGF0dXM7XG4gICAgaWYgKHN0YXR1cyAmJiBTVEFUVVNfTk9fUkVUUlkuaW5jbHVkZXMoK3N0YXR1cykpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgaWYgKGVycm9yPy5lcnJvcj8uY29kZSA9PT0gXCJpbnN1ZmZpY2llbnRfcXVvdGFcIikge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoZXJyb3I/Lm1lc3NhZ2UpO1xuICAgICAgICBlcnIubmFtZSA9IFwiSW5zdWZmaWNpZW50UXVvdGFFcnJvclwiO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufTtcbi8qKlxuICogQSBjbGFzcyB0aGF0IGNhbiBiZSB1c2VkIHRvIG1ha2UgYXN5bmMgY2FsbHMgd2l0aCBjb25jdXJyZW5jeSBhbmQgcmV0cnkgbG9naWMuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIG1ha2luZyBjYWxscyB0byBhbnkga2luZCBvZiBcImV4cGVuc2l2ZVwiIGV4dGVybmFsIHJlc291cmNlLFxuICogYmUgaXQgYmVjYXVzZSBpdCdzIHJhdGUtbGltaXRlZCwgc3ViamVjdCB0byBuZXR3b3JrIGlzc3VlcywgZXRjLlxuICpcbiAqIENvbmN1cnJlbnQgY2FsbHMgYXJlIGxpbWl0ZWQgYnkgdGhlIGBtYXhDb25jdXJyZW5jeWAgcGFyYW1ldGVyLCB3aGljaCBkZWZhdWx0c1xuICogdG8gYEluZmluaXR5YC4gVGhpcyBtZWFucyB0aGF0IGJ5IGRlZmF1bHQsIGFsbCBjYWxscyB3aWxsIGJlIG1hZGUgaW4gcGFyYWxsZWwuXG4gKlxuICogUmV0cmllcyBhcmUgbGltaXRlZCBieSB0aGUgYG1heFJldHJpZXNgIHBhcmFtZXRlciwgd2hpY2ggZGVmYXVsdHMgdG8gNi4gVGhpc1xuICogbWVhbnMgdGhhdCBieSBkZWZhdWx0LCBlYWNoIGNhbGwgd2lsbCBiZSByZXRyaWVkIHVwIHRvIDYgdGltZXMsIHdpdGggYW5cbiAqIGV4cG9uZW50aWFsIGJhY2tvZmYgYmV0d2VlbiBlYWNoIGF0dGVtcHQuXG4gKi9cbmNsYXNzIEFzeW5jQ2FsbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4Q29uY3VycmVuY3lcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4UmV0cmllc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkZhaWxlZEF0dGVtcHRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicXVldWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXhDb25jdXJyZW5jeSA9IHBhcmFtcy5tYXhDb25jdXJyZW5jeSA/PyBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5tYXhSZXRyaWVzID0gcGFyYW1zLm1heFJldHJpZXMgPz8gNjtcbiAgICAgICAgdGhpcy5vbkZhaWxlZEF0dGVtcHQgPVxuICAgICAgICAgICAgcGFyYW1zLm9uRmFpbGVkQXR0ZW1wdCA/PyBkZWZhdWx0RmFpbGVkQXR0ZW1wdEhhbmRsZXI7XG4gICAgICAgIGNvbnN0IFBRdWV1ZSA9IChcImRlZmF1bHRcIiBpbiBwX3F1ZXVlXzEuZGVmYXVsdCA/IHBfcXVldWVfMS5kZWZhdWx0LmRlZmF1bHQgOiBwX3F1ZXVlXzEuZGVmYXVsdCk7XG4gICAgICAgIHRoaXMucXVldWUgPSBuZXcgUFF1ZXVlKHsgY29uY3VycmVuY3k6IHRoaXMubWF4Q29uY3VycmVuY3kgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY2FsbChjYWxsYWJsZSwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZS5hZGQoKCkgPT4gKDAsIHBfcmV0cnlfMS5kZWZhdWx0KSgoKSA9PiBjYWxsYWJsZSguLi5hcmdzKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwge1xuICAgICAgICAgICAgb25GYWlsZWRBdHRlbXB0OiB0aGlzLm9uRmFpbGVkQXR0ZW1wdCxcbiAgICAgICAgICAgIHJldHJpZXM6IHRoaXMubWF4UmV0cmllcyxcbiAgICAgICAgICAgIHJhbmRvbWl6ZTogdHJ1ZSxcbiAgICAgICAgICAgIC8vIElmIG5lZWRlZCB3ZSBjYW4gY2hhbmdlIHNvbWUgb2YgdGhlIGRlZmF1bHRzIGhlcmUsXG4gICAgICAgICAgICAvLyBidXQgdGhleSdyZSBxdWl0ZSBzZW5zaWJsZS5cbiAgICAgICAgfSksIHsgdGhyb3dPblRpbWVvdXQ6IHRydWUgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY2FsbFdpdGhPcHRpb25zKG9wdGlvbnMsIGNhbGxhYmxlLCAuLi5hcmdzKSB7XG4gICAgICAgIC8vIE5vdGUgdGhpcyBkb2Vzbid0IGNhbmNlbCB0aGUgdW5kZXJseWluZyByZXF1ZXN0LFxuICAgICAgICAvLyB3aGVuIGF2YWlsYWJsZSBwcmVmZXIgdG8gdXNlIHRoZSBzaWduYWwgb3B0aW9uIG9mIHRoZSB1bmRlcmx5aW5nIGNhbGxcbiAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGwoY2FsbGFibGUsIC4uLmFyZ3MpLFxuICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWw/LmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQWJvcnRFcnJvclwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbChjYWxsYWJsZSwgLi4uYXJncyk7XG4gICAgfVxuICAgIGZldGNoKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbCgoKSA9PiBmZXRjaCguLi5hcmdzKS50aGVuKChyZXMpID0+IChyZXMub2sgPyByZXMgOiBQcm9taXNlLnJlamVjdChyZXMpKSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQXN5bmNDYWxsZXIgPSBBc3luY0NhbGxlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/callbacks.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/callbacks.cjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isTracingEnabled = void 0;\nconst env_js_1 = __webpack_require__(/*! ./env.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/env.cjs\");\nconst isTracingEnabled = (tracingEnabled) => {\n    if (tracingEnabled !== undefined) {\n        return tracingEnabled;\n    }\n    const envVars = [\n        \"LANGSMITH_TRACING_V2\",\n        \"LANGCHAIN_TRACING_V2\",\n        \"LANGSMITH_TRACING\",\n        \"LANGCHAIN_TRACING\",\n    ];\n    return !!envVars.find((envVar) => (0, env_js_1.getEnvironmentVariable)(envVar) === \"true\");\n};\nexports.isTracingEnabled = isTracingEnabled;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvY2FsbGJhY2tzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsaUJBQWlCLG1CQUFPLENBQUMsMEVBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvY2FsbGJhY2tzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNUcmFjaW5nRW5hYmxlZCA9IHZvaWQgMDtcbmNvbnN0IGVudl9qc18xID0gcmVxdWlyZShcIi4vZW52LmNqc1wiKTtcbmNvbnN0IGlzVHJhY2luZ0VuYWJsZWQgPSAodHJhY2luZ0VuYWJsZWQpID0+IHtcbiAgICBpZiAodHJhY2luZ0VuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdHJhY2luZ0VuYWJsZWQ7XG4gICAgfVxuICAgIGNvbnN0IGVudlZhcnMgPSBbXG4gICAgICAgIFwiTEFOR1NNSVRIX1RSQUNJTkdfVjJcIixcbiAgICAgICAgXCJMQU5HQ0hBSU5fVFJBQ0lOR19WMlwiLFxuICAgICAgICBcIkxBTkdTTUlUSF9UUkFDSU5HXCIsXG4gICAgICAgIFwiTEFOR0NIQUlOX1RSQUNJTkdcIixcbiAgICBdO1xuICAgIHJldHVybiAhIWVudlZhcnMuZmluZCgoZW52VmFyKSA9PiAoMCwgZW52X2pzXzEuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSkoZW52VmFyKSA9PT0gXCJ0cnVlXCIpO1xufTtcbmV4cG9ydHMuaXNUcmFjaW5nRW5hYmxlZCA9IGlzVHJhY2luZ0VuYWJsZWQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/callbacks.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/chunk_array.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/chunk_array.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.chunkArray = void 0;\nconst chunkArray = (arr, chunkSize) => arr.reduce((chunks, elem, index) => {\n    const chunkIndex = Math.floor(index / chunkSize);\n    const chunk = chunks[chunkIndex] || [];\n    // eslint-disable-next-line no-param-reassign\n    chunks[chunkIndex] = chunk.concat([elem]);\n    return chunks;\n}, []);\nexports.chunkArray = chunkArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvY2h1bmtfYXJyYXkuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWtCIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvY2h1bmtfYXJyYXkuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jaHVua0FycmF5ID0gdm9pZCAwO1xuY29uc3QgY2h1bmtBcnJheSA9IChhcnIsIGNodW5rU2l6ZSkgPT4gYXJyLnJlZHVjZSgoY2h1bmtzLCBlbGVtLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGNodW5rSW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gY2h1bmtTaXplKTtcbiAgICBjb25zdCBjaHVuayA9IGNodW5rc1tjaHVua0luZGV4XSB8fCBbXTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBjaHVua3NbY2h1bmtJbmRleF0gPSBjaHVuay5jb25jYXQoW2VsZW1dKTtcbiAgICByZXR1cm4gY2h1bmtzO1xufSwgW10pO1xuZXhwb3J0cy5jaHVua0FycmF5ID0gY2h1bmtBcnJheTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/chunk_array.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/env.cjs":
/*!*********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/env.cjs ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getEnv = exports.isNode = exports.isDeno = exports.isJsDom = exports.isWebWorker = exports.isBrowser = void 0;\nexports.getRuntimeEnvironment = getRuntimeEnvironment;\nexports.getRuntimeEnvironmentSync = getRuntimeEnvironmentSync;\nexports.getEnvironmentVariable = getEnvironmentVariable;\nconst isBrowser = () => typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\nexports.isBrowser = isBrowser;\nconst isWebWorker = () => typeof globalThis === \"object\" &&\n    globalThis.constructor &&\n    globalThis.constructor.name === \"DedicatedWorkerGlobalScope\";\nexports.isWebWorker = isWebWorker;\nconst isJsDom = () => (typeof window !== \"undefined\" && window.name === \"nodejs\") ||\n    (typeof navigator !== \"undefined\" && navigator.userAgent.includes(\"jsdom\"));\nexports.isJsDom = isJsDom;\n// Supabase Edge Function provides a `Deno` global object\n// without `version` property\nconst isDeno = () => typeof Deno !== \"undefined\";\nexports.isDeno = isDeno;\n// Mark not-as-node if in Supabase Edge Function\nconst isNode = () => typeof process !== \"undefined\" &&\n    typeof process.versions !== \"undefined\" &&\n    typeof process.versions.node !== \"undefined\" &&\n    !(0, exports.isDeno)();\nexports.isNode = isNode;\nconst getEnv = () => {\n    let env;\n    if ((0, exports.isBrowser)()) {\n        env = \"browser\";\n    }\n    else if ((0, exports.isNode)()) {\n        env = \"node\";\n    }\n    else if ((0, exports.isWebWorker)()) {\n        env = \"webworker\";\n    }\n    else if ((0, exports.isJsDom)()) {\n        env = \"jsdom\";\n    }\n    else if ((0, exports.isDeno)()) {\n        env = \"deno\";\n    }\n    else {\n        env = \"other\";\n    }\n    return env;\n};\nexports.getEnv = getEnv;\nlet runtimeEnvironment;\n/**\n * @deprecated Use getRuntimeEnvironmentSync instead\n */\nasync function getRuntimeEnvironment() {\n    return getRuntimeEnvironmentSync();\n}\nfunction getRuntimeEnvironmentSync() {\n    if (runtimeEnvironment === undefined) {\n        const env = (0, exports.getEnv)();\n        runtimeEnvironment = {\n            library: \"langchain-js\",\n            runtime: env,\n        };\n    }\n    return runtimeEnvironment;\n}\nfunction getEnvironmentVariable(name) {\n    // Certain Deno setups will throw an error if you try to access environment variables\n    // https://github.com/langchain-ai/langchainjs/issues/1412\n    try {\n        if (typeof process !== \"undefined\") {\n            // eslint-disable-next-line no-process-env\n            return process.env?.[name];\n        }\n        else if ((0, exports.isDeno)()) {\n            return Deno?.env.get(name);\n        }\n        else {\n            return undefined;\n        }\n    }\n    catch (e) {\n        return undefined;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZW52LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxlQUFlLEdBQUcsbUJBQW1CLEdBQUcsaUJBQWlCO0FBQzVHLDZCQUE2QjtBQUM3QixpQ0FBaUM7QUFDakMsOEJBQThCO0FBQzlCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2Vudi5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEVudiA9IGV4cG9ydHMuaXNOb2RlID0gZXhwb3J0cy5pc0Rlbm8gPSBleHBvcnRzLmlzSnNEb20gPSBleHBvcnRzLmlzV2ViV29ya2VyID0gZXhwb3J0cy5pc0Jyb3dzZXIgPSB2b2lkIDA7XG5leHBvcnRzLmdldFJ1bnRpbWVFbnZpcm9ubWVudCA9IGdldFJ1bnRpbWVFbnZpcm9ubWVudDtcbmV4cG9ydHMuZ2V0UnVudGltZUVudmlyb25tZW50U3luYyA9IGdldFJ1bnRpbWVFbnZpcm9ubWVudFN5bmM7XG5leHBvcnRzLmdldEVudmlyb25tZW50VmFyaWFibGUgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlO1xuY29uc3QgaXNCcm93c2VyID0gKCkgPT4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuZXhwb3J0cy5pc0Jyb3dzZXIgPSBpc0Jyb3dzZXI7XG5jb25zdCBpc1dlYldvcmtlciA9ICgpID0+IHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiICYmXG4gICAgZ2xvYmFsVGhpcy5jb25zdHJ1Y3RvciAmJlxuICAgIGdsb2JhbFRoaXMuY29uc3RydWN0b3IubmFtZSA9PT0gXCJEZWRpY2F0ZWRXb3JrZXJHbG9iYWxTY29wZVwiO1xuZXhwb3J0cy5pc1dlYldvcmtlciA9IGlzV2ViV29ya2VyO1xuY29uc3QgaXNKc0RvbSA9ICgpID0+ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5uYW1lID09PSBcIm5vZGVqc1wiKSB8fFxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoXCJqc2RvbVwiKSk7XG5leHBvcnRzLmlzSnNEb20gPSBpc0pzRG9tO1xuLy8gU3VwYWJhc2UgRWRnZSBGdW5jdGlvbiBwcm92aWRlcyBhIGBEZW5vYCBnbG9iYWwgb2JqZWN0XG4vLyB3aXRob3V0IGB2ZXJzaW9uYCBwcm9wZXJ0eVxuY29uc3QgaXNEZW5vID0gKCkgPT4gdHlwZW9mIERlbm8gIT09IFwidW5kZWZpbmVkXCI7XG5leHBvcnRzLmlzRGVubyA9IGlzRGVubztcbi8vIE1hcmsgbm90LWFzLW5vZGUgaWYgaW4gU3VwYWJhc2UgRWRnZSBGdW5jdGlvblxuY29uc3QgaXNOb2RlID0gKCkgPT4gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAhKDAsIGV4cG9ydHMuaXNEZW5vKSgpO1xuZXhwb3J0cy5pc05vZGUgPSBpc05vZGU7XG5jb25zdCBnZXRFbnYgPSAoKSA9PiB7XG4gICAgbGV0IGVudjtcbiAgICBpZiAoKDAsIGV4cG9ydHMuaXNCcm93c2VyKSgpKSB7XG4gICAgICAgIGVudiA9IFwiYnJvd3NlclwiO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgZXhwb3J0cy5pc05vZGUpKCkpIHtcbiAgICAgICAgZW52ID0gXCJub2RlXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCBleHBvcnRzLmlzV2ViV29ya2VyKSgpKSB7XG4gICAgICAgIGVudiA9IFwid2Vid29ya2VyXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCBleHBvcnRzLmlzSnNEb20pKCkpIHtcbiAgICAgICAgZW52ID0gXCJqc2RvbVwiO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgZXhwb3J0cy5pc0Rlbm8pKCkpIHtcbiAgICAgICAgZW52ID0gXCJkZW5vXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbnYgPSBcIm90aGVyXCI7XG4gICAgfVxuICAgIHJldHVybiBlbnY7XG59O1xuZXhwb3J0cy5nZXRFbnYgPSBnZXRFbnY7XG5sZXQgcnVudGltZUVudmlyb25tZW50O1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgZ2V0UnVudGltZUVudmlyb25tZW50U3luYyBpbnN0ZWFkXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFJ1bnRpbWVFbnZpcm9ubWVudCgpIHtcbiAgICByZXR1cm4gZ2V0UnVudGltZUVudmlyb25tZW50U3luYygpO1xufVxuZnVuY3Rpb24gZ2V0UnVudGltZUVudmlyb25tZW50U3luYygpIHtcbiAgICBpZiAocnVudGltZUVudmlyb25tZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZW52ID0gKDAsIGV4cG9ydHMuZ2V0RW52KSgpO1xuICAgICAgICBydW50aW1lRW52aXJvbm1lbnQgPSB7XG4gICAgICAgICAgICBsaWJyYXJ5OiBcImxhbmdjaGFpbi1qc1wiLFxuICAgICAgICAgICAgcnVudGltZTogZW52LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcnVudGltZUVudmlyb25tZW50O1xufVxuZnVuY3Rpb24gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShuYW1lKSB7XG4gICAgLy8gQ2VydGFpbiBEZW5vIHNldHVwcyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHlvdSB0cnkgdG8gYWNjZXNzIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9sYW5nY2hhaW4tYWkvbGFuZ2NoYWluanMvaXNzdWVzLzE0MTJcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9jZXNzLWVudlxuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3MuZW52Py5bbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKDAsIGV4cG9ydHMuaXNEZW5vKSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gRGVubz8uZW52LmdldChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/env.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/event_source_parse.cjs":
/*!************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/event_source_parse.cjs ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EventStreamContentType = void 0;\nexports.getBytes = getBytes;\nexports.getLines = getLines;\nexports.getMessages = getMessages;\nexports.convertEventStreamToIterableReadableDataStream = convertEventStreamToIterableReadableDataStream;\n/* eslint-disable prefer-template */\n/* eslint-disable default-case */\n/* eslint-disable no-plusplus */\n// Adapted from https://github.com/gfortaine/fetch-event-source/blob/main/src/parse.ts\n// due to a packaging issue in the original.\n// MIT License\nconst stream_js_1 = __webpack_require__(/*! ./stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\nexports.EventStreamContentType = \"text/event-stream\";\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nasync function getBytes(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nstream, onChunk) {\n    // TODO: Use Async iteration for both cases?\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (stream instanceof ReadableStream) {\n        const reader = stream.getReader();\n        // CHANGED: Introduced a \"flush\" mechanism to process potential pending messages when the stream ends.\n        //          This change is essential to ensure that we capture every last piece of information from streams,\n        //          such as those from Azure OpenAI, which may not terminate with a blank line. Without this\n        //          mechanism, we risk ignoring a possibly significant last message.\n        //          See https://github.com/langchain-ai/langchainjs/issues/1299 for details.\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const result = await reader.read();\n            if (result.done) {\n                onChunk(new Uint8Array(), true);\n                break;\n            }\n            onChunk(result.value);\n        }\n    }\n    else {\n        try {\n            // Handle Node.js Readable streams with async iteration\n            for await (const chunk of stream) {\n                onChunk(new Uint8Array(chunk));\n            }\n            onChunk(new Uint8Array(), true);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            throw new Error([\n                \"Parsing event source stream failed.\",\n                \"Ensure your implementation of fetch returns a web or Node readable stream.\",\n                `Error: ${e.message}`,\n            ].join(\"\\n\"));\n        }\n    }\n}\n/**\n * Parses arbitary byte chunks into EventSource line buffers.\n * Each line should be of the format \"field: value\" and ends with \\r, \\n, or \\r\\n.\n * @param onLine A function that will be called on each new EventSource line.\n * @returns A function that should be called for each incoming byte chunk.\n */\nfunction getLines(onLine) {\n    let buffer;\n    let position; // current read position\n    let fieldLength; // length of the `field` portion of the line\n    let discardTrailingNewline = false;\n    // return a function that can process each incoming byte chunk:\n    return function onChunk(arr, flush) {\n        if (flush) {\n            onLine(arr, 0, true);\n            return;\n        }\n        if (buffer === undefined) {\n            buffer = arr;\n            position = 0;\n            fieldLength = -1;\n        }\n        else {\n            // we're still parsing the old line. Append the new bytes into buffer:\n            buffer = concat(buffer, arr);\n        }\n        const bufLength = buffer.length;\n        let lineStart = 0; // index where the current line starts\n        while (position < bufLength) {\n            if (discardTrailingNewline) {\n                if (buffer[position] === 10 /* ControlChars.NewLine */) {\n                    lineStart = ++position; // skip to next char\n                }\n                discardTrailingNewline = false;\n            }\n            // start looking forward till the end of line:\n            let lineEnd = -1; // index of the \\r or \\n char\n            for (; position < bufLength && lineEnd === -1; ++position) {\n                switch (buffer[position]) {\n                    case 58 /* ControlChars.Colon */:\n                        if (fieldLength === -1) {\n                            // first colon in line\n                            fieldLength = position - lineStart;\n                        }\n                        break;\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n                    case 13 /* ControlChars.CarriageReturn */:\n                        discardTrailingNewline = true;\n                    // eslint-disable-next-line no-fallthrough\n                    case 10 /* ControlChars.NewLine */:\n                        lineEnd = position;\n                        break;\n                }\n            }\n            if (lineEnd === -1) {\n                // We reached the end of the buffer but the line hasn't ended.\n                // Wait for the next arr and then continue parsing:\n                break;\n            }\n            // we've reached the line end, send it out:\n            onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n            lineStart = position; // we're now on the next line\n            fieldLength = -1;\n        }\n        if (lineStart === bufLength) {\n            buffer = undefined; // we've finished reading it\n        }\n        else if (lineStart !== 0) {\n            // Create a new view into buffer beginning at lineStart so we don't\n            // need to copy over the previous lines when we get the new arr:\n            buffer = buffer.subarray(lineStart);\n            position -= lineStart;\n        }\n    };\n}\n/**\n * Parses line buffers into EventSourceMessages.\n * @param onId A function that will be called on each `id` field.\n * @param onRetry A function that will be called on each `retry` field.\n * @param onMessage A function that will be called on each message.\n * @returns A function that should be called for each incoming line buffer.\n */\nfunction getMessages(onMessage, onId, onRetry) {\n    let message = newMessage();\n    const decoder = new TextDecoder();\n    // return a function that can process each incoming line buffer:\n    return function onLine(line, fieldLength, flush) {\n        if (flush) {\n            if (!isEmpty(message)) {\n                onMessage?.(message);\n                message = newMessage();\n            }\n            return;\n        }\n        if (line.length === 0) {\n            // empty line denotes end of message. Trigger the callback and start a new message:\n            onMessage?.(message);\n            message = newMessage();\n        }\n        else if (fieldLength > 0) {\n            // exclude comments and lines with no values\n            // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n            // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n            const field = decoder.decode(line.subarray(0, fieldLength));\n            const valueOffset = fieldLength + (line[fieldLength + 1] === 32 /* ControlChars.Space */ ? 2 : 1);\n            const value = decoder.decode(line.subarray(valueOffset));\n            switch (field) {\n                case \"data\":\n                    // if this message already has data, append the new value to the old.\n                    // otherwise, just set to the new value:\n                    message.data = message.data ? message.data + \"\\n\" + value : value; // otherwise,\n                    break;\n                case \"event\":\n                    message.event = value;\n                    break;\n                case \"id\":\n                    onId?.((message.id = value));\n                    break;\n                case \"retry\": {\n                    const retry = parseInt(value, 10);\n                    if (!Number.isNaN(retry)) {\n                        // per spec, ignore non-integers\n                        onRetry?.((message.retry = retry));\n                    }\n                    break;\n                }\n            }\n        }\n    };\n}\nfunction concat(a, b) {\n    const res = new Uint8Array(a.length + b.length);\n    res.set(a);\n    res.set(b, a.length);\n    return res;\n}\nfunction newMessage() {\n    // data, event, and id must be initialized to empty strings:\n    // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n    // retry should be initialized to undefined so we return a consistent shape\n    // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n    return {\n        data: \"\",\n        event: \"\",\n        id: \"\",\n        retry: undefined,\n    };\n}\nfunction convertEventStreamToIterableReadableDataStream(stream, onMetadataEvent) {\n    const dataStream = new ReadableStream({\n        async start(controller) {\n            const enqueueLine = getMessages((msg) => {\n                if (msg.event === \"error\") {\n                    throw new Error(msg.data ?? \"Unspecified event streaming error.\");\n                }\n                else if (msg.event === \"metadata\") {\n                    onMetadataEvent?.(msg);\n                }\n                else {\n                    if (msg.data)\n                        controller.enqueue(msg.data);\n                }\n            });\n            const onLine = (line, fieldLength, flush) => {\n                enqueueLine(line, fieldLength, flush);\n                if (flush)\n                    controller.close();\n            };\n            await getBytes(stream, getLines(onLine));\n        },\n    });\n    return stream_js_1.IterableReadableStream.fromReadableStream(dataStream);\n}\nfunction isEmpty(message) {\n    return (message.data === \"\" &&\n        message.event === \"\" &&\n        message.id === \"\" &&\n        message.retry === undefined);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZXZlbnRfc291cmNlX3BhcnNlLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEI7QUFDOUIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixtQkFBbUI7QUFDbkIsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLGdGQUFjO0FBQzFDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLG1CQUFtQix3Q0FBd0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9ldmVudF9zb3VyY2VfcGFyc2UuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FdmVudFN0cmVhbUNvbnRlbnRUeXBlID0gdm9pZCAwO1xuZXhwb3J0cy5nZXRCeXRlcyA9IGdldEJ5dGVzO1xuZXhwb3J0cy5nZXRMaW5lcyA9IGdldExpbmVzO1xuZXhwb3J0cy5nZXRNZXNzYWdlcyA9IGdldE1lc3NhZ2VzO1xuZXhwb3J0cy5jb252ZXJ0RXZlbnRTdHJlYW1Ub0l0ZXJhYmxlUmVhZGFibGVEYXRhU3RyZWFtID0gY29udmVydEV2ZW50U3RyZWFtVG9JdGVyYWJsZVJlYWRhYmxlRGF0YVN0cmVhbTtcbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci10ZW1wbGF0ZSAqL1xuLyogZXNsaW50LWRpc2FibGUgZGVmYXVsdC1jYXNlICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wbHVzcGx1cyAqL1xuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9nZm9ydGFpbmUvZmV0Y2gtZXZlbnQtc291cmNlL2Jsb2IvbWFpbi9zcmMvcGFyc2UudHNcbi8vIGR1ZSB0byBhIHBhY2thZ2luZyBpc3N1ZSBpbiB0aGUgb3JpZ2luYWwuXG4vLyBNSVQgTGljZW5zZVxuY29uc3Qgc3RyZWFtX2pzXzEgPSByZXF1aXJlKFwiLi9zdHJlYW0uY2pzXCIpO1xuZXhwb3J0cy5FdmVudFN0cmVhbUNvbnRlbnRUeXBlID0gXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiO1xuLyoqXG4gKiBDb252ZXJ0cyBhIFJlYWRhYmxlU3RyZWFtIGludG8gYSBjYWxsYmFjayBwYXR0ZXJuLlxuICogQHBhcmFtIHN0cmVhbSBUaGUgaW5wdXQgUmVhZGFibGVTdHJlYW0uXG4gKiBAcGFyYW0gb25DaHVuayBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgb24gZWFjaCBuZXcgYnl0ZSBjaHVuayBpbiB0aGUgc3RyZWFtLlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2hlbiB0aGUgc3RyZWFtIGNsb3Nlcy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0Qnl0ZXMoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuc3RyZWFtLCBvbkNodW5rKSB7XG4gICAgLy8gVE9ETzogVXNlIEFzeW5jIGl0ZXJhdGlvbiBmb3IgYm90aCBjYXNlcz9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgICAgLy8gQ0hBTkdFRDogSW50cm9kdWNlZCBhIFwiZmx1c2hcIiBtZWNoYW5pc20gdG8gcHJvY2VzcyBwb3RlbnRpYWwgcGVuZGluZyBtZXNzYWdlcyB3aGVuIHRoZSBzdHJlYW0gZW5kcy5cbiAgICAgICAgLy8gICAgICAgICAgVGhpcyBjaGFuZ2UgaXMgZXNzZW50aWFsIHRvIGVuc3VyZSB0aGF0IHdlIGNhcHR1cmUgZXZlcnkgbGFzdCBwaWVjZSBvZiBpbmZvcm1hdGlvbiBmcm9tIHN0cmVhbXMsXG4gICAgICAgIC8vICAgICAgICAgIHN1Y2ggYXMgdGhvc2UgZnJvbSBBenVyZSBPcGVuQUksIHdoaWNoIG1heSBub3QgdGVybWluYXRlIHdpdGggYSBibGFuayBsaW5lLiBXaXRob3V0IHRoaXNcbiAgICAgICAgLy8gICAgICAgICAgbWVjaGFuaXNtLCB3ZSByaXNrIGlnbm9yaW5nIGEgcG9zc2libHkgc2lnbmlmaWNhbnQgbGFzdCBtZXNzYWdlLlxuICAgICAgICAvLyAgICAgICAgICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2xhbmdjaGFpbi1haS9sYW5nY2hhaW5qcy9pc3N1ZXMvMTI5OSBmb3IgZGV0YWlscy5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgIG9uQ2h1bmsobmV3IFVpbnQ4QXJyYXkoKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbkNodW5rKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgTm9kZS5qcyBSZWFkYWJsZSBzdHJlYW1zIHdpdGggYXN5bmMgaXRlcmF0aW9uXG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIG9uQ2h1bmsobmV3IFVpbnQ4QXJyYXkoY2h1bmspKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uQ2h1bmsobmV3IFVpbnQ4QXJyYXkoKSwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoW1xuICAgICAgICAgICAgICAgIFwiUGFyc2luZyBldmVudCBzb3VyY2Ugc3RyZWFtIGZhaWxlZC5cIixcbiAgICAgICAgICAgICAgICBcIkVuc3VyZSB5b3VyIGltcGxlbWVudGF0aW9uIG9mIGZldGNoIHJldHVybnMgYSB3ZWIgb3IgTm9kZSByZWFkYWJsZSBzdHJlYW0uXCIsXG4gICAgICAgICAgICAgICAgYEVycm9yOiAke2UubWVzc2FnZX1gLFxuICAgICAgICAgICAgXS5qb2luKFwiXFxuXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogUGFyc2VzIGFyYml0YXJ5IGJ5dGUgY2h1bmtzIGludG8gRXZlbnRTb3VyY2UgbGluZSBidWZmZXJzLlxuICogRWFjaCBsaW5lIHNob3VsZCBiZSBvZiB0aGUgZm9ybWF0IFwiZmllbGQ6IHZhbHVlXCIgYW5kIGVuZHMgd2l0aCBcXHIsIFxcbiwgb3IgXFxyXFxuLlxuICogQHBhcmFtIG9uTGluZSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgb24gZWFjaCBuZXcgRXZlbnRTb3VyY2UgbGluZS5cbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkIGZvciBlYWNoIGluY29taW5nIGJ5dGUgY2h1bmsuXG4gKi9cbmZ1bmN0aW9uIGdldExpbmVzKG9uTGluZSkge1xuICAgIGxldCBidWZmZXI7XG4gICAgbGV0IHBvc2l0aW9uOyAvLyBjdXJyZW50IHJlYWQgcG9zaXRpb25cbiAgICBsZXQgZmllbGRMZW5ndGg7IC8vIGxlbmd0aCBvZiB0aGUgYGZpZWxkYCBwb3J0aW9uIG9mIHRoZSBsaW5lXG4gICAgbGV0IGRpc2NhcmRUcmFpbGluZ05ld2xpbmUgPSBmYWxzZTtcbiAgICAvLyByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGNhbiBwcm9jZXNzIGVhY2ggaW5jb21pbmcgYnl0ZSBjaHVuazpcbiAgICByZXR1cm4gZnVuY3Rpb24gb25DaHVuayhhcnIsIGZsdXNoKSB7XG4gICAgICAgIGlmIChmbHVzaCkge1xuICAgICAgICAgICAgb25MaW5lKGFyciwgMCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBidWZmZXIgPSBhcnI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICBmaWVsZExlbmd0aCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gd2UncmUgc3RpbGwgcGFyc2luZyB0aGUgb2xkIGxpbmUuIEFwcGVuZCB0aGUgbmV3IGJ5dGVzIGludG8gYnVmZmVyOlxuICAgICAgICAgICAgYnVmZmVyID0gY29uY2F0KGJ1ZmZlciwgYXJyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZMZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICBsZXQgbGluZVN0YXJ0ID0gMDsgLy8gaW5kZXggd2hlcmUgdGhlIGN1cnJlbnQgbGluZSBzdGFydHNcbiAgICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgYnVmTGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoZGlzY2FyZFRyYWlsaW5nTmV3bGluZSkge1xuICAgICAgICAgICAgICAgIGlmIChidWZmZXJbcG9zaXRpb25dID09PSAxMCAvKiBDb250cm9sQ2hhcnMuTmV3TGluZSAqLykge1xuICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSArK3Bvc2l0aW9uOyAvLyBza2lwIHRvIG5leHQgY2hhclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNjYXJkVHJhaWxpbmdOZXdsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdGFydCBsb29raW5nIGZvcndhcmQgdGlsbCB0aGUgZW5kIG9mIGxpbmU6XG4gICAgICAgICAgICBsZXQgbGluZUVuZCA9IC0xOyAvLyBpbmRleCBvZiB0aGUgXFxyIG9yIFxcbiBjaGFyXG4gICAgICAgICAgICBmb3IgKDsgcG9zaXRpb24gPCBidWZMZW5ndGggJiYgbGluZUVuZCA9PT0gLTE7ICsrcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGJ1ZmZlcltwb3NpdGlvbl0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OCAvKiBDb250cm9sQ2hhcnMuQ29sb24gKi86XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRMZW5ndGggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlyc3QgY29sb24gaW4gbGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkTGVuZ3RoID0gcG9zaXRpb24gLSBsaW5lU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlOjcwMjkgXFxyIGNhc2UgYmVsb3cgc2hvdWxkIGZhbGx0aHJvdWdoIHRvIFxcbjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMyAvKiBDb250cm9sQ2hhcnMuQ2FycmlhZ2VSZXR1cm4gKi86XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNjYXJkVHJhaWxpbmdOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTAgLyogQ29udHJvbENoYXJzLk5ld0xpbmUgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lRW5kID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGluZUVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBidXQgdGhlIGxpbmUgaGFzbid0IGVuZGVkLlxuICAgICAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSBuZXh0IGFyciBhbmQgdGhlbiBjb250aW51ZSBwYXJzaW5nOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2UndmUgcmVhY2hlZCB0aGUgbGluZSBlbmQsIHNlbmQgaXQgb3V0OlxuICAgICAgICAgICAgb25MaW5lKGJ1ZmZlci5zdWJhcnJheShsaW5lU3RhcnQsIGxpbmVFbmQpLCBmaWVsZExlbmd0aCk7XG4gICAgICAgICAgICBsaW5lU3RhcnQgPSBwb3NpdGlvbjsgLy8gd2UncmUgbm93IG9uIHRoZSBuZXh0IGxpbmVcbiAgICAgICAgICAgIGZpZWxkTGVuZ3RoID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVTdGFydCA9PT0gYnVmTGVuZ3RoKSB7XG4gICAgICAgICAgICBidWZmZXIgPSB1bmRlZmluZWQ7IC8vIHdlJ3ZlIGZpbmlzaGVkIHJlYWRpbmcgaXRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsaW5lU3RhcnQgIT09IDApIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyB2aWV3IGludG8gYnVmZmVyIGJlZ2lubmluZyBhdCBsaW5lU3RhcnQgc28gd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gY29weSBvdmVyIHRoZSBwcmV2aW91cyBsaW5lcyB3aGVuIHdlIGdldCB0aGUgbmV3IGFycjpcbiAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zdWJhcnJheShsaW5lU3RhcnQpO1xuICAgICAgICAgICAgcG9zaXRpb24gLT0gbGluZVN0YXJ0O1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogUGFyc2VzIGxpbmUgYnVmZmVycyBpbnRvIEV2ZW50U291cmNlTWVzc2FnZXMuXG4gKiBAcGFyYW0gb25JZCBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgb24gZWFjaCBgaWRgIGZpZWxkLlxuICogQHBhcmFtIG9uUmV0cnkgQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uIGVhY2ggYHJldHJ5YCBmaWVsZC5cbiAqIEBwYXJhbSBvbk1lc3NhZ2UgQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uIGVhY2ggbWVzc2FnZS5cbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkIGZvciBlYWNoIGluY29taW5nIGxpbmUgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBnZXRNZXNzYWdlcyhvbk1lc3NhZ2UsIG9uSWQsIG9uUmV0cnkpIHtcbiAgICBsZXQgbWVzc2FnZSA9IG5ld01lc3NhZ2UoKTtcbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgLy8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBjYW4gcHJvY2VzcyBlYWNoIGluY29taW5nIGxpbmUgYnVmZmVyOlxuICAgIHJldHVybiBmdW5jdGlvbiBvbkxpbmUobGluZSwgZmllbGRMZW5ndGgsIGZsdXNoKSB7XG4gICAgICAgIGlmIChmbHVzaCkge1xuICAgICAgICAgICAgaWYgKCFpc0VtcHR5KG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgb25NZXNzYWdlPy4obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IG5ld01lc3NhZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIGVtcHR5IGxpbmUgZGVub3RlcyBlbmQgb2YgbWVzc2FnZS4gVHJpZ2dlciB0aGUgY2FsbGJhY2sgYW5kIHN0YXJ0IGEgbmV3IG1lc3NhZ2U6XG4gICAgICAgICAgICBvbk1lc3NhZ2U/LihtZXNzYWdlKTtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBuZXdNZXNzYWdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmllbGRMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBleGNsdWRlIGNvbW1lbnRzIGFuZCBsaW5lcyB3aXRoIG5vIHZhbHVlc1xuICAgICAgICAgICAgLy8gbGluZSBpcyBvZiBmb3JtYXQgXCI8ZmllbGQ+Ojx2YWx1ZT5cIiBvciBcIjxmaWVsZD46IDx2YWx1ZT5cIlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VydmVyLXNlbnQtZXZlbnRzLmh0bWwjZXZlbnQtc3RyZWFtLWludGVycHJldGF0aW9uXG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGRlY29kZXIuZGVjb2RlKGxpbmUuc3ViYXJyYXkoMCwgZmllbGRMZW5ndGgpKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlT2Zmc2V0ID0gZmllbGRMZW5ndGggKyAobGluZVtmaWVsZExlbmd0aCArIDFdID09PSAzMiAvKiBDb250cm9sQ2hhcnMuU3BhY2UgKi8gPyAyIDogMSk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRlY29kZXIuZGVjb2RlKGxpbmUuc3ViYXJyYXkodmFsdWVPZmZzZXQpKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGF0YVwiOlxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIG1lc3NhZ2UgYWxyZWFkeSBoYXMgZGF0YSwgYXBwZW5kIHRoZSBuZXcgdmFsdWUgdG8gdGhlIG9sZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBqdXN0IHNldCB0byB0aGUgbmV3IHZhbHVlOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGEgPSBtZXNzYWdlLmRhdGEgPyBtZXNzYWdlLmRhdGEgKyBcIlxcblwiICsgdmFsdWUgOiB2YWx1ZTsgLy8gb3RoZXJ3aXNlLFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ldmVudCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiaWRcIjpcbiAgICAgICAgICAgICAgICAgICAgb25JZD8uKChtZXNzYWdlLmlkID0gdmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJldHJ5XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0cnkgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc05hTihyZXRyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBlciBzcGVjLCBpZ25vcmUgbm9uLWludGVnZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICBvblJldHJ5Py4oKG1lc3NhZ2UucmV0cnkgPSByZXRyeSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjb25jYXQoYSwgYikge1xuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoICsgYi5sZW5ndGgpO1xuICAgIHJlcy5zZXQoYSk7XG4gICAgcmVzLnNldChiLCBhLmxlbmd0aCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIG5ld01lc3NhZ2UoKSB7XG4gICAgLy8gZGF0YSwgZXZlbnQsIGFuZCBpZCBtdXN0IGJlIGluaXRpYWxpemVkIHRvIGVtcHR5IHN0cmluZ3M6XG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VydmVyLXNlbnQtZXZlbnRzLmh0bWwjZXZlbnQtc3RyZWFtLWludGVycHJldGF0aW9uXG4gICAgLy8gcmV0cnkgc2hvdWxkIGJlIGluaXRpYWxpemVkIHRvIHVuZGVmaW5lZCBzbyB3ZSByZXR1cm4gYSBjb25zaXN0ZW50IHNoYXBlXG4gICAgLy8gdG8gdGhlIGpzIGVuZ2luZSBhbGwgdGhlIHRpbWU6IGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9zaGFwZXMtaWNzI3Rha2Vhd2F5c1xuICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IFwiXCIsXG4gICAgICAgIGV2ZW50OiBcIlwiLFxuICAgICAgICBpZDogXCJcIixcbiAgICAgICAgcmV0cnk6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29udmVydEV2ZW50U3RyZWFtVG9JdGVyYWJsZVJlYWRhYmxlRGF0YVN0cmVhbShzdHJlYW0sIG9uTWV0YWRhdGFFdmVudCkge1xuICAgIGNvbnN0IGRhdGFTdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb25zdCBlbnF1ZXVlTGluZSA9IGdldE1lc3NhZ2VzKChtc2cpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobXNnLmV2ZW50ID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZy5kYXRhID8/IFwiVW5zcGVjaWZpZWQgZXZlbnQgc3RyZWFtaW5nIGVycm9yLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobXNnLmV2ZW50ID09PSBcIm1ldGFkYXRhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb25NZXRhZGF0YUV2ZW50Py4obXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtc2cuZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShtc2cuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBvbkxpbmUgPSAobGluZSwgZmllbGRMZW5ndGgsIGZsdXNoKSA9PiB7XG4gICAgICAgICAgICAgICAgZW5xdWV1ZUxpbmUobGluZSwgZmllbGRMZW5ndGgsIGZsdXNoKTtcbiAgICAgICAgICAgICAgICBpZiAoZmx1c2gpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhd2FpdCBnZXRCeXRlcyhzdHJlYW0sIGdldExpbmVzKG9uTGluZSkpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBzdHJlYW1fanNfMS5JdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21SZWFkYWJsZVN0cmVhbShkYXRhU3RyZWFtKTtcbn1cbmZ1bmN0aW9uIGlzRW1wdHkobWVzc2FnZSkge1xuICAgIHJldHVybiAobWVzc2FnZS5kYXRhID09PSBcIlwiICYmXG4gICAgICAgIG1lc3NhZ2UuZXZlbnQgPT09IFwiXCIgJiZcbiAgICAgICAgbWVzc2FnZS5pZCA9PT0gXCJcIiAmJlxuICAgICAgICBtZXNzYWdlLnJldHJ5ID09PSB1bmRlZmluZWQpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/event_source_parse.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/index.cjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/fast-json-patch/index.cjs ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unescapePathComponent = exports.escapePathComponent = exports.deepClone = exports.JsonPatchError = void 0;\n__exportStar(__webpack_require__(/*! ./src/core.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./src/duplex.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.cjs\"), exports);\nvar helpers_js_1 = __webpack_require__(/*! ./src/helpers.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.cjs\");\nObject.defineProperty(exports, \"JsonPatchError\", ({ enumerable: true, get: function () { return helpers_js_1.PatchError; } }));\nObject.defineProperty(exports, \"deepClone\", ({ enumerable: true, get: function () { return helpers_js_1._deepClone; } }));\nObject.defineProperty(exports, \"escapePathComponent\", ({ enumerable: true, get: function () { return helpers_js_1.escapePathComponent; } }));\nObject.defineProperty(exports, \"unescapePathComponent\", ({ enumerable: true, get: function () { return helpers_js_1.unescapePathComponent; } }));\n/**\n * Default export for backwards compat\n */\nconst core = __importStar(__webpack_require__(/*! ./src/core.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.cjs\"));\nconst helpers_js_2 = __webpack_require__(/*! ./src/helpers.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.cjs\");\nexports[\"default\"] = {\n    ...core,\n    // ...duplex,\n    JsonPatchError: helpers_js_2.PatchError,\n    deepClone: helpers_js_2._deepClone,\n    escapePathComponent: helpers_js_2.escapePathComponent,\n    unescapePathComponent: helpers_js_2.unescapePathComponent,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZmFzdC1qc29uLXBhdGNoL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGNBQWM7QUFDekU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRywyQkFBMkIsR0FBRyxpQkFBaUIsR0FBRyxzQkFBc0I7QUFDeEcsYUFBYSxtQkFBTyxDQUFDLG9HQUFnQjtBQUNyQyxhQUFhLG1CQUFPLENBQUMsd0dBQWtCO0FBQ3ZDLG1CQUFtQixtQkFBTyxDQUFDLDBHQUFtQjtBQUM5QyxrREFBaUQsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDNUgsNkNBQTRDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQ3ZILHVEQUFzRCxFQUFFLHFDQUFxQyw0Q0FBNEMsRUFBQztBQUMxSSx5REFBd0QsRUFBRSxxQ0FBcUMsOENBQThDLEVBQUM7QUFDOUk7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsb0dBQWdCO0FBQ2xELHFCQUFxQixtQkFBTyxDQUFDLDBHQUFtQjtBQUNoRCxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZmFzdC1qc29uLXBhdGNoL2luZGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG93bktleXMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIG93bktleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgdmFyIGFyID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgICAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3duS2V5cyhvKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrID0gb3duS2V5cyhtb2QpLCBpID0gMDsgaSA8IGsubGVuZ3RoOyBpKyspIGlmIChrW2ldICE9PSBcImRlZmF1bHRcIikgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrW2ldKTtcbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudW5lc2NhcGVQYXRoQ29tcG9uZW50ID0gZXhwb3J0cy5lc2NhcGVQYXRoQ29tcG9uZW50ID0gZXhwb3J0cy5kZWVwQ2xvbmUgPSBleHBvcnRzLkpzb25QYXRjaEVycm9yID0gdm9pZCAwO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NyYy9jb3JlLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3JjL2R1cGxleC5janNcIiksIGV4cG9ydHMpO1xudmFyIGhlbHBlcnNfanNfMSA9IHJlcXVpcmUoXCIuL3NyYy9oZWxwZXJzLmNqc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkpzb25QYXRjaEVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoZWxwZXJzX2pzXzEuUGF0Y2hFcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZXBDbG9uZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGVscGVyc19qc18xLl9kZWVwQ2xvbmU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlc2NhcGVQYXRoQ29tcG9uZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoZWxwZXJzX2pzXzEuZXNjYXBlUGF0aENvbXBvbmVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVuZXNjYXBlUGF0aENvbXBvbmVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGVscGVyc19qc18xLnVuZXNjYXBlUGF0aENvbXBvbmVudDsgfSB9KTtcbi8qKlxuICogRGVmYXVsdCBleHBvcnQgZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAqL1xuY29uc3QgY29yZSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zcmMvY29yZS5janNcIikpO1xuY29uc3QgaGVscGVyc19qc18yID0gcmVxdWlyZShcIi4vc3JjL2hlbHBlcnMuY2pzXCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIC4uLmNvcmUsXG4gICAgLy8gLi4uZHVwbGV4LFxuICAgIEpzb25QYXRjaEVycm9yOiBoZWxwZXJzX2pzXzIuUGF0Y2hFcnJvcixcbiAgICBkZWVwQ2xvbmU6IGhlbHBlcnNfanNfMi5fZGVlcENsb25lLFxuICAgIGVzY2FwZVBhdGhDb21wb25lbnQ6IGhlbHBlcnNfanNfMi5lc2NhcGVQYXRoQ29tcG9uZW50LFxuICAgIHVuZXNjYXBlUGF0aENvbXBvbmVudDogaGVscGVyc19qc18yLnVuZXNjYXBlUGF0aENvbXBvbmVudCxcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.cjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.cjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// @ts-nocheck\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deepClone = exports.JsonPatchError = void 0;\nexports.getValueByPointer = getValueByPointer;\nexports.applyOperation = applyOperation;\nexports.applyPatch = applyPatch;\nexports.applyReducer = applyReducer;\nexports.validator = validator;\nexports.validate = validate;\nexports._areEquals = _areEquals;\nconst helpers_js_1 = __webpack_require__(/*! ./helpers.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.cjs\");\nexports.JsonPatchError = helpers_js_1.PatchError;\nexports.deepClone = helpers_js_1._deepClone;\n/* We use a Javascript hash to store each\n function. Each hash entry (property) uses\n the operation identifiers specified in rfc6902.\n In this way, we can map each patch operation\n to its dedicated function in efficient way.\n */\n/* The operations applicable to an object */\nconst objOps = {\n    add: function (obj, key, document) {\n        obj[key] = this.value;\n        return { newDocument: document };\n    },\n    remove: function (obj, key, document) {\n        var removed = obj[key];\n        delete obj[key];\n        return { newDocument: document, removed };\n    },\n    replace: function (obj, key, document) {\n        var removed = obj[key];\n        obj[key] = this.value;\n        return { newDocument: document, removed };\n    },\n    move: function (obj, key, document) {\n        /* in case move target overwrites an existing value,\n        return the removed value, this can be taxing performance-wise,\n        and is potentially unneeded */\n        let removed = getValueByPointer(document, this.path);\n        if (removed) {\n            removed = (0, helpers_js_1._deepClone)(removed);\n        }\n        const originalValue = applyOperation(document, {\n            op: \"remove\",\n            path: this.from,\n        }).removed;\n        applyOperation(document, {\n            op: \"add\",\n            path: this.path,\n            value: originalValue,\n        });\n        return { newDocument: document, removed };\n    },\n    copy: function (obj, key, document) {\n        const valueToCopy = getValueByPointer(document, this.from);\n        // enforce copy by value so further operations don't affect source (see issue #177)\n        applyOperation(document, {\n            op: \"add\",\n            path: this.path,\n            value: (0, helpers_js_1._deepClone)(valueToCopy),\n        });\n        return { newDocument: document };\n    },\n    test: function (obj, key, document) {\n        return { newDocument: document, test: _areEquals(obj[key], this.value) };\n    },\n    _get: function (obj, key, document) {\n        this.value = obj[key];\n        return { newDocument: document };\n    },\n};\n/* The operations applicable to an array. Many are the same as for the object */\nvar arrOps = {\n    add: function (arr, i, document) {\n        if ((0, helpers_js_1.isInteger)(i)) {\n            arr.splice(i, 0, this.value);\n        }\n        else {\n            // array props\n            arr[i] = this.value;\n        }\n        // this may be needed when using '-' in an array\n        return { newDocument: document, index: i };\n    },\n    remove: function (arr, i, document) {\n        var removedList = arr.splice(i, 1);\n        return { newDocument: document, removed: removedList[0] };\n    },\n    replace: function (arr, i, document) {\n        var removed = arr[i];\n        arr[i] = this.value;\n        return { newDocument: document, removed };\n    },\n    move: objOps.move,\n    copy: objOps.copy,\n    test: objOps.test,\n    _get: objOps._get,\n};\n/**\n * Retrieves a value from a JSON document by a JSON pointer.\n * Returns the value.\n *\n * @param document The document to get the value from\n * @param pointer an escaped JSON pointer\n * @return The retrieved value\n */\nfunction getValueByPointer(document, pointer) {\n    if (pointer == \"\") {\n        return document;\n    }\n    var getOriginalDestination = { op: \"_get\", path: pointer };\n    applyOperation(document, getOriginalDestination);\n    return getOriginalDestination.value;\n}\n/**\n * Apply a single JSON Patch Operation on a JSON document.\n * Returns the {newDocument, result} of the operation.\n * It modifies the `document` and `operation` objects - it gets the values by reference.\n * If you would like to avoid touching your values, clone them:\n * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.\n *\n * @param document The document to patch\n * @param operation The operation to apply\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\n * @param mutateDocument Whether to mutate the original document or clone it before applying\n * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.\n * @return `{newDocument, result}` after the operation\n */\nfunction applyOperation(document, operation, validateOperation = false, mutateDocument = true, banPrototypeModifications = true, index = 0) {\n    if (validateOperation) {\n        if (typeof validateOperation == \"function\") {\n            validateOperation(operation, 0, document, operation.path);\n        }\n        else {\n            validator(operation, 0);\n        }\n    }\n    /* ROOT OPERATIONS */\n    if (operation.path === \"\") {\n        let returnValue = { newDocument: document };\n        if (operation.op === \"add\") {\n            returnValue.newDocument = operation.value;\n            return returnValue;\n        }\n        else if (operation.op === \"replace\") {\n            returnValue.newDocument = operation.value;\n            returnValue.removed = document; //document we removed\n            return returnValue;\n        }\n        else if (operation.op === \"move\" || operation.op === \"copy\") {\n            // it's a move or copy to root\n            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field\n            if (operation.op === \"move\") {\n                // report removed item\n                returnValue.removed = document;\n            }\n            return returnValue;\n        }\n        else if (operation.op === \"test\") {\n            returnValue.test = _areEquals(document, operation.value);\n            if (returnValue.test === false) {\n                throw new exports.JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n            }\n            returnValue.newDocument = document;\n            return returnValue;\n        }\n        else if (operation.op === \"remove\") {\n            // a remove on root\n            returnValue.removed = document;\n            returnValue.newDocument = null;\n            return returnValue;\n        }\n        else if (operation.op === \"_get\") {\n            operation.value = document;\n            return returnValue;\n        }\n        else {\n            /* bad operation */\n            if (validateOperation) {\n                throw new exports.JsonPatchError(\"Operation `op` property is not one of operations defined in RFC-6902\", \"OPERATION_OP_INVALID\", index, operation, document);\n            }\n            else {\n                return returnValue;\n            }\n        }\n    } /* END ROOT OPERATIONS */\n    else {\n        if (!mutateDocument) {\n            document = (0, helpers_js_1._deepClone)(document);\n        }\n        const path = operation.path || \"\";\n        const keys = path.split(\"/\");\n        let obj = document;\n        let t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift\n        let len = keys.length;\n        let existingPathFragment = undefined;\n        let key;\n        let validateFunction;\n        if (typeof validateOperation == \"function\") {\n            validateFunction = validateOperation;\n        }\n        else {\n            validateFunction = validator;\n        }\n        while (true) {\n            key = keys[t];\n            if (key && key.indexOf(\"~\") != -1) {\n                key = (0, helpers_js_1.unescapePathComponent)(key);\n            }\n            if (banPrototypeModifications &&\n                (key == \"__proto__\" ||\n                    (key == \"prototype\" && t > 0 && keys[t - 1] == \"constructor\"))) {\n                throw new TypeError(\"JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README\");\n            }\n            if (validateOperation) {\n                if (existingPathFragment === undefined) {\n                    if (obj[key] === undefined) {\n                        existingPathFragment = keys.slice(0, t).join(\"/\");\n                    }\n                    else if (t == len - 1) {\n                        existingPathFragment = operation.path;\n                    }\n                    if (existingPathFragment !== undefined) {\n                        validateFunction(operation, 0, document, existingPathFragment);\n                    }\n                }\n            }\n            t++;\n            if (Array.isArray(obj)) {\n                if (key === \"-\") {\n                    key = obj.length;\n                }\n                else {\n                    if (validateOperation && !(0, helpers_js_1.isInteger)(key)) {\n                        throw new exports.JsonPatchError(\"Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index\", \"OPERATION_PATH_ILLEGAL_ARRAY_INDEX\", index, operation, document);\n                    } // only parse key when it's an integer for `arr.prop` to work\n                    else if ((0, helpers_js_1.isInteger)(key)) {\n                        key = ~~key;\n                    }\n                }\n                if (t >= len) {\n                    if (validateOperation && operation.op === \"add\" && key > obj.length) {\n                        throw new exports.JsonPatchError(\"The specified index MUST NOT be greater than the number of elements in the array\", \"OPERATION_VALUE_OUT_OF_BOUNDS\", index, operation, document);\n                    }\n                    const returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch\n                    if (returnValue.test === false) {\n                        throw new exports.JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n                    }\n                    return returnValue;\n                }\n            }\n            else {\n                if (t >= len) {\n                    const returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch\n                    if (returnValue.test === false) {\n                        throw new exports.JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n                    }\n                    return returnValue;\n                }\n            }\n            obj = obj[key];\n            // If we have more keys in the path, but the next value isn't a non-null object,\n            // throw an OPERATION_PATH_UNRESOLVABLE error instead of iterating again.\n            if (validateOperation && t < len && (!obj || typeof obj !== \"object\")) {\n                throw new exports.JsonPatchError(\"Cannot perform operation at the desired path\", \"OPERATION_PATH_UNRESOLVABLE\", index, operation, document);\n            }\n        }\n    }\n}\n/**\n * Apply a full JSON Patch array on a JSON document.\n * Returns the {newDocument, result} of the patch.\n * It modifies the `document` object and `patch` - it gets the values by reference.\n * If you would like to avoid touching your values, clone them:\n * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.\n *\n * @param document The document to patch\n * @param patch The patch to apply\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\n * @param mutateDocument Whether to mutate the original document or clone it before applying\n * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.\n * @return An array of `{newDocument, result}` after the patch\n */\nfunction applyPatch(document, patch, validateOperation, mutateDocument = true, banPrototypeModifications = true) {\n    if (validateOperation) {\n        if (!Array.isArray(patch)) {\n            throw new exports.JsonPatchError(\"Patch sequence must be an array\", \"SEQUENCE_NOT_AN_ARRAY\");\n        }\n    }\n    if (!mutateDocument) {\n        document = (0, helpers_js_1._deepClone)(document);\n    }\n    const results = new Array(patch.length);\n    for (let i = 0, length = patch.length; i < length; i++) {\n        // we don't need to pass mutateDocument argument because if it was true, we already deep cloned the object, we'll just pass `true`\n        results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);\n        document = results[i].newDocument; // in case root was replaced\n    }\n    results.newDocument = document;\n    return results;\n}\n/**\n * Apply a single JSON Patch Operation on a JSON document.\n * Returns the updated document.\n * Suitable as a reducer.\n *\n * @param document The document to patch\n * @param operation The operation to apply\n * @return The updated document\n */\nfunction applyReducer(document, operation, index) {\n    const operationResult = applyOperation(document, operation);\n    if (operationResult.test === false) {\n        // failed test\n        throw new exports.JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n    }\n    return operationResult.newDocument;\n}\n/**\n * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.\n * @param {object} operation - operation object (patch)\n * @param {number} index - index of operation in the sequence\n * @param {object} [document] - object where the operation is supposed to be applied\n * @param {string} [existingPathFragment] - comes along with `document`\n */\nfunction validator(operation, index, document, existingPathFragment) {\n    if (typeof operation !== \"object\" ||\n        operation === null ||\n        Array.isArray(operation)) {\n        throw new exports.JsonPatchError(\"Operation is not an object\", \"OPERATION_NOT_AN_OBJECT\", index, operation, document);\n    }\n    else if (!objOps[operation.op]) {\n        throw new exports.JsonPatchError(\"Operation `op` property is not one of operations defined in RFC-6902\", \"OPERATION_OP_INVALID\", index, operation, document);\n    }\n    else if (typeof operation.path !== \"string\") {\n        throw new exports.JsonPatchError(\"Operation `path` property is not a string\", \"OPERATION_PATH_INVALID\", index, operation, document);\n    }\n    else if (operation.path.indexOf(\"/\") !== 0 && operation.path.length > 0) {\n        // paths that aren't empty string should start with \"/\"\n        throw new exports.JsonPatchError('Operation `path` property must start with \"/\"', \"OPERATION_PATH_INVALID\", index, operation, document);\n    }\n    else if ((operation.op === \"move\" || operation.op === \"copy\") &&\n        typeof operation.from !== \"string\") {\n        throw new exports.JsonPatchError(\"Operation `from` property is not present (applicable in `move` and `copy` operations)\", \"OPERATION_FROM_REQUIRED\", index, operation, document);\n    }\n    else if ((operation.op === \"add\" ||\n        operation.op === \"replace\" ||\n        operation.op === \"test\") &&\n        operation.value === undefined) {\n        throw new exports.JsonPatchError(\"Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)\", \"OPERATION_VALUE_REQUIRED\", index, operation, document);\n    }\n    else if ((operation.op === \"add\" ||\n        operation.op === \"replace\" ||\n        operation.op === \"test\") &&\n        (0, helpers_js_1.hasUndefined)(operation.value)) {\n        throw new exports.JsonPatchError(\"Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)\", \"OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED\", index, operation, document);\n    }\n    else if (document) {\n        if (operation.op == \"add\") {\n            var pathLen = operation.path.split(\"/\").length;\n            var existingPathLen = existingPathFragment.split(\"/\").length;\n            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {\n                throw new exports.JsonPatchError(\"Cannot perform an `add` operation at the desired path\", \"OPERATION_PATH_CANNOT_ADD\", index, operation, document);\n            }\n        }\n        else if (operation.op === \"replace\" ||\n            operation.op === \"remove\" ||\n            operation.op === \"_get\") {\n            if (operation.path !== existingPathFragment) {\n                throw new exports.JsonPatchError(\"Cannot perform the operation at a path that does not exist\", \"OPERATION_PATH_UNRESOLVABLE\", index, operation, document);\n            }\n        }\n        else if (operation.op === \"move\" || operation.op === \"copy\") {\n            var existingValue = {\n                op: \"_get\",\n                path: operation.from,\n                value: undefined,\n            };\n            var error = validate([existingValue], document);\n            if (error && error.name === \"OPERATION_PATH_UNRESOLVABLE\") {\n                throw new exports.JsonPatchError(\"Cannot perform the operation from a path that does not exist\", \"OPERATION_FROM_UNRESOLVABLE\", index, operation, document);\n            }\n        }\n    }\n}\n/**\n * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.\n * If error is encountered, returns a JsonPatchError object\n * @param sequence\n * @param document\n * @returns {JsonPatchError|undefined}\n */\nfunction validate(sequence, document, externalValidator) {\n    try {\n        if (!Array.isArray(sequence)) {\n            throw new exports.JsonPatchError(\"Patch sequence must be an array\", \"SEQUENCE_NOT_AN_ARRAY\");\n        }\n        if (document) {\n            //clone document and sequence so that we can safely try applying operations\n            applyPatch((0, helpers_js_1._deepClone)(document), (0, helpers_js_1._deepClone)(sequence), externalValidator || true);\n        }\n        else {\n            externalValidator = externalValidator || validator;\n            for (var i = 0; i < sequence.length; i++) {\n                externalValidator(sequence[i], i, document, undefined);\n            }\n        }\n    }\n    catch (e) {\n        if (e instanceof exports.JsonPatchError) {\n            return e;\n        }\n        else {\n            throw e;\n        }\n    }\n}\n// based on https://github.com/epoberezkin/fast-deep-equal\n// MIT License\n// Copyright (c) 2017 Evgeny Poberezkin\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nfunction _areEquals(a, b) {\n    if (a === b)\n        return true;\n    if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n        var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;\n        if (arrA && arrB) {\n            length = a.length;\n            if (length != b.length)\n                return false;\n            for (i = length; i-- !== 0;)\n                if (!_areEquals(a[i], b[i]))\n                    return false;\n            return true;\n        }\n        if (arrA != arrB)\n            return false;\n        var keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length)\n            return false;\n        for (i = length; i-- !== 0;)\n            if (!b.hasOwnProperty(keys[i]))\n                return false;\n        for (i = length; i-- !== 0;) {\n            key = keys[i];\n            if (!_areEquals(a[key], b[key]))\n                return false;\n        }\n        return true;\n    }\n    return a !== a && b !== b;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZmFzdC1qc29uLXBhdGNoL3NyYy9jb3JlLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLHNCQUFzQjtBQUMxQyx5QkFBeUI7QUFDekIsc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQixvQkFBb0I7QUFDcEIsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQixrQkFBa0I7QUFDbEIscUJBQXFCLG1CQUFPLENBQUMsc0dBQWU7QUFDNUMsc0JBQXNCO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0c7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0JBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZmFzdC1qc29uLXBhdGNoL3NyYy9jb3JlLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIEB0cy1ub2NoZWNrXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZXBDbG9uZSA9IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IgPSB2b2lkIDA7XG5leHBvcnRzLmdldFZhbHVlQnlQb2ludGVyID0gZ2V0VmFsdWVCeVBvaW50ZXI7XG5leHBvcnRzLmFwcGx5T3BlcmF0aW9uID0gYXBwbHlPcGVyYXRpb247XG5leHBvcnRzLmFwcGx5UGF0Y2ggPSBhcHBseVBhdGNoO1xuZXhwb3J0cy5hcHBseVJlZHVjZXIgPSBhcHBseVJlZHVjZXI7XG5leHBvcnRzLnZhbGlkYXRvciA9IHZhbGlkYXRvcjtcbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbmV4cG9ydHMuX2FyZUVxdWFscyA9IF9hcmVFcXVhbHM7XG5jb25zdCBoZWxwZXJzX2pzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzLmNqc1wiKTtcbmV4cG9ydHMuSnNvblBhdGNoRXJyb3IgPSBoZWxwZXJzX2pzXzEuUGF0Y2hFcnJvcjtcbmV4cG9ydHMuZGVlcENsb25lID0gaGVscGVyc19qc18xLl9kZWVwQ2xvbmU7XG4vKiBXZSB1c2UgYSBKYXZhc2NyaXB0IGhhc2ggdG8gc3RvcmUgZWFjaFxuIGZ1bmN0aW9uLiBFYWNoIGhhc2ggZW50cnkgKHByb3BlcnR5KSB1c2VzXG4gdGhlIG9wZXJhdGlvbiBpZGVudGlmaWVycyBzcGVjaWZpZWQgaW4gcmZjNjkwMi5cbiBJbiB0aGlzIHdheSwgd2UgY2FuIG1hcCBlYWNoIHBhdGNoIG9wZXJhdGlvblxuIHRvIGl0cyBkZWRpY2F0ZWQgZnVuY3Rpb24gaW4gZWZmaWNpZW50IHdheS5cbiAqL1xuLyogVGhlIG9wZXJhdGlvbnMgYXBwbGljYWJsZSB0byBhbiBvYmplY3QgKi9cbmNvbnN0IG9iak9wcyA9IHtcbiAgICBhZGQ6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgb2JqW2tleV0gPSB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQgfTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IG9ialtrZXldO1xuICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZCB9O1xuICAgIH0sXG4gICAgcmVwbGFjZTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IG9ialtrZXldO1xuICAgICAgICBvYmpba2V5XSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZCB9O1xuICAgIH0sXG4gICAgbW92ZTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICAvKiBpbiBjYXNlIG1vdmUgdGFyZ2V0IG92ZXJ3cml0ZXMgYW4gZXhpc3RpbmcgdmFsdWUsXG4gICAgICAgIHJldHVybiB0aGUgcmVtb3ZlZCB2YWx1ZSwgdGhpcyBjYW4gYmUgdGF4aW5nIHBlcmZvcm1hbmNlLXdpc2UsXG4gICAgICAgIGFuZCBpcyBwb3RlbnRpYWxseSB1bm5lZWRlZCAqL1xuICAgICAgICBsZXQgcmVtb3ZlZCA9IGdldFZhbHVlQnlQb2ludGVyKGRvY3VtZW50LCB0aGlzLnBhdGgpO1xuICAgICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICAgICAgcmVtb3ZlZCA9ICgwLCBoZWxwZXJzX2pzXzEuX2RlZXBDbG9uZSkocmVtb3ZlZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxWYWx1ZSA9IGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCB7XG4gICAgICAgICAgICBvcDogXCJyZW1vdmVcIixcbiAgICAgICAgICAgIHBhdGg6IHRoaXMuZnJvbSxcbiAgICAgICAgfSkucmVtb3ZlZDtcbiAgICAgICAgYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHtcbiAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgcGF0aDogdGhpcy5wYXRoLFxuICAgICAgICAgICAgdmFsdWU6IG9yaWdpbmFsVmFsdWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQgfTtcbiAgICB9LFxuICAgIGNvcHk6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgY29uc3QgdmFsdWVUb0NvcHkgPSBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgdGhpcy5mcm9tKTtcbiAgICAgICAgLy8gZW5mb3JjZSBjb3B5IGJ5IHZhbHVlIHNvIGZ1cnRoZXIgb3BlcmF0aW9ucyBkb24ndCBhZmZlY3Qgc291cmNlIChzZWUgaXNzdWUgIzE3NylcbiAgICAgICAgYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHtcbiAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgcGF0aDogdGhpcy5wYXRoLFxuICAgICAgICAgICAgdmFsdWU6ICgwLCBoZWxwZXJzX2pzXzEuX2RlZXBDbG9uZSkodmFsdWVUb0NvcHkpLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50IH07XG4gICAgfSxcbiAgICB0ZXN0OiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgdGVzdDogX2FyZUVxdWFscyhvYmpba2V5XSwgdGhpcy52YWx1ZSkgfTtcbiAgICB9LFxuICAgIF9nZXQ6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQgfTtcbiAgICB9LFxufTtcbi8qIFRoZSBvcGVyYXRpb25zIGFwcGxpY2FibGUgdG8gYW4gYXJyYXkuIE1hbnkgYXJlIHRoZSBzYW1lIGFzIGZvciB0aGUgb2JqZWN0ICovXG52YXIgYXJyT3BzID0ge1xuICAgIGFkZDogZnVuY3Rpb24gKGFyciwgaSwgZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzX2pzXzEuaXNJbnRlZ2VyKShpKSkge1xuICAgICAgICAgICAgYXJyLnNwbGljZShpLCAwLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFycmF5IHByb3BzXG4gICAgICAgICAgICBhcnJbaV0gPSB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgbWF5IGJlIG5lZWRlZCB3aGVuIHVzaW5nICctJyBpbiBhbiBhcnJheVxuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIGluZGV4OiBpIH07XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChhcnIsIGksIGRvY3VtZW50KSB7XG4gICAgICAgIHZhciByZW1vdmVkTGlzdCA9IGFyci5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZDogcmVtb3ZlZExpc3RbMF0gfTtcbiAgICB9LFxuICAgIHJlcGxhY2U6IGZ1bmN0aW9uIChhcnIsIGksIGRvY3VtZW50KSB7XG4gICAgICAgIHZhciByZW1vdmVkID0gYXJyW2ldO1xuICAgICAgICBhcnJbaV0gPSB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQgfTtcbiAgICB9LFxuICAgIG1vdmU6IG9iak9wcy5tb3ZlLFxuICAgIGNvcHk6IG9iak9wcy5jb3B5LFxuICAgIHRlc3Q6IG9iak9wcy50ZXN0LFxuICAgIF9nZXQ6IG9iak9wcy5fZ2V0LFxufTtcbi8qKlxuICogUmV0cmlldmVzIGEgdmFsdWUgZnJvbSBhIEpTT04gZG9jdW1lbnQgYnkgYSBKU09OIHBvaW50ZXIuXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gZG9jdW1lbnQgVGhlIGRvY3VtZW50IHRvIGdldCB0aGUgdmFsdWUgZnJvbVxuICogQHBhcmFtIHBvaW50ZXIgYW4gZXNjYXBlZCBKU09OIHBvaW50ZXJcbiAqIEByZXR1cm4gVGhlIHJldHJpZXZlZCB2YWx1ZVxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgcG9pbnRlcikge1xuICAgIGlmIChwb2ludGVyID09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH1cbiAgICB2YXIgZ2V0T3JpZ2luYWxEZXN0aW5hdGlvbiA9IHsgb3A6IFwiX2dldFwiLCBwYXRoOiBwb2ludGVyIH07XG4gICAgYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIGdldE9yaWdpbmFsRGVzdGluYXRpb24pO1xuICAgIHJldHVybiBnZXRPcmlnaW5hbERlc3RpbmF0aW9uLnZhbHVlO1xufVxuLyoqXG4gKiBBcHBseSBhIHNpbmdsZSBKU09OIFBhdGNoIE9wZXJhdGlvbiBvbiBhIEpTT04gZG9jdW1lbnQuXG4gKiBSZXR1cm5zIHRoZSB7bmV3RG9jdW1lbnQsIHJlc3VsdH0gb2YgdGhlIG9wZXJhdGlvbi5cbiAqIEl0IG1vZGlmaWVzIHRoZSBgZG9jdW1lbnRgIGFuZCBgb3BlcmF0aW9uYCBvYmplY3RzIC0gaXQgZ2V0cyB0aGUgdmFsdWVzIGJ5IHJlZmVyZW5jZS5cbiAqIElmIHlvdSB3b3VsZCBsaWtlIHRvIGF2b2lkIHRvdWNoaW5nIHlvdXIgdmFsdWVzLCBjbG9uZSB0aGVtOlxuICogYGpzb25wYXRjaC5hcHBseU9wZXJhdGlvbihkb2N1bWVudCwganNvbnBhdGNoLl9kZWVwQ2xvbmUob3BlcmF0aW9uKSlgLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcGF0Y2hcbiAqIEBwYXJhbSBvcGVyYXRpb24gVGhlIG9wZXJhdGlvbiB0byBhcHBseVxuICogQHBhcmFtIHZhbGlkYXRlT3BlcmF0aW9uIGBmYWxzZWAgaXMgd2l0aG91dCB2YWxpZGF0aW9uLCBgdHJ1ZWAgdG8gdXNlIGRlZmF1bHQganNvbnBhdGNoJ3MgdmFsaWRhdGlvbiwgb3IgeW91IGNhbiBwYXNzIGEgYHZhbGlkYXRlT3BlcmF0aW9uYCBjYWxsYmFjayB0byBiZSB1c2VkIGZvciB2YWxpZGF0aW9uLlxuICogQHBhcmFtIG11dGF0ZURvY3VtZW50IFdoZXRoZXIgdG8gbXV0YXRlIHRoZSBvcmlnaW5hbCBkb2N1bWVudCBvciBjbG9uZSBpdCBiZWZvcmUgYXBwbHlpbmdcbiAqIEBwYXJhbSBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zIFdoZXRoZXIgdG8gYmFuIG1vZGlmaWNhdGlvbnMgdG8gYF9fcHJvdG9fX2AsIGRlZmF1bHRzIHRvIGB0cnVlYC5cbiAqIEByZXR1cm4gYHtuZXdEb2N1bWVudCwgcmVzdWx0fWAgYWZ0ZXIgdGhlIG9wZXJhdGlvblxuICovXG5mdW5jdGlvbiBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgb3BlcmF0aW9uLCB2YWxpZGF0ZU9wZXJhdGlvbiA9IGZhbHNlLCBtdXRhdGVEb2N1bWVudCA9IHRydWUsIGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMgPSB0cnVlLCBpbmRleCA9IDApIHtcbiAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWxpZGF0ZU9wZXJhdGlvbiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlT3BlcmF0aW9uKG9wZXJhdGlvbiwgMCwgZG9jdW1lbnQsIG9wZXJhdGlvbi5wYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkYXRvcihvcGVyYXRpb24sIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIFJPT1QgT1BFUkFUSU9OUyAqL1xuICAgIGlmIChvcGVyYXRpb24ucGF0aCA9PT0gXCJcIikge1xuICAgICAgICBsZXQgcmV0dXJuVmFsdWUgPSB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCB9O1xuICAgICAgICBpZiAob3BlcmF0aW9uLm9wID09PSBcImFkZFwiKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IG9wZXJhdGlvbi52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09IFwicmVwbGFjZVwiKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IG9wZXJhdGlvbi52YWx1ZTtcbiAgICAgICAgICAgIHJldHVyblZhbHVlLnJlbW92ZWQgPSBkb2N1bWVudDsgLy9kb2N1bWVudCB3ZSByZW1vdmVkXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcIm1vdmVcIiB8fCBvcGVyYXRpb24ub3AgPT09IFwiY29weVwiKSB7XG4gICAgICAgICAgICAvLyBpdCdzIGEgbW92ZSBvciBjb3B5IHRvIHJvb3RcbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gZ2V0VmFsdWVCeVBvaW50ZXIoZG9jdW1lbnQsIG9wZXJhdGlvbi5mcm9tKTsgLy8gZ2V0IHRoZSB2YWx1ZSBieSBqc29uLXBvaW50ZXIgaW4gYGZyb21gIGZpZWxkXG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLm9wID09PSBcIm1vdmVcIikge1xuICAgICAgICAgICAgICAgIC8vIHJlcG9ydCByZW1vdmVkIGl0ZW1cbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZS5yZW1vdmVkID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcInRlc3RcIikge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUudGVzdCA9IF9hcmVFcXVhbHMoZG9jdW1lbnQsIG9wZXJhdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUudGVzdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCBcIlRFU1RfT1BFUkFUSU9OX0ZBSUxFRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJyZW1vdmVcIikge1xuICAgICAgICAgICAgLy8gYSByZW1vdmUgb24gcm9vdFxuICAgICAgICAgICAgcmV0dXJuVmFsdWUucmVtb3ZlZCA9IGRvY3VtZW50O1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJfZ2V0XCIpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbi52YWx1ZSA9IGRvY3VtZW50O1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyogYmFkIG9wZXJhdGlvbiAqL1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJPcGVyYXRpb24gYG9wYCBwcm9wZXJ0eSBpcyBub3Qgb25lIG9mIG9wZXJhdGlvbnMgZGVmaW5lZCBpbiBSRkMtNjkwMlwiLCBcIk9QRVJBVElPTl9PUF9JTlZBTElEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gLyogRU5EIFJPT1QgT1BFUkFUSU9OUyAqL1xuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIW11dGF0ZURvY3VtZW50KSB7XG4gICAgICAgICAgICBkb2N1bWVudCA9ICgwLCBoZWxwZXJzX2pzXzEuX2RlZXBDbG9uZSkoZG9jdW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGggPSBvcGVyYXRpb24ucGF0aCB8fCBcIlwiO1xuICAgICAgICBjb25zdCBrZXlzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gICAgICAgIGxldCBvYmogPSBkb2N1bWVudDtcbiAgICAgICAgbGV0IHQgPSAxOyAvL3NraXAgZW1wdHkgZWxlbWVudCAtIGh0dHA6Ly9qc3BlcmYuY29tL3RvLXNoaWZ0LW9yLW5vdC10by1zaGlmdFxuICAgICAgICBsZXQgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGxldCBleGlzdGluZ1BhdGhGcmFnbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGtleTtcbiAgICAgICAgbGV0IHZhbGlkYXRlRnVuY3Rpb247XG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRhdGVPcGVyYXRpb24gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uID0gdmFsaWRhdGVPcGVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uID0gdmFsaWRhdG9yO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXlzW3RdO1xuICAgICAgICAgICAgaWYgKGtleSAmJiBrZXkuaW5kZXhPZihcIn5cIikgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSAoMCwgaGVscGVyc19qc18xLnVuZXNjYXBlUGF0aENvbXBvbmVudCkoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zICYmXG4gICAgICAgICAgICAgICAgKGtleSA9PSBcIl9fcHJvdG9fX1wiIHx8XG4gICAgICAgICAgICAgICAgICAgIChrZXkgPT0gXCJwcm90b3R5cGVcIiAmJiB0ID4gMCAmJiBrZXlzW3QgLSAxXSA9PSBcImNvbnN0cnVjdG9yXCIpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJKU09OLVBhdGNoOiBtb2RpZnlpbmcgYF9fcHJvdG9fX2Agb3IgYGNvbnN0cnVjdG9yL3Byb3RvdHlwZWAgcHJvcCBpcyBiYW5uZWQgZm9yIHNlY3VyaXR5IHJlYXNvbnMsIGlmIHRoaXMgd2FzIG9uIHB1cnBvc2UsIHBsZWFzZSBzZXQgYGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnNgIGZsYWcgZmFsc2UgYW5kIHBhc3MgaXQgdG8gdGhpcyBmdW5jdGlvbi4gTW9yZSBpbmZvIGluIGZhc3QtanNvbi1wYXRjaCBSRUFETUVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXRoRnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSBrZXlzLnNsaWNlKDAsIHQpLmpvaW4oXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHQgPT0gbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSBvcGVyYXRpb24ucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXRoRnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbihvcGVyYXRpb24sIDAsIGRvY3VtZW50LCBleGlzdGluZ1BhdGhGcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0Kys7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gb2JqLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbiAmJiAhKDAsIGhlbHBlcnNfanNfMS5pc0ludGVnZXIpKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiRXhwZWN0ZWQgYW4gdW5zaWduZWQgYmFzZS0xMCBpbnRlZ2VyIHZhbHVlLCBtYWtpbmcgdGhlIG5ldyByZWZlcmVuY2VkIHZhbHVlIHRoZSBhcnJheSBlbGVtZW50IHdpdGggdGhlIHplcm8tYmFzZWQgaW5kZXhcIiwgXCJPUEVSQVRJT05fUEFUSF9JTExFR0FMX0FSUkFZX0lOREVYXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSAvLyBvbmx5IHBhcnNlIGtleSB3aGVuIGl0J3MgYW4gaW50ZWdlciBmb3IgYGFyci5wcm9wYCB0byB3b3JrXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCgwLCBoZWxwZXJzX2pzXzEuaXNJbnRlZ2VyKShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSB+fmtleTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodCA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uICYmIG9wZXJhdGlvbi5vcCA9PT0gXCJhZGRcIiAmJiBrZXkgPiBvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRoZSBzcGVjaWZpZWQgaW5kZXggTVVTVCBOT1QgYmUgZ3JlYXRlciB0aGFuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5XCIsIFwiT1BFUkFUSU9OX1ZBTFVFX09VVF9PRl9CT1VORFNcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldHVyblZhbHVlID0gYXJyT3BzW29wZXJhdGlvbi5vcF0uY2FsbChvcGVyYXRpb24sIG9iaiwga2V5LCBkb2N1bWVudCk7IC8vIEFwcGx5IHBhdGNoXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZS50ZXN0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJUZXN0IG9wZXJhdGlvbiBmYWlsZWRcIiwgXCJURVNUX09QRVJBVElPTl9GQUlMRURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodCA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSBvYmpPcHNbb3BlcmF0aW9uLm9wXS5jYWxsKG9wZXJhdGlvbiwgb2JqLCBrZXksIGRvY3VtZW50KTsgLy8gQXBwbHkgcGF0Y2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCBcIlRFU1RfT1BFUkFUSU9OX0ZBSUxFRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iaiA9IG9ialtrZXldO1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBtb3JlIGtleXMgaW4gdGhlIHBhdGgsIGJ1dCB0aGUgbmV4dCB2YWx1ZSBpc24ndCBhIG5vbi1udWxsIG9iamVjdCxcbiAgICAgICAgICAgIC8vIHRocm93IGFuIE9QRVJBVElPTl9QQVRIX1VOUkVTT0xWQUJMRSBlcnJvciBpbnN0ZWFkIG9mIGl0ZXJhdGluZyBhZ2Fpbi5cbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbiAmJiB0IDwgbGVuICYmICghb2JqIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJDYW5ub3QgcGVyZm9ybSBvcGVyYXRpb24gYXQgdGhlIGRlc2lyZWQgcGF0aFwiLCBcIk9QRVJBVElPTl9QQVRIX1VOUkVTT0xWQUJMRVwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEFwcGx5IGEgZnVsbCBKU09OIFBhdGNoIGFycmF5IG9uIGEgSlNPTiBkb2N1bWVudC5cbiAqIFJldHVybnMgdGhlIHtuZXdEb2N1bWVudCwgcmVzdWx0fSBvZiB0aGUgcGF0Y2guXG4gKiBJdCBtb2RpZmllcyB0aGUgYGRvY3VtZW50YCBvYmplY3QgYW5kIGBwYXRjaGAgLSBpdCBnZXRzIHRoZSB2YWx1ZXMgYnkgcmVmZXJlbmNlLlxuICogSWYgeW91IHdvdWxkIGxpa2UgdG8gYXZvaWQgdG91Y2hpbmcgeW91ciB2YWx1ZXMsIGNsb25lIHRoZW06XG4gKiBganNvbnBhdGNoLmFwcGx5UGF0Y2goZG9jdW1lbnQsIGpzb25wYXRjaC5fZGVlcENsb25lKHBhdGNoKSlgLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcGF0Y2hcbiAqIEBwYXJhbSBwYXRjaCBUaGUgcGF0Y2ggdG8gYXBwbHlcbiAqIEBwYXJhbSB2YWxpZGF0ZU9wZXJhdGlvbiBgZmFsc2VgIGlzIHdpdGhvdXQgdmFsaWRhdGlvbiwgYHRydWVgIHRvIHVzZSBkZWZhdWx0IGpzb25wYXRjaCdzIHZhbGlkYXRpb24sIG9yIHlvdSBjYW4gcGFzcyBhIGB2YWxpZGF0ZU9wZXJhdGlvbmAgY2FsbGJhY2sgdG8gYmUgdXNlZCBmb3IgdmFsaWRhdGlvbi5cbiAqIEBwYXJhbSBtdXRhdGVEb2N1bWVudCBXaGV0aGVyIHRvIG11dGF0ZSB0aGUgb3JpZ2luYWwgZG9jdW1lbnQgb3IgY2xvbmUgaXQgYmVmb3JlIGFwcGx5aW5nXG4gKiBAcGFyYW0gYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyBXaGV0aGVyIHRvIGJhbiBtb2RpZmljYXRpb25zIHRvIGBfX3Byb3RvX19gLCBkZWZhdWx0cyB0byBgdHJ1ZWAuXG4gKiBAcmV0dXJuIEFuIGFycmF5IG9mIGB7bmV3RG9jdW1lbnQsIHJlc3VsdH1gIGFmdGVyIHRoZSBwYXRjaFxuICovXG5mdW5jdGlvbiBhcHBseVBhdGNoKGRvY3VtZW50LCBwYXRjaCwgdmFsaWRhdGVPcGVyYXRpb24sIG11dGF0ZURvY3VtZW50ID0gdHJ1ZSwgYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyA9IHRydWUpIHtcbiAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGNoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJQYXRjaCBzZXF1ZW5jZSBtdXN0IGJlIGFuIGFycmF5XCIsIFwiU0VRVUVOQ0VfTk9UX0FOX0FSUkFZXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghbXV0YXRlRG9jdW1lbnQpIHtcbiAgICAgICAgZG9jdW1lbnQgPSAoMCwgaGVscGVyc19qc18xLl9kZWVwQ2xvbmUpKGRvY3VtZW50KTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShwYXRjaC5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBwYXRjaC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHBhc3MgbXV0YXRlRG9jdW1lbnQgYXJndW1lbnQgYmVjYXVzZSBpZiBpdCB3YXMgdHJ1ZSwgd2UgYWxyZWFkeSBkZWVwIGNsb25lZCB0aGUgb2JqZWN0LCB3ZSdsbCBqdXN0IHBhc3MgYHRydWVgXG4gICAgICAgIHJlc3VsdHNbaV0gPSBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgcGF0Y2hbaV0sIHZhbGlkYXRlT3BlcmF0aW9uLCB0cnVlLCBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zLCBpKTtcbiAgICAgICAgZG9jdW1lbnQgPSByZXN1bHRzW2ldLm5ld0RvY3VtZW50OyAvLyBpbiBjYXNlIHJvb3Qgd2FzIHJlcGxhY2VkXG4gICAgfVxuICAgIHJlc3VsdHMubmV3RG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICByZXR1cm4gcmVzdWx0cztcbn1cbi8qKlxuICogQXBwbHkgYSBzaW5nbGUgSlNPTiBQYXRjaCBPcGVyYXRpb24gb24gYSBKU09OIGRvY3VtZW50LlxuICogUmV0dXJucyB0aGUgdXBkYXRlZCBkb2N1bWVudC5cbiAqIFN1aXRhYmxlIGFzIGEgcmVkdWNlci5cbiAqXG4gKiBAcGFyYW0gZG9jdW1lbnQgVGhlIGRvY3VtZW50IHRvIHBhdGNoXG4gKiBAcGFyYW0gb3BlcmF0aW9uIFRoZSBvcGVyYXRpb24gdG8gYXBwbHlcbiAqIEByZXR1cm4gVGhlIHVwZGF0ZWQgZG9jdW1lbnRcbiAqL1xuZnVuY3Rpb24gYXBwbHlSZWR1Y2VyKGRvY3VtZW50LCBvcGVyYXRpb24sIGluZGV4KSB7XG4gICAgY29uc3Qgb3BlcmF0aW9uUmVzdWx0ID0gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIG9wZXJhdGlvbik7XG4gICAgaWYgKG9wZXJhdGlvblJlc3VsdC50ZXN0ID09PSBmYWxzZSkge1xuICAgICAgICAvLyBmYWlsZWQgdGVzdFxuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCBcIlRFU1RfT1BFUkFUSU9OX0ZBSUxFRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIHJldHVybiBvcGVyYXRpb25SZXN1bHQubmV3RG9jdW1lbnQ7XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIHNpbmdsZSBvcGVyYXRpb24uIENhbGxlZCBmcm9tIGBqc29ucGF0Y2gudmFsaWRhdGVgLiBUaHJvd3MgYEpzb25QYXRjaEVycm9yYCBpbiBjYXNlIG9mIGFuIGVycm9yLlxuICogQHBhcmFtIHtvYmplY3R9IG9wZXJhdGlvbiAtIG9wZXJhdGlvbiBvYmplY3QgKHBhdGNoKVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggb2Ygb3BlcmF0aW9uIGluIHRoZSBzZXF1ZW5jZVxuICogQHBhcmFtIHtvYmplY3R9IFtkb2N1bWVudF0gLSBvYmplY3Qgd2hlcmUgdGhlIG9wZXJhdGlvbiBpcyBzdXBwb3NlZCB0byBiZSBhcHBsaWVkXG4gKiBAcGFyYW0ge3N0cmluZ30gW2V4aXN0aW5nUGF0aEZyYWdtZW50XSAtIGNvbWVzIGFsb25nIHdpdGggYGRvY3VtZW50YFxuICovXG5mdW5jdGlvbiB2YWxpZGF0b3Iob3BlcmF0aW9uLCBpbmRleCwgZG9jdW1lbnQsIGV4aXN0aW5nUGF0aEZyYWdtZW50KSB7XG4gICAgaWYgKHR5cGVvZiBvcGVyYXRpb24gIT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgb3BlcmF0aW9uID09PSBudWxsIHx8XG4gICAgICAgIEFycmF5LmlzQXJyYXkob3BlcmF0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIk9wZXJhdGlvbiBpcyBub3QgYW4gb2JqZWN0XCIsIFwiT1BFUkFUSU9OX05PVF9BTl9PQkpFQ1RcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICghb2JqT3BzW29wZXJhdGlvbi5vcF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJPcGVyYXRpb24gYG9wYCBwcm9wZXJ0eSBpcyBub3Qgb25lIG9mIG9wZXJhdGlvbnMgZGVmaW5lZCBpbiBSRkMtNjkwMlwiLCBcIk9QRVJBVElPTl9PUF9JTlZBTElEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9wZXJhdGlvbi5wYXRoICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiT3BlcmF0aW9uIGBwYXRoYCBwcm9wZXJ0eSBpcyBub3QgYSBzdHJpbmdcIiwgXCJPUEVSQVRJT05fUEFUSF9JTlZBTElEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3BlcmF0aW9uLnBhdGguaW5kZXhPZihcIi9cIikgIT09IDAgJiYgb3BlcmF0aW9uLnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBwYXRocyB0aGF0IGFyZW4ndCBlbXB0eSBzdHJpbmcgc2hvdWxkIHN0YXJ0IHdpdGggXCIvXCJcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgcGF0aGAgcHJvcGVydHkgbXVzdCBzdGFydCB3aXRoIFwiL1wiJywgXCJPUEVSQVRJT05fUEFUSF9JTlZBTElEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKG9wZXJhdGlvbi5vcCA9PT0gXCJtb3ZlXCIgfHwgb3BlcmF0aW9uLm9wID09PSBcImNvcHlcIikgJiZcbiAgICAgICAgdHlwZW9mIG9wZXJhdGlvbi5mcm9tICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiT3BlcmF0aW9uIGBmcm9tYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgbW92ZWAgYW5kIGBjb3B5YCBvcGVyYXRpb25zKVwiLCBcIk9QRVJBVElPTl9GUk9NX1JFUVVJUkVEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKG9wZXJhdGlvbi5vcCA9PT0gXCJhZGRcIiB8fFxuICAgICAgICBvcGVyYXRpb24ub3AgPT09IFwicmVwbGFjZVwiIHx8XG4gICAgICAgIG9wZXJhdGlvbi5vcCA9PT0gXCJ0ZXN0XCIpICYmXG4gICAgICAgIG9wZXJhdGlvbi52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiT3BlcmF0aW9uIGB2YWx1ZWAgcHJvcGVydHkgaXMgbm90IHByZXNlbnQgKGFwcGxpY2FibGUgaW4gYGFkZGAsIGByZXBsYWNlYCBhbmQgYHRlc3RgIG9wZXJhdGlvbnMpXCIsIFwiT1BFUkFUSU9OX1ZBTFVFX1JFUVVJUkVEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKG9wZXJhdGlvbi5vcCA9PT0gXCJhZGRcIiB8fFxuICAgICAgICBvcGVyYXRpb24ub3AgPT09IFwicmVwbGFjZVwiIHx8XG4gICAgICAgIG9wZXJhdGlvbi5vcCA9PT0gXCJ0ZXN0XCIpICYmXG4gICAgICAgICgwLCBoZWxwZXJzX2pzXzEuaGFzVW5kZWZpbmVkKShvcGVyYXRpb24udmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiT3BlcmF0aW9uIGB2YWx1ZWAgcHJvcGVydHkgaXMgbm90IHByZXNlbnQgKGFwcGxpY2FibGUgaW4gYGFkZGAsIGByZXBsYWNlYCBhbmQgYHRlc3RgIG9wZXJhdGlvbnMpXCIsIFwiT1BFUkFUSU9OX1ZBTFVFX0NBTk5PVF9DT05UQUlOX1VOREVGSU5FRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvY3VtZW50KSB7XG4gICAgICAgIGlmIChvcGVyYXRpb24ub3AgPT0gXCJhZGRcIikge1xuICAgICAgICAgICAgdmFyIHBhdGhMZW4gPSBvcGVyYXRpb24ucGF0aC5zcGxpdChcIi9cIikubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nUGF0aExlbiA9IGV4aXN0aW5nUGF0aEZyYWdtZW50LnNwbGl0KFwiL1wiKS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocGF0aExlbiAhPT0gZXhpc3RpbmdQYXRoTGVuICsgMSAmJiBwYXRoTGVuICE9PSBleGlzdGluZ1BhdGhMZW4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIkNhbm5vdCBwZXJmb3JtIGFuIGBhZGRgIG9wZXJhdGlvbiBhdCB0aGUgZGVzaXJlZCBwYXRoXCIsIFwiT1BFUkFUSU9OX1BBVEhfQ0FOTk9UX0FERFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcInJlcGxhY2VcIiB8fFxuICAgICAgICAgICAgb3BlcmF0aW9uLm9wID09PSBcInJlbW92ZVwiIHx8XG4gICAgICAgICAgICBvcGVyYXRpb24ub3AgPT09IFwiX2dldFwiKSB7XG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLnBhdGggIT09IGV4aXN0aW5nUGF0aEZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJDYW5ub3QgcGVyZm9ybSB0aGUgb3BlcmF0aW9uIGF0IGEgcGF0aCB0aGF0IGRvZXMgbm90IGV4aXN0XCIsIFwiT1BFUkFUSU9OX1BBVEhfVU5SRVNPTFZBQkxFXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09IFwibW92ZVwiIHx8IG9wZXJhdGlvbi5vcCA9PT0gXCJjb3B5XCIpIHtcbiAgICAgICAgICAgIHZhciBleGlzdGluZ1ZhbHVlID0ge1xuICAgICAgICAgICAgICAgIG9wOiBcIl9nZXRcIixcbiAgICAgICAgICAgICAgICBwYXRoOiBvcGVyYXRpb24uZnJvbSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IHZhbGlkYXRlKFtleGlzdGluZ1ZhbHVlXSwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLm5hbWUgPT09IFwiT1BFUkFUSU9OX1BBVEhfVU5SRVNPTFZBQkxFXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIkNhbm5vdCBwZXJmb3JtIHRoZSBvcGVyYXRpb24gZnJvbSBhIHBhdGggdGhhdCBkb2VzIG5vdCBleGlzdFwiLCBcIk9QRVJBVElPTl9GUk9NX1VOUkVTT0xWQUJMRVwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIHNlcXVlbmNlIG9mIG9wZXJhdGlvbnMuIElmIGBkb2N1bWVudGAgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCB0aGUgc2VxdWVuY2UgaXMgYWRkaXRpb25hbGx5IHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSBvYmplY3QgZG9jdW1lbnQuXG4gKiBJZiBlcnJvciBpcyBlbmNvdW50ZXJlZCwgcmV0dXJucyBhIEpzb25QYXRjaEVycm9yIG9iamVjdFxuICogQHBhcmFtIHNlcXVlbmNlXG4gKiBAcGFyYW0gZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtKc29uUGF0Y2hFcnJvcnx1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlKHNlcXVlbmNlLCBkb2N1bWVudCwgZXh0ZXJuYWxWYWxpZGF0b3IpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2VxdWVuY2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlBhdGNoIHNlcXVlbmNlIG11c3QgYmUgYW4gYXJyYXlcIiwgXCJTRVFVRU5DRV9OT1RfQU5fQVJSQVlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvY3VtZW50KSB7XG4gICAgICAgICAgICAvL2Nsb25lIGRvY3VtZW50IGFuZCBzZXF1ZW5jZSBzbyB0aGF0IHdlIGNhbiBzYWZlbHkgdHJ5IGFwcGx5aW5nIG9wZXJhdGlvbnNcbiAgICAgICAgICAgIGFwcGx5UGF0Y2goKDAsIGhlbHBlcnNfanNfMS5fZGVlcENsb25lKShkb2N1bWVudCksICgwLCBoZWxwZXJzX2pzXzEuX2RlZXBDbG9uZSkoc2VxdWVuY2UpLCBleHRlcm5hbFZhbGlkYXRvciB8fCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4dGVybmFsVmFsaWRhdG9yID0gZXh0ZXJuYWxWYWxpZGF0b3IgfHwgdmFsaWRhdG9yO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXF1ZW5jZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGV4dGVybmFsVmFsaWRhdG9yKHNlcXVlbmNlW2ldLCBpLCBkb2N1bWVudCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIGV4cG9ydHMuSnNvblBhdGNoRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9lcG9iZXJlemtpbi9mYXN0LWRlZXAtZXF1YWxcbi8vIE1JVCBMaWNlbnNlXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTcgRXZnZW55IFBvYmVyZXpraW5cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbi8vIFNPRlRXQVJFLlxuZnVuY3Rpb24gX2FyZUVxdWFscyhhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgYiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciBhcnJBID0gQXJyYXkuaXNBcnJheShhKSwgYXJyQiA9IEFycmF5LmlzQXJyYXkoYiksIGksIGxlbmd0aCwga2V5O1xuICAgICAgICBpZiAoYXJyQSAmJiBhcnJCKSB7XG4gICAgICAgICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICAgICAgICAgIGlmICghX2FyZUVxdWFscyhhW2ldLCBiW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyckEgIT0gYXJyQilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICAgICAgaWYgKCFiLmhhc093blByb3BlcnR5KGtleXNbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKCFfYXJlRXF1YWxzKGFba2V5XSwgYltrZXldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBhICE9PSBhICYmIGIgIT09IGI7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.cjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.cjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// @ts-nocheck\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unobserve = unobserve;\nexports.observe = observe;\nexports.generate = generate;\nexports.compare = compare;\n// Inlined because of ESM import issues\n/*!\n * https://github.com/Starcounter-Jack/JSON-Patch\n * (c) 2013-2021 Joachim Wester\n * MIT license\n */\nconst helpers_js_1 = __webpack_require__(/*! ./helpers.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.cjs\");\nconst core_js_1 = __webpack_require__(/*! ./core.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.cjs\");\nvar beforeDict = new WeakMap();\nclass Mirror {\n    constructor(obj) {\n        Object.defineProperty(this, \"obj\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"observers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"value\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.obj = obj;\n    }\n}\nclass ObserverInfo {\n    constructor(callback, observer) {\n        Object.defineProperty(this, \"callback\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"observer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.callback = callback;\n        this.observer = observer;\n    }\n}\nfunction getMirror(obj) {\n    return beforeDict.get(obj);\n}\nfunction getObserverFromMirror(mirror, callback) {\n    return mirror.observers.get(callback);\n}\nfunction removeObserverFromMirror(mirror, observer) {\n    mirror.observers.delete(observer.callback);\n}\n/**\n * Detach an observer from an object\n */\nfunction unobserve(root, observer) {\n    observer.unobserve();\n}\n/**\n * Observes changes made to an object, which can then be retrieved using generate\n */\nfunction observe(obj, callback) {\n    var patches = [];\n    var observer;\n    var mirror = getMirror(obj);\n    if (!mirror) {\n        mirror = new Mirror(obj);\n        beforeDict.set(obj, mirror);\n    }\n    else {\n        const observerInfo = getObserverFromMirror(mirror, callback);\n        observer = observerInfo && observerInfo.observer;\n    }\n    if (observer) {\n        return observer;\n    }\n    observer = {};\n    mirror.value = (0, helpers_js_1._deepClone)(obj);\n    if (callback) {\n        observer.callback = callback;\n        observer.next = null;\n        var dirtyCheck = () => {\n            generate(observer);\n        };\n        var fastCheck = () => {\n            clearTimeout(observer.next);\n            observer.next = setTimeout(dirtyCheck);\n        };\n        if (typeof window !== \"undefined\") {\n            //not Node\n            window.addEventListener(\"mouseup\", fastCheck);\n            window.addEventListener(\"keyup\", fastCheck);\n            window.addEventListener(\"mousedown\", fastCheck);\n            window.addEventListener(\"keydown\", fastCheck);\n            window.addEventListener(\"change\", fastCheck);\n        }\n    }\n    observer.patches = patches;\n    observer.object = obj;\n    observer.unobserve = () => {\n        generate(observer);\n        clearTimeout(observer.next);\n        removeObserverFromMirror(mirror, observer);\n        if (typeof window !== \"undefined\") {\n            window.removeEventListener(\"mouseup\", fastCheck);\n            window.removeEventListener(\"keyup\", fastCheck);\n            window.removeEventListener(\"mousedown\", fastCheck);\n            window.removeEventListener(\"keydown\", fastCheck);\n            window.removeEventListener(\"change\", fastCheck);\n        }\n    };\n    mirror.observers.set(callback, new ObserverInfo(callback, observer));\n    return observer;\n}\n/**\n * Generate an array of patches from an observer\n */\nfunction generate(observer, invertible = false) {\n    var mirror = beforeDict.get(observer.object);\n    _generate(mirror.value, observer.object, observer.patches, \"\", invertible);\n    if (observer.patches.length) {\n        (0, core_js_1.applyPatch)(mirror.value, observer.patches);\n    }\n    var temp = observer.patches;\n    if (temp.length > 0) {\n        observer.patches = [];\n        if (observer.callback) {\n            observer.callback(temp);\n        }\n    }\n    return temp;\n}\n// Dirty check if obj is different from mirror, generate patches and update mirror\nfunction _generate(mirror, obj, patches, path, invertible) {\n    if (obj === mirror) {\n        return;\n    }\n    if (typeof obj.toJSON === \"function\") {\n        obj = obj.toJSON();\n    }\n    var newKeys = (0, helpers_js_1._objectKeys)(obj);\n    var oldKeys = (0, helpers_js_1._objectKeys)(mirror);\n    var changed = false;\n    var deleted = false;\n    //if ever \"move\" operation is implemented here, make sure this test runs OK: \"should not generate the same patch twice (move)\"\n    for (var t = oldKeys.length - 1; t >= 0; t--) {\n        var key = oldKeys[t];\n        var oldVal = mirror[key];\n        if ((0, helpers_js_1.hasOwnProperty)(obj, key) &&\n            !(obj[key] === undefined &&\n                oldVal !== undefined &&\n                Array.isArray(obj) === false)) {\n            var newVal = obj[key];\n            if (typeof oldVal == \"object\" &&\n                oldVal != null &&\n                typeof newVal == \"object\" &&\n                newVal != null &&\n                Array.isArray(oldVal) === Array.isArray(newVal)) {\n                _generate(oldVal, newVal, patches, path + \"/\" + (0, helpers_js_1.escapePathComponent)(key), invertible);\n            }\n            else {\n                if (oldVal !== newVal) {\n                    changed = true;\n                    if (invertible) {\n                        patches.push({\n                            op: \"test\",\n                            path: path + \"/\" + (0, helpers_js_1.escapePathComponent)(key),\n                            value: (0, helpers_js_1._deepClone)(oldVal),\n                        });\n                    }\n                    patches.push({\n                        op: \"replace\",\n                        path: path + \"/\" + (0, helpers_js_1.escapePathComponent)(key),\n                        value: (0, helpers_js_1._deepClone)(newVal),\n                    });\n                }\n            }\n        }\n        else if (Array.isArray(mirror) === Array.isArray(obj)) {\n            if (invertible) {\n                patches.push({\n                    op: \"test\",\n                    path: path + \"/\" + (0, helpers_js_1.escapePathComponent)(key),\n                    value: (0, helpers_js_1._deepClone)(oldVal),\n                });\n            }\n            patches.push({\n                op: \"remove\",\n                path: path + \"/\" + (0, helpers_js_1.escapePathComponent)(key),\n            });\n            deleted = true; // property has been deleted\n        }\n        else {\n            if (invertible) {\n                patches.push({ op: \"test\", path, value: mirror });\n            }\n            patches.push({ op: \"replace\", path, value: obj });\n            changed = true;\n        }\n    }\n    if (!deleted && newKeys.length == oldKeys.length) {\n        return;\n    }\n    for (var t = 0; t < newKeys.length; t++) {\n        var key = newKeys[t];\n        if (!(0, helpers_js_1.hasOwnProperty)(mirror, key) && obj[key] !== undefined) {\n            patches.push({\n                op: \"add\",\n                path: path + \"/\" + (0, helpers_js_1.escapePathComponent)(key),\n                value: (0, helpers_js_1._deepClone)(obj[key]),\n            });\n        }\n    }\n}\n/**\n * Create an array of patches from the differences in two objects\n */\nfunction compare(tree1, tree2, invertible = false) {\n    var patches = [];\n    _generate(tree1, tree2, patches, \"\", invertible);\n    return patches;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZmFzdC1qc29uLXBhdGNoL3NyYy9kdXBsZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLHNHQUFlO0FBQzVDLGtCQUFrQixtQkFBTyxDQUFDLGdHQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlDQUFpQztBQUNoRTtBQUNBLDJCQUEyQixpQ0FBaUM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2Zhc3QtanNvbi1wYXRjaC9zcmMvZHVwbGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIEB0cy1ub2NoZWNrXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVub2JzZXJ2ZSA9IHVub2JzZXJ2ZTtcbmV4cG9ydHMub2JzZXJ2ZSA9IG9ic2VydmU7XG5leHBvcnRzLmdlbmVyYXRlID0gZ2VuZXJhdGU7XG5leHBvcnRzLmNvbXBhcmUgPSBjb21wYXJlO1xuLy8gSW5saW5lZCBiZWNhdXNlIG9mIEVTTSBpbXBvcnQgaXNzdWVzXG4vKiFcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9TdGFyY291bnRlci1KYWNrL0pTT04tUGF0Y2hcbiAqIChjKSAyMDEzLTIwMjEgSm9hY2hpbSBXZXN0ZXJcbiAqIE1JVCBsaWNlbnNlXG4gKi9cbmNvbnN0IGhlbHBlcnNfanNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMuY2pzXCIpO1xuY29uc3QgY29yZV9qc18xID0gcmVxdWlyZShcIi4vY29yZS5janNcIik7XG52YXIgYmVmb3JlRGljdCA9IG5ldyBXZWFrTWFwKCk7XG5jbGFzcyBNaXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvYmpcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib2JzZXJ2ZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgIH1cbn1cbmNsYXNzIE9ic2VydmVySW5mbyB7XG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2ssIG9ic2VydmVyKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhbGxiYWNrXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9ic2VydmVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldE1pcnJvcihvYmopIHtcbiAgICByZXR1cm4gYmVmb3JlRGljdC5nZXQob2JqKTtcbn1cbmZ1bmN0aW9uIGdldE9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG1pcnJvci5vYnNlcnZlcnMuZ2V0KGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZU9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIG9ic2VydmVyKSB7XG4gICAgbWlycm9yLm9ic2VydmVycy5kZWxldGUob2JzZXJ2ZXIuY2FsbGJhY2spO1xufVxuLyoqXG4gKiBEZXRhY2ggYW4gb2JzZXJ2ZXIgZnJvbSBhbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gdW5vYnNlcnZlKHJvb3QsIG9ic2VydmVyKSB7XG4gICAgb2JzZXJ2ZXIudW5vYnNlcnZlKCk7XG59XG4vKipcbiAqIE9ic2VydmVzIGNoYW5nZXMgbWFkZSB0byBhbiBvYmplY3QsIHdoaWNoIGNhbiB0aGVuIGJlIHJldHJpZXZlZCB1c2luZyBnZW5lcmF0ZVxuICovXG5mdW5jdGlvbiBvYnNlcnZlKG9iaiwgY2FsbGJhY2spIHtcbiAgICB2YXIgcGF0Y2hlcyA9IFtdO1xuICAgIHZhciBvYnNlcnZlcjtcbiAgICB2YXIgbWlycm9yID0gZ2V0TWlycm9yKG9iaik7XG4gICAgaWYgKCFtaXJyb3IpIHtcbiAgICAgICAgbWlycm9yID0gbmV3IE1pcnJvcihvYmopO1xuICAgICAgICBiZWZvcmVEaWN0LnNldChvYmosIG1pcnJvcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBvYnNlcnZlckluZm8gPSBnZXRPYnNlcnZlckZyb21NaXJyb3IobWlycm9yLCBjYWxsYmFjayk7XG4gICAgICAgIG9ic2VydmVyID0gb2JzZXJ2ZXJJbmZvICYmIG9ic2VydmVySW5mby5vYnNlcnZlcjtcbiAgICB9XG4gICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICB9XG4gICAgb2JzZXJ2ZXIgPSB7fTtcbiAgICBtaXJyb3IudmFsdWUgPSAoMCwgaGVscGVyc19qc18xLl9kZWVwQ2xvbmUpKG9iaik7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIG9ic2VydmVyLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIG9ic2VydmVyLm5leHQgPSBudWxsO1xuICAgICAgICB2YXIgZGlydHlDaGVjayA9ICgpID0+IHtcbiAgICAgICAgICAgIGdlbmVyYXRlKG9ic2VydmVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGZhc3RDaGVjayA9ICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChvYnNlcnZlci5uZXh0KTtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQgPSBzZXRUaW1lb3V0KGRpcnR5Q2hlY2spO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgLy9ub3QgTm9kZVxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBmYXN0Q2hlY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9ic2VydmVyLnBhdGNoZXMgPSBwYXRjaGVzO1xuICAgIG9ic2VydmVyLm9iamVjdCA9IG9iajtcbiAgICBvYnNlcnZlci51bm9ic2VydmUgPSAoKSA9PiB7XG4gICAgICAgIGdlbmVyYXRlKG9ic2VydmVyKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KG9ic2VydmVyLm5leHQpO1xuICAgICAgICByZW1vdmVPYnNlcnZlckZyb21NaXJyb3IobWlycm9yLCBvYnNlcnZlcik7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZhc3RDaGVjayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIG1pcnJvci5vYnNlcnZlcnMuc2V0KGNhbGxiYWNrLCBuZXcgT2JzZXJ2ZXJJbmZvKGNhbGxiYWNrLCBvYnNlcnZlcikpO1xuICAgIHJldHVybiBvYnNlcnZlcjtcbn1cbi8qKlxuICogR2VuZXJhdGUgYW4gYXJyYXkgb2YgcGF0Y2hlcyBmcm9tIGFuIG9ic2VydmVyXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlKG9ic2VydmVyLCBpbnZlcnRpYmxlID0gZmFsc2UpIHtcbiAgICB2YXIgbWlycm9yID0gYmVmb3JlRGljdC5nZXQob2JzZXJ2ZXIub2JqZWN0KTtcbiAgICBfZ2VuZXJhdGUobWlycm9yLnZhbHVlLCBvYnNlcnZlci5vYmplY3QsIG9ic2VydmVyLnBhdGNoZXMsIFwiXCIsIGludmVydGlibGUpO1xuICAgIGlmIChvYnNlcnZlci5wYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICAoMCwgY29yZV9qc18xLmFwcGx5UGF0Y2gpKG1pcnJvci52YWx1ZSwgb2JzZXJ2ZXIucGF0Y2hlcyk7XG4gICAgfVxuICAgIHZhciB0ZW1wID0gb2JzZXJ2ZXIucGF0Y2hlcztcbiAgICBpZiAodGVtcC5sZW5ndGggPiAwKSB7XG4gICAgICAgIG9ic2VydmVyLnBhdGNoZXMgPSBbXTtcbiAgICAgICAgaWYgKG9ic2VydmVyLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5jYWxsYmFjayh0ZW1wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGVtcDtcbn1cbi8vIERpcnR5IGNoZWNrIGlmIG9iaiBpcyBkaWZmZXJlbnQgZnJvbSBtaXJyb3IsIGdlbmVyYXRlIHBhdGNoZXMgYW5kIHVwZGF0ZSBtaXJyb3JcbmZ1bmN0aW9uIF9nZW5lcmF0ZShtaXJyb3IsIG9iaiwgcGF0Y2hlcywgcGF0aCwgaW52ZXJ0aWJsZSkge1xuICAgIGlmIChvYmogPT09IG1pcnJvcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9iaiA9IG9iai50b0pTT04oKTtcbiAgICB9XG4gICAgdmFyIG5ld0tleXMgPSAoMCwgaGVscGVyc19qc18xLl9vYmplY3RLZXlzKShvYmopO1xuICAgIHZhciBvbGRLZXlzID0gKDAsIGhlbHBlcnNfanNfMS5fb2JqZWN0S2V5cykobWlycm9yKTtcbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBkZWxldGVkID0gZmFsc2U7XG4gICAgLy9pZiBldmVyIFwibW92ZVwiIG9wZXJhdGlvbiBpcyBpbXBsZW1lbnRlZCBoZXJlLCBtYWtlIHN1cmUgdGhpcyB0ZXN0IHJ1bnMgT0s6IFwic2hvdWxkIG5vdCBnZW5lcmF0ZSB0aGUgc2FtZSBwYXRjaCB0d2ljZSAobW92ZSlcIlxuICAgIGZvciAodmFyIHQgPSBvbGRLZXlzLmxlbmd0aCAtIDE7IHQgPj0gMDsgdC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBvbGRLZXlzW3RdO1xuICAgICAgICB2YXIgb2xkVmFsID0gbWlycm9yW2tleV07XG4gICAgICAgIGlmICgoMCwgaGVscGVyc19qc18xLmhhc093blByb3BlcnR5KShvYmosIGtleSkgJiZcbiAgICAgICAgICAgICEob2JqW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIG9sZFZhbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShvYmopID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgIHZhciBuZXdWYWwgPSBvYmpba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2xkVmFsID09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICBvbGRWYWwgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBuZXdWYWwgPT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIG5ld1ZhbCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShvbGRWYWwpID09PSBBcnJheS5pc0FycmF5KG5ld1ZhbCkpIHtcbiAgICAgICAgICAgICAgICBfZ2VuZXJhdGUob2xkVmFsLCBuZXdWYWwsIHBhdGNoZXMsIHBhdGggKyBcIi9cIiArICgwLCBoZWxwZXJzX2pzXzEuZXNjYXBlUGF0aENvbXBvbmVudCkoa2V5KSwgaW52ZXJ0aWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob2xkVmFsICE9PSBuZXdWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnZlcnRpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBcInRlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoICsgXCIvXCIgKyAoMCwgaGVscGVyc19qc18xLmVzY2FwZVBhdGhDb21wb25lbnQpKGtleSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICgwLCBoZWxwZXJzX2pzXzEuX2RlZXBDbG9uZSkob2xkVmFsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoICsgXCIvXCIgKyAoMCwgaGVscGVyc19qc18xLmVzY2FwZVBhdGhDb21wb25lbnQpKGtleSksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogKDAsIGhlbHBlcnNfanNfMS5fZGVlcENsb25lKShuZXdWYWwpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtaXJyb3IpID09PSBBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIGlmIChpbnZlcnRpYmxlKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwidGVzdFwiLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoICsgXCIvXCIgKyAoMCwgaGVscGVyc19qc18xLmVzY2FwZVBhdGhDb21wb25lbnQpKGtleSksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAoMCwgaGVscGVyc19qc18xLl9kZWVwQ2xvbmUpKG9sZFZhbCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9wOiBcInJlbW92ZVwiLFxuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGggKyBcIi9cIiArICgwLCBoZWxwZXJzX2pzXzEuZXNjYXBlUGF0aENvbXBvbmVudCkoa2V5KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVsZXRlZCA9IHRydWU7IC8vIHByb3BlcnR5IGhhcyBiZWVuIGRlbGV0ZWRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbnZlcnRpYmxlKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwidGVzdFwiLCBwYXRoLCB2YWx1ZTogbWlycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwicmVwbGFjZVwiLCBwYXRoLCB2YWx1ZTogb2JqIH0pO1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFkZWxldGVkICYmIG5ld0tleXMubGVuZ3RoID09IG9sZEtleXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCBuZXdLZXlzLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBuZXdLZXlzW3RdO1xuICAgICAgICBpZiAoISgwLCBoZWxwZXJzX2pzXzEuaGFzT3duUHJvcGVydHkpKG1pcnJvciwga2V5KSAmJiBvYmpba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGggKyBcIi9cIiArICgwLCBoZWxwZXJzX2pzXzEuZXNjYXBlUGF0aENvbXBvbmVudCkoa2V5KSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogKDAsIGhlbHBlcnNfanNfMS5fZGVlcENsb25lKShvYmpba2V5XSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIGFuIGFycmF5IG9mIHBhdGNoZXMgZnJvbSB0aGUgZGlmZmVyZW5jZXMgaW4gdHdvIG9iamVjdHNcbiAqL1xuZnVuY3Rpb24gY29tcGFyZSh0cmVlMSwgdHJlZTIsIGludmVydGlibGUgPSBmYWxzZSkge1xuICAgIHZhciBwYXRjaGVzID0gW107XG4gICAgX2dlbmVyYXRlKHRyZWUxLCB0cmVlMiwgcGF0Y2hlcywgXCJcIiwgaW52ZXJ0aWJsZSk7XG4gICAgcmV0dXJuIHBhdGNoZXM7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.cjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.cjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// @ts-nocheck\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PatchError = void 0;\nexports.hasOwnProperty = hasOwnProperty;\nexports._objectKeys = _objectKeys;\nexports._deepClone = _deepClone;\nexports.isInteger = isInteger;\nexports.escapePathComponent = escapePathComponent;\nexports.unescapePathComponent = unescapePathComponent;\nexports._getPathRecursive = _getPathRecursive;\nexports.getPath = getPath;\nexports.hasUndefined = hasUndefined;\n// Inlined because of ESM import issues\n/*!\n * https://github.com/Starcounter-Jack/JSON-Patch\n * (c) 2017-2022 Joachim Wester\n * MIT licensed\n */\nconst _hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwnProperty(obj, key) {\n    return _hasOwnProperty.call(obj, key);\n}\nfunction _objectKeys(obj) {\n    if (Array.isArray(obj)) {\n        const keys = new Array(obj.length);\n        for (let k = 0; k < keys.length; k++) {\n            keys[k] = \"\" + k;\n        }\n        return keys;\n    }\n    if (Object.keys) {\n        return Object.keys(obj);\n    }\n    let keys = [];\n    for (let i in obj) {\n        if (hasOwnProperty(obj, i)) {\n            keys.push(i);\n        }\n    }\n    return keys;\n}\n/**\n * Deeply clone the object.\n * https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)\n * @param  {any} obj value to clone\n * @return {any} cloned obj\n */\nfunction _deepClone(obj) {\n    switch (typeof obj) {\n        case \"object\":\n            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5\n        case \"undefined\":\n            return null; //this is how JSON.stringify behaves for array items\n        default:\n            return obj; //no need to clone primitives\n    }\n}\n//3x faster than cached /^\\d+$/.test(str)\nfunction isInteger(str) {\n    let i = 0;\n    const len = str.length;\n    let charCode;\n    while (i < len) {\n        charCode = str.charCodeAt(i);\n        if (charCode >= 48 && charCode <= 57) {\n            i++;\n            continue;\n        }\n        return false;\n    }\n    return true;\n}\n/**\n * Escapes a json pointer path\n * @param path The raw pointer\n * @return the Escaped path\n */\nfunction escapePathComponent(path) {\n    if (path.indexOf(\"/\") === -1 && path.indexOf(\"~\") === -1)\n        return path;\n    return path.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\n/**\n * Unescapes a json pointer path\n * @param path The escaped pointer\n * @return The unescaped path\n */\nfunction unescapePathComponent(path) {\n    return path.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nfunction _getPathRecursive(root, obj) {\n    let found;\n    for (let key in root) {\n        if (hasOwnProperty(root, key)) {\n            if (root[key] === obj) {\n                return escapePathComponent(key) + \"/\";\n            }\n            else if (typeof root[key] === \"object\") {\n                found = _getPathRecursive(root[key], obj);\n                if (found != \"\") {\n                    return escapePathComponent(key) + \"/\" + found;\n                }\n            }\n        }\n    }\n    return \"\";\n}\nfunction getPath(root, obj) {\n    if (root === obj) {\n        return \"/\";\n    }\n    const path = _getPathRecursive(root, obj);\n    if (path === \"\") {\n        throw new Error(\"Object not found in root\");\n    }\n    return `/${path}`;\n}\n/**\n * Recursively checks whether an object has any undefined values inside.\n */\nfunction hasUndefined(obj) {\n    if (obj === undefined) {\n        return true;\n    }\n    if (obj) {\n        if (Array.isArray(obj)) {\n            for (let i = 0, len = obj.length; i < len; i++) {\n                if (hasUndefined(obj[i])) {\n                    return true;\n                }\n            }\n        }\n        else if (typeof obj === \"object\") {\n            const objKeys = _objectKeys(obj);\n            const objKeysLength = objKeys.length;\n            for (var i = 0; i < objKeysLength; i++) {\n                if (hasUndefined(obj[objKeys[i]])) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\nfunction patchErrorMessageFormatter(message, args) {\n    const messageParts = [message];\n    for (const key in args) {\n        const value = typeof args[key] === \"object\"\n            ? JSON.stringify(args[key], null, 2)\n            : args[key]; // pretty print\n        if (typeof value !== \"undefined\") {\n            messageParts.push(`${key}: ${value}`);\n        }\n    }\n    return messageParts.join(\"\\n\");\n}\nclass PatchError extends Error {\n    constructor(message, name, index, operation, tree) {\n        super(patchErrorMessageFormatter(message, { name, index, operation, tree }));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: name\n        });\n        Object.defineProperty(this, \"index\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: index\n        });\n        Object.defineProperty(this, \"operation\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: operation\n        });\n        Object.defineProperty(this, \"tree\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: tree\n        });\n        Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain, see https://stackoverflow.com/a/48342359\n        this.message = patchErrorMessageFormatter(message, {\n            name,\n            index,\n            operation,\n            tree,\n        });\n    }\n}\nexports.PatchError = PatchError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZmFzdC1qc29uLXBhdGNoL3NyYy9oZWxwZXJzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixzQkFBc0I7QUFDdEIsbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakIsMkJBQTJCO0FBQzNCLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIsZUFBZTtBQUNmLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlDQUFpQyxJQUFJLElBQUksTUFBTTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsOEJBQThCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFrQiIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2Zhc3QtanNvbi1wYXRjaC9zcmMvaGVscGVycy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBAdHMtbm9jaGVja1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXRjaEVycm9yID0gdm9pZCAwO1xuZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eSA9IGhhc093blByb3BlcnR5O1xuZXhwb3J0cy5fb2JqZWN0S2V5cyA9IF9vYmplY3RLZXlzO1xuZXhwb3J0cy5fZGVlcENsb25lID0gX2RlZXBDbG9uZTtcbmV4cG9ydHMuaXNJbnRlZ2VyID0gaXNJbnRlZ2VyO1xuZXhwb3J0cy5lc2NhcGVQYXRoQ29tcG9uZW50ID0gZXNjYXBlUGF0aENvbXBvbmVudDtcbmV4cG9ydHMudW5lc2NhcGVQYXRoQ29tcG9uZW50ID0gdW5lc2NhcGVQYXRoQ29tcG9uZW50O1xuZXhwb3J0cy5fZ2V0UGF0aFJlY3Vyc2l2ZSA9IF9nZXRQYXRoUmVjdXJzaXZlO1xuZXhwb3J0cy5nZXRQYXRoID0gZ2V0UGF0aDtcbmV4cG9ydHMuaGFzVW5kZWZpbmVkID0gaGFzVW5kZWZpbmVkO1xuLy8gSW5saW5lZCBiZWNhdXNlIG9mIEVTTSBpbXBvcnQgaXNzdWVzXG4vKiFcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9TdGFyY291bnRlci1KYWNrL0pTT04tUGF0Y2hcbiAqIChjKSAyMDE3LTIwMjIgSm9hY2hpbSBXZXN0ZXJcbiAqIE1JVCBsaWNlbnNlZFxuICovXG5jb25zdCBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gX2hhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuZnVuY3Rpb24gX29iamVjdEtleXMob2JqKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICBjb25zdCBrZXlzID0gbmV3IEFycmF5KG9iai5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGtleXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGtleXNba10gPSBcIlwiICsgaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopO1xuICAgIH1cbiAgICBsZXQga2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShvYmosIGkpKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59XG4vKipcbiAqIERlZXBseSBjbG9uZSB0aGUgb2JqZWN0LlxuICogaHR0cHM6Ly9qc3BlcmYuY29tL2RlZXAtY29weS12cy1qc29uLXN0cmluZ2lmeS1qc29uLXBhcnNlLzI1IChyZWN1cnNpdmVEZWVwQ29weSlcbiAqIEBwYXJhbSAge2FueX0gb2JqIHZhbHVlIHRvIGNsb25lXG4gKiBAcmV0dXJuIHthbnl9IGNsb25lZCBvYmpcbiAqL1xuZnVuY3Rpb24gX2RlZXBDbG9uZShvYmopIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBvYmopIHtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7IC8vRmFzdGVyIHRoYW4gRVM1IGNsb25lIC0gaHR0cDovL2pzcGVyZi5jb20vZGVlcC1jbG9uaW5nLW9mLW9iamVjdHMvNVxuICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy90aGlzIGlzIGhvdyBKU09OLnN0cmluZ2lmeSBiZWhhdmVzIGZvciBhcnJheSBpdGVtc1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG9iajsgLy9ubyBuZWVkIHRvIGNsb25lIHByaW1pdGl2ZXNcbiAgICB9XG59XG4vLzN4IGZhc3RlciB0aGFuIGNhY2hlZCAvXlxcZCskLy50ZXN0KHN0cilcbmZ1bmN0aW9uIGlzSW50ZWdlcihzdHIpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3QgbGVuID0gc3RyLmxlbmd0aDtcbiAgICBsZXQgY2hhckNvZGU7XG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBFc2NhcGVzIGEganNvbiBwb2ludGVyIHBhdGhcbiAqIEBwYXJhbSBwYXRoIFRoZSByYXcgcG9pbnRlclxuICogQHJldHVybiB0aGUgRXNjYXBlZCBwYXRoXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVBhdGhDb21wb25lbnQocGF0aCkge1xuICAgIGlmIChwYXRoLmluZGV4T2YoXCIvXCIpID09PSAtMSAmJiBwYXRoLmluZGV4T2YoXCJ+XCIpID09PSAtMSlcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcLy9nLCBcIn4xXCIpO1xufVxuLyoqXG4gKiBVbmVzY2FwZXMgYSBqc29uIHBvaW50ZXIgcGF0aFxuICogQHBhcmFtIHBhdGggVGhlIGVzY2FwZWQgcG9pbnRlclxuICogQHJldHVybiBUaGUgdW5lc2NhcGVkIHBhdGhcbiAqL1xuZnVuY3Rpb24gdW5lc2NhcGVQYXRoQ29tcG9uZW50KHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9+MS9nLCBcIi9cIikucmVwbGFjZSgvfjAvZywgXCJ+XCIpO1xufVxuZnVuY3Rpb24gX2dldFBhdGhSZWN1cnNpdmUocm9vdCwgb2JqKSB7XG4gICAgbGV0IGZvdW5kO1xuICAgIGZvciAobGV0IGtleSBpbiByb290KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShyb290LCBrZXkpKSB7XG4gICAgICAgICAgICBpZiAocm9vdFtrZXldID09PSBvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXNjYXBlUGF0aENvbXBvbmVudChrZXkpICsgXCIvXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygcm9vdFtrZXldID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSBfZ2V0UGF0aFJlY3Vyc2l2ZShyb290W2tleV0sIG9iaik7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kICE9IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSArIFwiL1wiICsgZm91bmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIlwiO1xufVxuZnVuY3Rpb24gZ2V0UGF0aChyb290LCBvYmopIHtcbiAgICBpZiAocm9vdCA9PT0gb2JqKSB7XG4gICAgICAgIHJldHVybiBcIi9cIjtcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IF9nZXRQYXRoUmVjdXJzaXZlKHJvb3QsIG9iaik7XG4gICAgaWYgKHBhdGggPT09IFwiXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0IG5vdCBmb3VuZCBpbiByb290XCIpO1xuICAgIH1cbiAgICByZXR1cm4gYC8ke3BhdGh9YDtcbn1cbi8qKlxuICogUmVjdXJzaXZlbHkgY2hlY2tzIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhbnkgdW5kZWZpbmVkIHZhbHVlcyBpbnNpZGUuXG4gKi9cbmZ1bmN0aW9uIGhhc1VuZGVmaW5lZChvYmopIHtcbiAgICBpZiAob2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChvYmopIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChoYXNVbmRlZmluZWQob2JqW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc3Qgb2JqS2V5cyA9IF9vYmplY3RLZXlzKG9iaik7XG4gICAgICAgICAgICBjb25zdCBvYmpLZXlzTGVuZ3RoID0gb2JqS2V5cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iaktleXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChoYXNVbmRlZmluZWQob2JqW29iaktleXNbaV1dKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcGF0Y2hFcnJvck1lc3NhZ2VGb3JtYXR0ZXIobWVzc2FnZSwgYXJncykge1xuICAgIGNvbnN0IG1lc3NhZ2VQYXJ0cyA9IFttZXNzYWdlXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhcmdzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdHlwZW9mIGFyZ3Nba2V5XSA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgPyBKU09OLnN0cmluZ2lmeShhcmdzW2tleV0sIG51bGwsIDIpXG4gICAgICAgICAgICA6IGFyZ3Nba2V5XTsgLy8gcHJldHR5IHByaW50XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VQYXJ0cy5wdXNoKGAke2tleX06ICR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2VQYXJ0cy5qb2luKFwiXFxuXCIpO1xufVxuY2xhc3MgUGF0Y2hFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBuYW1lLCBpbmRleCwgb3BlcmF0aW9uLCB0cmVlKSB7XG4gICAgICAgIHN1cGVyKHBhdGNoRXJyb3JNZXNzYWdlRm9ybWF0dGVyKG1lc3NhZ2UsIHsgbmFtZSwgaW5kZXgsIG9wZXJhdGlvbiwgdHJlZSB9KSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluZGV4XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBpbmRleFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3BlcmF0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBvcGVyYXRpb25cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyZWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRyZWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7IC8vIHJlc3RvcmUgcHJvdG90eXBlIGNoYWluLCBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ4MzQyMzU5XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHBhdGNoRXJyb3JNZXNzYWdlRm9ybWF0dGVyKG1lc3NhZ2UsIHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIG9wZXJhdGlvbixcbiAgICAgICAgICAgIHRyZWUsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuUGF0Y2hFcnJvciA9IFBhdGNoRXJyb3I7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/function_calling.cjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/function_calling.cjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isLangChainTool = exports.isRunnableToolLike = exports.isStructuredToolParams = exports.isStructuredTool = void 0;\nexports.convertToOpenAIFunction = convertToOpenAIFunction;\nexports.convertToOpenAITool = convertToOpenAITool;\nconst types_js_1 = __webpack_require__(/*! ../tools/types.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tools/types.cjs\");\nconst json_schema_js_1 = __webpack_require__(/*! ./json_schema.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_schema.cjs\");\n// These utility functions were moved to a more appropriate location,\n// but we still export them here for backwards compatibility.\nvar types_js_2 = __webpack_require__(/*! ../tools/types.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tools/types.cjs\");\nObject.defineProperty(exports, \"isStructuredTool\", ({ enumerable: true, get: function () { return types_js_2.isStructuredTool; } }));\nObject.defineProperty(exports, \"isStructuredToolParams\", ({ enumerable: true, get: function () { return types_js_2.isStructuredToolParams; } }));\nObject.defineProperty(exports, \"isRunnableToolLike\", ({ enumerable: true, get: function () { return types_js_2.isRunnableToolLike; } }));\nObject.defineProperty(exports, \"isLangChainTool\", ({ enumerable: true, get: function () { return types_js_2.isLangChainTool; } }));\n/**\n * Formats a `StructuredTool` or `RunnableToolLike` instance into a format\n * that is compatible with OpenAI function calling. If `StructuredTool` or\n * `RunnableToolLike` has a zod schema, the output will be converted into a\n * JSON schema, which is then used as the parameters for the OpenAI tool.\n *\n * @param {StructuredToolInterface | RunnableToolLike} tool The tool to convert to an OpenAI function.\n * @returns {FunctionDefinition} The inputted tool in OpenAI function format.\n */\nfunction convertToOpenAIFunction(tool, fields) {\n    // @TODO 0.3.0 Remove the `number` typing\n    const fieldsCopy = typeof fields === \"number\" ? undefined : fields;\n    return {\n        name: tool.name,\n        description: tool.description,\n        parameters: (0, json_schema_js_1.toJsonSchema)(tool.schema),\n        // Do not include the `strict` field if it is `undefined`.\n        ...(fieldsCopy?.strict !== undefined ? { strict: fieldsCopy.strict } : {}),\n    };\n}\n/**\n * Formats a `StructuredTool` or `RunnableToolLike` instance into a\n * format that is compatible with OpenAI tool calling. If `StructuredTool` or\n * `RunnableToolLike` has a zod schema, the output will be converted into a\n * JSON schema, which is then used as the parameters for the OpenAI tool.\n *\n * @param {StructuredToolInterface | Record<string, any> | RunnableToolLike} tool The tool to convert to an OpenAI tool.\n * @returns {ToolDefinition} The inputted tool in OpenAI tool format.\n */\nfunction convertToOpenAITool(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntool, fields) {\n    // @TODO 0.3.0 Remove the `number` typing\n    const fieldsCopy = typeof fields === \"number\" ? undefined : fields;\n    let toolDef;\n    if ((0, types_js_1.isLangChainTool)(tool)) {\n        toolDef = {\n            type: \"function\",\n            function: convertToOpenAIFunction(tool),\n        };\n    }\n    else {\n        toolDef = tool;\n    }\n    if (fieldsCopy?.strict !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        toolDef.function.strict = fieldsCopy.strict;\n    }\n    return toolDef;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZnVuY3Rpb25fY2FsbGluZy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCLEdBQUcsMEJBQTBCLEdBQUcsOEJBQThCLEdBQUcsd0JBQXdCO0FBQ2hILCtCQUErQjtBQUMvQiwyQkFBMkI7QUFDM0IsbUJBQW1CLG1CQUFPLENBQUMscUZBQW9CO0FBQy9DLHlCQUF5QixtQkFBTyxDQUFDLDBGQUFtQjtBQUNwRDtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMscUZBQW9CO0FBQzdDLG9EQUFtRCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUNsSSwwREFBeUQsRUFBRSxxQ0FBcUMsNkNBQTZDLEVBQUM7QUFDOUksc0RBQXFELEVBQUUscUNBQXFDLHlDQUF5QyxFQUFDO0FBQ3RJLG1EQUFrRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRDQUE0QztBQUN2RCxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsNEJBQTRCLElBQUk7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0VBQWtFO0FBQzdFLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZnVuY3Rpb25fY2FsbGluZy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzTGFuZ0NoYWluVG9vbCA9IGV4cG9ydHMuaXNSdW5uYWJsZVRvb2xMaWtlID0gZXhwb3J0cy5pc1N0cnVjdHVyZWRUb29sUGFyYW1zID0gZXhwb3J0cy5pc1N0cnVjdHVyZWRUb29sID0gdm9pZCAwO1xuZXhwb3J0cy5jb252ZXJ0VG9PcGVuQUlGdW5jdGlvbiA9IGNvbnZlcnRUb09wZW5BSUZ1bmN0aW9uO1xuZXhwb3J0cy5jb252ZXJ0VG9PcGVuQUlUb29sID0gY29udmVydFRvT3BlbkFJVG9vbDtcbmNvbnN0IHR5cGVzX2pzXzEgPSByZXF1aXJlKFwiLi4vdG9vbHMvdHlwZXMuY2pzXCIpO1xuY29uc3QganNvbl9zY2hlbWFfanNfMSA9IHJlcXVpcmUoXCIuL2pzb25fc2NoZW1hLmNqc1wiKTtcbi8vIFRoZXNlIHV0aWxpdHkgZnVuY3Rpb25zIHdlcmUgbW92ZWQgdG8gYSBtb3JlIGFwcHJvcHJpYXRlIGxvY2F0aW9uLFxuLy8gYnV0IHdlIHN0aWxsIGV4cG9ydCB0aGVtIGhlcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxudmFyIHR5cGVzX2pzXzIgPSByZXF1aXJlKFwiLi4vdG9vbHMvdHlwZXMuY2pzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNTdHJ1Y3R1cmVkVG9vbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfanNfMi5pc1N0cnVjdHVyZWRUb29sOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNTdHJ1Y3R1cmVkVG9vbFBhcmFtc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfanNfMi5pc1N0cnVjdHVyZWRUb29sUGFyYW1zOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNSdW5uYWJsZVRvb2xMaWtlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc19qc18yLmlzUnVubmFibGVUb29sTGlrZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzTGFuZ0NoYWluVG9vbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfanNfMi5pc0xhbmdDaGFpblRvb2w7IH0gfSk7XG4vKipcbiAqIEZvcm1hdHMgYSBgU3RydWN0dXJlZFRvb2xgIG9yIGBSdW5uYWJsZVRvb2xMaWtlYCBpbnN0YW5jZSBpbnRvIGEgZm9ybWF0XG4gKiB0aGF0IGlzIGNvbXBhdGlibGUgd2l0aCBPcGVuQUkgZnVuY3Rpb24gY2FsbGluZy4gSWYgYFN0cnVjdHVyZWRUb29sYCBvclxuICogYFJ1bm5hYmxlVG9vbExpa2VgIGhhcyBhIHpvZCBzY2hlbWEsIHRoZSBvdXRwdXQgd2lsbCBiZSBjb252ZXJ0ZWQgaW50byBhXG4gKiBKU09OIHNjaGVtYSwgd2hpY2ggaXMgdGhlbiB1c2VkIGFzIHRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgT3BlbkFJIHRvb2wuXG4gKlxuICogQHBhcmFtIHtTdHJ1Y3R1cmVkVG9vbEludGVyZmFjZSB8IFJ1bm5hYmxlVG9vbExpa2V9IHRvb2wgVGhlIHRvb2wgdG8gY29udmVydCB0byBhbiBPcGVuQUkgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb25EZWZpbml0aW9ufSBUaGUgaW5wdXR0ZWQgdG9vbCBpbiBPcGVuQUkgZnVuY3Rpb24gZm9ybWF0LlxuICovXG5mdW5jdGlvbiBjb252ZXJ0VG9PcGVuQUlGdW5jdGlvbih0b29sLCBmaWVsZHMpIHtcbiAgICAvLyBAVE9ETyAwLjMuMCBSZW1vdmUgdGhlIGBudW1iZXJgIHR5cGluZ1xuICAgIGNvbnN0IGZpZWxkc0NvcHkgPSB0eXBlb2YgZmllbGRzID09PSBcIm51bWJlclwiID8gdW5kZWZpbmVkIDogZmllbGRzO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHRvb2wubmFtZSxcbiAgICAgICAgZGVzY3JpcHRpb246IHRvb2wuZGVzY3JpcHRpb24sXG4gICAgICAgIHBhcmFtZXRlcnM6ICgwLCBqc29uX3NjaGVtYV9qc18xLnRvSnNvblNjaGVtYSkodG9vbC5zY2hlbWEpLFxuICAgICAgICAvLyBEbyBub3QgaW5jbHVkZSB0aGUgYHN0cmljdGAgZmllbGQgaWYgaXQgaXMgYHVuZGVmaW5lZGAuXG4gICAgICAgIC4uLihmaWVsZHNDb3B5Py5zdHJpY3QgIT09IHVuZGVmaW5lZCA/IHsgc3RyaWN0OiBmaWVsZHNDb3B5LnN0cmljdCB9IDoge30pLFxuICAgIH07XG59XG4vKipcbiAqIEZvcm1hdHMgYSBgU3RydWN0dXJlZFRvb2xgIG9yIGBSdW5uYWJsZVRvb2xMaWtlYCBpbnN0YW5jZSBpbnRvIGFcbiAqIGZvcm1hdCB0aGF0IGlzIGNvbXBhdGlibGUgd2l0aCBPcGVuQUkgdG9vbCBjYWxsaW5nLiBJZiBgU3RydWN0dXJlZFRvb2xgIG9yXG4gKiBgUnVubmFibGVUb29sTGlrZWAgaGFzIGEgem9kIHNjaGVtYSwgdGhlIG91dHB1dCB3aWxsIGJlIGNvbnZlcnRlZCBpbnRvIGFcbiAqIEpTT04gc2NoZW1hLCB3aGljaCBpcyB0aGVuIHVzZWQgYXMgdGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBPcGVuQUkgdG9vbC5cbiAqXG4gKiBAcGFyYW0ge1N0cnVjdHVyZWRUb29sSW50ZXJmYWNlIHwgUmVjb3JkPHN0cmluZywgYW55PiB8IFJ1bm5hYmxlVG9vbExpa2V9IHRvb2wgVGhlIHRvb2wgdG8gY29udmVydCB0byBhbiBPcGVuQUkgdG9vbC5cbiAqIEByZXR1cm5zIHtUb29sRGVmaW5pdGlvbn0gVGhlIGlucHV0dGVkIHRvb2wgaW4gT3BlbkFJIHRvb2wgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBjb252ZXJ0VG9PcGVuQUlUb29sKFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnRvb2wsIGZpZWxkcykge1xuICAgIC8vIEBUT0RPIDAuMy4wIFJlbW92ZSB0aGUgYG51bWJlcmAgdHlwaW5nXG4gICAgY29uc3QgZmllbGRzQ29weSA9IHR5cGVvZiBmaWVsZHMgPT09IFwibnVtYmVyXCIgPyB1bmRlZmluZWQgOiBmaWVsZHM7XG4gICAgbGV0IHRvb2xEZWY7XG4gICAgaWYgKCgwLCB0eXBlc19qc18xLmlzTGFuZ0NoYWluVG9vbCkodG9vbCkpIHtcbiAgICAgICAgdG9vbERlZiA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgIGZ1bmN0aW9uOiBjb252ZXJ0VG9PcGVuQUlGdW5jdGlvbih0b29sKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRvb2xEZWYgPSB0b29sO1xuICAgIH1cbiAgICBpZiAoZmllbGRzQ29weT8uc3RyaWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgdG9vbERlZi5mdW5jdGlvbi5zdHJpY3QgPSBmaWVsZHNDb3B5LnN0cmljdDtcbiAgICB9XG4gICAgcmV0dXJuIHRvb2xEZWY7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/function_calling.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/hash.cjs":
/*!**********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/hash.cjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sha256 = exports.insecureHash = void 0;\nvar hash_js_1 = __webpack_require__(/*! ./js-sha1/hash.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/js-sha1/hash.cjs\");\nObject.defineProperty(exports, \"insecureHash\", ({ enumerable: true, get: function () { return hash_js_1.insecureHash; } }));\nvar hash_js_2 = __webpack_require__(/*! ./js-sha256/hash.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/js-sha256/hash.cjs\");\nObject.defineProperty(exports, \"sha256\", ({ enumerable: true, get: function () { return hash_js_2.sha256; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvaGFzaC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLG9CQUFvQjtBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyw0RkFBb0I7QUFDNUMsZ0RBQStDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3pILGdCQUFnQixtQkFBTyxDQUFDLGdHQUFzQjtBQUM5QywwQ0FBeUMsRUFBRSxxQ0FBcUMsNEJBQTRCLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9oYXNoLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hhMjU2ID0gZXhwb3J0cy5pbnNlY3VyZUhhc2ggPSB2b2lkIDA7XG52YXIgaGFzaF9qc18xID0gcmVxdWlyZShcIi4vanMtc2hhMS9oYXNoLmNqc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImluc2VjdXJlSGFzaFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFzaF9qc18xLmluc2VjdXJlSGFzaDsgfSB9KTtcbnZhciBoYXNoX2pzXzIgPSByZXF1aXJlKFwiLi9qcy1zaGEyNTYvaGFzaC5janNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzaGEyNTZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc2hfanNfMi5zaGEyNTY7IH0gfSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/hash.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/js-sha1/hash.cjs":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/js-sha1/hash.cjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("// @ts-nocheck\n// Inlined to deal with portability issues with importing crypto module\n/*\n * [js-sha1]{@link https://github.com/emn178/js-sha1}\n *\n * @version 0.6.0\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2014-2017\n * @license MIT\n */\n/*jslint bitwise: true */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.insecureHash = void 0;\nvar root = typeof window === \"object\" ? window : {};\nvar HEX_CHARS = \"0123456789abcdef\".split(\"\");\nvar EXTRA = [-2147483648, 8388608, 32768, 128];\nvar SHIFT = [24, 16, 8, 0];\nvar OUTPUT_TYPES = [\"hex\", \"array\", \"digest\", \"arrayBuffer\"];\nvar blocks = [];\nfunction Sha1(sharedMemory) {\n    if (sharedMemory) {\n        blocks[0] =\n            blocks[16] =\n                blocks[1] =\n                    blocks[2] =\n                        blocks[3] =\n                            blocks[4] =\n                                blocks[5] =\n                                    blocks[6] =\n                                        blocks[7] =\n                                            blocks[8] =\n                                                blocks[9] =\n                                                    blocks[10] =\n                                                        blocks[11] =\n                                                            blocks[12] =\n                                                                blocks[13] =\n                                                                    blocks[14] =\n                                                                        blocks[15] =\n                                                                            0;\n        this.blocks = blocks;\n    }\n    else {\n        this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    }\n    this.h0 = 0x67452301;\n    this.h1 = 0xefcdab89;\n    this.h2 = 0x98badcfe;\n    this.h3 = 0x10325476;\n    this.h4 = 0xc3d2e1f0;\n    this.block = this.start = this.bytes = this.hBytes = 0;\n    this.finalized = this.hashed = false;\n    this.first = true;\n}\nSha1.prototype.update = function (message) {\n    if (this.finalized) {\n        return;\n    }\n    var notString = typeof message !== \"string\";\n    if (notString && message.constructor === root.ArrayBuffer) {\n        message = new Uint8Array(message);\n    }\n    var code, index = 0, i, length = message.length || 0, blocks = this.blocks;\n    while (index < length) {\n        if (this.hashed) {\n            this.hashed = false;\n            blocks[0] = this.block;\n            blocks[16] =\n                blocks[1] =\n                    blocks[2] =\n                        blocks[3] =\n                            blocks[4] =\n                                blocks[5] =\n                                    blocks[6] =\n                                        blocks[7] =\n                                            blocks[8] =\n                                                blocks[9] =\n                                                    blocks[10] =\n                                                        blocks[11] =\n                                                            blocks[12] =\n                                                                blocks[13] =\n                                                                    blocks[14] =\n                                                                        blocks[15] =\n                                                                            0;\n        }\n        if (notString) {\n            for (i = this.start; index < length && i < 64; ++index) {\n                blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];\n            }\n        }\n        else {\n            for (i = this.start; index < length && i < 64; ++index) {\n                code = message.charCodeAt(index);\n                if (code < 0x80) {\n                    blocks[i >> 2] |= code << SHIFT[i++ & 3];\n                }\n                else if (code < 0x800) {\n                    blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];\n                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n                }\n                else if (code < 0xd800 || code >= 0xe000) {\n                    blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];\n                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n                }\n                else {\n                    code =\n                        0x10000 +\n                            (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n                    blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];\n                    blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];\n                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n                }\n            }\n        }\n        this.lastByteIndex = i;\n        this.bytes += i - this.start;\n        if (i >= 64) {\n            this.block = blocks[16];\n            this.start = i - 64;\n            this.hash();\n            this.hashed = true;\n        }\n        else {\n            this.start = i;\n        }\n    }\n    if (this.bytes > 4294967295) {\n        this.hBytes += (this.bytes / 4294967296) << 0;\n        this.bytes = this.bytes % 4294967296;\n    }\n    return this;\n};\nSha1.prototype.finalize = function () {\n    if (this.finalized) {\n        return;\n    }\n    this.finalized = true;\n    var blocks = this.blocks, i = this.lastByteIndex;\n    blocks[16] = this.block;\n    blocks[i >> 2] |= EXTRA[i & 3];\n    this.block = blocks[16];\n    if (i >= 56) {\n        if (!this.hashed) {\n            this.hash();\n        }\n        blocks[0] = this.block;\n        blocks[16] =\n            blocks[1] =\n                blocks[2] =\n                    blocks[3] =\n                        blocks[4] =\n                            blocks[5] =\n                                blocks[6] =\n                                    blocks[7] =\n                                        blocks[8] =\n                                            blocks[9] =\n                                                blocks[10] =\n                                                    blocks[11] =\n                                                        blocks[12] =\n                                                            blocks[13] =\n                                                                blocks[14] =\n                                                                    blocks[15] =\n                                                                        0;\n    }\n    blocks[14] = (this.hBytes << 3) | (this.bytes >>> 29);\n    blocks[15] = this.bytes << 3;\n    this.hash();\n};\nSha1.prototype.hash = function () {\n    var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4;\n    var f, j, t, blocks = this.blocks;\n    for (j = 16; j < 80; ++j) {\n        t = blocks[j - 3] ^ blocks[j - 8] ^ blocks[j - 14] ^ blocks[j - 16];\n        blocks[j] = (t << 1) | (t >>> 31);\n    }\n    for (j = 0; j < 20; j += 5) {\n        f = (b & c) | (~b & d);\n        t = (a << 5) | (a >>> 27);\n        e = (t + f + e + 1518500249 + blocks[j]) << 0;\n        b = (b << 30) | (b >>> 2);\n        f = (a & b) | (~a & c);\n        t = (e << 5) | (e >>> 27);\n        d = (t + f + d + 1518500249 + blocks[j + 1]) << 0;\n        a = (a << 30) | (a >>> 2);\n        f = (e & a) | (~e & b);\n        t = (d << 5) | (d >>> 27);\n        c = (t + f + c + 1518500249 + blocks[j + 2]) << 0;\n        e = (e << 30) | (e >>> 2);\n        f = (d & e) | (~d & a);\n        t = (c << 5) | (c >>> 27);\n        b = (t + f + b + 1518500249 + blocks[j + 3]) << 0;\n        d = (d << 30) | (d >>> 2);\n        f = (c & d) | (~c & e);\n        t = (b << 5) | (b >>> 27);\n        a = (t + f + a + 1518500249 + blocks[j + 4]) << 0;\n        c = (c << 30) | (c >>> 2);\n    }\n    for (; j < 40; j += 5) {\n        f = b ^ c ^ d;\n        t = (a << 5) | (a >>> 27);\n        e = (t + f + e + 1859775393 + blocks[j]) << 0;\n        b = (b << 30) | (b >>> 2);\n        f = a ^ b ^ c;\n        t = (e << 5) | (e >>> 27);\n        d = (t + f + d + 1859775393 + blocks[j + 1]) << 0;\n        a = (a << 30) | (a >>> 2);\n        f = e ^ a ^ b;\n        t = (d << 5) | (d >>> 27);\n        c = (t + f + c + 1859775393 + blocks[j + 2]) << 0;\n        e = (e << 30) | (e >>> 2);\n        f = d ^ e ^ a;\n        t = (c << 5) | (c >>> 27);\n        b = (t + f + b + 1859775393 + blocks[j + 3]) << 0;\n        d = (d << 30) | (d >>> 2);\n        f = c ^ d ^ e;\n        t = (b << 5) | (b >>> 27);\n        a = (t + f + a + 1859775393 + blocks[j + 4]) << 0;\n        c = (c << 30) | (c >>> 2);\n    }\n    for (; j < 60; j += 5) {\n        f = (b & c) | (b & d) | (c & d);\n        t = (a << 5) | (a >>> 27);\n        e = (t + f + e - 1894007588 + blocks[j]) << 0;\n        b = (b << 30) | (b >>> 2);\n        f = (a & b) | (a & c) | (b & c);\n        t = (e << 5) | (e >>> 27);\n        d = (t + f + d - 1894007588 + blocks[j + 1]) << 0;\n        a = (a << 30) | (a >>> 2);\n        f = (e & a) | (e & b) | (a & b);\n        t = (d << 5) | (d >>> 27);\n        c = (t + f + c - 1894007588 + blocks[j + 2]) << 0;\n        e = (e << 30) | (e >>> 2);\n        f = (d & e) | (d & a) | (e & a);\n        t = (c << 5) | (c >>> 27);\n        b = (t + f + b - 1894007588 + blocks[j + 3]) << 0;\n        d = (d << 30) | (d >>> 2);\n        f = (c & d) | (c & e) | (d & e);\n        t = (b << 5) | (b >>> 27);\n        a = (t + f + a - 1894007588 + blocks[j + 4]) << 0;\n        c = (c << 30) | (c >>> 2);\n    }\n    for (; j < 80; j += 5) {\n        f = b ^ c ^ d;\n        t = (a << 5) | (a >>> 27);\n        e = (t + f + e - 899497514 + blocks[j]) << 0;\n        b = (b << 30) | (b >>> 2);\n        f = a ^ b ^ c;\n        t = (e << 5) | (e >>> 27);\n        d = (t + f + d - 899497514 + blocks[j + 1]) << 0;\n        a = (a << 30) | (a >>> 2);\n        f = e ^ a ^ b;\n        t = (d << 5) | (d >>> 27);\n        c = (t + f + c - 899497514 + blocks[j + 2]) << 0;\n        e = (e << 30) | (e >>> 2);\n        f = d ^ e ^ a;\n        t = (c << 5) | (c >>> 27);\n        b = (t + f + b - 899497514 + blocks[j + 3]) << 0;\n        d = (d << 30) | (d >>> 2);\n        f = c ^ d ^ e;\n        t = (b << 5) | (b >>> 27);\n        a = (t + f + a - 899497514 + blocks[j + 4]) << 0;\n        c = (c << 30) | (c >>> 2);\n    }\n    this.h0 = (this.h0 + a) << 0;\n    this.h1 = (this.h1 + b) << 0;\n    this.h2 = (this.h2 + c) << 0;\n    this.h3 = (this.h3 + d) << 0;\n    this.h4 = (this.h4 + e) << 0;\n};\nSha1.prototype.hex = function () {\n    this.finalize();\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4;\n    return (HEX_CHARS[(h0 >> 28) & 0x0f] +\n        HEX_CHARS[(h0 >> 24) & 0x0f] +\n        HEX_CHARS[(h0 >> 20) & 0x0f] +\n        HEX_CHARS[(h0 >> 16) & 0x0f] +\n        HEX_CHARS[(h0 >> 12) & 0x0f] +\n        HEX_CHARS[(h0 >> 8) & 0x0f] +\n        HEX_CHARS[(h0 >> 4) & 0x0f] +\n        HEX_CHARS[h0 & 0x0f] +\n        HEX_CHARS[(h1 >> 28) & 0x0f] +\n        HEX_CHARS[(h1 >> 24) & 0x0f] +\n        HEX_CHARS[(h1 >> 20) & 0x0f] +\n        HEX_CHARS[(h1 >> 16) & 0x0f] +\n        HEX_CHARS[(h1 >> 12) & 0x0f] +\n        HEX_CHARS[(h1 >> 8) & 0x0f] +\n        HEX_CHARS[(h1 >> 4) & 0x0f] +\n        HEX_CHARS[h1 & 0x0f] +\n        HEX_CHARS[(h2 >> 28) & 0x0f] +\n        HEX_CHARS[(h2 >> 24) & 0x0f] +\n        HEX_CHARS[(h2 >> 20) & 0x0f] +\n        HEX_CHARS[(h2 >> 16) & 0x0f] +\n        HEX_CHARS[(h2 >> 12) & 0x0f] +\n        HEX_CHARS[(h2 >> 8) & 0x0f] +\n        HEX_CHARS[(h2 >> 4) & 0x0f] +\n        HEX_CHARS[h2 & 0x0f] +\n        HEX_CHARS[(h3 >> 28) & 0x0f] +\n        HEX_CHARS[(h3 >> 24) & 0x0f] +\n        HEX_CHARS[(h3 >> 20) & 0x0f] +\n        HEX_CHARS[(h3 >> 16) & 0x0f] +\n        HEX_CHARS[(h3 >> 12) & 0x0f] +\n        HEX_CHARS[(h3 >> 8) & 0x0f] +\n        HEX_CHARS[(h3 >> 4) & 0x0f] +\n        HEX_CHARS[h3 & 0x0f] +\n        HEX_CHARS[(h4 >> 28) & 0x0f] +\n        HEX_CHARS[(h4 >> 24) & 0x0f] +\n        HEX_CHARS[(h4 >> 20) & 0x0f] +\n        HEX_CHARS[(h4 >> 16) & 0x0f] +\n        HEX_CHARS[(h4 >> 12) & 0x0f] +\n        HEX_CHARS[(h4 >> 8) & 0x0f] +\n        HEX_CHARS[(h4 >> 4) & 0x0f] +\n        HEX_CHARS[h4 & 0x0f]);\n};\nSha1.prototype.toString = Sha1.prototype.hex;\nSha1.prototype.digest = function () {\n    this.finalize();\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4;\n    return [\n        (h0 >> 24) & 0xff,\n        (h0 >> 16) & 0xff,\n        (h0 >> 8) & 0xff,\n        h0 & 0xff,\n        (h1 >> 24) & 0xff,\n        (h1 >> 16) & 0xff,\n        (h1 >> 8) & 0xff,\n        h1 & 0xff,\n        (h2 >> 24) & 0xff,\n        (h2 >> 16) & 0xff,\n        (h2 >> 8) & 0xff,\n        h2 & 0xff,\n        (h3 >> 24) & 0xff,\n        (h3 >> 16) & 0xff,\n        (h3 >> 8) & 0xff,\n        h3 & 0xff,\n        (h4 >> 24) & 0xff,\n        (h4 >> 16) & 0xff,\n        (h4 >> 8) & 0xff,\n        h4 & 0xff,\n    ];\n};\nSha1.prototype.array = Sha1.prototype.digest;\nSha1.prototype.arrayBuffer = function () {\n    this.finalize();\n    var buffer = new ArrayBuffer(20);\n    var dataView = new DataView(buffer);\n    dataView.setUint32(0, this.h0);\n    dataView.setUint32(4, this.h1);\n    dataView.setUint32(8, this.h2);\n    dataView.setUint32(12, this.h3);\n    dataView.setUint32(16, this.h4);\n    return buffer;\n};\nlet hasLoggedWarning = false;\n/**\n * @deprecated Use `makeDefaultKeyEncoder()` to create a custom key encoder.\n * This function will be removed in a future version.\n */\nconst insecureHash = (message) => {\n    if (!hasLoggedWarning) {\n        console.warn([\n            `The default method for hashing keys is insecure and will be replaced in a future version,`,\n            `but hasn't been replaced yet as to not break existing caches. It's recommended that you use`,\n            `a more secure hashing algorithm to avoid cache poisoning.`,\n            ``,\n            `See this page for more information:`,\n            `|`,\n            `> https://js.langchain.com/docs/troubleshooting/warnings/insecure-cache-algorithm`,\n        ].join(\"\\n\"));\n        hasLoggedWarning = true;\n    }\n    return new Sha1(true).update(message)[\"hex\"]();\n};\nexports.insecureHash = insecureHash;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvanMtc2hhMS9oYXNoLmNqcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBCQUEwQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwQkFBMEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9qcy1zaGExL2hhc2guY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEB0cy1ub2NoZWNrXG4vLyBJbmxpbmVkIHRvIGRlYWwgd2l0aCBwb3J0YWJpbGl0eSBpc3N1ZXMgd2l0aCBpbXBvcnRpbmcgY3J5cHRvIG1vZHVsZVxuLypcbiAqIFtqcy1zaGExXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZW1uMTc4L2pzLXNoYTF9XG4gKlxuICogQHZlcnNpb24gMC42LjBcbiAqIEBhdXRob3IgQ2hlbiwgWWktQ3l1YW4gW2VtbjE3OEBnbWFpbC5jb21dXG4gKiBAY29weXJpZ2h0IENoZW4sIFlpLUN5dWFuIDIwMTQtMjAxN1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cbi8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbnNlY3VyZUhhc2ggPSB2b2lkIDA7XG52YXIgcm9vdCA9IHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOiB7fTtcbnZhciBIRVhfQ0hBUlMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIi5zcGxpdChcIlwiKTtcbnZhciBFWFRSQSA9IFstMjE0NzQ4MzY0OCwgODM4ODYwOCwgMzI3NjgsIDEyOF07XG52YXIgU0hJRlQgPSBbMjQsIDE2LCA4LCAwXTtcbnZhciBPVVRQVVRfVFlQRVMgPSBbXCJoZXhcIiwgXCJhcnJheVwiLCBcImRpZ2VzdFwiLCBcImFycmF5QnVmZmVyXCJdO1xudmFyIGJsb2NrcyA9IFtdO1xuZnVuY3Rpb24gU2hhMShzaGFyZWRNZW1vcnkpIHtcbiAgICBpZiAoc2hhcmVkTWVtb3J5KSB7XG4gICAgICAgIGJsb2Nrc1swXSA9XG4gICAgICAgICAgICBibG9ja3NbMTZdID1cbiAgICAgICAgICAgICAgICBibG9ja3NbMV0gPVxuICAgICAgICAgICAgICAgICAgICBibG9ja3NbMl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzNdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzZdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbN10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbOF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzldID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTBdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzExXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTJdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTNdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzE0XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwO1xuICAgICAgICB0aGlzLmJsb2NrcyA9IGJsb2NrcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuYmxvY2tzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICAgIH1cbiAgICB0aGlzLmgwID0gMHg2NzQ1MjMwMTtcbiAgICB0aGlzLmgxID0gMHhlZmNkYWI4OTtcbiAgICB0aGlzLmgyID0gMHg5OGJhZGNmZTtcbiAgICB0aGlzLmgzID0gMHgxMDMyNTQ3NjtcbiAgICB0aGlzLmg0ID0gMHhjM2QyZTFmMDtcbiAgICB0aGlzLmJsb2NrID0gdGhpcy5zdGFydCA9IHRoaXMuYnl0ZXMgPSB0aGlzLmhCeXRlcyA9IDA7XG4gICAgdGhpcy5maW5hbGl6ZWQgPSB0aGlzLmhhc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuZmlyc3QgPSB0cnVlO1xufVxuU2hhMS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbm90U3RyaW5nID0gdHlwZW9mIG1lc3NhZ2UgIT09IFwic3RyaW5nXCI7XG4gICAgaWYgKG5vdFN0cmluZyAmJiBtZXNzYWdlLmNvbnN0cnVjdG9yID09PSByb290LkFycmF5QnVmZmVyKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBuZXcgVWludDhBcnJheShtZXNzYWdlKTtcbiAgICB9XG4gICAgdmFyIGNvZGUsIGluZGV4ID0gMCwgaSwgbGVuZ3RoID0gbWVzc2FnZS5sZW5ndGggfHwgMCwgYmxvY2tzID0gdGhpcy5ibG9ja3M7XG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc2hlZCkge1xuICAgICAgICAgICAgdGhpcy5oYXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJsb2Nrc1swXSA9IHRoaXMuYmxvY2s7XG4gICAgICAgICAgICBibG9ja3NbMTZdID1cbiAgICAgICAgICAgICAgICBibG9ja3NbMV0gPVxuICAgICAgICAgICAgICAgICAgICBibG9ja3NbMl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzNdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzZdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbN10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbOF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzldID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTBdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzExXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTJdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTNdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzE0XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub3RTdHJpbmcpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IHRoaXMuc3RhcnQ7IGluZGV4IDwgbGVuZ3RoICYmIGkgPCA2NDsgKytpbmRleCkge1xuICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9IG1lc3NhZ2VbaW5kZXhdIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IDY0OyArK2luZGV4KSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IG1lc3NhZ2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9IGNvZGUgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPCAweDgwMCkge1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhjMCB8IChjb2RlID4+IDYpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29kZSA8IDB4ZDgwMCB8fCBjb2RlID49IDB4ZTAwMCkge1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhlMCB8IChjb2RlID4+IDEyKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDYpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAweDEwMDAwICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKChjb2RlICYgMHgzZmYpIDw8IDEwKSB8IChtZXNzYWdlLmNoYXJDb2RlQXQoKytpbmRleCkgJiAweDNmZikpO1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhmMCB8IChjb2RlID4+IDE4KSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDEyKSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdEJ5dGVJbmRleCA9IGk7XG4gICAgICAgIHRoaXMuYnl0ZXMgKz0gaSAtIHRoaXMuc3RhcnQ7XG4gICAgICAgIGlmIChpID49IDY0KSB7XG4gICAgICAgICAgICB0aGlzLmJsb2NrID0gYmxvY2tzWzE2XTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBpIC0gNjQ7XG4gICAgICAgICAgICB0aGlzLmhhc2goKTtcbiAgICAgICAgICAgIHRoaXMuaGFzaGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmJ5dGVzID4gNDI5NDk2NzI5NSkge1xuICAgICAgICB0aGlzLmhCeXRlcyArPSAodGhpcy5ieXRlcyAvIDQyOTQ5NjcyOTYpIDw8IDA7XG4gICAgICAgIHRoaXMuYnl0ZXMgPSB0aGlzLmJ5dGVzICUgNDI5NDk2NzI5NjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuU2hhMS5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5maW5hbGl6ZWQgPSB0cnVlO1xuICAgIHZhciBibG9ja3MgPSB0aGlzLmJsb2NrcywgaSA9IHRoaXMubGFzdEJ5dGVJbmRleDtcbiAgICBibG9ja3NbMTZdID0gdGhpcy5ibG9jaztcbiAgICBibG9ja3NbaSA+PiAyXSB8PSBFWFRSQVtpICYgM107XG4gICAgdGhpcy5ibG9jayA9IGJsb2Nrc1sxNl07XG4gICAgaWYgKGkgPj0gNTYpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc2hlZCkge1xuICAgICAgICAgICAgdGhpcy5oYXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgYmxvY2tzWzBdID0gdGhpcy5ibG9jaztcbiAgICAgICAgYmxvY2tzWzE2XSA9XG4gICAgICAgICAgICBibG9ja3NbMV0gPVxuICAgICAgICAgICAgICAgIGJsb2Nrc1syXSA9XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1szXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s1XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s2XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbN10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s4XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s5XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTBdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTFdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzEyXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTNdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTRdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzE1XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwO1xuICAgIH1cbiAgICBibG9ja3NbMTRdID0gKHRoaXMuaEJ5dGVzIDw8IDMpIHwgKHRoaXMuYnl0ZXMgPj4+IDI5KTtcbiAgICBibG9ja3NbMTVdID0gdGhpcy5ieXRlcyA8PCAzO1xuICAgIHRoaXMuaGFzaCgpO1xufTtcblNoYTEucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGEgPSB0aGlzLmgwLCBiID0gdGhpcy5oMSwgYyA9IHRoaXMuaDIsIGQgPSB0aGlzLmgzLCBlID0gdGhpcy5oNDtcbiAgICB2YXIgZiwgaiwgdCwgYmxvY2tzID0gdGhpcy5ibG9ja3M7XG4gICAgZm9yIChqID0gMTY7IGogPCA4MDsgKytqKSB7XG4gICAgICAgIHQgPSBibG9ja3NbaiAtIDNdIF4gYmxvY2tzW2ogLSA4XSBeIGJsb2Nrc1tqIC0gMTRdIF4gYmxvY2tzW2ogLSAxNl07XG4gICAgICAgIGJsb2Nrc1tqXSA9ICh0IDw8IDEpIHwgKHQgPj4+IDMxKTtcbiAgICB9XG4gICAgZm9yIChqID0gMDsgaiA8IDIwOyBqICs9IDUpIHtcbiAgICAgICAgZiA9IChiICYgYykgfCAofmIgJiBkKTtcbiAgICAgICAgdCA9IChhIDw8IDUpIHwgKGEgPj4+IDI3KTtcbiAgICAgICAgZSA9ICh0ICsgZiArIGUgKyAxNTE4NTAwMjQ5ICsgYmxvY2tzW2pdKSA8PCAwO1xuICAgICAgICBiID0gKGIgPDwgMzApIHwgKGIgPj4+IDIpO1xuICAgICAgICBmID0gKGEgJiBiKSB8ICh+YSAmIGMpO1xuICAgICAgICB0ID0gKGUgPDwgNSkgfCAoZSA+Pj4gMjcpO1xuICAgICAgICBkID0gKHQgKyBmICsgZCArIDE1MTg1MDAyNDkgKyBibG9ja3NbaiArIDFdKSA8PCAwO1xuICAgICAgICBhID0gKGEgPDwgMzApIHwgKGEgPj4+IDIpO1xuICAgICAgICBmID0gKGUgJiBhKSB8ICh+ZSAmIGIpO1xuICAgICAgICB0ID0gKGQgPDwgNSkgfCAoZCA+Pj4gMjcpO1xuICAgICAgICBjID0gKHQgKyBmICsgYyArIDE1MTg1MDAyNDkgKyBibG9ja3NbaiArIDJdKSA8PCAwO1xuICAgICAgICBlID0gKGUgPDwgMzApIHwgKGUgPj4+IDIpO1xuICAgICAgICBmID0gKGQgJiBlKSB8ICh+ZCAmIGEpO1xuICAgICAgICB0ID0gKGMgPDwgNSkgfCAoYyA+Pj4gMjcpO1xuICAgICAgICBiID0gKHQgKyBmICsgYiArIDE1MTg1MDAyNDkgKyBibG9ja3NbaiArIDNdKSA8PCAwO1xuICAgICAgICBkID0gKGQgPDwgMzApIHwgKGQgPj4+IDIpO1xuICAgICAgICBmID0gKGMgJiBkKSB8ICh+YyAmIGUpO1xuICAgICAgICB0ID0gKGIgPDwgNSkgfCAoYiA+Pj4gMjcpO1xuICAgICAgICBhID0gKHQgKyBmICsgYSArIDE1MTg1MDAyNDkgKyBibG9ja3NbaiArIDRdKSA8PCAwO1xuICAgICAgICBjID0gKGMgPDwgMzApIHwgKGMgPj4+IDIpO1xuICAgIH1cbiAgICBmb3IgKDsgaiA8IDQwOyBqICs9IDUpIHtcbiAgICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgICAgdCA9IChhIDw8IDUpIHwgKGEgPj4+IDI3KTtcbiAgICAgICAgZSA9ICh0ICsgZiArIGUgKyAxODU5Nzc1MzkzICsgYmxvY2tzW2pdKSA8PCAwO1xuICAgICAgICBiID0gKGIgPDwgMzApIHwgKGIgPj4+IDIpO1xuICAgICAgICBmID0gYSBeIGIgXiBjO1xuICAgICAgICB0ID0gKGUgPDwgNSkgfCAoZSA+Pj4gMjcpO1xuICAgICAgICBkID0gKHQgKyBmICsgZCArIDE4NTk3NzUzOTMgKyBibG9ja3NbaiArIDFdKSA8PCAwO1xuICAgICAgICBhID0gKGEgPDwgMzApIHwgKGEgPj4+IDIpO1xuICAgICAgICBmID0gZSBeIGEgXiBiO1xuICAgICAgICB0ID0gKGQgPDwgNSkgfCAoZCA+Pj4gMjcpO1xuICAgICAgICBjID0gKHQgKyBmICsgYyArIDE4NTk3NzUzOTMgKyBibG9ja3NbaiArIDJdKSA8PCAwO1xuICAgICAgICBlID0gKGUgPDwgMzApIHwgKGUgPj4+IDIpO1xuICAgICAgICBmID0gZCBeIGUgXiBhO1xuICAgICAgICB0ID0gKGMgPDwgNSkgfCAoYyA+Pj4gMjcpO1xuICAgICAgICBiID0gKHQgKyBmICsgYiArIDE4NTk3NzUzOTMgKyBibG9ja3NbaiArIDNdKSA8PCAwO1xuICAgICAgICBkID0gKGQgPDwgMzApIHwgKGQgPj4+IDIpO1xuICAgICAgICBmID0gYyBeIGQgXiBlO1xuICAgICAgICB0ID0gKGIgPDwgNSkgfCAoYiA+Pj4gMjcpO1xuICAgICAgICBhID0gKHQgKyBmICsgYSArIDE4NTk3NzUzOTMgKyBibG9ja3NbaiArIDRdKSA8PCAwO1xuICAgICAgICBjID0gKGMgPDwgMzApIHwgKGMgPj4+IDIpO1xuICAgIH1cbiAgICBmb3IgKDsgaiA8IDYwOyBqICs9IDUpIHtcbiAgICAgICAgZiA9IChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKTtcbiAgICAgICAgdCA9IChhIDw8IDUpIHwgKGEgPj4+IDI3KTtcbiAgICAgICAgZSA9ICh0ICsgZiArIGUgLSAxODk0MDA3NTg4ICsgYmxvY2tzW2pdKSA8PCAwO1xuICAgICAgICBiID0gKGIgPDwgMzApIHwgKGIgPj4+IDIpO1xuICAgICAgICBmID0gKGEgJiBiKSB8IChhICYgYykgfCAoYiAmIGMpO1xuICAgICAgICB0ID0gKGUgPDwgNSkgfCAoZSA+Pj4gMjcpO1xuICAgICAgICBkID0gKHQgKyBmICsgZCAtIDE4OTQwMDc1ODggKyBibG9ja3NbaiArIDFdKSA8PCAwO1xuICAgICAgICBhID0gKGEgPDwgMzApIHwgKGEgPj4+IDIpO1xuICAgICAgICBmID0gKGUgJiBhKSB8IChlICYgYikgfCAoYSAmIGIpO1xuICAgICAgICB0ID0gKGQgPDwgNSkgfCAoZCA+Pj4gMjcpO1xuICAgICAgICBjID0gKHQgKyBmICsgYyAtIDE4OTQwMDc1ODggKyBibG9ja3NbaiArIDJdKSA8PCAwO1xuICAgICAgICBlID0gKGUgPDwgMzApIHwgKGUgPj4+IDIpO1xuICAgICAgICBmID0gKGQgJiBlKSB8IChkICYgYSkgfCAoZSAmIGEpO1xuICAgICAgICB0ID0gKGMgPDwgNSkgfCAoYyA+Pj4gMjcpO1xuICAgICAgICBiID0gKHQgKyBmICsgYiAtIDE4OTQwMDc1ODggKyBibG9ja3NbaiArIDNdKSA8PCAwO1xuICAgICAgICBkID0gKGQgPDwgMzApIHwgKGQgPj4+IDIpO1xuICAgICAgICBmID0gKGMgJiBkKSB8IChjICYgZSkgfCAoZCAmIGUpO1xuICAgICAgICB0ID0gKGIgPDwgNSkgfCAoYiA+Pj4gMjcpO1xuICAgICAgICBhID0gKHQgKyBmICsgYSAtIDE4OTQwMDc1ODggKyBibG9ja3NbaiArIDRdKSA8PCAwO1xuICAgICAgICBjID0gKGMgPDwgMzApIHwgKGMgPj4+IDIpO1xuICAgIH1cbiAgICBmb3IgKDsgaiA8IDgwOyBqICs9IDUpIHtcbiAgICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgICAgdCA9IChhIDw8IDUpIHwgKGEgPj4+IDI3KTtcbiAgICAgICAgZSA9ICh0ICsgZiArIGUgLSA4OTk0OTc1MTQgKyBibG9ja3Nbal0pIDw8IDA7XG4gICAgICAgIGIgPSAoYiA8PCAzMCkgfCAoYiA+Pj4gMik7XG4gICAgICAgIGYgPSBhIF4gYiBeIGM7XG4gICAgICAgIHQgPSAoZSA8PCA1KSB8IChlID4+PiAyNyk7XG4gICAgICAgIGQgPSAodCArIGYgKyBkIC0gODk5NDk3NTE0ICsgYmxvY2tzW2ogKyAxXSkgPDwgMDtcbiAgICAgICAgYSA9IChhIDw8IDMwKSB8IChhID4+PiAyKTtcbiAgICAgICAgZiA9IGUgXiBhIF4gYjtcbiAgICAgICAgdCA9IChkIDw8IDUpIHwgKGQgPj4+IDI3KTtcbiAgICAgICAgYyA9ICh0ICsgZiArIGMgLSA4OTk0OTc1MTQgKyBibG9ja3NbaiArIDJdKSA8PCAwO1xuICAgICAgICBlID0gKGUgPDwgMzApIHwgKGUgPj4+IDIpO1xuICAgICAgICBmID0gZCBeIGUgXiBhO1xuICAgICAgICB0ID0gKGMgPDwgNSkgfCAoYyA+Pj4gMjcpO1xuICAgICAgICBiID0gKHQgKyBmICsgYiAtIDg5OTQ5NzUxNCArIGJsb2Nrc1tqICsgM10pIDw8IDA7XG4gICAgICAgIGQgPSAoZCA8PCAzMCkgfCAoZCA+Pj4gMik7XG4gICAgICAgIGYgPSBjIF4gZCBeIGU7XG4gICAgICAgIHQgPSAoYiA8PCA1KSB8IChiID4+PiAyNyk7XG4gICAgICAgIGEgPSAodCArIGYgKyBhIC0gODk5NDk3NTE0ICsgYmxvY2tzW2ogKyA0XSkgPDwgMDtcbiAgICAgICAgYyA9IChjIDw8IDMwKSB8IChjID4+PiAyKTtcbiAgICB9XG4gICAgdGhpcy5oMCA9ICh0aGlzLmgwICsgYSkgPDwgMDtcbiAgICB0aGlzLmgxID0gKHRoaXMuaDEgKyBiKSA8PCAwO1xuICAgIHRoaXMuaDIgPSAodGhpcy5oMiArIGMpIDw8IDA7XG4gICAgdGhpcy5oMyA9ICh0aGlzLmgzICsgZCkgPDwgMDtcbiAgICB0aGlzLmg0ID0gKHRoaXMuaDQgKyBlKSA8PCAwO1xufTtcblNoYTEucHJvdG90eXBlLmhleCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbmFsaXplKCk7XG4gICAgdmFyIGgwID0gdGhpcy5oMCwgaDEgPSB0aGlzLmgxLCBoMiA9IHRoaXMuaDIsIGgzID0gdGhpcy5oMywgaDQgPSB0aGlzLmg0O1xuICAgIHJldHVybiAoSEVYX0NIQVJTWyhoMCA+PiAyOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDAgPj4gMjQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgwID4+IDIwKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMCA+PiAxNikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDAgPj4gMTIpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgwID4+IDgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgwID4+IDQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbaDAgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDEgPj4gMjgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgxID4+IDI0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMSA+PiAyMCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDEgPj4gMTYpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgxID4+IDEyKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMSA+PiA4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMSA+PiA0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTW2gxICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgyID4+IDI4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMiA+PiAyNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDIgPj4gMjApICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgyID4+IDE2KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMiA+PiAxMikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDIgPj4gOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDIgPj4gNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1toMiAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMyA+PiAyOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDMgPj4gMjQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgzID4+IDIwKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMyA+PiAxNikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDMgPj4gMTIpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgzID4+IDgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgzID4+IDQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbaDMgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDQgPj4gMjgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg0ID4+IDI0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNCA+PiAyMCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDQgPj4gMTYpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg0ID4+IDEyKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNCA+PiA4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNCA+PiA0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTW2g0ICYgMHgwZl0pO1xufTtcblNoYTEucHJvdG90eXBlLnRvU3RyaW5nID0gU2hhMS5wcm90b3R5cGUuaGV4O1xuU2hhMS5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcbiAgICB2YXIgaDAgPSB0aGlzLmgwLCBoMSA9IHRoaXMuaDEsIGgyID0gdGhpcy5oMiwgaDMgPSB0aGlzLmgzLCBoNCA9IHRoaXMuaDQ7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgKGgwID4+IDI0KSAmIDB4ZmYsXG4gICAgICAgIChoMCA+PiAxNikgJiAweGZmLFxuICAgICAgICAoaDAgPj4gOCkgJiAweGZmLFxuICAgICAgICBoMCAmIDB4ZmYsXG4gICAgICAgIChoMSA+PiAyNCkgJiAweGZmLFxuICAgICAgICAoaDEgPj4gMTYpICYgMHhmZixcbiAgICAgICAgKGgxID4+IDgpICYgMHhmZixcbiAgICAgICAgaDEgJiAweGZmLFxuICAgICAgICAoaDIgPj4gMjQpICYgMHhmZixcbiAgICAgICAgKGgyID4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChoMiA+PiA4KSAmIDB4ZmYsXG4gICAgICAgIGgyICYgMHhmZixcbiAgICAgICAgKGgzID4+IDI0KSAmIDB4ZmYsXG4gICAgICAgIChoMyA+PiAxNikgJiAweGZmLFxuICAgICAgICAoaDMgPj4gOCkgJiAweGZmLFxuICAgICAgICBoMyAmIDB4ZmYsXG4gICAgICAgIChoNCA+PiAyNCkgJiAweGZmLFxuICAgICAgICAoaDQgPj4gMTYpICYgMHhmZixcbiAgICAgICAgKGg0ID4+IDgpICYgMHhmZixcbiAgICAgICAgaDQgJiAweGZmLFxuICAgIF07XG59O1xuU2hhMS5wcm90b3R5cGUuYXJyYXkgPSBTaGExLnByb3RvdHlwZS5kaWdlc3Q7XG5TaGExLnByb3RvdHlwZS5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbmFsaXplKCk7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigyMCk7XG4gICAgdmFyIGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDAsIHRoaXMuaDApO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMig0LCB0aGlzLmgxKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoOCwgdGhpcy5oMik7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDEyLCB0aGlzLmgzKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoMTYsIHRoaXMuaDQpO1xuICAgIHJldHVybiBidWZmZXI7XG59O1xubGV0IGhhc0xvZ2dlZFdhcm5pbmcgPSBmYWxzZTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBtYWtlRGVmYXVsdEtleUVuY29kZXIoKWAgdG8gY3JlYXRlIGEgY3VzdG9tIGtleSBlbmNvZGVyLlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cbiAqL1xuY29uc3QgaW5zZWN1cmVIYXNoID0gKG1lc3NhZ2UpID0+IHtcbiAgICBpZiAoIWhhc0xvZ2dlZFdhcm5pbmcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFtcbiAgICAgICAgICAgIGBUaGUgZGVmYXVsdCBtZXRob2QgZm9yIGhhc2hpbmcga2V5cyBpcyBpbnNlY3VyZSBhbmQgd2lsbCBiZSByZXBsYWNlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLGAsXG4gICAgICAgICAgICBgYnV0IGhhc24ndCBiZWVuIHJlcGxhY2VkIHlldCBhcyB0byBub3QgYnJlYWsgZXhpc3RpbmcgY2FjaGVzLiBJdCdzIHJlY29tbWVuZGVkIHRoYXQgeW91IHVzZWAsXG4gICAgICAgICAgICBgYSBtb3JlIHNlY3VyZSBoYXNoaW5nIGFsZ29yaXRobSB0byBhdm9pZCBjYWNoZSBwb2lzb25pbmcuYCxcbiAgICAgICAgICAgIGBgLFxuICAgICAgICAgICAgYFNlZSB0aGlzIHBhZ2UgZm9yIG1vcmUgaW5mb3JtYXRpb246YCxcbiAgICAgICAgICAgIGB8YCxcbiAgICAgICAgICAgIGDilJQ+IGh0dHBzOi8vanMubGFuZ2NoYWluLmNvbS9kb2NzL3Ryb3VibGVzaG9vdGluZy93YXJuaW5ncy9pbnNlY3VyZS1jYWNoZS1hbGdvcml0aG1gLFxuICAgICAgICBdLmpvaW4oXCJcXG5cIikpO1xuICAgICAgICBoYXNMb2dnZWRXYXJuaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTaGExKHRydWUpLnVwZGF0ZShtZXNzYWdlKVtcImhleFwiXSgpO1xufTtcbmV4cG9ydHMuaW5zZWN1cmVIYXNoID0gaW5zZWN1cmVIYXNoO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/js-sha1/hash.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/js-sha256/hash.cjs":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/js-sha256/hash.cjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("// @ts-nocheck\n// Inlined to deal with portability issues with importing crypto module\n/**\n * [js-sha256]{@link https://github.com/emn178/js-sha256}\n *\n * @version 0.11.1\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2014-2025\n * @license MIT\n */\n/*jslint bitwise: true */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sha256 = void 0;\nvar HEX_CHARS = \"0123456789abcdef\".split(\"\");\nvar EXTRA = [-2147483648, 8388608, 32768, 128];\nvar SHIFT = [24, 16, 8, 0];\nvar K = [\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,\n    0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,\n    0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n    0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,\n    0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,\n    0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,\n];\nvar OUTPUT_TYPES = [\"hex\", \"array\", \"digest\", \"arrayBuffer\"];\nvar blocks = [];\nfunction Sha256(is224, sharedMemory) {\n    if (sharedMemory) {\n        blocks[0] =\n            blocks[16] =\n                blocks[1] =\n                    blocks[2] =\n                        blocks[3] =\n                            blocks[4] =\n                                blocks[5] =\n                                    blocks[6] =\n                                        blocks[7] =\n                                            blocks[8] =\n                                                blocks[9] =\n                                                    blocks[10] =\n                                                        blocks[11] =\n                                                            blocks[12] =\n                                                                blocks[13] =\n                                                                    blocks[14] =\n                                                                        blocks[15] =\n                                                                            0;\n        this.blocks = blocks;\n    }\n    else {\n        this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    }\n    if (is224) {\n        this.h0 = 0xc1059ed8;\n        this.h1 = 0x367cd507;\n        this.h2 = 0x3070dd17;\n        this.h3 = 0xf70e5939;\n        this.h4 = 0xffc00b31;\n        this.h5 = 0x68581511;\n        this.h6 = 0x64f98fa7;\n        this.h7 = 0xbefa4fa4;\n    }\n    else {\n        // 256\n        this.h0 = 0x6a09e667;\n        this.h1 = 0xbb67ae85;\n        this.h2 = 0x3c6ef372;\n        this.h3 = 0xa54ff53a;\n        this.h4 = 0x510e527f;\n        this.h5 = 0x9b05688c;\n        this.h6 = 0x1f83d9ab;\n        this.h7 = 0x5be0cd19;\n    }\n    this.block = this.start = this.bytes = this.hBytes = 0;\n    this.finalized = this.hashed = false;\n    this.first = true;\n    this.is224 = is224;\n}\nSha256.prototype.update = function (message) {\n    if (this.finalized) {\n        return;\n    }\n    var notString, type = typeof message;\n    if (type !== \"string\") {\n        if (type === \"object\") {\n            if (message === null) {\n                throw new Error(ERROR);\n            }\n            else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {\n                message = new Uint8Array(message);\n            }\n            else if (!Array.isArray(message)) {\n                if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {\n                    throw new Error(ERROR);\n                }\n            }\n        }\n        else {\n            throw new Error(ERROR);\n        }\n        notString = true;\n    }\n    var code, index = 0, i, length = message.length, blocks = this.blocks;\n    while (index < length) {\n        if (this.hashed) {\n            this.hashed = false;\n            blocks[0] = this.block;\n            this.block =\n                blocks[16] =\n                    blocks[1] =\n                        blocks[2] =\n                            blocks[3] =\n                                blocks[4] =\n                                    blocks[5] =\n                                        blocks[6] =\n                                            blocks[7] =\n                                                blocks[8] =\n                                                    blocks[9] =\n                                                        blocks[10] =\n                                                            blocks[11] =\n                                                                blocks[12] =\n                                                                    blocks[13] =\n                                                                        blocks[14] =\n                                                                            blocks[15] =\n                                                                                0;\n        }\n        if (notString) {\n            for (i = this.start; index < length && i < 64; ++index) {\n                blocks[i >>> 2] |= message[index] << SHIFT[i++ & 3];\n            }\n        }\n        else {\n            for (i = this.start; index < length && i < 64; ++index) {\n                code = message.charCodeAt(index);\n                if (code < 0x80) {\n                    blocks[i >>> 2] |= code << SHIFT[i++ & 3];\n                }\n                else if (code < 0x800) {\n                    blocks[i >>> 2] |= (0xc0 | (code >>> 6)) << SHIFT[i++ & 3];\n                    blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n                }\n                else if (code < 0xd800 || code >= 0xe000) {\n                    blocks[i >>> 2] |= (0xe0 | (code >>> 12)) << SHIFT[i++ & 3];\n                    blocks[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFT[i++ & 3];\n                    blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n                }\n                else {\n                    code =\n                        0x10000 +\n                            (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n                    blocks[i >>> 2] |= (0xf0 | (code >>> 18)) << SHIFT[i++ & 3];\n                    blocks[i >>> 2] |= (0x80 | ((code >>> 12) & 0x3f)) << SHIFT[i++ & 3];\n                    blocks[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFT[i++ & 3];\n                    blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n                }\n            }\n        }\n        this.lastByteIndex = i;\n        this.bytes += i - this.start;\n        if (i >= 64) {\n            this.block = blocks[16];\n            this.start = i - 64;\n            this.hash();\n            this.hashed = true;\n        }\n        else {\n            this.start = i;\n        }\n    }\n    if (this.bytes > 4294967295) {\n        this.hBytes += (this.bytes / 4294967296) << 0;\n        this.bytes = this.bytes % 4294967296;\n    }\n    return this;\n};\nSha256.prototype.finalize = function () {\n    if (this.finalized) {\n        return;\n    }\n    this.finalized = true;\n    var blocks = this.blocks, i = this.lastByteIndex;\n    blocks[16] = this.block;\n    blocks[i >>> 2] |= EXTRA[i & 3];\n    this.block = blocks[16];\n    if (i >= 56) {\n        if (!this.hashed) {\n            this.hash();\n        }\n        blocks[0] = this.block;\n        blocks[16] =\n            blocks[1] =\n                blocks[2] =\n                    blocks[3] =\n                        blocks[4] =\n                            blocks[5] =\n                                blocks[6] =\n                                    blocks[7] =\n                                        blocks[8] =\n                                            blocks[9] =\n                                                blocks[10] =\n                                                    blocks[11] =\n                                                        blocks[12] =\n                                                            blocks[13] =\n                                                                blocks[14] =\n                                                                    blocks[15] =\n                                                                        0;\n    }\n    blocks[14] = (this.hBytes << 3) | (this.bytes >>> 29);\n    blocks[15] = this.bytes << 3;\n    this.hash();\n};\nSha256.prototype.hash = function () {\n    var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6, h = this.h7, blocks = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;\n    for (j = 16; j < 64; ++j) {\n        // rightrotate\n        t1 = blocks[j - 15];\n        s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);\n        t1 = blocks[j - 2];\n        s1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);\n        blocks[j] = (blocks[j - 16] + s0 + blocks[j - 7] + s1) << 0;\n    }\n    bc = b & c;\n    for (j = 0; j < 64; j += 4) {\n        if (this.first) {\n            if (this.is224) {\n                ab = 300032;\n                t1 = blocks[0] - 1413257819;\n                h = (t1 - 150054599) << 0;\n                d = (t1 + 24177077) << 0;\n            }\n            else {\n                ab = 704751109;\n                t1 = blocks[0] - 210244248;\n                h = (t1 - 1521486534) << 0;\n                d = (t1 + 143694565) << 0;\n            }\n            this.first = false;\n        }\n        else {\n            s0 =\n                ((a >>> 2) | (a << 30)) ^\n                    ((a >>> 13) | (a << 19)) ^\n                    ((a >>> 22) | (a << 10));\n            s1 =\n                ((e >>> 6) | (e << 26)) ^\n                    ((e >>> 11) | (e << 21)) ^\n                    ((e >>> 25) | (e << 7));\n            ab = a & b;\n            maj = ab ^ (a & c) ^ bc;\n            ch = (e & f) ^ (~e & g);\n            t1 = h + s1 + ch + K[j] + blocks[j];\n            t2 = s0 + maj;\n            h = (d + t1) << 0;\n            d = (t1 + t2) << 0;\n        }\n        s0 =\n            ((d >>> 2) | (d << 30)) ^\n                ((d >>> 13) | (d << 19)) ^\n                ((d >>> 22) | (d << 10));\n        s1 =\n            ((h >>> 6) | (h << 26)) ^\n                ((h >>> 11) | (h << 21)) ^\n                ((h >>> 25) | (h << 7));\n        da = d & a;\n        maj = da ^ (d & b) ^ ab;\n        ch = (g & h) ^ (~g & e);\n        t1 = f + s1 + ch + K[j + 1] + blocks[j + 1];\n        t2 = s0 + maj;\n        g = (c + t1) << 0;\n        c = (t1 + t2) << 0;\n        s0 =\n            ((c >>> 2) | (c << 30)) ^\n                ((c >>> 13) | (c << 19)) ^\n                ((c >>> 22) | (c << 10));\n        s1 =\n            ((g >>> 6) | (g << 26)) ^\n                ((g >>> 11) | (g << 21)) ^\n                ((g >>> 25) | (g << 7));\n        cd = c & d;\n        maj = cd ^ (c & a) ^ da;\n        ch = (f & g) ^ (~f & h);\n        t1 = e + s1 + ch + K[j + 2] + blocks[j + 2];\n        t2 = s0 + maj;\n        f = (b + t1) << 0;\n        b = (t1 + t2) << 0;\n        s0 =\n            ((b >>> 2) | (b << 30)) ^\n                ((b >>> 13) | (b << 19)) ^\n                ((b >>> 22) | (b << 10));\n        s1 =\n            ((f >>> 6) | (f << 26)) ^\n                ((f >>> 11) | (f << 21)) ^\n                ((f >>> 25) | (f << 7));\n        bc = b & c;\n        maj = bc ^ (b & d) ^ cd;\n        ch = (f & g) ^ (~f & h);\n        t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];\n        t2 = s0 + maj;\n        e = (a + t1) << 0;\n        a = (t1 + t2) << 0;\n        this.chromeBugWorkAround = true;\n    }\n    this.h0 = (this.h0 + a) << 0;\n    this.h1 = (this.h1 + b) << 0;\n    this.h2 = (this.h2 + c) << 0;\n    this.h3 = (this.h3 + d) << 0;\n    this.h4 = (this.h4 + e) << 0;\n    this.h5 = (this.h5 + f) << 0;\n    this.h6 = (this.h6 + g) << 0;\n    this.h7 = (this.h7 + h) << 0;\n};\nSha256.prototype.hex = function () {\n    this.finalize();\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;\n    var hex = HEX_CHARS[(h0 >>> 28) & 0x0f] +\n        HEX_CHARS[(h0 >>> 24) & 0x0f] +\n        HEX_CHARS[(h0 >>> 20) & 0x0f] +\n        HEX_CHARS[(h0 >>> 16) & 0x0f] +\n        HEX_CHARS[(h0 >>> 12) & 0x0f] +\n        HEX_CHARS[(h0 >>> 8) & 0x0f] +\n        HEX_CHARS[(h0 >>> 4) & 0x0f] +\n        HEX_CHARS[h0 & 0x0f] +\n        HEX_CHARS[(h1 >>> 28) & 0x0f] +\n        HEX_CHARS[(h1 >>> 24) & 0x0f] +\n        HEX_CHARS[(h1 >>> 20) & 0x0f] +\n        HEX_CHARS[(h1 >>> 16) & 0x0f] +\n        HEX_CHARS[(h1 >>> 12) & 0x0f] +\n        HEX_CHARS[(h1 >>> 8) & 0x0f] +\n        HEX_CHARS[(h1 >>> 4) & 0x0f] +\n        HEX_CHARS[h1 & 0x0f] +\n        HEX_CHARS[(h2 >>> 28) & 0x0f] +\n        HEX_CHARS[(h2 >>> 24) & 0x0f] +\n        HEX_CHARS[(h2 >>> 20) & 0x0f] +\n        HEX_CHARS[(h2 >>> 16) & 0x0f] +\n        HEX_CHARS[(h2 >>> 12) & 0x0f] +\n        HEX_CHARS[(h2 >>> 8) & 0x0f] +\n        HEX_CHARS[(h2 >>> 4) & 0x0f] +\n        HEX_CHARS[h2 & 0x0f] +\n        HEX_CHARS[(h3 >>> 28) & 0x0f] +\n        HEX_CHARS[(h3 >>> 24) & 0x0f] +\n        HEX_CHARS[(h3 >>> 20) & 0x0f] +\n        HEX_CHARS[(h3 >>> 16) & 0x0f] +\n        HEX_CHARS[(h3 >>> 12) & 0x0f] +\n        HEX_CHARS[(h3 >>> 8) & 0x0f] +\n        HEX_CHARS[(h3 >>> 4) & 0x0f] +\n        HEX_CHARS[h3 & 0x0f] +\n        HEX_CHARS[(h4 >>> 28) & 0x0f] +\n        HEX_CHARS[(h4 >>> 24) & 0x0f] +\n        HEX_CHARS[(h4 >>> 20) & 0x0f] +\n        HEX_CHARS[(h4 >>> 16) & 0x0f] +\n        HEX_CHARS[(h4 >>> 12) & 0x0f] +\n        HEX_CHARS[(h4 >>> 8) & 0x0f] +\n        HEX_CHARS[(h4 >>> 4) & 0x0f] +\n        HEX_CHARS[h4 & 0x0f] +\n        HEX_CHARS[(h5 >>> 28) & 0x0f] +\n        HEX_CHARS[(h5 >>> 24) & 0x0f] +\n        HEX_CHARS[(h5 >>> 20) & 0x0f] +\n        HEX_CHARS[(h5 >>> 16) & 0x0f] +\n        HEX_CHARS[(h5 >>> 12) & 0x0f] +\n        HEX_CHARS[(h5 >>> 8) & 0x0f] +\n        HEX_CHARS[(h5 >>> 4) & 0x0f] +\n        HEX_CHARS[h5 & 0x0f] +\n        HEX_CHARS[(h6 >>> 28) & 0x0f] +\n        HEX_CHARS[(h6 >>> 24) & 0x0f] +\n        HEX_CHARS[(h6 >>> 20) & 0x0f] +\n        HEX_CHARS[(h6 >>> 16) & 0x0f] +\n        HEX_CHARS[(h6 >>> 12) & 0x0f] +\n        HEX_CHARS[(h6 >>> 8) & 0x0f] +\n        HEX_CHARS[(h6 >>> 4) & 0x0f] +\n        HEX_CHARS[h6 & 0x0f];\n    if (!this.is224) {\n        hex +=\n            HEX_CHARS[(h7 >>> 28) & 0x0f] +\n                HEX_CHARS[(h7 >>> 24) & 0x0f] +\n                HEX_CHARS[(h7 >>> 20) & 0x0f] +\n                HEX_CHARS[(h7 >>> 16) & 0x0f] +\n                HEX_CHARS[(h7 >>> 12) & 0x0f] +\n                HEX_CHARS[(h7 >>> 8) & 0x0f] +\n                HEX_CHARS[(h7 >>> 4) & 0x0f] +\n                HEX_CHARS[h7 & 0x0f];\n    }\n    return hex;\n};\nSha256.prototype.toString = Sha256.prototype.hex;\nSha256.prototype.digest = function () {\n    this.finalize();\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;\n    var arr = [\n        (h0 >>> 24) & 0xff,\n        (h0 >>> 16) & 0xff,\n        (h0 >>> 8) & 0xff,\n        h0 & 0xff,\n        (h1 >>> 24) & 0xff,\n        (h1 >>> 16) & 0xff,\n        (h1 >>> 8) & 0xff,\n        h1 & 0xff,\n        (h2 >>> 24) & 0xff,\n        (h2 >>> 16) & 0xff,\n        (h2 >>> 8) & 0xff,\n        h2 & 0xff,\n        (h3 >>> 24) & 0xff,\n        (h3 >>> 16) & 0xff,\n        (h3 >>> 8) & 0xff,\n        h3 & 0xff,\n        (h4 >>> 24) & 0xff,\n        (h4 >>> 16) & 0xff,\n        (h4 >>> 8) & 0xff,\n        h4 & 0xff,\n        (h5 >>> 24) & 0xff,\n        (h5 >>> 16) & 0xff,\n        (h5 >>> 8) & 0xff,\n        h5 & 0xff,\n        (h6 >>> 24) & 0xff,\n        (h6 >>> 16) & 0xff,\n        (h6 >>> 8) & 0xff,\n        h6 & 0xff,\n    ];\n    if (!this.is224) {\n        arr.push((h7 >>> 24) & 0xff, (h7 >>> 16) & 0xff, (h7 >>> 8) & 0xff, h7 & 0xff);\n    }\n    return arr;\n};\nSha256.prototype.array = Sha256.prototype.digest;\nSha256.prototype.arrayBuffer = function () {\n    this.finalize();\n    var buffer = new ArrayBuffer(this.is224 ? 28 : 32);\n    var dataView = new DataView(buffer);\n    dataView.setUint32(0, this.h0);\n    dataView.setUint32(4, this.h1);\n    dataView.setUint32(8, this.h2);\n    dataView.setUint32(12, this.h3);\n    dataView.setUint32(16, this.h4);\n    dataView.setUint32(20, this.h5);\n    dataView.setUint32(24, this.h6);\n    if (!this.is224) {\n        dataView.setUint32(28, this.h7);\n    }\n    return buffer;\n};\nconst sha256 = (...strings) => {\n    return new Sha256(false, true).update(strings.join(\"\")).hex();\n};\nexports.sha256 = sha256;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvanMtc2hhMjU2L2hhc2guY2pzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwQkFBMEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMEJBQTBCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2pzLXNoYTI1Ni9oYXNoLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAdHMtbm9jaGVja1xuLy8gSW5saW5lZCB0byBkZWFsIHdpdGggcG9ydGFiaWxpdHkgaXNzdWVzIHdpdGggaW1wb3J0aW5nIGNyeXB0byBtb2R1bGVcbi8qKlxuICogW2pzLXNoYTI1Nl17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2VtbjE3OC9qcy1zaGEyNTZ9XG4gKlxuICogQHZlcnNpb24gMC4xMS4xXG4gKiBAYXV0aG9yIENoZW4sIFlpLUN5dWFuIFtlbW4xNzhAZ21haWwuY29tXVxuICogQGNvcHlyaWdodCBDaGVuLCBZaS1DeXVhbiAyMDE0LTIwMjVcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4vKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hhMjU2ID0gdm9pZCAwO1xudmFyIEhFWF9DSEFSUyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiLnNwbGl0KFwiXCIpO1xudmFyIEVYVFJBID0gWy0yMTQ3NDgzNjQ4LCA4Mzg4NjA4LCAzMjc2OCwgMTI4XTtcbnZhciBTSElGVCA9IFsyNCwgMTYsIDgsIDBdO1xudmFyIEsgPSBbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSxcbiAgICAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LCAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLFxuICAgIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsXG4gICAgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LFxuICAgIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsXG4gICAgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSwgMHhhMmJmZThhMSwgMHhhODFhNjY0YixcbiAgICAweGMyNGI4YjcwLCAweGM3NmM1MWEzLCAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAgIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsXG4gICAgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMywgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCxcbiAgICAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyLFxuXTtcbnZhciBPVVRQVVRfVFlQRVMgPSBbXCJoZXhcIiwgXCJhcnJheVwiLCBcImRpZ2VzdFwiLCBcImFycmF5QnVmZmVyXCJdO1xudmFyIGJsb2NrcyA9IFtdO1xuZnVuY3Rpb24gU2hhMjU2KGlzMjI0LCBzaGFyZWRNZW1vcnkpIHtcbiAgICBpZiAoc2hhcmVkTWVtb3J5KSB7XG4gICAgICAgIGJsb2Nrc1swXSA9XG4gICAgICAgICAgICBibG9ja3NbMTZdID1cbiAgICAgICAgICAgICAgICBibG9ja3NbMV0gPVxuICAgICAgICAgICAgICAgICAgICBibG9ja3NbMl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzNdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzZdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbN10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbOF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzldID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTBdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzExXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTJdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTNdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzE0XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwO1xuICAgICAgICB0aGlzLmJsb2NrcyA9IGJsb2NrcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuYmxvY2tzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICAgIH1cbiAgICBpZiAoaXMyMjQpIHtcbiAgICAgICAgdGhpcy5oMCA9IDB4YzEwNTllZDg7XG4gICAgICAgIHRoaXMuaDEgPSAweDM2N2NkNTA3O1xuICAgICAgICB0aGlzLmgyID0gMHgzMDcwZGQxNztcbiAgICAgICAgdGhpcy5oMyA9IDB4ZjcwZTU5Mzk7XG4gICAgICAgIHRoaXMuaDQgPSAweGZmYzAwYjMxO1xuICAgICAgICB0aGlzLmg1ID0gMHg2ODU4MTUxMTtcbiAgICAgICAgdGhpcy5oNiA9IDB4NjRmOThmYTc7XG4gICAgICAgIHRoaXMuaDcgPSAweGJlZmE0ZmE0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gMjU2XG4gICAgICAgIHRoaXMuaDAgPSAweDZhMDllNjY3O1xuICAgICAgICB0aGlzLmgxID0gMHhiYjY3YWU4NTtcbiAgICAgICAgdGhpcy5oMiA9IDB4M2M2ZWYzNzI7XG4gICAgICAgIHRoaXMuaDMgPSAweGE1NGZmNTNhO1xuICAgICAgICB0aGlzLmg0ID0gMHg1MTBlNTI3ZjtcbiAgICAgICAgdGhpcy5oNSA9IDB4OWIwNTY4OGM7XG4gICAgICAgIHRoaXMuaDYgPSAweDFmODNkOWFiO1xuICAgICAgICB0aGlzLmg3ID0gMHg1YmUwY2QxOTtcbiAgICB9XG4gICAgdGhpcy5ibG9jayA9IHRoaXMuc3RhcnQgPSB0aGlzLmJ5dGVzID0gdGhpcy5oQnl0ZXMgPSAwO1xuICAgIHRoaXMuZmluYWxpemVkID0gdGhpcy5oYXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmZpcnN0ID0gdHJ1ZTtcbiAgICB0aGlzLmlzMjI0ID0gaXMyMjQ7XG59XG5TaGEyNTYucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vdFN0cmluZywgdHlwZSA9IHR5cGVvZiBtZXNzYWdlO1xuICAgIGlmICh0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBUlJBWV9CVUZGRVIgJiYgbWVzc2FnZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIGlmICghQVJSQVlfQlVGRkVSIHx8ICFBcnJheUJ1ZmZlci5pc1ZpZXcobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1IpO1xuICAgICAgICB9XG4gICAgICAgIG5vdFN0cmluZyA9IHRydWU7XG4gICAgfVxuICAgIHZhciBjb2RlLCBpbmRleCA9IDAsIGksIGxlbmd0aCA9IG1lc3NhZ2UubGVuZ3RoLCBibG9ja3MgPSB0aGlzLmJsb2NrcztcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzaGVkKSB7XG4gICAgICAgICAgICB0aGlzLmhhc2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgYmxvY2tzWzBdID0gdGhpcy5ibG9jaztcbiAgICAgICAgICAgIHRoaXMuYmxvY2sgPVxuICAgICAgICAgICAgICAgIGJsb2Nrc1sxNl0gPVxuICAgICAgICAgICAgICAgICAgICBibG9ja3NbMV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzJdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbM10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbN10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzhdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbOV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTBdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTNdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxNF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxNV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub3RTdHJpbmcpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IHRoaXMuc3RhcnQ7IGluZGV4IDwgbGVuZ3RoICYmIGkgPCA2NDsgKytpbmRleCkge1xuICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+PiAyXSB8PSBtZXNzYWdlW2luZGV4XSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaSA9IHRoaXMuc3RhcnQ7IGluZGV4IDwgbGVuZ3RoICYmIGkgPCA2NDsgKytpbmRleCkge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBtZXNzYWdlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlIDwgMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+Pj4gMl0gfD0gY29kZSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+PiAyXSB8PSAoMHhjMCB8IChjb2RlID4+PiA2KSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb2RlIDwgMHhkODAwIHx8IGNvZGUgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+PiAyXSB8PSAoMHhlMCB8IChjb2RlID4+PiAxMikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+Pj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4+IDYpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+Pj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgMHgxMDAwMCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCgoY29kZSAmIDB4M2ZmKSA8PCAxMCkgfCAobWVzc2FnZS5jaGFyQ29kZUF0KCsraW5kZXgpICYgMHgzZmYpKTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4+IDJdIHw9ICgweGYwIHwgKGNvZGUgPj4+IDE4KSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+Pj4gMTIpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+Pj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4+IDYpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+Pj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0Qnl0ZUluZGV4ID0gaTtcbiAgICAgICAgdGhpcy5ieXRlcyArPSBpIC0gdGhpcy5zdGFydDtcbiAgICAgICAgaWYgKGkgPj0gNjQpIHtcbiAgICAgICAgICAgIHRoaXMuYmxvY2sgPSBibG9ja3NbMTZdO1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IGkgLSA2NDtcbiAgICAgICAgICAgIHRoaXMuaGFzaCgpO1xuICAgICAgICAgICAgdGhpcy5oYXNoZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuYnl0ZXMgPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgIHRoaXMuaEJ5dGVzICs9ICh0aGlzLmJ5dGVzIC8gNDI5NDk2NzI5NikgPDwgMDtcbiAgICAgICAgdGhpcy5ieXRlcyA9IHRoaXMuYnl0ZXMgJSA0Mjk0OTY3Mjk2O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5TaGEyNTYucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZmluYWxpemVkID0gdHJ1ZTtcbiAgICB2YXIgYmxvY2tzID0gdGhpcy5ibG9ja3MsIGkgPSB0aGlzLmxhc3RCeXRlSW5kZXg7XG4gICAgYmxvY2tzWzE2XSA9IHRoaXMuYmxvY2s7XG4gICAgYmxvY2tzW2kgPj4+IDJdIHw9IEVYVFJBW2kgJiAzXTtcbiAgICB0aGlzLmJsb2NrID0gYmxvY2tzWzE2XTtcbiAgICBpZiAoaSA+PSA1Nikge1xuICAgICAgICBpZiAoIXRoaXMuaGFzaGVkKSB7XG4gICAgICAgICAgICB0aGlzLmhhc2goKTtcbiAgICAgICAgfVxuICAgICAgICBibG9ja3NbMF0gPSB0aGlzLmJsb2NrO1xuICAgICAgICBibG9ja3NbMTZdID1cbiAgICAgICAgICAgIGJsb2Nrc1sxXSA9XG4gICAgICAgICAgICAgICAgYmxvY2tzWzJdID1cbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzNdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s0XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzZdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s3XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzhdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzldID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTJdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxM10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxNF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDA7XG4gICAgfVxuICAgIGJsb2Nrc1sxNF0gPSAodGhpcy5oQnl0ZXMgPDwgMykgfCAodGhpcy5ieXRlcyA+Pj4gMjkpO1xuICAgIGJsb2Nrc1sxNV0gPSB0aGlzLmJ5dGVzIDw8IDM7XG4gICAgdGhpcy5oYXNoKCk7XG59O1xuU2hhMjU2LnByb3RvdHlwZS5oYXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhID0gdGhpcy5oMCwgYiA9IHRoaXMuaDEsIGMgPSB0aGlzLmgyLCBkID0gdGhpcy5oMywgZSA9IHRoaXMuaDQsIGYgPSB0aGlzLmg1LCBnID0gdGhpcy5oNiwgaCA9IHRoaXMuaDcsIGJsb2NrcyA9IHRoaXMuYmxvY2tzLCBqLCBzMCwgczEsIG1haiwgdDEsIHQyLCBjaCwgYWIsIGRhLCBjZCwgYmM7XG4gICAgZm9yIChqID0gMTY7IGogPCA2NDsgKytqKSB7XG4gICAgICAgIC8vIHJpZ2h0cm90YXRlXG4gICAgICAgIHQxID0gYmxvY2tzW2ogLSAxNV07XG4gICAgICAgIHMwID0gKCh0MSA+Pj4gNykgfCAodDEgPDwgMjUpKSBeICgodDEgPj4+IDE4KSB8ICh0MSA8PCAxNCkpIF4gKHQxID4+PiAzKTtcbiAgICAgICAgdDEgPSBibG9ja3NbaiAtIDJdO1xuICAgICAgICBzMSA9ICgodDEgPj4+IDE3KSB8ICh0MSA8PCAxNSkpIF4gKCh0MSA+Pj4gMTkpIHwgKHQxIDw8IDEzKSkgXiAodDEgPj4+IDEwKTtcbiAgICAgICAgYmxvY2tzW2pdID0gKGJsb2Nrc1tqIC0gMTZdICsgczAgKyBibG9ja3NbaiAtIDddICsgczEpIDw8IDA7XG4gICAgfVxuICAgIGJjID0gYiAmIGM7XG4gICAgZm9yIChqID0gMDsgaiA8IDY0OyBqICs9IDQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlyc3QpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzMjI0KSB7XG4gICAgICAgICAgICAgICAgYWIgPSAzMDAwMzI7XG4gICAgICAgICAgICAgICAgdDEgPSBibG9ja3NbMF0gLSAxNDEzMjU3ODE5O1xuICAgICAgICAgICAgICAgIGggPSAodDEgLSAxNTAwNTQ1OTkpIDw8IDA7XG4gICAgICAgICAgICAgICAgZCA9ICh0MSArIDI0MTc3MDc3KSA8PCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWIgPSA3MDQ3NTExMDk7XG4gICAgICAgICAgICAgICAgdDEgPSBibG9ja3NbMF0gLSAyMTAyNDQyNDg7XG4gICAgICAgICAgICAgICAgaCA9ICh0MSAtIDE1MjE0ODY1MzQpIDw8IDA7XG4gICAgICAgICAgICAgICAgZCA9ICh0MSArIDE0MzY5NDU2NSkgPDwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHMwID1cbiAgICAgICAgICAgICAgICAoKGEgPj4+IDIpIHwgKGEgPDwgMzApKSBeXG4gICAgICAgICAgICAgICAgICAgICgoYSA+Pj4gMTMpIHwgKGEgPDwgMTkpKSBeXG4gICAgICAgICAgICAgICAgICAgICgoYSA+Pj4gMjIpIHwgKGEgPDwgMTApKTtcbiAgICAgICAgICAgIHMxID1cbiAgICAgICAgICAgICAgICAoKGUgPj4+IDYpIHwgKGUgPDwgMjYpKSBeXG4gICAgICAgICAgICAgICAgICAgICgoZSA+Pj4gMTEpIHwgKGUgPDwgMjEpKSBeXG4gICAgICAgICAgICAgICAgICAgICgoZSA+Pj4gMjUpIHwgKGUgPDwgNykpO1xuICAgICAgICAgICAgYWIgPSBhICYgYjtcbiAgICAgICAgICAgIG1haiA9IGFiIF4gKGEgJiBjKSBeIGJjO1xuICAgICAgICAgICAgY2ggPSAoZSAmIGYpIF4gKH5lICYgZyk7XG4gICAgICAgICAgICB0MSA9IGggKyBzMSArIGNoICsgS1tqXSArIGJsb2Nrc1tqXTtcbiAgICAgICAgICAgIHQyID0gczAgKyBtYWo7XG4gICAgICAgICAgICBoID0gKGQgKyB0MSkgPDwgMDtcbiAgICAgICAgICAgIGQgPSAodDEgKyB0MikgPDwgMDtcbiAgICAgICAgfVxuICAgICAgICBzMCA9XG4gICAgICAgICAgICAoKGQgPj4+IDIpIHwgKGQgPDwgMzApKSBeXG4gICAgICAgICAgICAgICAgKChkID4+PiAxMykgfCAoZCA8PCAxOSkpIF5cbiAgICAgICAgICAgICAgICAoKGQgPj4+IDIyKSB8IChkIDw8IDEwKSk7XG4gICAgICAgIHMxID1cbiAgICAgICAgICAgICgoaCA+Pj4gNikgfCAoaCA8PCAyNikpIF5cbiAgICAgICAgICAgICAgICAoKGggPj4+IDExKSB8IChoIDw8IDIxKSkgXlxuICAgICAgICAgICAgICAgICgoaCA+Pj4gMjUpIHwgKGggPDwgNykpO1xuICAgICAgICBkYSA9IGQgJiBhO1xuICAgICAgICBtYWogPSBkYSBeIChkICYgYikgXiBhYjtcbiAgICAgICAgY2ggPSAoZyAmIGgpIF4gKH5nICYgZSk7XG4gICAgICAgIHQxID0gZiArIHMxICsgY2ggKyBLW2ogKyAxXSArIGJsb2Nrc1tqICsgMV07XG4gICAgICAgIHQyID0gczAgKyBtYWo7XG4gICAgICAgIGcgPSAoYyArIHQxKSA8PCAwO1xuICAgICAgICBjID0gKHQxICsgdDIpIDw8IDA7XG4gICAgICAgIHMwID1cbiAgICAgICAgICAgICgoYyA+Pj4gMikgfCAoYyA8PCAzMCkpIF5cbiAgICAgICAgICAgICAgICAoKGMgPj4+IDEzKSB8IChjIDw8IDE5KSkgXlxuICAgICAgICAgICAgICAgICgoYyA+Pj4gMjIpIHwgKGMgPDwgMTApKTtcbiAgICAgICAgczEgPVxuICAgICAgICAgICAgKChnID4+PiA2KSB8IChnIDw8IDI2KSkgXlxuICAgICAgICAgICAgICAgICgoZyA+Pj4gMTEpIHwgKGcgPDwgMjEpKSBeXG4gICAgICAgICAgICAgICAgKChnID4+PiAyNSkgfCAoZyA8PCA3KSk7XG4gICAgICAgIGNkID0gYyAmIGQ7XG4gICAgICAgIG1haiA9IGNkIF4gKGMgJiBhKSBeIGRhO1xuICAgICAgICBjaCA9IChmICYgZykgXiAofmYgJiBoKTtcbiAgICAgICAgdDEgPSBlICsgczEgKyBjaCArIEtbaiArIDJdICsgYmxvY2tzW2ogKyAyXTtcbiAgICAgICAgdDIgPSBzMCArIG1hajtcbiAgICAgICAgZiA9IChiICsgdDEpIDw8IDA7XG4gICAgICAgIGIgPSAodDEgKyB0MikgPDwgMDtcbiAgICAgICAgczAgPVxuICAgICAgICAgICAgKChiID4+PiAyKSB8IChiIDw8IDMwKSkgXlxuICAgICAgICAgICAgICAgICgoYiA+Pj4gMTMpIHwgKGIgPDwgMTkpKSBeXG4gICAgICAgICAgICAgICAgKChiID4+PiAyMikgfCAoYiA8PCAxMCkpO1xuICAgICAgICBzMSA9XG4gICAgICAgICAgICAoKGYgPj4+IDYpIHwgKGYgPDwgMjYpKSBeXG4gICAgICAgICAgICAgICAgKChmID4+PiAxMSkgfCAoZiA8PCAyMSkpIF5cbiAgICAgICAgICAgICAgICAoKGYgPj4+IDI1KSB8IChmIDw8IDcpKTtcbiAgICAgICAgYmMgPSBiICYgYztcbiAgICAgICAgbWFqID0gYmMgXiAoYiAmIGQpIF4gY2Q7XG4gICAgICAgIGNoID0gKGYgJiBnKSBeICh+ZiAmIGgpO1xuICAgICAgICB0MSA9IGUgKyBzMSArIGNoICsgS1tqICsgM10gKyBibG9ja3NbaiArIDNdO1xuICAgICAgICB0MiA9IHMwICsgbWFqO1xuICAgICAgICBlID0gKGEgKyB0MSkgPDwgMDtcbiAgICAgICAgYSA9ICh0MSArIHQyKSA8PCAwO1xuICAgICAgICB0aGlzLmNocm9tZUJ1Z1dvcmtBcm91bmQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmgwID0gKHRoaXMuaDAgKyBhKSA8PCAwO1xuICAgIHRoaXMuaDEgPSAodGhpcy5oMSArIGIpIDw8IDA7XG4gICAgdGhpcy5oMiA9ICh0aGlzLmgyICsgYykgPDwgMDtcbiAgICB0aGlzLmgzID0gKHRoaXMuaDMgKyBkKSA8PCAwO1xuICAgIHRoaXMuaDQgPSAodGhpcy5oNCArIGUpIDw8IDA7XG4gICAgdGhpcy5oNSA9ICh0aGlzLmg1ICsgZikgPDwgMDtcbiAgICB0aGlzLmg2ID0gKHRoaXMuaDYgKyBnKSA8PCAwO1xuICAgIHRoaXMuaDcgPSAodGhpcy5oNyArIGgpIDw8IDA7XG59O1xuU2hhMjU2LnByb3RvdHlwZS5oZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuICAgIHZhciBoMCA9IHRoaXMuaDAsIGgxID0gdGhpcy5oMSwgaDIgPSB0aGlzLmgyLCBoMyA9IHRoaXMuaDMsIGg0ID0gdGhpcy5oNCwgaDUgPSB0aGlzLmg1LCBoNiA9IHRoaXMuaDYsIGg3ID0gdGhpcy5oNztcbiAgICB2YXIgaGV4ID0gSEVYX0NIQVJTWyhoMCA+Pj4gMjgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgwID4+PiAyNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDAgPj4+IDIwKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMCA+Pj4gMTYpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgwID4+PiAxMikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDAgPj4+IDgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgwID4+PiA0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTW2gwICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgxID4+PiAyOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDEgPj4+IDI0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMSA+Pj4gMjApICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgxID4+PiAxNikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDEgPj4+IDEyKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMSA+Pj4gOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDEgPj4+IDQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbaDEgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDIgPj4+IDI4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMiA+Pj4gMjQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgyID4+PiAyMCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDIgPj4+IDE2KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMiA+Pj4gMTIpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgyID4+PiA4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMiA+Pj4gNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1toMiAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMyA+Pj4gMjgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgzID4+PiAyNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDMgPj4+IDIwKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMyA+Pj4gMTYpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgzID4+PiAxMikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDMgPj4+IDgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgzID4+PiA0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTW2gzICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg0ID4+PiAyOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDQgPj4+IDI0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNCA+Pj4gMjApICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg0ID4+PiAxNikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDQgPj4+IDEyKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNCA+Pj4gOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDQgPj4+IDQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbaDQgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDUgPj4+IDI4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNSA+Pj4gMjQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg1ID4+PiAyMCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDUgPj4+IDE2KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNSA+Pj4gMTIpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg1ID4+PiA4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNSA+Pj4gNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1toNSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNiA+Pj4gMjgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg2ID4+PiAyNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDYgPj4+IDIwKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNiA+Pj4gMTYpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg2ID4+PiAxMikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDYgPj4+IDgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg2ID4+PiA0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTW2g2ICYgMHgwZl07XG4gICAgaWYgKCF0aGlzLmlzMjI0KSB7XG4gICAgICAgIGhleCArPVxuICAgICAgICAgICAgSEVYX0NIQVJTWyhoNyA+Pj4gMjgpICYgMHgwZl0gK1xuICAgICAgICAgICAgICAgIEhFWF9DSEFSU1soaDcgPj4+IDI0KSAmIDB4MGZdICtcbiAgICAgICAgICAgICAgICBIRVhfQ0hBUlNbKGg3ID4+PiAyMCkgJiAweDBmXSArXG4gICAgICAgICAgICAgICAgSEVYX0NIQVJTWyhoNyA+Pj4gMTYpICYgMHgwZl0gK1xuICAgICAgICAgICAgICAgIEhFWF9DSEFSU1soaDcgPj4+IDEyKSAmIDB4MGZdICtcbiAgICAgICAgICAgICAgICBIRVhfQ0hBUlNbKGg3ID4+PiA4KSAmIDB4MGZdICtcbiAgICAgICAgICAgICAgICBIRVhfQ0hBUlNbKGg3ID4+PiA0KSAmIDB4MGZdICtcbiAgICAgICAgICAgICAgICBIRVhfQ0hBUlNbaDcgJiAweDBmXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn07XG5TaGEyNTYucHJvdG90eXBlLnRvU3RyaW5nID0gU2hhMjU2LnByb3RvdHlwZS5oZXg7XG5TaGEyNTYucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbmFsaXplKCk7XG4gICAgdmFyIGgwID0gdGhpcy5oMCwgaDEgPSB0aGlzLmgxLCBoMiA9IHRoaXMuaDIsIGgzID0gdGhpcy5oMywgaDQgPSB0aGlzLmg0LCBoNSA9IHRoaXMuaDUsIGg2ID0gdGhpcy5oNiwgaDcgPSB0aGlzLmg3O1xuICAgIHZhciBhcnIgPSBbXG4gICAgICAgIChoMCA+Pj4gMjQpICYgMHhmZixcbiAgICAgICAgKGgwID4+PiAxNikgJiAweGZmLFxuICAgICAgICAoaDAgPj4+IDgpICYgMHhmZixcbiAgICAgICAgaDAgJiAweGZmLFxuICAgICAgICAoaDEgPj4+IDI0KSAmIDB4ZmYsXG4gICAgICAgIChoMSA+Pj4gMTYpICYgMHhmZixcbiAgICAgICAgKGgxID4+PiA4KSAmIDB4ZmYsXG4gICAgICAgIGgxICYgMHhmZixcbiAgICAgICAgKGgyID4+PiAyNCkgJiAweGZmLFxuICAgICAgICAoaDIgPj4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChoMiA+Pj4gOCkgJiAweGZmLFxuICAgICAgICBoMiAmIDB4ZmYsXG4gICAgICAgIChoMyA+Pj4gMjQpICYgMHhmZixcbiAgICAgICAgKGgzID4+PiAxNikgJiAweGZmLFxuICAgICAgICAoaDMgPj4+IDgpICYgMHhmZixcbiAgICAgICAgaDMgJiAweGZmLFxuICAgICAgICAoaDQgPj4+IDI0KSAmIDB4ZmYsXG4gICAgICAgIChoNCA+Pj4gMTYpICYgMHhmZixcbiAgICAgICAgKGg0ID4+PiA4KSAmIDB4ZmYsXG4gICAgICAgIGg0ICYgMHhmZixcbiAgICAgICAgKGg1ID4+PiAyNCkgJiAweGZmLFxuICAgICAgICAoaDUgPj4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChoNSA+Pj4gOCkgJiAweGZmLFxuICAgICAgICBoNSAmIDB4ZmYsXG4gICAgICAgIChoNiA+Pj4gMjQpICYgMHhmZixcbiAgICAgICAgKGg2ID4+PiAxNikgJiAweGZmLFxuICAgICAgICAoaDYgPj4+IDgpICYgMHhmZixcbiAgICAgICAgaDYgJiAweGZmLFxuICAgIF07XG4gICAgaWYgKCF0aGlzLmlzMjI0KSB7XG4gICAgICAgIGFyci5wdXNoKChoNyA+Pj4gMjQpICYgMHhmZiwgKGg3ID4+PiAxNikgJiAweGZmLCAoaDcgPj4+IDgpICYgMHhmZiwgaDcgJiAweGZmKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn07XG5TaGEyNTYucHJvdG90eXBlLmFycmF5ID0gU2hhMjU2LnByb3RvdHlwZS5kaWdlc3Q7XG5TaGEyNTYucHJvdG90eXBlLmFycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuaXMyMjQgPyAyOCA6IDMyKTtcbiAgICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoMCwgdGhpcy5oMCk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDQsIHRoaXMuaDEpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMig4LCB0aGlzLmgyKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoMTIsIHRoaXMuaDMpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMigxNiwgdGhpcy5oNCk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDIwLCB0aGlzLmg1KTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoMjQsIHRoaXMuaDYpO1xuICAgIGlmICghdGhpcy5pczIyNCkge1xuICAgICAgICBkYXRhVmlldy5zZXRVaW50MzIoMjgsIHRoaXMuaDcpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xufTtcbmNvbnN0IHNoYTI1NiA9ICguLi5zdHJpbmdzKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBTaGEyNTYoZmFsc2UsIHRydWUpLnVwZGF0ZShzdHJpbmdzLmpvaW4oXCJcIikpLmhleCgpO1xufTtcbmV4cG9ydHMuc2hhMjU2ID0gc2hhMjU2O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/js-sha256/hash.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/json.cjs":
/*!**********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/json.cjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseJsonMarkdown = parseJsonMarkdown;\nexports.parsePartialJson = parsePartialJson;\nfunction parseJsonMarkdown(s, parser = parsePartialJson) {\n    // eslint-disable-next-line no-param-reassign\n    s = s.trim();\n    const firstFenceIndex = s.indexOf(\"```\");\n    if (firstFenceIndex === -1) {\n        return parser(s);\n    }\n    let contentAfterFence = s.substring(firstFenceIndex + 3);\n    if (contentAfterFence.startsWith(\"json\\n\")) {\n        contentAfterFence = contentAfterFence.substring(5);\n    }\n    else if (contentAfterFence.startsWith(\"json\")) {\n        contentAfterFence = contentAfterFence.substring(4);\n    }\n    else if (contentAfterFence.startsWith(\"\\n\")) {\n        contentAfterFence = contentAfterFence.substring(1);\n    }\n    const closingFenceIndex = contentAfterFence.indexOf(\"```\");\n    let finalContent = contentAfterFence;\n    if (closingFenceIndex !== -1) {\n        finalContent = contentAfterFence.substring(0, closingFenceIndex);\n    }\n    return parser(finalContent.trim());\n}\n// Adapted from https://github.com/KillianLucas/open-interpreter/blob/main/interpreter/core/llm/utils/parse_partial_json.py\n// MIT License\nfunction parsePartialJson(s) {\n    // If the input is undefined, return null to indicate failure.\n    if (typeof s === \"undefined\") {\n        return null;\n    }\n    // Attempt to parse the string as-is.\n    try {\n        return JSON.parse(s);\n    }\n    catch (error) {\n        // Pass\n    }\n    // Initialize variables.\n    let new_s = \"\";\n    const stack = [];\n    let isInsideString = false;\n    let escaped = false;\n    // Process each character in the string one at a time.\n    for (let char of s) {\n        if (isInsideString) {\n            if (char === '\"' && !escaped) {\n                isInsideString = false;\n            }\n            else if (char === \"\\n\" && !escaped) {\n                char = \"\\\\n\"; // Replace the newline character with the escape sequence.\n            }\n            else if (char === \"\\\\\") {\n                escaped = !escaped;\n            }\n            else {\n                escaped = false;\n            }\n        }\n        else {\n            if (char === '\"') {\n                isInsideString = true;\n                escaped = false;\n            }\n            else if (char === \"{\") {\n                stack.push(\"}\");\n            }\n            else if (char === \"[\") {\n                stack.push(\"]\");\n            }\n            else if (char === \"}\" || char === \"]\") {\n                if (stack && stack[stack.length - 1] === char) {\n                    stack.pop();\n                }\n                else {\n                    // Mismatched closing character; the input is malformed.\n                    return null;\n                }\n            }\n        }\n        // Append the processed character to the new string.\n        new_s += char;\n    }\n    // If we're still inside a string at the end of processing,\n    // we need to close the string.\n    if (isInsideString) {\n        new_s += '\"';\n    }\n    // Close any remaining open structures in the reverse order that they were opened.\n    for (let i = stack.length - 1; i >= 0; i -= 1) {\n        new_s += stack[i];\n    }\n    // Attempt to parse the modified string as JSON.\n    try {\n        return JSON.parse(new_s);\n    }\n    catch (error) {\n        // If we still can't parse the string as JSON, return null to indicate failure.\n        return null;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvanNvbi5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9qc29uLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VKc29uTWFya2Rvd24gPSBwYXJzZUpzb25NYXJrZG93bjtcbmV4cG9ydHMucGFyc2VQYXJ0aWFsSnNvbiA9IHBhcnNlUGFydGlhbEpzb247XG5mdW5jdGlvbiBwYXJzZUpzb25NYXJrZG93bihzLCBwYXJzZXIgPSBwYXJzZVBhcnRpYWxKc29uKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgcyA9IHMudHJpbSgpO1xuICAgIGNvbnN0IGZpcnN0RmVuY2VJbmRleCA9IHMuaW5kZXhPZihcImBgYFwiKTtcbiAgICBpZiAoZmlyc3RGZW5jZUluZGV4ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gcGFyc2VyKHMpO1xuICAgIH1cbiAgICBsZXQgY29udGVudEFmdGVyRmVuY2UgPSBzLnN1YnN0cmluZyhmaXJzdEZlbmNlSW5kZXggKyAzKTtcbiAgICBpZiAoY29udGVudEFmdGVyRmVuY2Uuc3RhcnRzV2l0aChcImpzb25cXG5cIikpIHtcbiAgICAgICAgY29udGVudEFmdGVyRmVuY2UgPSBjb250ZW50QWZ0ZXJGZW5jZS5zdWJzdHJpbmcoNSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRlbnRBZnRlckZlbmNlLnN0YXJ0c1dpdGgoXCJqc29uXCIpKSB7XG4gICAgICAgIGNvbnRlbnRBZnRlckZlbmNlID0gY29udGVudEFmdGVyRmVuY2Uuc3Vic3RyaW5nKDQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb250ZW50QWZ0ZXJGZW5jZS5zdGFydHNXaXRoKFwiXFxuXCIpKSB7XG4gICAgICAgIGNvbnRlbnRBZnRlckZlbmNlID0gY29udGVudEFmdGVyRmVuY2Uuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICBjb25zdCBjbG9zaW5nRmVuY2VJbmRleCA9IGNvbnRlbnRBZnRlckZlbmNlLmluZGV4T2YoXCJgYGBcIik7XG4gICAgbGV0IGZpbmFsQ29udGVudCA9IGNvbnRlbnRBZnRlckZlbmNlO1xuICAgIGlmIChjbG9zaW5nRmVuY2VJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgZmluYWxDb250ZW50ID0gY29udGVudEFmdGVyRmVuY2Uuc3Vic3RyaW5nKDAsIGNsb3NpbmdGZW5jZUluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlcihmaW5hbENvbnRlbnQudHJpbSgpKTtcbn1cbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vS2lsbGlhbkx1Y2FzL29wZW4taW50ZXJwcmV0ZXIvYmxvYi9tYWluL2ludGVycHJldGVyL2NvcmUvbGxtL3V0aWxzL3BhcnNlX3BhcnRpYWxfanNvbi5weVxuLy8gTUlUIExpY2Vuc2VcbmZ1bmN0aW9uIHBhcnNlUGFydGlhbEpzb24ocykge1xuICAgIC8vIElmIHRoZSBpbnB1dCBpcyB1bmRlZmluZWQsIHJldHVybiBudWxsIHRvIGluZGljYXRlIGZhaWx1cmUuXG4gICAgaWYgKHR5cGVvZiBzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIHRoZSBzdHJpbmcgYXMtaXMuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uocyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBQYXNzXG4gICAgfVxuICAgIC8vIEluaXRpYWxpemUgdmFyaWFibGVzLlxuICAgIGxldCBuZXdfcyA9IFwiXCI7XG4gICAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgICBsZXQgaXNJbnNpZGVTdHJpbmcgPSBmYWxzZTtcbiAgICBsZXQgZXNjYXBlZCA9IGZhbHNlO1xuICAgIC8vIFByb2Nlc3MgZWFjaCBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZyBvbmUgYXQgYSB0aW1lLlxuICAgIGZvciAobGV0IGNoYXIgb2Ygcykge1xuICAgICAgICBpZiAoaXNJbnNpZGVTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmIChjaGFyID09PSAnXCInICYmICFlc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgaXNJbnNpZGVTdHJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IFwiXFxuXCIgJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgICBjaGFyID0gXCJcXFxcblwiOyAvLyBSZXBsYWNlIHRoZSBuZXdsaW5lIGNoYXJhY3RlciB3aXRoIHRoZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjaGFyID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgaXNJbnNpZGVTdHJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IFwie1wiKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChcIn1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSBcIltcIikge1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goXCJdXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gXCJ9XCIgfHwgY2hhciA9PT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2sgJiYgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IGNoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBNaXNtYXRjaGVkIGNsb3NpbmcgY2hhcmFjdGVyOyB0aGUgaW5wdXQgaXMgbWFsZm9ybWVkLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXBwZW5kIHRoZSBwcm9jZXNzZWQgY2hhcmFjdGVyIHRvIHRoZSBuZXcgc3RyaW5nLlxuICAgICAgICBuZXdfcyArPSBjaGFyO1xuICAgIH1cbiAgICAvLyBJZiB3ZSdyZSBzdGlsbCBpbnNpZGUgYSBzdHJpbmcgYXQgdGhlIGVuZCBvZiBwcm9jZXNzaW5nLFxuICAgIC8vIHdlIG5lZWQgdG8gY2xvc2UgdGhlIHN0cmluZy5cbiAgICBpZiAoaXNJbnNpZGVTdHJpbmcpIHtcbiAgICAgICAgbmV3X3MgKz0gJ1wiJztcbiAgICB9XG4gICAgLy8gQ2xvc2UgYW55IHJlbWFpbmluZyBvcGVuIHN0cnVjdHVyZXMgaW4gdGhlIHJldmVyc2Ugb3JkZXIgdGhhdCB0aGV5IHdlcmUgb3BlbmVkLlxuICAgIGZvciAobGV0IGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBuZXdfcyArPSBzdGFja1tpXTtcbiAgICB9XG4gICAgLy8gQXR0ZW1wdCB0byBwYXJzZSB0aGUgbW9kaWZpZWQgc3RyaW5nIGFzIEpTT04uXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UobmV3X3MpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gSWYgd2Ugc3RpbGwgY2FuJ3QgcGFyc2UgdGhlIHN0cmluZyBhcyBKU09OLCByZXR1cm4gbnVsbCB0byBpbmRpY2F0ZSBmYWlsdXJlLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/json.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/json_patch.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/json_patch.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.applyPatch = exports.compare = void 0;\nvar index_js_1 = __webpack_require__(/*! ./fast-json-patch/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/index.cjs\");\nObject.defineProperty(exports, \"compare\", ({ enumerable: true, get: function () { return index_js_1.compare; } }));\nObject.defineProperty(exports, \"applyPatch\", ({ enumerable: true, get: function () { return index_js_1.applyPatch; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvanNvbl9wYXRjaC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsZUFBZTtBQUNwQyxpQkFBaUIsbUJBQU8sQ0FBQyw4R0FBNkI7QUFDdEQsMkNBQTBDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ2hILDhDQUE2QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2pzb25fcGF0Y2guY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hcHBseVBhdGNoID0gZXhwb3J0cy5jb21wYXJlID0gdm9pZCAwO1xudmFyIGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi9mYXN0LWpzb24tcGF0Y2gvaW5kZXguY2pzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcGFyZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMS5jb21wYXJlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXBwbHlQYXRjaFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMS5hcHBseVBhdGNoOyB9IH0pO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/json_patch.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/json_schema.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/json_schema.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Validator = exports.deepCompareStrict = void 0;\nexports.toJsonSchema = toJsonSchema;\nexports.validatesOnlyStrings = validatesOnlyStrings;\nconst core_1 = __webpack_require__(/*! zod/v4/core */ \"(rsc)/./node_modules/zod/v4/core/index.cjs\");\nconst zod_to_json_schema_1 = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/cjs/index.js\");\nconst json_schema_1 = __webpack_require__(/*! @cfworker/json-schema */ \"(rsc)/./node_modules/@cfworker/json-schema/dist/commonjs/index.js\");\nconst zod_js_1 = __webpack_require__(/*! ./types/zod.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.cjs\");\nvar json_schema_2 = __webpack_require__(/*! @cfworker/json-schema */ \"(rsc)/./node_modules/@cfworker/json-schema/dist/commonjs/index.js\");\nObject.defineProperty(exports, \"deepCompareStrict\", ({ enumerable: true, get: function () { return json_schema_2.deepCompareStrict; } }));\nObject.defineProperty(exports, \"Validator\", ({ enumerable: true, get: function () { return json_schema_2.Validator; } }));\n/**\n * Converts a Zod schema or JSON schema to a JSON schema.\n * @param schema - The schema to convert.\n * @returns The converted schema.\n */\nfunction toJsonSchema(schema) {\n    if ((0, zod_js_1.isZodSchemaV4)(schema)) {\n        const inputSchema = (0, zod_js_1.interopZodTransformInputSchema)(schema, true);\n        if ((0, zod_js_1.isZodObjectV4)(inputSchema)) {\n            const strictSchema = (0, zod_js_1.interopZodObjectStrict)(inputSchema, true);\n            return (0, core_1.toJSONSchema)(strictSchema);\n        }\n        else {\n            return (0, core_1.toJSONSchema)(schema);\n        }\n    }\n    if ((0, zod_js_1.isZodSchemaV3)(schema)) {\n        return (0, zod_to_json_schema_1.zodToJsonSchema)(schema);\n    }\n    return schema;\n}\n/**\n * Validates if a JSON schema validates only strings. May return false negatives in some edge cases\n * (like recursive or unresolvable refs).\n *\n * @param schema - The schema to validate.\n * @returns `true` if the schema validates only strings, `false` otherwise.\n */\nfunction validatesOnlyStrings(schema) {\n    // Null, undefined, or empty schema\n    if (!schema ||\n        typeof schema !== \"object\" ||\n        Object.keys(schema).length === 0 ||\n        Array.isArray(schema)) {\n        return false; // Validates anything, not just strings\n    }\n    // Explicit type constraint\n    if (\"type\" in schema) {\n        if (typeof schema.type === \"string\") {\n            return schema.type === \"string\";\n        }\n        if (Array.isArray(schema.type)) {\n            // not sure why someone would do `\"type\": [\"string\"]` or especially `\"type\": [\"string\",\n            // \"string\", \"string\", ...]` but we're not here to judge\n            return schema.type.every((t) => t === \"string\");\n        }\n        return false; // Invalid or non-string type\n    }\n    // Enum with only string values\n    if (\"enum\" in schema) {\n        return (Array.isArray(schema.enum) &&\n            schema.enum.length > 0 &&\n            schema.enum.every((val) => typeof val === \"string\"));\n    }\n    // String constant\n    if (\"const\" in schema) {\n        return typeof schema.const === \"string\";\n    }\n    // Schema combinations\n    if (\"allOf\" in schema && Array.isArray(schema.allOf)) {\n        // If any subschema validates only strings, then the overall schema validates only strings\n        return schema.allOf.some((subschema) => validatesOnlyStrings(subschema));\n    }\n    if ((\"anyOf\" in schema && Array.isArray(schema.anyOf)) ||\n        (\"oneOf\" in schema && Array.isArray(schema.oneOf))) {\n        const subschemas = (\"anyOf\" in schema ? schema.anyOf : schema.oneOf);\n        // All subschemas must validate only strings\n        return (subschemas.length > 0 &&\n            subschemas.every((subschema) => validatesOnlyStrings(subschema)));\n    }\n    // We're not going to try on this one, it's too complex - we just assume if it has a \"not\" key and hasn't matched one of the above checks, it's not a string schema.\n    if (\"not\" in schema) {\n        return false; // The not case can validate non-strings\n    }\n    if (\"$ref\" in schema && typeof schema.$ref === \"string\") {\n        const ref = schema.$ref;\n        const resolved = (0, json_schema_1.dereference)(schema);\n        if (resolved[ref]) {\n            return validatesOnlyStrings(resolved[ref]);\n        }\n        return false;\n    }\n    // ignore recursive refs and other cases where type is omitted for now\n    // ignore other cases for now where type is omitted\n    return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvanNvbl9zY2hlbWEuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLHlCQUF5QjtBQUM3QyxvQkFBb0I7QUFDcEIsNEJBQTRCO0FBQzVCLGVBQWUsbUJBQU8sQ0FBQywrREFBYTtBQUNwQyw2QkFBNkIsbUJBQU8sQ0FBQyxxRkFBb0I7QUFDekQsc0JBQXNCLG1CQUFPLENBQUMsZ0dBQXVCO0FBQ3JELGlCQUFpQixtQkFBTyxDQUFDLHNGQUFpQjtBQUMxQyxvQkFBb0IsbUJBQU8sQ0FBQyxnR0FBdUI7QUFDbkQscURBQW9ELEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQ3ZJLDZDQUE0QyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvanNvbl9zY2hlbWEuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WYWxpZGF0b3IgPSBleHBvcnRzLmRlZXBDb21wYXJlU3RyaWN0ID0gdm9pZCAwO1xuZXhwb3J0cy50b0pzb25TY2hlbWEgPSB0b0pzb25TY2hlbWE7XG5leHBvcnRzLnZhbGlkYXRlc09ubHlTdHJpbmdzID0gdmFsaWRhdGVzT25seVN0cmluZ3M7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiem9kL3Y0L2NvcmVcIik7XG5jb25zdCB6b2RfdG9fanNvbl9zY2hlbWFfMSA9IHJlcXVpcmUoXCJ6b2QtdG8tanNvbi1zY2hlbWFcIik7XG5jb25zdCBqc29uX3NjaGVtYV8xID0gcmVxdWlyZShcIkBjZndvcmtlci9qc29uLXNjaGVtYVwiKTtcbmNvbnN0IHpvZF9qc18xID0gcmVxdWlyZShcIi4vdHlwZXMvem9kLmNqc1wiKTtcbnZhciBqc29uX3NjaGVtYV8yID0gcmVxdWlyZShcIkBjZndvcmtlci9qc29uLXNjaGVtYVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZXBDb21wYXJlU3RyaWN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqc29uX3NjaGVtYV8yLmRlZXBDb21wYXJlU3RyaWN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmFsaWRhdG9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqc29uX3NjaGVtYV8yLlZhbGlkYXRvcjsgfSB9KTtcbi8qKlxuICogQ29udmVydHMgYSBab2Qgc2NoZW1hIG9yIEpTT04gc2NoZW1hIHRvIGEgSlNPTiBzY2hlbWEuXG4gKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBzY2hlbWEuXG4gKi9cbmZ1bmN0aW9uIHRvSnNvblNjaGVtYShzY2hlbWEpIHtcbiAgICBpZiAoKDAsIHpvZF9qc18xLmlzWm9kU2NoZW1hVjQpKHNjaGVtYSkpIHtcbiAgICAgICAgY29uc3QgaW5wdXRTY2hlbWEgPSAoMCwgem9kX2pzXzEuaW50ZXJvcFpvZFRyYW5zZm9ybUlucHV0U2NoZW1hKShzY2hlbWEsIHRydWUpO1xuICAgICAgICBpZiAoKDAsIHpvZF9qc18xLmlzWm9kT2JqZWN0VjQpKGlucHV0U2NoZW1hKSkge1xuICAgICAgICAgICAgY29uc3Qgc3RyaWN0U2NoZW1hID0gKDAsIHpvZF9qc18xLmludGVyb3Bab2RPYmplY3RTdHJpY3QpKGlucHV0U2NoZW1hLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY29yZV8xLnRvSlNPTlNjaGVtYSkoc3RyaWN0U2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY29yZV8xLnRvSlNPTlNjaGVtYSkoc2NoZW1hKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoKDAsIHpvZF9qc18xLmlzWm9kU2NoZW1hVjMpKHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuICgwLCB6b2RfdG9fanNvbl9zY2hlbWFfMS56b2RUb0pzb25TY2hlbWEpKHNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWE7XG59XG4vKipcbiAqIFZhbGlkYXRlcyBpZiBhIEpTT04gc2NoZW1hIHZhbGlkYXRlcyBvbmx5IHN0cmluZ3MuIE1heSByZXR1cm4gZmFsc2UgbmVnYXRpdmVzIGluIHNvbWUgZWRnZSBjYXNlc1xuICogKGxpa2UgcmVjdXJzaXZlIG9yIHVucmVzb2x2YWJsZSByZWZzKS5cbiAqXG4gKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSB0byB2YWxpZGF0ZS5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgc2NoZW1hIHZhbGlkYXRlcyBvbmx5IHN0cmluZ3MsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZXNPbmx5U3RyaW5ncyhzY2hlbWEpIHtcbiAgICAvLyBOdWxsLCB1bmRlZmluZWQsIG9yIGVtcHR5IHNjaGVtYVxuICAgIGlmICghc2NoZW1hIHx8XG4gICAgICAgIHR5cGVvZiBzY2hlbWEgIT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgT2JqZWN0LmtleXMoc2NoZW1hKS5sZW5ndGggPT09IDAgfHxcbiAgICAgICAgQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gVmFsaWRhdGVzIGFueXRoaW5nLCBub3QganVzdCBzdHJpbmdzXG4gICAgfVxuICAgIC8vIEV4cGxpY2l0IHR5cGUgY29uc3RyYWludFxuICAgIGlmIChcInR5cGVcIiBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS50eXBlID09PSBcInN0cmluZ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS50eXBlKSkge1xuICAgICAgICAgICAgLy8gbm90IHN1cmUgd2h5IHNvbWVvbmUgd291bGQgZG8gYFwidHlwZVwiOiBbXCJzdHJpbmdcIl1gIG9yIGVzcGVjaWFsbHkgYFwidHlwZVwiOiBbXCJzdHJpbmdcIixcbiAgICAgICAgICAgIC8vIFwic3RyaW5nXCIsIFwic3RyaW5nXCIsIC4uLl1gIGJ1dCB3ZSdyZSBub3QgaGVyZSB0byBqdWRnZVxuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS50eXBlLmV2ZXJ5KCh0KSA9PiB0ID09PSBcInN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEludmFsaWQgb3Igbm9uLXN0cmluZyB0eXBlXG4gICAgfVxuICAgIC8vIEVudW0gd2l0aCBvbmx5IHN0cmluZyB2YWx1ZXNcbiAgICBpZiAoXCJlbnVtXCIgaW4gc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheShzY2hlbWEuZW51bSkgJiZcbiAgICAgICAgICAgIHNjaGVtYS5lbnVtLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHNjaGVtYS5lbnVtLmV2ZXJ5KCh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpKTtcbiAgICB9XG4gICAgLy8gU3RyaW5nIGNvbnN0YW50XG4gICAgaWYgKFwiY29uc3RcIiBpbiBzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBzY2hlbWEuY29uc3QgPT09IFwic3RyaW5nXCI7XG4gICAgfVxuICAgIC8vIFNjaGVtYSBjb21iaW5hdGlvbnNcbiAgICBpZiAoXCJhbGxPZlwiIGluIHNjaGVtYSAmJiBBcnJheS5pc0FycmF5KHNjaGVtYS5hbGxPZikpIHtcbiAgICAgICAgLy8gSWYgYW55IHN1YnNjaGVtYSB2YWxpZGF0ZXMgb25seSBzdHJpbmdzLCB0aGVuIHRoZSBvdmVyYWxsIHNjaGVtYSB2YWxpZGF0ZXMgb25seSBzdHJpbmdzXG4gICAgICAgIHJldHVybiBzY2hlbWEuYWxsT2Yuc29tZSgoc3Vic2NoZW1hKSA9PiB2YWxpZGF0ZXNPbmx5U3RyaW5ncyhzdWJzY2hlbWEpKTtcbiAgICB9XG4gICAgaWYgKChcImFueU9mXCIgaW4gc2NoZW1hICYmIEFycmF5LmlzQXJyYXkoc2NoZW1hLmFueU9mKSkgfHxcbiAgICAgICAgKFwib25lT2ZcIiBpbiBzY2hlbWEgJiYgQXJyYXkuaXNBcnJheShzY2hlbWEub25lT2YpKSkge1xuICAgICAgICBjb25zdCBzdWJzY2hlbWFzID0gKFwiYW55T2ZcIiBpbiBzY2hlbWEgPyBzY2hlbWEuYW55T2YgOiBzY2hlbWEub25lT2YpO1xuICAgICAgICAvLyBBbGwgc3Vic2NoZW1hcyBtdXN0IHZhbGlkYXRlIG9ubHkgc3RyaW5nc1xuICAgICAgICByZXR1cm4gKHN1YnNjaGVtYXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgc3Vic2NoZW1hcy5ldmVyeSgoc3Vic2NoZW1hKSA9PiB2YWxpZGF0ZXNPbmx5U3RyaW5ncyhzdWJzY2hlbWEpKSk7XG4gICAgfVxuICAgIC8vIFdlJ3JlIG5vdCBnb2luZyB0byB0cnkgb24gdGhpcyBvbmUsIGl0J3MgdG9vIGNvbXBsZXggLSB3ZSBqdXN0IGFzc3VtZSBpZiBpdCBoYXMgYSBcIm5vdFwiIGtleSBhbmQgaGFzbid0IG1hdGNoZWQgb25lIG9mIHRoZSBhYm92ZSBjaGVja3MsIGl0J3Mgbm90IGEgc3RyaW5nIHNjaGVtYS5cbiAgICBpZiAoXCJub3RcIiBpbiBzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBUaGUgbm90IGNhc2UgY2FuIHZhbGlkYXRlIG5vbi1zdHJpbmdzXG4gICAgfVxuICAgIGlmIChcIiRyZWZcIiBpbiBzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYS4kcmVmID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IHJlZiA9IHNjaGVtYS4kcmVmO1xuICAgICAgICBjb25zdCByZXNvbHZlZCA9ICgwLCBqc29uX3NjaGVtYV8xLmRlcmVmZXJlbmNlKShzY2hlbWEpO1xuICAgICAgICBpZiAocmVzb2x2ZWRbcmVmXSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlc09ubHlTdHJpbmdzKHJlc29sdmVkW3JlZl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gaWdub3JlIHJlY3Vyc2l2ZSByZWZzIGFuZCBvdGhlciBjYXNlcyB3aGVyZSB0eXBlIGlzIG9taXR0ZWQgZm9yIG5vd1xuICAgIC8vIGlnbm9yZSBvdGhlciBjYXNlcyBmb3Igbm93IHdoZXJlIHR5cGUgaXMgb21pdHRlZFxuICAgIHJldHVybiBmYWxzZTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/json_schema.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/sax-js/sax.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/sax-js/sax.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// @ts-nocheck\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sax = void 0;\n// Inlined to deal with portability issues\n// Originally from: https://github.com/isaacs/sax-js\nconst initializeSax = function () {\n    const sax = {};\n    sax.parser = function (strict, opt) {\n        return new SAXParser(strict, opt);\n    };\n    sax.SAXParser = SAXParser;\n    sax.SAXStream = SAXStream;\n    sax.createStream = createStream;\n    // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n    // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n    // since that's the earliest that a buffer overrun could occur.  This way, checks are\n    // as rare as required, but as often as necessary to ensure never crossing this bound.\n    // Furthermore, buffers are only tested at most once per write(), so passing a very\n    // large string into write() might have undesirable effects, but this is manageable by\n    // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n    // edge case, result in creating at most one complete copy of the string passed in.\n    // Set to Infinity to have unlimited buffers.\n    sax.MAX_BUFFER_LENGTH = 64 * 1024;\n    const buffers = [\n        \"comment\",\n        \"sgmlDecl\",\n        \"textNode\",\n        \"tagName\",\n        \"doctype\",\n        \"procInstName\",\n        \"procInstBody\",\n        \"entity\",\n        \"attribName\",\n        \"attribValue\",\n        \"cdata\",\n        \"script\",\n    ];\n    sax.EVENTS = [\n        \"text\",\n        \"processinginstruction\",\n        \"sgmldeclaration\",\n        \"doctype\",\n        \"comment\",\n        \"opentagstart\",\n        \"attribute\",\n        \"opentag\",\n        \"closetag\",\n        \"opencdata\",\n        \"cdata\",\n        \"closecdata\",\n        \"error\",\n        \"end\",\n        \"ready\",\n        \"script\",\n        \"opennamespace\",\n        \"closenamespace\",\n    ];\n    function SAXParser(strict, opt) {\n        if (!(this instanceof SAXParser)) {\n            return new SAXParser(strict, opt);\n        }\n        var parser = this;\n        clearBuffers(parser);\n        parser.q = parser.c = \"\";\n        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;\n        parser.opt = opt || {};\n        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;\n        parser.looseCase = parser.opt.lowercase ? \"toLowerCase\" : \"toUpperCase\";\n        parser.tags = [];\n        parser.closed = parser.closedRoot = parser.sawRoot = false;\n        parser.tag = parser.error = null;\n        parser.strict = !!strict;\n        parser.noscript = !!(strict || parser.opt.noscript);\n        parser.state = S.BEGIN;\n        parser.strictEntities = parser.opt.strictEntities;\n        parser.ENTITIES = parser.strictEntities\n            ? Object.create(sax.XML_ENTITIES)\n            : Object.create(sax.ENTITIES);\n        parser.attribList = [];\n        // namespaces form a prototype chain.\n        // it always points at the current tag,\n        // which protos to its parent tag.\n        if (parser.opt.xmlns) {\n            parser.ns = Object.create(rootNS);\n        }\n        // mostly just for error reporting\n        parser.trackPosition = parser.opt.position !== false;\n        if (parser.trackPosition) {\n            parser.position = parser.line = parser.column = 0;\n        }\n        emit(parser, \"onready\");\n    }\n    if (!Object.create) {\n        Object.create = function (o) {\n            function F() { }\n            F.prototype = o;\n            var newf = new F();\n            return newf;\n        };\n    }\n    if (!Object.keys) {\n        Object.keys = function (o) {\n            var a = [];\n            for (var i in o)\n                if (o.hasOwnProperty(i))\n                    a.push(i);\n            return a;\n        };\n    }\n    function checkBufferLength(parser) {\n        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);\n        var maxActual = 0;\n        for (var i = 0, l = buffers.length; i < l; i++) {\n            var len = parser[buffers[i]].length;\n            if (len > maxAllowed) {\n                // Text/cdata nodes can get big, and since they're buffered,\n                // we can get here under normal conditions.\n                // Avoid issues by emitting the text node now,\n                // so at least it won't get any bigger.\n                switch (buffers[i]) {\n                    case \"textNode\":\n                        closeText(parser);\n                        break;\n                    case \"cdata\":\n                        emitNode(parser, \"oncdata\", parser.cdata);\n                        parser.cdata = \"\";\n                        break;\n                    case \"script\":\n                        emitNode(parser, \"onscript\", parser.script);\n                        parser.script = \"\";\n                        break;\n                    default:\n                        error(parser, \"Max buffer length exceeded: \" + buffers[i]);\n                }\n            }\n            maxActual = Math.max(maxActual, len);\n        }\n        // schedule the next check for the earliest possible buffer overrun.\n        var m = sax.MAX_BUFFER_LENGTH - maxActual;\n        parser.bufferCheckPosition = m + parser.position;\n    }\n    function clearBuffers(parser) {\n        for (var i = 0, l = buffers.length; i < l; i++) {\n            parser[buffers[i]] = \"\";\n        }\n    }\n    function flushBuffers(parser) {\n        closeText(parser);\n        if (parser.cdata !== \"\") {\n            emitNode(parser, \"oncdata\", parser.cdata);\n            parser.cdata = \"\";\n        }\n        if (parser.script !== \"\") {\n            emitNode(parser, \"onscript\", parser.script);\n            parser.script = \"\";\n        }\n    }\n    SAXParser.prototype = {\n        end: function () {\n            end(this);\n        },\n        write: write,\n        resume: function () {\n            this.error = null;\n            return this;\n        },\n        close: function () {\n            return this.write(null);\n        },\n        flush: function () {\n            flushBuffers(this);\n        },\n    };\n    var Stream = ReadableStream;\n    if (!Stream)\n        Stream = function () { };\n    var streamWraps = sax.EVENTS.filter(function (ev) {\n        return ev !== \"error\" && ev !== \"end\";\n    });\n    function createStream(strict, opt) {\n        return new SAXStream(strict, opt);\n    }\n    function SAXStream(strict, opt) {\n        if (!(this instanceof SAXStream)) {\n            return new SAXStream(strict, opt);\n        }\n        Stream.apply(this);\n        this._parser = new SAXParser(strict, opt);\n        this.writable = true;\n        this.readable = true;\n        var me = this;\n        this._parser.onend = function () {\n            me.emit(\"end\");\n        };\n        this._parser.onerror = function (er) {\n            me.emit(\"error\", er);\n            // if didn't throw, then means error was handled.\n            // go ahead and clear error, so we can write again.\n            me._parser.error = null;\n        };\n        this._decoder = null;\n        streamWraps.forEach(function (ev) {\n            Object.defineProperty(me, \"on\" + ev, {\n                get: function () {\n                    return me._parser[\"on\" + ev];\n                },\n                set: function (h) {\n                    if (!h) {\n                        me.removeAllListeners(ev);\n                        me._parser[\"on\" + ev] = h;\n                        return h;\n                    }\n                    me.on(ev, h);\n                },\n                enumerable: true,\n                configurable: false,\n            });\n        });\n    }\n    SAXStream.prototype = Object.create(Stream.prototype, {\n        constructor: {\n            value: SAXStream,\n        },\n    });\n    SAXStream.prototype.write = function (data) {\n        this._parser.write(data.toString());\n        this.emit(\"data\", data);\n        return true;\n    };\n    SAXStream.prototype.end = function (chunk) {\n        if (chunk && chunk.length) {\n            this.write(chunk);\n        }\n        this._parser.end();\n        return true;\n    };\n    SAXStream.prototype.on = function (ev, handler) {\n        var me = this;\n        if (!me._parser[\"on\" + ev] && streamWraps.indexOf(ev) !== -1) {\n            me._parser[\"on\" + ev] = function () {\n                var args = arguments.length === 1\n                    ? [arguments[0]]\n                    : Array.apply(null, arguments);\n                args.splice(0, 0, ev);\n                me.emit.apply(me, args);\n            };\n        }\n        return Stream.prototype.on.call(me, ev, handler);\n    };\n    // this really needs to be replaced with character classes.\n    // XML allows all manner of ridiculous numbers and digits.\n    var CDATA = \"[CDATA[\";\n    var DOCTYPE = \"DOCTYPE\";\n    var XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\n    var XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\n    var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };\n    // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n    // This implementation works on strings, a single character at a time\n    // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n    // without a significant breaking change to either this  parser, or the\n    // JavaScript language.  Implementation of an emoji-capable xml parser\n    // is left as an exercise for the reader.\n    var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n    var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n    var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n    var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n    function isWhitespace(c) {\n        return c === \" \" || c === \"\\n\" || c === \"\\r\" || c === \"\\t\";\n    }\n    function isQuote(c) {\n        return c === '\"' || c === \"'\";\n    }\n    function isAttribEnd(c) {\n        return c === \">\" || isWhitespace(c);\n    }\n    function isMatch(regex, c) {\n        return regex.test(c);\n    }\n    function notMatch(regex, c) {\n        return !isMatch(regex, c);\n    }\n    var S = 0;\n    sax.STATE = {\n        BEGIN: S++, // leading byte order mark or whitespace\n        BEGIN_WHITESPACE: S++, // leading whitespace\n        TEXT: S++, // general stuff\n        TEXT_ENTITY: S++, // &amp and such.\n        OPEN_WAKA: S++, // <\n        SGML_DECL: S++, // <!BLARG\n        SGML_DECL_QUOTED: S++, // <!BLARG foo \"bar\n        DOCTYPE: S++, // <!DOCTYPE\n        DOCTYPE_QUOTED: S++, // <!DOCTYPE \"//blah\n        DOCTYPE_DTD: S++, // <!DOCTYPE \"//blah\" [ ...\n        DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE \"//blah\" [ \"foo\n        COMMENT_STARTING: S++, // <!-\n        COMMENT: S++, // <!--\n        COMMENT_ENDING: S++, // <!-- blah -\n        COMMENT_ENDED: S++, // <!-- blah --\n        CDATA: S++, // <![CDATA[ something\n        CDATA_ENDING: S++, // ]\n        CDATA_ENDING_2: S++, // ]]\n        PROC_INST: S++, // <?hi\n        PROC_INST_BODY: S++, // <?hi there\n        PROC_INST_ENDING: S++, // <?hi \"there\" ?\n        OPEN_TAG: S++, // <strong\n        OPEN_TAG_SLASH: S++, // <strong /\n        ATTRIB: S++, // <a\n        ATTRIB_NAME: S++, // <a foo\n        ATTRIB_NAME_SAW_WHITE: S++, // <a foo _\n        ATTRIB_VALUE: S++, // <a foo=\n        ATTRIB_VALUE_QUOTED: S++, // <a foo=\"bar\n        ATTRIB_VALUE_CLOSED: S++, // <a foo=\"bar\"\n        ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar\n        ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar=\"&quot;\"\n        ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot\n        CLOSE_TAG: S++, // </a\n        CLOSE_TAG_SAW_WHITE: S++, // </a   >\n        SCRIPT: S++, // <script> ...\n        SCRIPT_ENDING: S++, // <script> ... <\n    };\n    sax.XML_ENTITIES = {\n        amp: \"&\",\n        gt: \">\",\n        lt: \"<\",\n        quot: '\"',\n        apos: \"'\",\n    };\n    sax.ENTITIES = {\n        amp: \"&\",\n        gt: \">\",\n        lt: \"<\",\n        quot: '\"',\n        apos: \"'\",\n        AElig: 198,\n        Aacute: 193,\n        Acirc: 194,\n        Agrave: 192,\n        Aring: 197,\n        Atilde: 195,\n        Auml: 196,\n        Ccedil: 199,\n        ETH: 208,\n        Eacute: 201,\n        Ecirc: 202,\n        Egrave: 200,\n        Euml: 203,\n        Iacute: 205,\n        Icirc: 206,\n        Igrave: 204,\n        Iuml: 207,\n        Ntilde: 209,\n        Oacute: 211,\n        Ocirc: 212,\n        Ograve: 210,\n        Oslash: 216,\n        Otilde: 213,\n        Ouml: 214,\n        THORN: 222,\n        Uacute: 218,\n        Ucirc: 219,\n        Ugrave: 217,\n        Uuml: 220,\n        Yacute: 221,\n        aacute: 225,\n        acirc: 226,\n        aelig: 230,\n        agrave: 224,\n        aring: 229,\n        atilde: 227,\n        auml: 228,\n        ccedil: 231,\n        eacute: 233,\n        ecirc: 234,\n        egrave: 232,\n        eth: 240,\n        euml: 235,\n        iacute: 237,\n        icirc: 238,\n        igrave: 236,\n        iuml: 239,\n        ntilde: 241,\n        oacute: 243,\n        ocirc: 244,\n        ograve: 242,\n        oslash: 248,\n        otilde: 245,\n        ouml: 246,\n        szlig: 223,\n        thorn: 254,\n        uacute: 250,\n        ucirc: 251,\n        ugrave: 249,\n        uuml: 252,\n        yacute: 253,\n        yuml: 255,\n        copy: 169,\n        reg: 174,\n        nbsp: 160,\n        iexcl: 161,\n        cent: 162,\n        pound: 163,\n        curren: 164,\n        yen: 165,\n        brvbar: 166,\n        sect: 167,\n        uml: 168,\n        ordf: 170,\n        laquo: 171,\n        not: 172,\n        shy: 173,\n        macr: 175,\n        deg: 176,\n        plusmn: 177,\n        sup1: 185,\n        sup2: 178,\n        sup3: 179,\n        acute: 180,\n        micro: 181,\n        para: 182,\n        middot: 183,\n        cedil: 184,\n        ordm: 186,\n        raquo: 187,\n        frac14: 188,\n        frac12: 189,\n        frac34: 190,\n        iquest: 191,\n        times: 215,\n        divide: 247,\n        OElig: 338,\n        oelig: 339,\n        Scaron: 352,\n        scaron: 353,\n        Yuml: 376,\n        fnof: 402,\n        circ: 710,\n        tilde: 732,\n        Alpha: 913,\n        Beta: 914,\n        Gamma: 915,\n        Delta: 916,\n        Epsilon: 917,\n        Zeta: 918,\n        Eta: 919,\n        Theta: 920,\n        Iota: 921,\n        Kappa: 922,\n        Lambda: 923,\n        Mu: 924,\n        Nu: 925,\n        Xi: 926,\n        Omicron: 927,\n        Pi: 928,\n        Rho: 929,\n        Sigma: 931,\n        Tau: 932,\n        Upsilon: 933,\n        Phi: 934,\n        Chi: 935,\n        Psi: 936,\n        Omega: 937,\n        alpha: 945,\n        beta: 946,\n        gamma: 947,\n        delta: 948,\n        epsilon: 949,\n        zeta: 950,\n        eta: 951,\n        theta: 952,\n        iota: 953,\n        kappa: 954,\n        lambda: 955,\n        mu: 956,\n        nu: 957,\n        xi: 958,\n        omicron: 959,\n        pi: 960,\n        rho: 961,\n        sigmaf: 962,\n        sigma: 963,\n        tau: 964,\n        upsilon: 965,\n        phi: 966,\n        chi: 967,\n        psi: 968,\n        omega: 969,\n        thetasym: 977,\n        upsih: 978,\n        piv: 982,\n        ensp: 8194,\n        emsp: 8195,\n        thinsp: 8201,\n        zwnj: 8204,\n        zwj: 8205,\n        lrm: 8206,\n        rlm: 8207,\n        ndash: 8211,\n        mdash: 8212,\n        lsquo: 8216,\n        rsquo: 8217,\n        sbquo: 8218,\n        ldquo: 8220,\n        rdquo: 8221,\n        bdquo: 8222,\n        dagger: 8224,\n        Dagger: 8225,\n        bull: 8226,\n        hellip: 8230,\n        permil: 8240,\n        prime: 8242,\n        Prime: 8243,\n        lsaquo: 8249,\n        rsaquo: 8250,\n        oline: 8254,\n        frasl: 8260,\n        euro: 8364,\n        image: 8465,\n        weierp: 8472,\n        real: 8476,\n        trade: 8482,\n        alefsym: 8501,\n        larr: 8592,\n        uarr: 8593,\n        rarr: 8594,\n        darr: 8595,\n        harr: 8596,\n        crarr: 8629,\n        lArr: 8656,\n        uArr: 8657,\n        rArr: 8658,\n        dArr: 8659,\n        hArr: 8660,\n        forall: 8704,\n        part: 8706,\n        exist: 8707,\n        empty: 8709,\n        nabla: 8711,\n        isin: 8712,\n        notin: 8713,\n        ni: 8715,\n        prod: 8719,\n        sum: 8721,\n        minus: 8722,\n        lowast: 8727,\n        radic: 8730,\n        prop: 8733,\n        infin: 8734,\n        ang: 8736,\n        and: 8743,\n        or: 8744,\n        cap: 8745,\n        cup: 8746,\n        int: 8747,\n        there4: 8756,\n        sim: 8764,\n        cong: 8773,\n        asymp: 8776,\n        ne: 8800,\n        equiv: 8801,\n        le: 8804,\n        ge: 8805,\n        sub: 8834,\n        sup: 8835,\n        nsub: 8836,\n        sube: 8838,\n        supe: 8839,\n        oplus: 8853,\n        otimes: 8855,\n        perp: 8869,\n        sdot: 8901,\n        lceil: 8968,\n        rceil: 8969,\n        lfloor: 8970,\n        rfloor: 8971,\n        lang: 9001,\n        rang: 9002,\n        loz: 9674,\n        spades: 9824,\n        clubs: 9827,\n        hearts: 9829,\n        diams: 9830,\n    };\n    Object.keys(sax.ENTITIES).forEach(function (key) {\n        var e = sax.ENTITIES[key];\n        var s = typeof e === \"number\" ? String.fromCharCode(e) : e;\n        sax.ENTITIES[key] = s;\n    });\n    for (var s in sax.STATE) {\n        sax.STATE[sax.STATE[s]] = s;\n    }\n    // shorthand\n    S = sax.STATE;\n    function emit(parser, event, data) {\n        parser[event] && parser[event](data);\n    }\n    function emitNode(parser, nodeType, data) {\n        if (parser.textNode)\n            closeText(parser);\n        emit(parser, nodeType, data);\n    }\n    function closeText(parser) {\n        parser.textNode = textopts(parser.opt, parser.textNode);\n        if (parser.textNode)\n            emit(parser, \"ontext\", parser.textNode);\n        parser.textNode = \"\";\n    }\n    function textopts(opt, text) {\n        if (opt.trim)\n            text = text.trim();\n        if (opt.normalize)\n            text = text.replace(/\\s+/g, \" \");\n        return text;\n    }\n    function error(parser, er) {\n        closeText(parser);\n        if (parser.trackPosition) {\n            er +=\n                \"\\nLine: \" +\n                    parser.line +\n                    \"\\nColumn: \" +\n                    parser.column +\n                    \"\\nChar: \" +\n                    parser.c;\n        }\n        er = new Error(er);\n        parser.error = er;\n        emit(parser, \"onerror\", er);\n        return parser;\n    }\n    function end(parser) {\n        if (parser.sawRoot && !parser.closedRoot)\n            strictFail(parser, \"Unclosed root tag\");\n        if (parser.state !== S.BEGIN &&\n            parser.state !== S.BEGIN_WHITESPACE &&\n            parser.state !== S.TEXT) {\n            error(parser, \"Unexpected end\");\n        }\n        closeText(parser);\n        parser.c = \"\";\n        parser.closed = true;\n        emit(parser, \"onend\");\n        SAXParser.call(parser, parser.strict, parser.opt);\n        return parser;\n    }\n    function strictFail(parser, message) {\n        if (typeof parser !== \"object\" || !(parser instanceof SAXParser)) {\n            throw new Error(\"bad call to strictFail\");\n        }\n        if (parser.strict) {\n            error(parser, message);\n        }\n    }\n    function newTag(parser) {\n        if (!parser.strict)\n            parser.tagName = parser.tagName[parser.looseCase]();\n        var parent = parser.tags[parser.tags.length - 1] || parser;\n        var tag = (parser.tag = { name: parser.tagName, attributes: {} });\n        // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n        if (parser.opt.xmlns) {\n            tag.ns = parent.ns;\n        }\n        parser.attribList.length = 0;\n        emitNode(parser, \"onopentagstart\", tag);\n    }\n    function qname(name, attribute) {\n        var i = name.indexOf(\":\");\n        var qualName = i < 0 ? [\"\", name] : name.split(\":\");\n        var prefix = qualName[0];\n        var local = qualName[1];\n        // <x \"xmlns\"=\"http://foo\">\n        if (attribute && name === \"xmlns\") {\n            prefix = \"xmlns\";\n            local = \"\";\n        }\n        return { prefix: prefix, local: local };\n    }\n    function attrib(parser) {\n        if (!parser.strict) {\n            parser.attribName = parser.attribName[parser.looseCase]();\n        }\n        if (parser.attribList.indexOf(parser.attribName) !== -1 ||\n            parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n            parser.attribName = parser.attribValue = \"\";\n            return;\n        }\n        if (parser.opt.xmlns) {\n            var qn = qname(parser.attribName, true);\n            var prefix = qn.prefix;\n            var local = qn.local;\n            if (prefix === \"xmlns\") {\n                // namespace binding attribute. push the binding into scope\n                if (local === \"xml\" && parser.attribValue !== XML_NAMESPACE) {\n                    strictFail(parser, \"xml: prefix must be bound to \" +\n                        XML_NAMESPACE +\n                        \"\\n\" +\n                        \"Actual: \" +\n                        parser.attribValue);\n                }\n                else if (local === \"xmlns\" &&\n                    parser.attribValue !== XMLNS_NAMESPACE) {\n                    strictFail(parser, \"xmlns: prefix must be bound to \" +\n                        XMLNS_NAMESPACE +\n                        \"\\n\" +\n                        \"Actual: \" +\n                        parser.attribValue);\n                }\n                else {\n                    var tag = parser.tag;\n                    var parent = parser.tags[parser.tags.length - 1] || parser;\n                    if (tag.ns === parent.ns) {\n                        tag.ns = Object.create(parent.ns);\n                    }\n                    tag.ns[local] = parser.attribValue;\n                }\n            }\n            // defer onattribute events until all attributes have been seen\n            // so any new bindings can take effect. preserve attribute order\n            // so deferred events can be emitted in document order\n            parser.attribList.push([parser.attribName, parser.attribValue]);\n        }\n        else {\n            // in non-xmlns mode, we can emit the event right away\n            parser.tag.attributes[parser.attribName] = parser.attribValue;\n            emitNode(parser, \"onattribute\", {\n                name: parser.attribName,\n                value: parser.attribValue,\n            });\n        }\n        parser.attribName = parser.attribValue = \"\";\n    }\n    function openTag(parser, selfClosing) {\n        if (parser.opt.xmlns) {\n            // emit namespace binding events\n            var tag = parser.tag;\n            // add namespace info to tag\n            var qn = qname(parser.tagName);\n            tag.prefix = qn.prefix;\n            tag.local = qn.local;\n            tag.uri = tag.ns[qn.prefix] || \"\";\n            if (tag.prefix && !tag.uri) {\n                strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(parser.tagName));\n                tag.uri = qn.prefix;\n            }\n            var parent = parser.tags[parser.tags.length - 1] || parser;\n            if (tag.ns && parent.ns !== tag.ns) {\n                Object.keys(tag.ns).forEach(function (p) {\n                    emitNode(parser, \"onopennamespace\", {\n                        prefix: p,\n                        uri: tag.ns[p],\n                    });\n                });\n            }\n            // handle deferred onattribute events\n            // Note: do not apply default ns to attributes:\n            //   http://www.w3.org/TR/REC-xml-names/#defaulting\n            for (var i = 0, l = parser.attribList.length; i < l; i++) {\n                var nv = parser.attribList[i];\n                var name = nv[0];\n                var value = nv[1];\n                var qualName = qname(name, true);\n                var prefix = qualName.prefix;\n                var local = qualName.local;\n                var uri = prefix === \"\" ? \"\" : tag.ns[prefix] || \"\";\n                var a = {\n                    name: name,\n                    value: value,\n                    prefix: prefix,\n                    local: local,\n                    uri: uri,\n                };\n                // if there's any attributes with an undefined namespace,\n                // then fail on them now.\n                if (prefix && prefix !== \"xmlns\" && !uri) {\n                    strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(prefix));\n                    a.uri = prefix;\n                }\n                parser.tag.attributes[name] = a;\n                emitNode(parser, \"onattribute\", a);\n            }\n            parser.attribList.length = 0;\n        }\n        parser.tag.isSelfClosing = !!selfClosing;\n        // process the tag\n        parser.sawRoot = true;\n        parser.tags.push(parser.tag);\n        emitNode(parser, \"onopentag\", parser.tag);\n        if (!selfClosing) {\n            // special case for <script> in non-strict mode.\n            if (!parser.noscript && parser.tagName.toLowerCase() === \"script\") {\n                parser.state = S.SCRIPT;\n            }\n            else {\n                parser.state = S.TEXT;\n            }\n            parser.tag = null;\n            parser.tagName = \"\";\n        }\n        parser.attribName = parser.attribValue = \"\";\n        parser.attribList.length = 0;\n    }\n    function closeTag(parser) {\n        if (!parser.tagName) {\n            strictFail(parser, \"Weird empty close tag.\");\n            parser.textNode += \"</>\";\n            parser.state = S.TEXT;\n            return;\n        }\n        if (parser.script) {\n            if (parser.tagName !== \"script\") {\n                parser.script += \"</\" + parser.tagName + \">\";\n                parser.tagName = \"\";\n                parser.state = S.SCRIPT;\n                return;\n            }\n            emitNode(parser, \"onscript\", parser.script);\n            parser.script = \"\";\n        }\n        // first make sure that the closing tag actually exists.\n        // <a><b></c></b></a> will close everything, otherwise.\n        var t = parser.tags.length;\n        var tagName = parser.tagName;\n        if (!parser.strict) {\n            tagName = tagName[parser.looseCase]();\n        }\n        var closeTo = tagName;\n        while (t--) {\n            var close = parser.tags[t];\n            if (close.name !== closeTo) {\n                // fail the first time in strict mode\n                strictFail(parser, \"Unexpected close tag\");\n            }\n            else {\n                break;\n            }\n        }\n        // didn't find it.  we already failed for strict, so just abort.\n        if (t < 0) {\n            strictFail(parser, \"Unmatched closing tag: \" + parser.tagName);\n            parser.textNode += \"</\" + parser.tagName + \">\";\n            parser.state = S.TEXT;\n            return;\n        }\n        parser.tagName = tagName;\n        var s = parser.tags.length;\n        while (s-- > t) {\n            var tag = (parser.tag = parser.tags.pop());\n            parser.tagName = parser.tag.name;\n            emitNode(parser, \"onclosetag\", parser.tagName);\n            var x = {};\n            for (var i in tag.ns) {\n                x[i] = tag.ns[i];\n            }\n            var parent = parser.tags[parser.tags.length - 1] || parser;\n            if (parser.opt.xmlns && tag.ns !== parent.ns) {\n                // remove namespace bindings introduced by tag\n                Object.keys(tag.ns).forEach(function (p) {\n                    var n = tag.ns[p];\n                    emitNode(parser, \"onclosenamespace\", { prefix: p, uri: n });\n                });\n            }\n        }\n        if (t === 0)\n            parser.closedRoot = true;\n        parser.tagName = parser.attribValue = parser.attribName = \"\";\n        parser.attribList.length = 0;\n        parser.state = S.TEXT;\n    }\n    function parseEntity(parser) {\n        var entity = parser.entity;\n        var entityLC = entity.toLowerCase();\n        var num;\n        var numStr = \"\";\n        if (parser.ENTITIES[entity]) {\n            return parser.ENTITIES[entity];\n        }\n        if (parser.ENTITIES[entityLC]) {\n            return parser.ENTITIES[entityLC];\n        }\n        entity = entityLC;\n        if (entity.charAt(0) === \"#\") {\n            if (entity.charAt(1) === \"x\") {\n                entity = entity.slice(2);\n                num = parseInt(entity, 16);\n                numStr = num.toString(16);\n            }\n            else {\n                entity = entity.slice(1);\n                num = parseInt(entity, 10);\n                numStr = num.toString(10);\n            }\n        }\n        entity = entity.replace(/^0+/, \"\");\n        if (isNaN(num) || numStr.toLowerCase() !== entity) {\n            strictFail(parser, \"Invalid character entity\");\n            return \"&\" + parser.entity + \";\";\n        }\n        return String.fromCodePoint(num);\n    }\n    function beginWhiteSpace(parser, c) {\n        if (c === \"<\") {\n            parser.state = S.OPEN_WAKA;\n            parser.startTagPosition = parser.position;\n        }\n        else if (!isWhitespace(c)) {\n            // have to process this as a text node.\n            // weird, but happens.\n            strictFail(parser, \"Non-whitespace before first tag.\");\n            parser.textNode = c;\n            parser.state = S.TEXT;\n        }\n    }\n    function charAt(chunk, i) {\n        var result = \"\";\n        if (i < chunk.length) {\n            result = chunk.charAt(i);\n        }\n        return result;\n    }\n    function write(chunk) {\n        var parser = this;\n        if (this.error) {\n            throw this.error;\n        }\n        if (parser.closed) {\n            return error(parser, \"Cannot write after close. Assign an onready handler.\");\n        }\n        if (chunk === null) {\n            return end(parser);\n        }\n        if (typeof chunk === \"object\") {\n            chunk = chunk.toString();\n        }\n        var i = 0;\n        var c = \"\";\n        while (true) {\n            c = charAt(chunk, i++);\n            parser.c = c;\n            if (!c) {\n                break;\n            }\n            if (parser.trackPosition) {\n                parser.position++;\n                if (c === \"\\n\") {\n                    parser.line++;\n                    parser.column = 0;\n                }\n                else {\n                    parser.column++;\n                }\n            }\n            switch (parser.state) {\n                case S.BEGIN:\n                    parser.state = S.BEGIN_WHITESPACE;\n                    if (c === \"\\uFEFF\") {\n                        continue;\n                    }\n                    beginWhiteSpace(parser, c);\n                    continue;\n                case S.BEGIN_WHITESPACE:\n                    beginWhiteSpace(parser, c);\n                    continue;\n                case S.TEXT:\n                    if (parser.sawRoot && !parser.closedRoot) {\n                        var starti = i - 1;\n                        while (c && c !== \"<\" && c !== \"&\") {\n                            c = charAt(chunk, i++);\n                            if (c && parser.trackPosition) {\n                                parser.position++;\n                                if (c === \"\\n\") {\n                                    parser.line++;\n                                    parser.column = 0;\n                                }\n                                else {\n                                    parser.column++;\n                                }\n                            }\n                        }\n                        parser.textNode += chunk.substring(starti, i - 1);\n                    }\n                    if (c === \"<\" &&\n                        !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n                        parser.state = S.OPEN_WAKA;\n                        parser.startTagPosition = parser.position;\n                    }\n                    else {\n                        if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\n                            strictFail(parser, \"Text data outside of root node.\");\n                        }\n                        if (c === \"&\") {\n                            parser.state = S.TEXT_ENTITY;\n                        }\n                        else {\n                            parser.textNode += c;\n                        }\n                    }\n                    continue;\n                case S.SCRIPT:\n                    // only non-strict\n                    if (c === \"<\") {\n                        parser.state = S.SCRIPT_ENDING;\n                    }\n                    else {\n                        parser.script += c;\n                    }\n                    continue;\n                case S.SCRIPT_ENDING:\n                    if (c === \"/\") {\n                        parser.state = S.CLOSE_TAG;\n                    }\n                    else {\n                        parser.script += \"<\" + c;\n                        parser.state = S.SCRIPT;\n                    }\n                    continue;\n                case S.OPEN_WAKA:\n                    // either a /, ?, !, or text is coming next.\n                    if (c === \"!\") {\n                        parser.state = S.SGML_DECL;\n                        parser.sgmlDecl = \"\";\n                    }\n                    else if (isWhitespace(c)) {\n                        // wait for it...\n                    }\n                    else if (isMatch(nameStart, c)) {\n                        parser.state = S.OPEN_TAG;\n                        parser.tagName = c;\n                    }\n                    else if (c === \"/\") {\n                        parser.state = S.CLOSE_TAG;\n                        parser.tagName = \"\";\n                    }\n                    else if (c === \"?\") {\n                        parser.state = S.PROC_INST;\n                        parser.procInstName = parser.procInstBody = \"\";\n                    }\n                    else {\n                        strictFail(parser, \"Unencoded <\");\n                        // if there was some whitespace, then add that in.\n                        if (parser.startTagPosition + 1 < parser.position) {\n                            var pad = parser.position - parser.startTagPosition;\n                            c = new Array(pad).join(\" \") + c;\n                        }\n                        parser.textNode += \"<\" + c;\n                        parser.state = S.TEXT;\n                    }\n                    continue;\n                case S.SGML_DECL:\n                    if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n                        emitNode(parser, \"onopencdata\");\n                        parser.state = S.CDATA;\n                        parser.sgmlDecl = \"\";\n                        parser.cdata = \"\";\n                    }\n                    else if (parser.sgmlDecl + c === \"--\") {\n                        parser.state = S.COMMENT;\n                        parser.comment = \"\";\n                        parser.sgmlDecl = \"\";\n                    }\n                    else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n                        parser.state = S.DOCTYPE;\n                        if (parser.doctype || parser.sawRoot) {\n                            strictFail(parser, \"Inappropriately located doctype declaration\");\n                        }\n                        parser.doctype = \"\";\n                        parser.sgmlDecl = \"\";\n                    }\n                    else if (c === \">\") {\n                        emitNode(parser, \"onsgmldeclaration\", parser.sgmlDecl);\n                        parser.sgmlDecl = \"\";\n                        parser.state = S.TEXT;\n                    }\n                    else if (isQuote(c)) {\n                        parser.state = S.SGML_DECL_QUOTED;\n                        parser.sgmlDecl += c;\n                    }\n                    else {\n                        parser.sgmlDecl += c;\n                    }\n                    continue;\n                case S.SGML_DECL_QUOTED:\n                    if (c === parser.q) {\n                        parser.state = S.SGML_DECL;\n                        parser.q = \"\";\n                    }\n                    parser.sgmlDecl += c;\n                    continue;\n                case S.DOCTYPE:\n                    if (c === \">\") {\n                        parser.state = S.TEXT;\n                        emitNode(parser, \"ondoctype\", parser.doctype);\n                        parser.doctype = true; // just remember that we saw it.\n                    }\n                    else {\n                        parser.doctype += c;\n                        if (c === \"[\") {\n                            parser.state = S.DOCTYPE_DTD;\n                        }\n                        else if (isQuote(c)) {\n                            parser.state = S.DOCTYPE_QUOTED;\n                            parser.q = c;\n                        }\n                    }\n                    continue;\n                case S.DOCTYPE_QUOTED:\n                    parser.doctype += c;\n                    if (c === parser.q) {\n                        parser.q = \"\";\n                        parser.state = S.DOCTYPE;\n                    }\n                    continue;\n                case S.DOCTYPE_DTD:\n                    parser.doctype += c;\n                    if (c === \"]\") {\n                        parser.state = S.DOCTYPE;\n                    }\n                    else if (isQuote(c)) {\n                        parser.state = S.DOCTYPE_DTD_QUOTED;\n                        parser.q = c;\n                    }\n                    continue;\n                case S.DOCTYPE_DTD_QUOTED:\n                    parser.doctype += c;\n                    if (c === parser.q) {\n                        parser.state = S.DOCTYPE_DTD;\n                        parser.q = \"\";\n                    }\n                    continue;\n                case S.COMMENT:\n                    if (c === \"-\") {\n                        parser.state = S.COMMENT_ENDING;\n                    }\n                    else {\n                        parser.comment += c;\n                    }\n                    continue;\n                case S.COMMENT_ENDING:\n                    if (c === \"-\") {\n                        parser.state = S.COMMENT_ENDED;\n                        parser.comment = textopts(parser.opt, parser.comment);\n                        if (parser.comment) {\n                            emitNode(parser, \"oncomment\", parser.comment);\n                        }\n                        parser.comment = \"\";\n                    }\n                    else {\n                        parser.comment += \"-\" + c;\n                        parser.state = S.COMMENT;\n                    }\n                    continue;\n                case S.COMMENT_ENDED:\n                    if (c !== \">\") {\n                        strictFail(parser, \"Malformed comment\");\n                        // allow <!-- blah -- bloo --> in non-strict mode,\n                        // which is a comment of \" blah -- bloo \"\n                        parser.comment += \"--\" + c;\n                        parser.state = S.COMMENT;\n                    }\n                    else {\n                        parser.state = S.TEXT;\n                    }\n                    continue;\n                case S.CDATA:\n                    if (c === \"]\") {\n                        parser.state = S.CDATA_ENDING;\n                    }\n                    else {\n                        parser.cdata += c;\n                    }\n                    continue;\n                case S.CDATA_ENDING:\n                    if (c === \"]\") {\n                        parser.state = S.CDATA_ENDING_2;\n                    }\n                    else {\n                        parser.cdata += \"]\" + c;\n                        parser.state = S.CDATA;\n                    }\n                    continue;\n                case S.CDATA_ENDING_2:\n                    if (c === \">\") {\n                        if (parser.cdata) {\n                            emitNode(parser, \"oncdata\", parser.cdata);\n                        }\n                        emitNode(parser, \"onclosecdata\");\n                        parser.cdata = \"\";\n                        parser.state = S.TEXT;\n                    }\n                    else if (c === \"]\") {\n                        parser.cdata += \"]\";\n                    }\n                    else {\n                        parser.cdata += \"]]\" + c;\n                        parser.state = S.CDATA;\n                    }\n                    continue;\n                case S.PROC_INST:\n                    if (c === \"?\") {\n                        parser.state = S.PROC_INST_ENDING;\n                    }\n                    else if (isWhitespace(c)) {\n                        parser.state = S.PROC_INST_BODY;\n                    }\n                    else {\n                        parser.procInstName += c;\n                    }\n                    continue;\n                case S.PROC_INST_BODY:\n                    if (!parser.procInstBody && isWhitespace(c)) {\n                        continue;\n                    }\n                    else if (c === \"?\") {\n                        parser.state = S.PROC_INST_ENDING;\n                    }\n                    else {\n                        parser.procInstBody += c;\n                    }\n                    continue;\n                case S.PROC_INST_ENDING:\n                    if (c === \">\") {\n                        emitNode(parser, \"onprocessinginstruction\", {\n                            name: parser.procInstName,\n                            body: parser.procInstBody,\n                        });\n                        parser.procInstName = parser.procInstBody = \"\";\n                        parser.state = S.TEXT;\n                    }\n                    else {\n                        parser.procInstBody += \"?\" + c;\n                        parser.state = S.PROC_INST_BODY;\n                    }\n                    continue;\n                case S.OPEN_TAG:\n                    if (isMatch(nameBody, c)) {\n                        parser.tagName += c;\n                    }\n                    else {\n                        newTag(parser);\n                        if (c === \">\") {\n                            openTag(parser);\n                        }\n                        else if (c === \"/\") {\n                            parser.state = S.OPEN_TAG_SLASH;\n                        }\n                        else {\n                            if (!isWhitespace(c)) {\n                                strictFail(parser, \"Invalid character in tag name\");\n                            }\n                            parser.state = S.ATTRIB;\n                        }\n                    }\n                    continue;\n                case S.OPEN_TAG_SLASH:\n                    if (c === \">\") {\n                        openTag(parser, true);\n                        closeTag(parser);\n                    }\n                    else {\n                        strictFail(parser, \"Forward-slash in opening tag not followed by >\");\n                        parser.state = S.ATTRIB;\n                    }\n                    continue;\n                case S.ATTRIB:\n                    // haven't read the attribute name yet.\n                    if (isWhitespace(c)) {\n                        continue;\n                    }\n                    else if (c === \">\") {\n                        openTag(parser);\n                    }\n                    else if (c === \"/\") {\n                        parser.state = S.OPEN_TAG_SLASH;\n                    }\n                    else if (isMatch(nameStart, c)) {\n                        parser.attribName = c;\n                        parser.attribValue = \"\";\n                        parser.state = S.ATTRIB_NAME;\n                    }\n                    else {\n                        strictFail(parser, \"Invalid attribute name\");\n                    }\n                    continue;\n                case S.ATTRIB_NAME:\n                    if (c === \"=\") {\n                        parser.state = S.ATTRIB_VALUE;\n                    }\n                    else if (c === \">\") {\n                        strictFail(parser, \"Attribute without value\");\n                        parser.attribValue = parser.attribName;\n                        attrib(parser);\n                        openTag(parser);\n                    }\n                    else if (isWhitespace(c)) {\n                        parser.state = S.ATTRIB_NAME_SAW_WHITE;\n                    }\n                    else if (isMatch(nameBody, c)) {\n                        parser.attribName += c;\n                    }\n                    else {\n                        strictFail(parser, \"Invalid attribute name\");\n                    }\n                    continue;\n                case S.ATTRIB_NAME_SAW_WHITE:\n                    if (c === \"=\") {\n                        parser.state = S.ATTRIB_VALUE;\n                    }\n                    else if (isWhitespace(c)) {\n                        continue;\n                    }\n                    else {\n                        strictFail(parser, \"Attribute without value\");\n                        parser.tag.attributes[parser.attribName] = \"\";\n                        parser.attribValue = \"\";\n                        emitNode(parser, \"onattribute\", {\n                            name: parser.attribName,\n                            value: \"\",\n                        });\n                        parser.attribName = \"\";\n                        if (c === \">\") {\n                            openTag(parser);\n                        }\n                        else if (isMatch(nameStart, c)) {\n                            parser.attribName = c;\n                            parser.state = S.ATTRIB_NAME;\n                        }\n                        else {\n                            strictFail(parser, \"Invalid attribute name\");\n                            parser.state = S.ATTRIB;\n                        }\n                    }\n                    continue;\n                case S.ATTRIB_VALUE:\n                    if (isWhitespace(c)) {\n                        continue;\n                    }\n                    else if (isQuote(c)) {\n                        parser.q = c;\n                        parser.state = S.ATTRIB_VALUE_QUOTED;\n                    }\n                    else {\n                        strictFail(parser, \"Unquoted attribute value\");\n                        parser.state = S.ATTRIB_VALUE_UNQUOTED;\n                        parser.attribValue = c;\n                    }\n                    continue;\n                case S.ATTRIB_VALUE_QUOTED:\n                    if (c !== parser.q) {\n                        if (c === \"&\") {\n                            parser.state = S.ATTRIB_VALUE_ENTITY_Q;\n                        }\n                        else {\n                            parser.attribValue += c;\n                        }\n                        continue;\n                    }\n                    attrib(parser);\n                    parser.q = \"\";\n                    parser.state = S.ATTRIB_VALUE_CLOSED;\n                    continue;\n                case S.ATTRIB_VALUE_CLOSED:\n                    if (isWhitespace(c)) {\n                        parser.state = S.ATTRIB;\n                    }\n                    else if (c === \">\") {\n                        openTag(parser);\n                    }\n                    else if (c === \"/\") {\n                        parser.state = S.OPEN_TAG_SLASH;\n                    }\n                    else if (isMatch(nameStart, c)) {\n                        strictFail(parser, \"No whitespace between attributes\");\n                        parser.attribName = c;\n                        parser.attribValue = \"\";\n                        parser.state = S.ATTRIB_NAME;\n                    }\n                    else {\n                        strictFail(parser, \"Invalid attribute name\");\n                    }\n                    continue;\n                case S.ATTRIB_VALUE_UNQUOTED:\n                    if (!isAttribEnd(c)) {\n                        if (c === \"&\") {\n                            parser.state = S.ATTRIB_VALUE_ENTITY_U;\n                        }\n                        else {\n                            parser.attribValue += c;\n                        }\n                        continue;\n                    }\n                    attrib(parser);\n                    if (c === \">\") {\n                        openTag(parser);\n                    }\n                    else {\n                        parser.state = S.ATTRIB;\n                    }\n                    continue;\n                case S.CLOSE_TAG:\n                    if (!parser.tagName) {\n                        if (isWhitespace(c)) {\n                            continue;\n                        }\n                        else if (notMatch(nameStart, c)) {\n                            if (parser.script) {\n                                parser.script += \"</\" + c;\n                                parser.state = S.SCRIPT;\n                            }\n                            else {\n                                strictFail(parser, \"Invalid tagname in closing tag.\");\n                            }\n                        }\n                        else {\n                            parser.tagName = c;\n                        }\n                    }\n                    else if (c === \">\") {\n                        closeTag(parser);\n                    }\n                    else if (isMatch(nameBody, c)) {\n                        parser.tagName += c;\n                    }\n                    else if (parser.script) {\n                        parser.script += \"</\" + parser.tagName;\n                        parser.tagName = \"\";\n                        parser.state = S.SCRIPT;\n                    }\n                    else {\n                        if (!isWhitespace(c)) {\n                            strictFail(parser, \"Invalid tagname in closing tag\");\n                        }\n                        parser.state = S.CLOSE_TAG_SAW_WHITE;\n                    }\n                    continue;\n                case S.CLOSE_TAG_SAW_WHITE:\n                    if (isWhitespace(c)) {\n                        continue;\n                    }\n                    if (c === \">\") {\n                        closeTag(parser);\n                    }\n                    else {\n                        strictFail(parser, \"Invalid characters in closing tag\");\n                    }\n                    continue;\n                case S.TEXT_ENTITY:\n                case S.ATTRIB_VALUE_ENTITY_Q:\n                case S.ATTRIB_VALUE_ENTITY_U:\n                    var returnState;\n                    var buffer;\n                    switch (parser.state) {\n                        case S.TEXT_ENTITY:\n                            returnState = S.TEXT;\n                            buffer = \"textNode\";\n                            break;\n                        case S.ATTRIB_VALUE_ENTITY_Q:\n                            returnState = S.ATTRIB_VALUE_QUOTED;\n                            buffer = \"attribValue\";\n                            break;\n                        case S.ATTRIB_VALUE_ENTITY_U:\n                            returnState = S.ATTRIB_VALUE_UNQUOTED;\n                            buffer = \"attribValue\";\n                            break;\n                    }\n                    if (c === \";\") {\n                        if (parser.opt.unparsedEntities) {\n                            var parsedEntity = parseEntity(parser);\n                            parser.entity = \"\";\n                            parser.state = returnState;\n                            parser.write(parsedEntity);\n                        }\n                        else {\n                            parser[buffer] += parseEntity(parser);\n                            parser.entity = \"\";\n                            parser.state = returnState;\n                        }\n                    }\n                    else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {\n                        parser.entity += c;\n                    }\n                    else {\n                        strictFail(parser, \"Invalid character in entity name\");\n                        parser[buffer] += \"&\" + parser.entity + c;\n                        parser.entity = \"\";\n                        parser.state = returnState;\n                    }\n                    continue;\n                default: /* istanbul ignore next */ {\n                    throw new Error(parser, \"Unknown state: \" + parser.state);\n                }\n            }\n        } // while\n        if (parser.position >= parser.bufferCheckPosition) {\n            checkBufferLength(parser);\n        }\n        return parser;\n    }\n    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n    /* istanbul ignore next */\n    if (!String.fromCodePoint) {\n        (function () {\n            var stringFromCharCode = String.fromCharCode;\n            var floor = Math.floor;\n            var fromCodePoint = function () {\n                var MAX_SIZE = 0x4000;\n                var codeUnits = [];\n                var highSurrogate;\n                var lowSurrogate;\n                var index = -1;\n                var length = arguments.length;\n                if (!length) {\n                    return \"\";\n                }\n                var result = \"\";\n                while (++index < length) {\n                    var codePoint = Number(arguments[index]);\n                    if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n                        codePoint < 0 || // not a valid Unicode code point\n                        codePoint > 0x10ffff || // not a valid Unicode code point\n                        floor(codePoint) !== codePoint // not an integer\n                    ) {\n                        throw RangeError(\"Invalid code point: \" + codePoint);\n                    }\n                    if (codePoint <= 0xffff) {\n                        // BMP code point\n                        codeUnits.push(codePoint);\n                    }\n                    else {\n                        // Astral code point; split in surrogate halves\n                        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n                        codePoint -= 0x10000;\n                        highSurrogate = (codePoint >> 10) + 0xd800;\n                        lowSurrogate = (codePoint % 0x400) + 0xdc00;\n                        codeUnits.push(highSurrogate, lowSurrogate);\n                    }\n                    if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n                        result += stringFromCharCode.apply(null, codeUnits);\n                        codeUnits.length = 0;\n                    }\n                }\n                return result;\n            };\n            /* istanbul ignore next */\n            if (Object.defineProperty) {\n                Object.defineProperty(String, \"fromCodePoint\", {\n                    value: fromCodePoint,\n                    configurable: true,\n                    writable: true,\n                });\n            }\n            else {\n                String.fromCodePoint = fromCodePoint;\n            }\n        })();\n    }\n    return sax;\n};\nconst sax = /** #__PURE__ */ initializeSax();\nexports.sax = sax;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvc2F4LWpzL3NheC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzQ0FBc0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELE9BQU87QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxtQkFBbUI7QUFDOUUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL3NheC1qcy9zYXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQHRzLW5vY2hlY2tcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2F4ID0gdm9pZCAwO1xuLy8gSW5saW5lZCB0byBkZWFsIHdpdGggcG9ydGFiaWxpdHkgaXNzdWVzXG4vLyBPcmlnaW5hbGx5IGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3Mvc2F4LWpzXG5jb25zdCBpbml0aWFsaXplU2F4ID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHNheCA9IHt9O1xuICAgIHNheC5wYXJzZXIgPSBmdW5jdGlvbiAoc3RyaWN0LCBvcHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTQVhQYXJzZXIoc3RyaWN0LCBvcHQpO1xuICAgIH07XG4gICAgc2F4LlNBWFBhcnNlciA9IFNBWFBhcnNlcjtcbiAgICBzYXguU0FYU3RyZWFtID0gU0FYU3RyZWFtO1xuICAgIHNheC5jcmVhdGVTdHJlYW0gPSBjcmVhdGVTdHJlYW07XG4gICAgLy8gV2hlbiB3ZSBwYXNzIHRoZSBNQVhfQlVGRkVSX0xFTkdUSCBwb3NpdGlvbiwgc3RhcnQgY2hlY2tpbmcgZm9yIGJ1ZmZlciBvdmVycnVucy5cbiAgICAvLyBXaGVuIHdlIGNoZWNrLCBzY2hlZHVsZSB0aGUgbmV4dCBjaGVjayBmb3IgTUFYX0JVRkZFUl9MRU5HVEggLSAobWF4KGJ1ZmZlciBsZW5ndGhzKSksXG4gICAgLy8gc2luY2UgdGhhdCdzIHRoZSBlYXJsaWVzdCB0aGF0IGEgYnVmZmVyIG92ZXJydW4gY291bGQgb2NjdXIuICBUaGlzIHdheSwgY2hlY2tzIGFyZVxuICAgIC8vIGFzIHJhcmUgYXMgcmVxdWlyZWQsIGJ1dCBhcyBvZnRlbiBhcyBuZWNlc3NhcnkgdG8gZW5zdXJlIG5ldmVyIGNyb3NzaW5nIHRoaXMgYm91bmQuXG4gICAgLy8gRnVydGhlcm1vcmUsIGJ1ZmZlcnMgYXJlIG9ubHkgdGVzdGVkIGF0IG1vc3Qgb25jZSBwZXIgd3JpdGUoKSwgc28gcGFzc2luZyBhIHZlcnlcbiAgICAvLyBsYXJnZSBzdHJpbmcgaW50byB3cml0ZSgpIG1pZ2h0IGhhdmUgdW5kZXNpcmFibGUgZWZmZWN0cywgYnV0IHRoaXMgaXMgbWFuYWdlYWJsZSBieVxuICAgIC8vIHRoZSBjYWxsZXIsIHNvIGl0IGlzIGFzc3VtZWQgdG8gYmUgc2FmZS4gIFRodXMsIGEgY2FsbCB0byB3cml0ZSgpIG1heSwgaW4gdGhlIGV4dHJlbWVcbiAgICAvLyBlZGdlIGNhc2UsIHJlc3VsdCBpbiBjcmVhdGluZyBhdCBtb3N0IG9uZSBjb21wbGV0ZSBjb3B5IG9mIHRoZSBzdHJpbmcgcGFzc2VkIGluLlxuICAgIC8vIFNldCB0byBJbmZpbml0eSB0byBoYXZlIHVubGltaXRlZCBidWZmZXJzLlxuICAgIHNheC5NQVhfQlVGRkVSX0xFTkdUSCA9IDY0ICogMTAyNDtcbiAgICBjb25zdCBidWZmZXJzID0gW1xuICAgICAgICBcImNvbW1lbnRcIixcbiAgICAgICAgXCJzZ21sRGVjbFwiLFxuICAgICAgICBcInRleHROb2RlXCIsXG4gICAgICAgIFwidGFnTmFtZVwiLFxuICAgICAgICBcImRvY3R5cGVcIixcbiAgICAgICAgXCJwcm9jSW5zdE5hbWVcIixcbiAgICAgICAgXCJwcm9jSW5zdEJvZHlcIixcbiAgICAgICAgXCJlbnRpdHlcIixcbiAgICAgICAgXCJhdHRyaWJOYW1lXCIsXG4gICAgICAgIFwiYXR0cmliVmFsdWVcIixcbiAgICAgICAgXCJjZGF0YVwiLFxuICAgICAgICBcInNjcmlwdFwiLFxuICAgIF07XG4gICAgc2F4LkVWRU5UUyA9IFtcbiAgICAgICAgXCJ0ZXh0XCIsXG4gICAgICAgIFwicHJvY2Vzc2luZ2luc3RydWN0aW9uXCIsXG4gICAgICAgIFwic2dtbGRlY2xhcmF0aW9uXCIsXG4gICAgICAgIFwiZG9jdHlwZVwiLFxuICAgICAgICBcImNvbW1lbnRcIixcbiAgICAgICAgXCJvcGVudGFnc3RhcnRcIixcbiAgICAgICAgXCJhdHRyaWJ1dGVcIixcbiAgICAgICAgXCJvcGVudGFnXCIsXG4gICAgICAgIFwiY2xvc2V0YWdcIixcbiAgICAgICAgXCJvcGVuY2RhdGFcIixcbiAgICAgICAgXCJjZGF0YVwiLFxuICAgICAgICBcImNsb3NlY2RhdGFcIixcbiAgICAgICAgXCJlcnJvclwiLFxuICAgICAgICBcImVuZFwiLFxuICAgICAgICBcInJlYWR5XCIsXG4gICAgICAgIFwic2NyaXB0XCIsXG4gICAgICAgIFwib3Blbm5hbWVzcGFjZVwiLFxuICAgICAgICBcImNsb3NlbmFtZXNwYWNlXCIsXG4gICAgXTtcbiAgICBmdW5jdGlvbiBTQVhQYXJzZXIoc3RyaWN0LCBvcHQpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNBWFBhcnNlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU0FYUGFyc2VyKHN0cmljdCwgb3B0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyc2VyID0gdGhpcztcbiAgICAgICAgY2xlYXJCdWZmZXJzKHBhcnNlcik7XG4gICAgICAgIHBhcnNlci5xID0gcGFyc2VyLmMgPSBcIlwiO1xuICAgICAgICBwYXJzZXIuYnVmZmVyQ2hlY2tQb3NpdGlvbiA9IHNheC5NQVhfQlVGRkVSX0xFTkdUSDtcbiAgICAgICAgcGFyc2VyLm9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgcGFyc2VyLm9wdC5sb3dlcmNhc2UgPSBwYXJzZXIub3B0Lmxvd2VyY2FzZSB8fCBwYXJzZXIub3B0Lmxvd2VyY2FzZXRhZ3M7XG4gICAgICAgIHBhcnNlci5sb29zZUNhc2UgPSBwYXJzZXIub3B0Lmxvd2VyY2FzZSA/IFwidG9Mb3dlckNhc2VcIiA6IFwidG9VcHBlckNhc2VcIjtcbiAgICAgICAgcGFyc2VyLnRhZ3MgPSBbXTtcbiAgICAgICAgcGFyc2VyLmNsb3NlZCA9IHBhcnNlci5jbG9zZWRSb290ID0gcGFyc2VyLnNhd1Jvb3QgPSBmYWxzZTtcbiAgICAgICAgcGFyc2VyLnRhZyA9IHBhcnNlci5lcnJvciA9IG51bGw7XG4gICAgICAgIHBhcnNlci5zdHJpY3QgPSAhIXN0cmljdDtcbiAgICAgICAgcGFyc2VyLm5vc2NyaXB0ID0gISEoc3RyaWN0IHx8IHBhcnNlci5vcHQubm9zY3JpcHQpO1xuICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkJFR0lOO1xuICAgICAgICBwYXJzZXIuc3RyaWN0RW50aXRpZXMgPSBwYXJzZXIub3B0LnN0cmljdEVudGl0aWVzO1xuICAgICAgICBwYXJzZXIuRU5USVRJRVMgPSBwYXJzZXIuc3RyaWN0RW50aXRpZXNcbiAgICAgICAgICAgID8gT2JqZWN0LmNyZWF0ZShzYXguWE1MX0VOVElUSUVTKVxuICAgICAgICAgICAgOiBPYmplY3QuY3JlYXRlKHNheC5FTlRJVElFUyk7XG4gICAgICAgIHBhcnNlci5hdHRyaWJMaXN0ID0gW107XG4gICAgICAgIC8vIG5hbWVzcGFjZXMgZm9ybSBhIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgICAgLy8gaXQgYWx3YXlzIHBvaW50cyBhdCB0aGUgY3VycmVudCB0YWcsXG4gICAgICAgIC8vIHdoaWNoIHByb3RvcyB0byBpdHMgcGFyZW50IHRhZy5cbiAgICAgICAgaWYgKHBhcnNlci5vcHQueG1sbnMpIHtcbiAgICAgICAgICAgIHBhcnNlci5ucyA9IE9iamVjdC5jcmVhdGUocm9vdE5TKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtb3N0bHkganVzdCBmb3IgZXJyb3IgcmVwb3J0aW5nXG4gICAgICAgIHBhcnNlci50cmFja1Bvc2l0aW9uID0gcGFyc2VyLm9wdC5wb3NpdGlvbiAhPT0gZmFsc2U7XG4gICAgICAgIGlmIChwYXJzZXIudHJhY2tQb3NpdGlvbikge1xuICAgICAgICAgICAgcGFyc2VyLnBvc2l0aW9uID0gcGFyc2VyLmxpbmUgPSBwYXJzZXIuY29sdW1uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbWl0KHBhcnNlciwgXCJvbnJlYWR5XCIpO1xuICAgIH1cbiAgICBpZiAoIU9iamVjdC5jcmVhdGUpIHtcbiAgICAgICAgT2JqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBGKCkgeyB9XG4gICAgICAgICAgICBGLnByb3RvdHlwZSA9IG87XG4gICAgICAgICAgICB2YXIgbmV3ZiA9IG5ldyBGKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3ZjtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFPYmplY3Qua2V5cykge1xuICAgICAgICBPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBvKVxuICAgICAgICAgICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGkpKVxuICAgICAgICAgICAgICAgICAgICBhLnB1c2goaSk7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tCdWZmZXJMZW5ndGgocGFyc2VyKSB7XG4gICAgICAgIHZhciBtYXhBbGxvd2VkID0gTWF0aC5tYXgoc2F4Lk1BWF9CVUZGRVJfTEVOR1RILCAxMCk7XG4gICAgICAgIHZhciBtYXhBY3R1YWwgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGJ1ZmZlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gcGFyc2VyW2J1ZmZlcnNbaV1dLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW4gPiBtYXhBbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gVGV4dC9jZGF0YSBub2RlcyBjYW4gZ2V0IGJpZywgYW5kIHNpbmNlIHRoZXkncmUgYnVmZmVyZWQsXG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuIGdldCBoZXJlIHVuZGVyIG5vcm1hbCBjb25kaXRpb25zLlxuICAgICAgICAgICAgICAgIC8vIEF2b2lkIGlzc3VlcyBieSBlbWl0dGluZyB0aGUgdGV4dCBub2RlIG5vdyxcbiAgICAgICAgICAgICAgICAvLyBzbyBhdCBsZWFzdCBpdCB3b24ndCBnZXQgYW55IGJpZ2dlci5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGJ1ZmZlcnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHROb2RlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZVRleHQocGFyc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2RhdGFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbmNkYXRhXCIsIHBhcnNlci5jZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuY2RhdGEgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbnNjcmlwdFwiLCBwYXJzZXIuc2NyaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihwYXJzZXIsIFwiTWF4IGJ1ZmZlciBsZW5ndGggZXhjZWVkZWQ6IFwiICsgYnVmZmVyc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF4QWN0dWFsID0gTWF0aC5tYXgobWF4QWN0dWFsLCBsZW4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNjaGVkdWxlIHRoZSBuZXh0IGNoZWNrIGZvciB0aGUgZWFybGllc3QgcG9zc2libGUgYnVmZmVyIG92ZXJydW4uXG4gICAgICAgIHZhciBtID0gc2F4Lk1BWF9CVUZGRVJfTEVOR1RIIC0gbWF4QWN0dWFsO1xuICAgICAgICBwYXJzZXIuYnVmZmVyQ2hlY2tQb3NpdGlvbiA9IG0gKyBwYXJzZXIucG9zaXRpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFyQnVmZmVycyhwYXJzZXIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBidWZmZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgcGFyc2VyW2J1ZmZlcnNbaV1dID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaEJ1ZmZlcnMocGFyc2VyKSB7XG4gICAgICAgIGNsb3NlVGV4dChwYXJzZXIpO1xuICAgICAgICBpZiAocGFyc2VyLmNkYXRhICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsIFwib25jZGF0YVwiLCBwYXJzZXIuY2RhdGEpO1xuICAgICAgICAgICAgcGFyc2VyLmNkYXRhID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyc2VyLnNjcmlwdCAhPT0gXCJcIikge1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9uc2NyaXB0XCIsIHBhcnNlci5zY3JpcHQpO1xuICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgU0FYUGFyc2VyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbmQodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRlOiB3cml0ZSxcbiAgICAgICAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JpdGUobnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZsdXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmbHVzaEJ1ZmZlcnModGhpcyk7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICB2YXIgU3RyZWFtID0gUmVhZGFibGVTdHJlYW07XG4gICAgaWYgKCFTdHJlYW0pXG4gICAgICAgIFN0cmVhbSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICB2YXIgc3RyZWFtV3JhcHMgPSBzYXguRVZFTlRTLmZpbHRlcihmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgcmV0dXJuIGV2ICE9PSBcImVycm9yXCIgJiYgZXYgIT09IFwiZW5kXCI7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gY3JlYXRlU3RyZWFtKHN0cmljdCwgb3B0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU0FYU3RyZWFtKHN0cmljdCwgb3B0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gU0FYU3RyZWFtKHN0cmljdCwgb3B0KSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTQVhTdHJlYW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNBWFN0cmVhbShzdHJpY3QsIG9wdCk7XG4gICAgICAgIH1cbiAgICAgICAgU3RyZWFtLmFwcGx5KHRoaXMpO1xuICAgICAgICB0aGlzLl9wYXJzZXIgPSBuZXcgU0FYUGFyc2VyKHN0cmljdCwgb3B0KTtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB0aGlzLl9wYXJzZXIub25lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBtZS5lbWl0KFwiZW5kXCIpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wYXJzZXIub25lcnJvciA9IGZ1bmN0aW9uIChlcikge1xuICAgICAgICAgICAgbWUuZW1pdChcImVycm9yXCIsIGVyKTtcbiAgICAgICAgICAgIC8vIGlmIGRpZG4ndCB0aHJvdywgdGhlbiBtZWFucyBlcnJvciB3YXMgaGFuZGxlZC5cbiAgICAgICAgICAgIC8vIGdvIGFoZWFkIGFuZCBjbGVhciBlcnJvciwgc28gd2UgY2FuIHdyaXRlIGFnYWluLlxuICAgICAgICAgICAgbWUuX3BhcnNlci5lcnJvciA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2RlY29kZXIgPSBudWxsO1xuICAgICAgICBzdHJlYW1XcmFwcy5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1lLCBcIm9uXCIgKyBldiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWUuX3BhcnNlcltcIm9uXCIgKyBldl07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUucmVtb3ZlQWxsTGlzdGVuZXJzKGV2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLl9wYXJzZXJbXCJvblwiICsgZXZdID0gaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lLm9uKGV2LCBoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgU0FYU3RyZWFtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3RyZWFtLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IFNBWFN0cmVhbSxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBTQVhTdHJlYW0ucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fcGFyc2VyLndyaXRlKGRhdGEudG9TdHJpbmcoKSk7XG4gICAgICAgIHRoaXMuZW1pdChcImRhdGFcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgU0FYU3RyZWFtLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy53cml0ZShjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGFyc2VyLmVuZCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFNBWFN0cmVhbS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgaWYgKCFtZS5fcGFyc2VyW1wib25cIiArIGV2XSAmJiBzdHJlYW1XcmFwcy5pbmRleE9mKGV2KSAhPT0gLTEpIHtcbiAgICAgICAgICAgIG1lLl9wYXJzZXJbXCJvblwiICsgZXZdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgICAgICAgICAgICAgICAgICA/IFthcmd1bWVudHNbMF1dXG4gICAgICAgICAgICAgICAgICAgIDogQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBhcmdzLnNwbGljZSgwLCAwLCBldik7XG4gICAgICAgICAgICAgICAgbWUuZW1pdC5hcHBseShtZSwgYXJncyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwobWUsIGV2LCBoYW5kbGVyKTtcbiAgICB9O1xuICAgIC8vIHRoaXMgcmVhbGx5IG5lZWRzIHRvIGJlIHJlcGxhY2VkIHdpdGggY2hhcmFjdGVyIGNsYXNzZXMuXG4gICAgLy8gWE1MIGFsbG93cyBhbGwgbWFubmVyIG9mIHJpZGljdWxvdXMgbnVtYmVycyBhbmQgZGlnaXRzLlxuICAgIHZhciBDREFUQSA9IFwiW0NEQVRBW1wiO1xuICAgIHZhciBET0NUWVBFID0gXCJET0NUWVBFXCI7XG4gICAgdmFyIFhNTF9OQU1FU1BBQ0UgPSBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiO1xuICAgIHZhciBYTUxOU19OQU1FU1BBQ0UgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvXCI7XG4gICAgdmFyIHJvb3ROUyA9IHsgeG1sOiBYTUxfTkFNRVNQQUNFLCB4bWxuczogWE1MTlNfTkFNRVNQQUNFIH07XG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVN0YXJ0Q2hhclxuICAgIC8vIFRoaXMgaW1wbGVtZW50YXRpb24gd29ya3Mgb24gc3RyaW5ncywgYSBzaW5nbGUgY2hhcmFjdGVyIGF0IGEgdGltZVxuICAgIC8vIGFzIHN1Y2gsIGl0IGNhbm5vdCBldmVyIHN1cHBvcnQgYXN0cmFsLXBsYW5lIGNoYXJhY3RlcnMgKDEwMDAwLUVGRkZGKVxuICAgIC8vIHdpdGhvdXQgYSBzaWduaWZpY2FudCBicmVha2luZyBjaGFuZ2UgdG8gZWl0aGVyIHRoaXMgIHBhcnNlciwgb3IgdGhlXG4gICAgLy8gSmF2YVNjcmlwdCBsYW5ndWFnZS4gIEltcGxlbWVudGF0aW9uIG9mIGFuIGVtb2ppLWNhcGFibGUgeG1sIHBhcnNlclxuICAgIC8vIGlzIGxlZnQgYXMgYW4gZXhlcmNpc2UgZm9yIHRoZSByZWFkZXIuXG4gICAgdmFyIG5hbWVTdGFydCA9IC9bOl9BLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRdLztcbiAgICB2YXIgbmFtZUJvZHkgPSAvWzpfQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXFx1MDBCN1xcdTAzMDAtXFx1MDM2RlxcdTIwM0YtXFx1MjA0MC5cXGQtXS87XG4gICAgdmFyIGVudGl0eVN0YXJ0ID0gL1sjOl9BLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRdLztcbiAgICB2YXIgZW50aXR5Qm9keSA9IC9bIzpfQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXFx1MDBCN1xcdTAzMDAtXFx1MDM2RlxcdTIwM0YtXFx1MjA0MC5cXGQtXS87XG4gICAgZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGMpIHtcbiAgICAgICAgcmV0dXJuIGMgPT09IFwiIFwiIHx8IGMgPT09IFwiXFxuXCIgfHwgYyA9PT0gXCJcXHJcIiB8fCBjID09PSBcIlxcdFwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1F1b3RlKGMpIHtcbiAgICAgICAgcmV0dXJuIGMgPT09ICdcIicgfHwgYyA9PT0gXCInXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQXR0cmliRW5kKGMpIHtcbiAgICAgICAgcmV0dXJuIGMgPT09IFwiPlwiIHx8IGlzV2hpdGVzcGFjZShjKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNNYXRjaChyZWdleCwgYykge1xuICAgICAgICByZXR1cm4gcmVnZXgudGVzdChjKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm90TWF0Y2gocmVnZXgsIGMpIHtcbiAgICAgICAgcmV0dXJuICFpc01hdGNoKHJlZ2V4LCBjKTtcbiAgICB9XG4gICAgdmFyIFMgPSAwO1xuICAgIHNheC5TVEFURSA9IHtcbiAgICAgICAgQkVHSU46IFMrKywgLy8gbGVhZGluZyBieXRlIG9yZGVyIG1hcmsgb3Igd2hpdGVzcGFjZVxuICAgICAgICBCRUdJTl9XSElURVNQQUNFOiBTKyssIC8vIGxlYWRpbmcgd2hpdGVzcGFjZVxuICAgICAgICBURVhUOiBTKyssIC8vIGdlbmVyYWwgc3R1ZmZcbiAgICAgICAgVEVYVF9FTlRJVFk6IFMrKywgLy8gJmFtcCBhbmQgc3VjaC5cbiAgICAgICAgT1BFTl9XQUtBOiBTKyssIC8vIDxcbiAgICAgICAgU0dNTF9ERUNMOiBTKyssIC8vIDwhQkxBUkdcbiAgICAgICAgU0dNTF9ERUNMX1FVT1RFRDogUysrLCAvLyA8IUJMQVJHIGZvbyBcImJhclxuICAgICAgICBET0NUWVBFOiBTKyssIC8vIDwhRE9DVFlQRVxuICAgICAgICBET0NUWVBFX1FVT1RFRDogUysrLCAvLyA8IURPQ1RZUEUgXCIvL2JsYWhcbiAgICAgICAgRE9DVFlQRV9EVEQ6IFMrKywgLy8gPCFET0NUWVBFIFwiLy9ibGFoXCIgWyAuLi5cbiAgICAgICAgRE9DVFlQRV9EVERfUVVPVEVEOiBTKyssIC8vIDwhRE9DVFlQRSBcIi8vYmxhaFwiIFsgXCJmb29cbiAgICAgICAgQ09NTUVOVF9TVEFSVElORzogUysrLCAvLyA8IS1cbiAgICAgICAgQ09NTUVOVDogUysrLCAvLyA8IS0tXG4gICAgICAgIENPTU1FTlRfRU5ESU5HOiBTKyssIC8vIDwhLS0gYmxhaCAtXG4gICAgICAgIENPTU1FTlRfRU5ERUQ6IFMrKywgLy8gPCEtLSBibGFoIC0tXG4gICAgICAgIENEQVRBOiBTKyssIC8vIDwhW0NEQVRBWyBzb21ldGhpbmdcbiAgICAgICAgQ0RBVEFfRU5ESU5HOiBTKyssIC8vIF1cbiAgICAgICAgQ0RBVEFfRU5ESU5HXzI6IFMrKywgLy8gXV1cbiAgICAgICAgUFJPQ19JTlNUOiBTKyssIC8vIDw/aGlcbiAgICAgICAgUFJPQ19JTlNUX0JPRFk6IFMrKywgLy8gPD9oaSB0aGVyZVxuICAgICAgICBQUk9DX0lOU1RfRU5ESU5HOiBTKyssIC8vIDw/aGkgXCJ0aGVyZVwiID9cbiAgICAgICAgT1BFTl9UQUc6IFMrKywgLy8gPHN0cm9uZ1xuICAgICAgICBPUEVOX1RBR19TTEFTSDogUysrLCAvLyA8c3Ryb25nIC9cbiAgICAgICAgQVRUUklCOiBTKyssIC8vIDxhXG4gICAgICAgIEFUVFJJQl9OQU1FOiBTKyssIC8vIDxhIGZvb1xuICAgICAgICBBVFRSSUJfTkFNRV9TQVdfV0hJVEU6IFMrKywgLy8gPGEgZm9vIF9cbiAgICAgICAgQVRUUklCX1ZBTFVFOiBTKyssIC8vIDxhIGZvbz1cbiAgICAgICAgQVRUUklCX1ZBTFVFX1FVT1RFRDogUysrLCAvLyA8YSBmb289XCJiYXJcbiAgICAgICAgQVRUUklCX1ZBTFVFX0NMT1NFRDogUysrLCAvLyA8YSBmb289XCJiYXJcIlxuICAgICAgICBBVFRSSUJfVkFMVUVfVU5RVU9URUQ6IFMrKywgLy8gPGEgZm9vPWJhclxuICAgICAgICBBVFRSSUJfVkFMVUVfRU5USVRZX1E6IFMrKywgLy8gPGZvbyBiYXI9XCImcXVvdDtcIlxuICAgICAgICBBVFRSSUJfVkFMVUVfRU5USVRZX1U6IFMrKywgLy8gPGZvbyBiYXI9JnF1b3RcbiAgICAgICAgQ0xPU0VfVEFHOiBTKyssIC8vIDwvYVxuICAgICAgICBDTE9TRV9UQUdfU0FXX1dISVRFOiBTKyssIC8vIDwvYSAgID5cbiAgICAgICAgU0NSSVBUOiBTKyssIC8vIDxzY3JpcHQ+IC4uLlxuICAgICAgICBTQ1JJUFRfRU5ESU5HOiBTKyssIC8vIDxzY3JpcHQ+IC4uLiA8XG4gICAgfTtcbiAgICBzYXguWE1MX0VOVElUSUVTID0ge1xuICAgICAgICBhbXA6IFwiJlwiLFxuICAgICAgICBndDogXCI+XCIsXG4gICAgICAgIGx0OiBcIjxcIixcbiAgICAgICAgcXVvdDogJ1wiJyxcbiAgICAgICAgYXBvczogXCInXCIsXG4gICAgfTtcbiAgICBzYXguRU5USVRJRVMgPSB7XG4gICAgICAgIGFtcDogXCImXCIsXG4gICAgICAgIGd0OiBcIj5cIixcbiAgICAgICAgbHQ6IFwiPFwiLFxuICAgICAgICBxdW90OiAnXCInLFxuICAgICAgICBhcG9zOiBcIidcIixcbiAgICAgICAgQUVsaWc6IDE5OCxcbiAgICAgICAgQWFjdXRlOiAxOTMsXG4gICAgICAgIEFjaXJjOiAxOTQsXG4gICAgICAgIEFncmF2ZTogMTkyLFxuICAgICAgICBBcmluZzogMTk3LFxuICAgICAgICBBdGlsZGU6IDE5NSxcbiAgICAgICAgQXVtbDogMTk2LFxuICAgICAgICBDY2VkaWw6IDE5OSxcbiAgICAgICAgRVRIOiAyMDgsXG4gICAgICAgIEVhY3V0ZTogMjAxLFxuICAgICAgICBFY2lyYzogMjAyLFxuICAgICAgICBFZ3JhdmU6IDIwMCxcbiAgICAgICAgRXVtbDogMjAzLFxuICAgICAgICBJYWN1dGU6IDIwNSxcbiAgICAgICAgSWNpcmM6IDIwNixcbiAgICAgICAgSWdyYXZlOiAyMDQsXG4gICAgICAgIEl1bWw6IDIwNyxcbiAgICAgICAgTnRpbGRlOiAyMDksXG4gICAgICAgIE9hY3V0ZTogMjExLFxuICAgICAgICBPY2lyYzogMjEyLFxuICAgICAgICBPZ3JhdmU6IDIxMCxcbiAgICAgICAgT3NsYXNoOiAyMTYsXG4gICAgICAgIE90aWxkZTogMjEzLFxuICAgICAgICBPdW1sOiAyMTQsXG4gICAgICAgIFRIT1JOOiAyMjIsXG4gICAgICAgIFVhY3V0ZTogMjE4LFxuICAgICAgICBVY2lyYzogMjE5LFxuICAgICAgICBVZ3JhdmU6IDIxNyxcbiAgICAgICAgVXVtbDogMjIwLFxuICAgICAgICBZYWN1dGU6IDIyMSxcbiAgICAgICAgYWFjdXRlOiAyMjUsXG4gICAgICAgIGFjaXJjOiAyMjYsXG4gICAgICAgIGFlbGlnOiAyMzAsXG4gICAgICAgIGFncmF2ZTogMjI0LFxuICAgICAgICBhcmluZzogMjI5LFxuICAgICAgICBhdGlsZGU6IDIyNyxcbiAgICAgICAgYXVtbDogMjI4LFxuICAgICAgICBjY2VkaWw6IDIzMSxcbiAgICAgICAgZWFjdXRlOiAyMzMsXG4gICAgICAgIGVjaXJjOiAyMzQsXG4gICAgICAgIGVncmF2ZTogMjMyLFxuICAgICAgICBldGg6IDI0MCxcbiAgICAgICAgZXVtbDogMjM1LFxuICAgICAgICBpYWN1dGU6IDIzNyxcbiAgICAgICAgaWNpcmM6IDIzOCxcbiAgICAgICAgaWdyYXZlOiAyMzYsXG4gICAgICAgIGl1bWw6IDIzOSxcbiAgICAgICAgbnRpbGRlOiAyNDEsXG4gICAgICAgIG9hY3V0ZTogMjQzLFxuICAgICAgICBvY2lyYzogMjQ0LFxuICAgICAgICBvZ3JhdmU6IDI0MixcbiAgICAgICAgb3NsYXNoOiAyNDgsXG4gICAgICAgIG90aWxkZTogMjQ1LFxuICAgICAgICBvdW1sOiAyNDYsXG4gICAgICAgIHN6bGlnOiAyMjMsXG4gICAgICAgIHRob3JuOiAyNTQsXG4gICAgICAgIHVhY3V0ZTogMjUwLFxuICAgICAgICB1Y2lyYzogMjUxLFxuICAgICAgICB1Z3JhdmU6IDI0OSxcbiAgICAgICAgdXVtbDogMjUyLFxuICAgICAgICB5YWN1dGU6IDI1MyxcbiAgICAgICAgeXVtbDogMjU1LFxuICAgICAgICBjb3B5OiAxNjksXG4gICAgICAgIHJlZzogMTc0LFxuICAgICAgICBuYnNwOiAxNjAsXG4gICAgICAgIGlleGNsOiAxNjEsXG4gICAgICAgIGNlbnQ6IDE2MixcbiAgICAgICAgcG91bmQ6IDE2MyxcbiAgICAgICAgY3VycmVuOiAxNjQsXG4gICAgICAgIHllbjogMTY1LFxuICAgICAgICBicnZiYXI6IDE2NixcbiAgICAgICAgc2VjdDogMTY3LFxuICAgICAgICB1bWw6IDE2OCxcbiAgICAgICAgb3JkZjogMTcwLFxuICAgICAgICBsYXF1bzogMTcxLFxuICAgICAgICBub3Q6IDE3MixcbiAgICAgICAgc2h5OiAxNzMsXG4gICAgICAgIG1hY3I6IDE3NSxcbiAgICAgICAgZGVnOiAxNzYsXG4gICAgICAgIHBsdXNtbjogMTc3LFxuICAgICAgICBzdXAxOiAxODUsXG4gICAgICAgIHN1cDI6IDE3OCxcbiAgICAgICAgc3VwMzogMTc5LFxuICAgICAgICBhY3V0ZTogMTgwLFxuICAgICAgICBtaWNybzogMTgxLFxuICAgICAgICBwYXJhOiAxODIsXG4gICAgICAgIG1pZGRvdDogMTgzLFxuICAgICAgICBjZWRpbDogMTg0LFxuICAgICAgICBvcmRtOiAxODYsXG4gICAgICAgIHJhcXVvOiAxODcsXG4gICAgICAgIGZyYWMxNDogMTg4LFxuICAgICAgICBmcmFjMTI6IDE4OSxcbiAgICAgICAgZnJhYzM0OiAxOTAsXG4gICAgICAgIGlxdWVzdDogMTkxLFxuICAgICAgICB0aW1lczogMjE1LFxuICAgICAgICBkaXZpZGU6IDI0NyxcbiAgICAgICAgT0VsaWc6IDMzOCxcbiAgICAgICAgb2VsaWc6IDMzOSxcbiAgICAgICAgU2Nhcm9uOiAzNTIsXG4gICAgICAgIHNjYXJvbjogMzUzLFxuICAgICAgICBZdW1sOiAzNzYsXG4gICAgICAgIGZub2Y6IDQwMixcbiAgICAgICAgY2lyYzogNzEwLFxuICAgICAgICB0aWxkZTogNzMyLFxuICAgICAgICBBbHBoYTogOTEzLFxuICAgICAgICBCZXRhOiA5MTQsXG4gICAgICAgIEdhbW1hOiA5MTUsXG4gICAgICAgIERlbHRhOiA5MTYsXG4gICAgICAgIEVwc2lsb246IDkxNyxcbiAgICAgICAgWmV0YTogOTE4LFxuICAgICAgICBFdGE6IDkxOSxcbiAgICAgICAgVGhldGE6IDkyMCxcbiAgICAgICAgSW90YTogOTIxLFxuICAgICAgICBLYXBwYTogOTIyLFxuICAgICAgICBMYW1iZGE6IDkyMyxcbiAgICAgICAgTXU6IDkyNCxcbiAgICAgICAgTnU6IDkyNSxcbiAgICAgICAgWGk6IDkyNixcbiAgICAgICAgT21pY3JvbjogOTI3LFxuICAgICAgICBQaTogOTI4LFxuICAgICAgICBSaG86IDkyOSxcbiAgICAgICAgU2lnbWE6IDkzMSxcbiAgICAgICAgVGF1OiA5MzIsXG4gICAgICAgIFVwc2lsb246IDkzMyxcbiAgICAgICAgUGhpOiA5MzQsXG4gICAgICAgIENoaTogOTM1LFxuICAgICAgICBQc2k6IDkzNixcbiAgICAgICAgT21lZ2E6IDkzNyxcbiAgICAgICAgYWxwaGE6IDk0NSxcbiAgICAgICAgYmV0YTogOTQ2LFxuICAgICAgICBnYW1tYTogOTQ3LFxuICAgICAgICBkZWx0YTogOTQ4LFxuICAgICAgICBlcHNpbG9uOiA5NDksXG4gICAgICAgIHpldGE6IDk1MCxcbiAgICAgICAgZXRhOiA5NTEsXG4gICAgICAgIHRoZXRhOiA5NTIsXG4gICAgICAgIGlvdGE6IDk1MyxcbiAgICAgICAga2FwcGE6IDk1NCxcbiAgICAgICAgbGFtYmRhOiA5NTUsXG4gICAgICAgIG11OiA5NTYsXG4gICAgICAgIG51OiA5NTcsXG4gICAgICAgIHhpOiA5NTgsXG4gICAgICAgIG9taWNyb246IDk1OSxcbiAgICAgICAgcGk6IDk2MCxcbiAgICAgICAgcmhvOiA5NjEsXG4gICAgICAgIHNpZ21hZjogOTYyLFxuICAgICAgICBzaWdtYTogOTYzLFxuICAgICAgICB0YXU6IDk2NCxcbiAgICAgICAgdXBzaWxvbjogOTY1LFxuICAgICAgICBwaGk6IDk2NixcbiAgICAgICAgY2hpOiA5NjcsXG4gICAgICAgIHBzaTogOTY4LFxuICAgICAgICBvbWVnYTogOTY5LFxuICAgICAgICB0aGV0YXN5bTogOTc3LFxuICAgICAgICB1cHNpaDogOTc4LFxuICAgICAgICBwaXY6IDk4MixcbiAgICAgICAgZW5zcDogODE5NCxcbiAgICAgICAgZW1zcDogODE5NSxcbiAgICAgICAgdGhpbnNwOiA4MjAxLFxuICAgICAgICB6d25qOiA4MjA0LFxuICAgICAgICB6d2o6IDgyMDUsXG4gICAgICAgIGxybTogODIwNixcbiAgICAgICAgcmxtOiA4MjA3LFxuICAgICAgICBuZGFzaDogODIxMSxcbiAgICAgICAgbWRhc2g6IDgyMTIsXG4gICAgICAgIGxzcXVvOiA4MjE2LFxuICAgICAgICByc3F1bzogODIxNyxcbiAgICAgICAgc2JxdW86IDgyMTgsXG4gICAgICAgIGxkcXVvOiA4MjIwLFxuICAgICAgICByZHF1bzogODIyMSxcbiAgICAgICAgYmRxdW86IDgyMjIsXG4gICAgICAgIGRhZ2dlcjogODIyNCxcbiAgICAgICAgRGFnZ2VyOiA4MjI1LFxuICAgICAgICBidWxsOiA4MjI2LFxuICAgICAgICBoZWxsaXA6IDgyMzAsXG4gICAgICAgIHBlcm1pbDogODI0MCxcbiAgICAgICAgcHJpbWU6IDgyNDIsXG4gICAgICAgIFByaW1lOiA4MjQzLFxuICAgICAgICBsc2FxdW86IDgyNDksXG4gICAgICAgIHJzYXF1bzogODI1MCxcbiAgICAgICAgb2xpbmU6IDgyNTQsXG4gICAgICAgIGZyYXNsOiA4MjYwLFxuICAgICAgICBldXJvOiA4MzY0LFxuICAgICAgICBpbWFnZTogODQ2NSxcbiAgICAgICAgd2VpZXJwOiA4NDcyLFxuICAgICAgICByZWFsOiA4NDc2LFxuICAgICAgICB0cmFkZTogODQ4MixcbiAgICAgICAgYWxlZnN5bTogODUwMSxcbiAgICAgICAgbGFycjogODU5MixcbiAgICAgICAgdWFycjogODU5MyxcbiAgICAgICAgcmFycjogODU5NCxcbiAgICAgICAgZGFycjogODU5NSxcbiAgICAgICAgaGFycjogODU5NixcbiAgICAgICAgY3JhcnI6IDg2MjksXG4gICAgICAgIGxBcnI6IDg2NTYsXG4gICAgICAgIHVBcnI6IDg2NTcsXG4gICAgICAgIHJBcnI6IDg2NTgsXG4gICAgICAgIGRBcnI6IDg2NTksXG4gICAgICAgIGhBcnI6IDg2NjAsXG4gICAgICAgIGZvcmFsbDogODcwNCxcbiAgICAgICAgcGFydDogODcwNixcbiAgICAgICAgZXhpc3Q6IDg3MDcsXG4gICAgICAgIGVtcHR5OiA4NzA5LFxuICAgICAgICBuYWJsYTogODcxMSxcbiAgICAgICAgaXNpbjogODcxMixcbiAgICAgICAgbm90aW46IDg3MTMsXG4gICAgICAgIG5pOiA4NzE1LFxuICAgICAgICBwcm9kOiA4NzE5LFxuICAgICAgICBzdW06IDg3MjEsXG4gICAgICAgIG1pbnVzOiA4NzIyLFxuICAgICAgICBsb3dhc3Q6IDg3MjcsXG4gICAgICAgIHJhZGljOiA4NzMwLFxuICAgICAgICBwcm9wOiA4NzMzLFxuICAgICAgICBpbmZpbjogODczNCxcbiAgICAgICAgYW5nOiA4NzM2LFxuICAgICAgICBhbmQ6IDg3NDMsXG4gICAgICAgIG9yOiA4NzQ0LFxuICAgICAgICBjYXA6IDg3NDUsXG4gICAgICAgIGN1cDogODc0NixcbiAgICAgICAgaW50OiA4NzQ3LFxuICAgICAgICB0aGVyZTQ6IDg3NTYsXG4gICAgICAgIHNpbTogODc2NCxcbiAgICAgICAgY29uZzogODc3MyxcbiAgICAgICAgYXN5bXA6IDg3NzYsXG4gICAgICAgIG5lOiA4ODAwLFxuICAgICAgICBlcXVpdjogODgwMSxcbiAgICAgICAgbGU6IDg4MDQsXG4gICAgICAgIGdlOiA4ODA1LFxuICAgICAgICBzdWI6IDg4MzQsXG4gICAgICAgIHN1cDogODgzNSxcbiAgICAgICAgbnN1YjogODgzNixcbiAgICAgICAgc3ViZTogODgzOCxcbiAgICAgICAgc3VwZTogODgzOSxcbiAgICAgICAgb3BsdXM6IDg4NTMsXG4gICAgICAgIG90aW1lczogODg1NSxcbiAgICAgICAgcGVycDogODg2OSxcbiAgICAgICAgc2RvdDogODkwMSxcbiAgICAgICAgbGNlaWw6IDg5NjgsXG4gICAgICAgIHJjZWlsOiA4OTY5LFxuICAgICAgICBsZmxvb3I6IDg5NzAsXG4gICAgICAgIHJmbG9vcjogODk3MSxcbiAgICAgICAgbGFuZzogOTAwMSxcbiAgICAgICAgcmFuZzogOTAwMixcbiAgICAgICAgbG96OiA5Njc0LFxuICAgICAgICBzcGFkZXM6IDk4MjQsXG4gICAgICAgIGNsdWJzOiA5ODI3LFxuICAgICAgICBoZWFydHM6IDk4MjksXG4gICAgICAgIGRpYW1zOiA5ODMwLFxuICAgIH07XG4gICAgT2JqZWN0LmtleXMoc2F4LkVOVElUSUVTKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGUgPSBzYXguRU5USVRJRVNba2V5XTtcbiAgICAgICAgdmFyIHMgPSB0eXBlb2YgZSA9PT0gXCJudW1iZXJcIiA/IFN0cmluZy5mcm9tQ2hhckNvZGUoZSkgOiBlO1xuICAgICAgICBzYXguRU5USVRJRVNba2V5XSA9IHM7XG4gICAgfSk7XG4gICAgZm9yICh2YXIgcyBpbiBzYXguU1RBVEUpIHtcbiAgICAgICAgc2F4LlNUQVRFW3NheC5TVEFURVtzXV0gPSBzO1xuICAgIH1cbiAgICAvLyBzaG9ydGhhbmRcbiAgICBTID0gc2F4LlNUQVRFO1xuICAgIGZ1bmN0aW9uIGVtaXQocGFyc2VyLCBldmVudCwgZGF0YSkge1xuICAgICAgICBwYXJzZXJbZXZlbnRdICYmIHBhcnNlcltldmVudF0oZGF0YSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVtaXROb2RlKHBhcnNlciwgbm9kZVR5cGUsIGRhdGEpIHtcbiAgICAgICAgaWYgKHBhcnNlci50ZXh0Tm9kZSlcbiAgICAgICAgICAgIGNsb3NlVGV4dChwYXJzZXIpO1xuICAgICAgICBlbWl0KHBhcnNlciwgbm9kZVR5cGUsIGRhdGEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9zZVRleHQocGFyc2VyKSB7XG4gICAgICAgIHBhcnNlci50ZXh0Tm9kZSA9IHRleHRvcHRzKHBhcnNlci5vcHQsIHBhcnNlci50ZXh0Tm9kZSk7XG4gICAgICAgIGlmIChwYXJzZXIudGV4dE5vZGUpXG4gICAgICAgICAgICBlbWl0KHBhcnNlciwgXCJvbnRleHRcIiwgcGFyc2VyLnRleHROb2RlKTtcbiAgICAgICAgcGFyc2VyLnRleHROb2RlID0gXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGV4dG9wdHMob3B0LCB0ZXh0KSB7XG4gICAgICAgIGlmIChvcHQudHJpbSlcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnRyaW0oKTtcbiAgICAgICAgaWYgKG9wdC5ub3JtYWxpemUpXG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVycm9yKHBhcnNlciwgZXIpIHtcbiAgICAgICAgY2xvc2VUZXh0KHBhcnNlcik7XG4gICAgICAgIGlmIChwYXJzZXIudHJhY2tQb3NpdGlvbikge1xuICAgICAgICAgICAgZXIgKz1cbiAgICAgICAgICAgICAgICBcIlxcbkxpbmU6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmxpbmUgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcbkNvbHVtbjogXCIgK1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXIuY29sdW1uICtcbiAgICAgICAgICAgICAgICAgICAgXCJcXG5DaGFyOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5jO1xuICAgICAgICB9XG4gICAgICAgIGVyID0gbmV3IEVycm9yKGVyKTtcbiAgICAgICAgcGFyc2VyLmVycm9yID0gZXI7XG4gICAgICAgIGVtaXQocGFyc2VyLCBcIm9uZXJyb3JcIiwgZXIpO1xuICAgICAgICByZXR1cm4gcGFyc2VyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmQocGFyc2VyKSB7XG4gICAgICAgIGlmIChwYXJzZXIuc2F3Um9vdCAmJiAhcGFyc2VyLmNsb3NlZFJvb3QpXG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJVbmNsb3NlZCByb290IHRhZ1wiKTtcbiAgICAgICAgaWYgKHBhcnNlci5zdGF0ZSAhPT0gUy5CRUdJTiAmJlxuICAgICAgICAgICAgcGFyc2VyLnN0YXRlICE9PSBTLkJFR0lOX1dISVRFU1BBQ0UgJiZcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSAhPT0gUy5URVhUKSB7XG4gICAgICAgICAgICBlcnJvcihwYXJzZXIsIFwiVW5leHBlY3RlZCBlbmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY2xvc2VUZXh0KHBhcnNlcik7XG4gICAgICAgIHBhcnNlci5jID0gXCJcIjtcbiAgICAgICAgcGFyc2VyLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIGVtaXQocGFyc2VyLCBcIm9uZW5kXCIpO1xuICAgICAgICBTQVhQYXJzZXIuY2FsbChwYXJzZXIsIHBhcnNlci5zdHJpY3QsIHBhcnNlci5vcHQpO1xuICAgICAgICByZXR1cm4gcGFyc2VyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHJpY3RGYWlsKHBhcnNlciwgbWVzc2FnZSkge1xuICAgICAgICBpZiAodHlwZW9mIHBhcnNlciAhPT0gXCJvYmplY3RcIiB8fCAhKHBhcnNlciBpbnN0YW5jZW9mIFNBWFBhcnNlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBjYWxsIHRvIHN0cmljdEZhaWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlci5zdHJpY3QpIHtcbiAgICAgICAgICAgIGVycm9yKHBhcnNlciwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbmV3VGFnKHBhcnNlcikge1xuICAgICAgICBpZiAoIXBhcnNlci5zdHJpY3QpXG4gICAgICAgICAgICBwYXJzZXIudGFnTmFtZSA9IHBhcnNlci50YWdOYW1lW3BhcnNlci5sb29zZUNhc2VdKCk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBwYXJzZXIudGFnc1twYXJzZXIudGFncy5sZW5ndGggLSAxXSB8fCBwYXJzZXI7XG4gICAgICAgIHZhciB0YWcgPSAocGFyc2VyLnRhZyA9IHsgbmFtZTogcGFyc2VyLnRhZ05hbWUsIGF0dHJpYnV0ZXM6IHt9IH0pO1xuICAgICAgICAvLyB3aWxsIGJlIG92ZXJyaWRkZW4gaWYgdGFnIGNvbnRhaWxzIGFuIHhtbG5zPVwiZm9vXCIgb3IgeG1sbnM6Zm9vPVwiYmFyXCJcbiAgICAgICAgaWYgKHBhcnNlci5vcHQueG1sbnMpIHtcbiAgICAgICAgICAgIHRhZy5ucyA9IHBhcmVudC5ucztcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIuYXR0cmliTGlzdC5sZW5ndGggPSAwO1xuICAgICAgICBlbWl0Tm9kZShwYXJzZXIsIFwib25vcGVudGFnc3RhcnRcIiwgdGFnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcW5hbWUobmFtZSwgYXR0cmlidXRlKSB7XG4gICAgICAgIHZhciBpID0gbmFtZS5pbmRleE9mKFwiOlwiKTtcbiAgICAgICAgdmFyIHF1YWxOYW1lID0gaSA8IDAgPyBbXCJcIiwgbmFtZV0gOiBuYW1lLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgdmFyIHByZWZpeCA9IHF1YWxOYW1lWzBdO1xuICAgICAgICB2YXIgbG9jYWwgPSBxdWFsTmFtZVsxXTtcbiAgICAgICAgLy8gPHggXCJ4bWxuc1wiPVwiaHR0cDovL2Zvb1wiPlxuICAgICAgICBpZiAoYXR0cmlidXRlICYmIG5hbWUgPT09IFwieG1sbnNcIikge1xuICAgICAgICAgICAgcHJlZml4ID0gXCJ4bWxuc1wiO1xuICAgICAgICAgICAgbG9jYWwgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHByZWZpeDogcHJlZml4LCBsb2NhbDogbG9jYWwgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0cmliKHBhcnNlcikge1xuICAgICAgICBpZiAoIXBhcnNlci5zdHJpY3QpIHtcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gcGFyc2VyLmF0dHJpYk5hbWVbcGFyc2VyLmxvb3NlQ2FzZV0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyc2VyLmF0dHJpYkxpc3QuaW5kZXhPZihwYXJzZXIuYXR0cmliTmFtZSkgIT09IC0xIHx8XG4gICAgICAgICAgICBwYXJzZXIudGFnLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkocGFyc2VyLmF0dHJpYk5hbWUpKSB7XG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IHBhcnNlci5hdHRyaWJWYWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlci5vcHQueG1sbnMpIHtcbiAgICAgICAgICAgIHZhciBxbiA9IHFuYW1lKHBhcnNlci5hdHRyaWJOYW1lLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBxbi5wcmVmaXg7XG4gICAgICAgICAgICB2YXIgbG9jYWwgPSBxbi5sb2NhbDtcbiAgICAgICAgICAgIGlmIChwcmVmaXggPT09IFwieG1sbnNcIikge1xuICAgICAgICAgICAgICAgIC8vIG5hbWVzcGFjZSBiaW5kaW5nIGF0dHJpYnV0ZS4gcHVzaCB0aGUgYmluZGluZyBpbnRvIHNjb3BlXG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsID09PSBcInhtbFwiICYmIHBhcnNlci5hdHRyaWJWYWx1ZSAhPT0gWE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJ4bWw6IHByZWZpeCBtdXN0IGJlIGJvdW5kIHRvIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFhNTF9OQU1FU1BBQ0UgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkFjdHVhbDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobG9jYWwgPT09IFwieG1sbnNcIiAmJlxuICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgIT09IFhNTE5TX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJ4bWxuczogcHJlZml4IG11c3QgYmUgYm91bmQgdG8gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgWE1MTlNfTkFNRVNQQUNFICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJBY3R1YWw6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gcGFyc2VyLnRhZztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHBhcnNlci50YWdzW3BhcnNlci50YWdzLmxlbmd0aCAtIDFdIHx8IHBhcnNlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZy5ucyA9PT0gcGFyZW50Lm5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWcubnMgPSBPYmplY3QuY3JlYXRlKHBhcmVudC5ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFnLm5zW2xvY2FsXSA9IHBhcnNlci5hdHRyaWJWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkZWZlciBvbmF0dHJpYnV0ZSBldmVudHMgdW50aWwgYWxsIGF0dHJpYnV0ZXMgaGF2ZSBiZWVuIHNlZW5cbiAgICAgICAgICAgIC8vIHNvIGFueSBuZXcgYmluZGluZ3MgY2FuIHRha2UgZWZmZWN0LiBwcmVzZXJ2ZSBhdHRyaWJ1dGUgb3JkZXJcbiAgICAgICAgICAgIC8vIHNvIGRlZmVycmVkIGV2ZW50cyBjYW4gYmUgZW1pdHRlZCBpbiBkb2N1bWVudCBvcmRlclxuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYkxpc3QucHVzaChbcGFyc2VyLmF0dHJpYk5hbWUsIHBhcnNlci5hdHRyaWJWYWx1ZV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaW4gbm9uLXhtbG5zIG1vZGUsIHdlIGNhbiBlbWl0IHRoZSBldmVudCByaWdodCBhd2F5XG4gICAgICAgICAgICBwYXJzZXIudGFnLmF0dHJpYnV0ZXNbcGFyc2VyLmF0dHJpYk5hbWVdID0gcGFyc2VyLmF0dHJpYlZhbHVlO1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9uYXR0cmlidXRlXCIsIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJzZXIuYXR0cmliTmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGFyc2VyLmF0dHJpYlZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBwYXJzZXIuYXR0cmliVmFsdWUgPSBcIlwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvcGVuVGFnKHBhcnNlciwgc2VsZkNsb3NpbmcpIHtcbiAgICAgICAgaWYgKHBhcnNlci5vcHQueG1sbnMpIHtcbiAgICAgICAgICAgIC8vIGVtaXQgbmFtZXNwYWNlIGJpbmRpbmcgZXZlbnRzXG4gICAgICAgICAgICB2YXIgdGFnID0gcGFyc2VyLnRhZztcbiAgICAgICAgICAgIC8vIGFkZCBuYW1lc3BhY2UgaW5mbyB0byB0YWdcbiAgICAgICAgICAgIHZhciBxbiA9IHFuYW1lKHBhcnNlci50YWdOYW1lKTtcbiAgICAgICAgICAgIHRhZy5wcmVmaXggPSBxbi5wcmVmaXg7XG4gICAgICAgICAgICB0YWcubG9jYWwgPSBxbi5sb2NhbDtcbiAgICAgICAgICAgIHRhZy51cmkgPSB0YWcubnNbcW4ucHJlZml4XSB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKHRhZy5wcmVmaXggJiYgIXRhZy51cmkpIHtcbiAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJVbmJvdW5kIG5hbWVzcGFjZSBwcmVmaXg6IFwiICsgSlNPTi5zdHJpbmdpZnkocGFyc2VyLnRhZ05hbWUpKTtcbiAgICAgICAgICAgICAgICB0YWcudXJpID0gcW4ucHJlZml4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHBhcnNlci50YWdzW3BhcnNlci50YWdzLmxlbmd0aCAtIDFdIHx8IHBhcnNlcjtcbiAgICAgICAgICAgIGlmICh0YWcubnMgJiYgcGFyZW50Lm5zICE9PSB0YWcubnMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh0YWcubnMpLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9ub3Blbm5hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXg6IHAsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmk6IHRhZy5uc1twXSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoYW5kbGUgZGVmZXJyZWQgb25hdHRyaWJ1dGUgZXZlbnRzXG4gICAgICAgICAgICAvLyBOb3RlOiBkbyBub3QgYXBwbHkgZGVmYXVsdCBucyB0byBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgLy8gICBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLW5hbWVzLyNkZWZhdWx0aW5nXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBudiA9IHBhcnNlci5hdHRyaWJMaXN0W2ldO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbnZbMF07XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gbnZbMV07XG4gICAgICAgICAgICAgICAgdmFyIHF1YWxOYW1lID0gcW5hbWUobmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIHByZWZpeCA9IHF1YWxOYW1lLnByZWZpeDtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWwgPSBxdWFsTmFtZS5sb2NhbDtcbiAgICAgICAgICAgICAgICB2YXIgdXJpID0gcHJlZml4ID09PSBcIlwiID8gXCJcIiA6IHRhZy5uc1twcmVmaXhdIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsOiBsb2NhbCxcbiAgICAgICAgICAgICAgICAgICAgdXJpOiB1cmksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSdzIGFueSBhdHRyaWJ1dGVzIHdpdGggYW4gdW5kZWZpbmVkIG5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGZhaWwgb24gdGhlbSBub3cuXG4gICAgICAgICAgICAgICAgaWYgKHByZWZpeCAmJiBwcmVmaXggIT09IFwieG1sbnNcIiAmJiAhdXJpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIlVuYm91bmQgbmFtZXNwYWNlIHByZWZpeDogXCIgKyBKU09OLnN0cmluZ2lmeShwcmVmaXgpKTtcbiAgICAgICAgICAgICAgICAgICAgYS51cmkgPSBwcmVmaXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnNlci50YWcuYXR0cmlidXRlc1tuYW1lXSA9IGE7XG4gICAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9uYXR0cmlidXRlXCIsIGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYkxpc3QubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIudGFnLmlzU2VsZkNsb3NpbmcgPSAhIXNlbGZDbG9zaW5nO1xuICAgICAgICAvLyBwcm9jZXNzIHRoZSB0YWdcbiAgICAgICAgcGFyc2VyLnNhd1Jvb3QgPSB0cnVlO1xuICAgICAgICBwYXJzZXIudGFncy5wdXNoKHBhcnNlci50YWcpO1xuICAgICAgICBlbWl0Tm9kZShwYXJzZXIsIFwib25vcGVudGFnXCIsIHBhcnNlci50YWcpO1xuICAgICAgICBpZiAoIXNlbGZDbG9zaW5nKSB7XG4gICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIDxzY3JpcHQ+IGluIG5vbi1zdHJpY3QgbW9kZS5cbiAgICAgICAgICAgIGlmICghcGFyc2VyLm5vc2NyaXB0ICYmIHBhcnNlci50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic2NyaXB0XCIpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlci50YWcgPSBudWxsO1xuICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gcGFyc2VyLmF0dHJpYlZhbHVlID0gXCJcIjtcbiAgICAgICAgcGFyc2VyLmF0dHJpYkxpc3QubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xvc2VUYWcocGFyc2VyKSB7XG4gICAgICAgIGlmICghcGFyc2VyLnRhZ05hbWUpIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIldlaXJkIGVtcHR5IGNsb3NlIHRhZy5cIik7XG4gICAgICAgICAgICBwYXJzZXIudGV4dE5vZGUgKz0gXCI8Lz5cIjtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyc2VyLnNjcmlwdCkge1xuICAgICAgICAgICAgaWYgKHBhcnNlci50YWdOYW1lICE9PSBcInNjcmlwdFwiKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCArPSBcIjwvXCIgKyBwYXJzZXIudGFnTmFtZSArIFwiPlwiO1xuICAgICAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsIFwib25zY3JpcHRcIiwgcGFyc2VyLnNjcmlwdCk7XG4gICAgICAgICAgICBwYXJzZXIuc2NyaXB0ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBmaXJzdCBtYWtlIHN1cmUgdGhhdCB0aGUgY2xvc2luZyB0YWcgYWN0dWFsbHkgZXhpc3RzLlxuICAgICAgICAvLyA8YT48Yj48L2M+PC9iPjwvYT4gd2lsbCBjbG9zZSBldmVyeXRoaW5nLCBvdGhlcndpc2UuXG4gICAgICAgIHZhciB0ID0gcGFyc2VyLnRhZ3MubGVuZ3RoO1xuICAgICAgICB2YXIgdGFnTmFtZSA9IHBhcnNlci50YWdOYW1lO1xuICAgICAgICBpZiAoIXBhcnNlci5zdHJpY3QpIHtcbiAgICAgICAgICAgIHRhZ05hbWUgPSB0YWdOYW1lW3BhcnNlci5sb29zZUNhc2VdKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNsb3NlVG8gPSB0YWdOYW1lO1xuICAgICAgICB3aGlsZSAodC0tKSB7XG4gICAgICAgICAgICB2YXIgY2xvc2UgPSBwYXJzZXIudGFnc1t0XTtcbiAgICAgICAgICAgIGlmIChjbG9zZS5uYW1lICE9PSBjbG9zZVRvKSB7XG4gICAgICAgICAgICAgICAgLy8gZmFpbCB0aGUgZmlyc3QgdGltZSBpbiBzdHJpY3QgbW9kZVxuICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIlVuZXhwZWN0ZWQgY2xvc2UgdGFnXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlkbid0IGZpbmQgaXQuICB3ZSBhbHJlYWR5IGZhaWxlZCBmb3Igc3RyaWN0LCBzbyBqdXN0IGFib3J0LlxuICAgICAgICBpZiAodCA8IDApIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIlVubWF0Y2hlZCBjbG9zaW5nIHRhZzogXCIgKyBwYXJzZXIudGFnTmFtZSk7XG4gICAgICAgICAgICBwYXJzZXIudGV4dE5vZGUgKz0gXCI8L1wiICsgcGFyc2VyLnRhZ05hbWUgKyBcIj5cIjtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIudGFnTmFtZSA9IHRhZ05hbWU7XG4gICAgICAgIHZhciBzID0gcGFyc2VyLnRhZ3MubGVuZ3RoO1xuICAgICAgICB3aGlsZSAocy0tID4gdCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IChwYXJzZXIudGFnID0gcGFyc2VyLnRhZ3MucG9wKCkpO1xuICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSBwYXJzZXIudGFnLm5hbWU7XG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsIFwib25jbG9zZXRhZ1wiLCBwYXJzZXIudGFnTmFtZSk7XG4gICAgICAgICAgICB2YXIgeCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0YWcubnMpIHtcbiAgICAgICAgICAgICAgICB4W2ldID0gdGFnLm5zW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHBhcnNlci50YWdzW3BhcnNlci50YWdzLmxlbmd0aCAtIDFdIHx8IHBhcnNlcjtcbiAgICAgICAgICAgIGlmIChwYXJzZXIub3B0LnhtbG5zICYmIHRhZy5ucyAhPT0gcGFyZW50Lm5zKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG5hbWVzcGFjZSBiaW5kaW5ncyBpbnRyb2R1Y2VkIGJ5IHRhZ1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHRhZy5ucykuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHRhZy5uc1twXTtcbiAgICAgICAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9uY2xvc2VuYW1lc3BhY2VcIiwgeyBwcmVmaXg6IHAsIHVyaTogbiB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodCA9PT0gMClcbiAgICAgICAgICAgIHBhcnNlci5jbG9zZWRSb290ID0gdHJ1ZTtcbiAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSBwYXJzZXIuYXR0cmliVmFsdWUgPSBwYXJzZXIuYXR0cmliTmFtZSA9IFwiXCI7XG4gICAgICAgIHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aCA9IDA7XG4gICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VFbnRpdHkocGFyc2VyKSB7XG4gICAgICAgIHZhciBlbnRpdHkgPSBwYXJzZXIuZW50aXR5O1xuICAgICAgICB2YXIgZW50aXR5TEMgPSBlbnRpdHkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIG51bTtcbiAgICAgICAgdmFyIG51bVN0ciA9IFwiXCI7XG4gICAgICAgIGlmIChwYXJzZXIuRU5USVRJRVNbZW50aXR5XSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlci5FTlRJVElFU1tlbnRpdHldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZXIuRU5USVRJRVNbZW50aXR5TENdKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VyLkVOVElUSUVTW2VudGl0eUxDXTtcbiAgICAgICAgfVxuICAgICAgICBlbnRpdHkgPSBlbnRpdHlMQztcbiAgICAgICAgaWYgKGVudGl0eS5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICBpZiAoZW50aXR5LmNoYXJBdCgxKSA9PT0gXCJ4XCIpIHtcbiAgICAgICAgICAgICAgICBlbnRpdHkgPSBlbnRpdHkuc2xpY2UoMik7XG4gICAgICAgICAgICAgICAgbnVtID0gcGFyc2VJbnQoZW50aXR5LCAxNik7XG4gICAgICAgICAgICAgICAgbnVtU3RyID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVudGl0eSA9IGVudGl0eS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBudW0gPSBwYXJzZUludChlbnRpdHksIDEwKTtcbiAgICAgICAgICAgICAgICBudW1TdHIgPSBudW0udG9TdHJpbmcoMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVudGl0eSA9IGVudGl0eS5yZXBsYWNlKC9eMCsvLCBcIlwiKTtcbiAgICAgICAgaWYgKGlzTmFOKG51bSkgfHwgbnVtU3RyLnRvTG93ZXJDYXNlKCkgIT09IGVudGl0eSkge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiSW52YWxpZCBjaGFyYWN0ZXIgZW50aXR5XCIpO1xuICAgICAgICAgICAgcmV0dXJuIFwiJlwiICsgcGFyc2VyLmVudGl0eSArIFwiO1wiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChudW0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiZWdpbldoaXRlU3BhY2UocGFyc2VyLCBjKSB7XG4gICAgICAgIGlmIChjID09PSBcIjxcIikge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1dBS0E7XG4gICAgICAgICAgICBwYXJzZXIuc3RhcnRUYWdQb3NpdGlvbiA9IHBhcnNlci5wb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAvLyBoYXZlIHRvIHByb2Nlc3MgdGhpcyBhcyBhIHRleHQgbm9kZS5cbiAgICAgICAgICAgIC8vIHdlaXJkLCBidXQgaGFwcGVucy5cbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIk5vbi13aGl0ZXNwYWNlIGJlZm9yZSBmaXJzdCB0YWcuXCIpO1xuICAgICAgICAgICAgcGFyc2VyLnRleHROb2RlID0gYztcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGFyQXQoY2h1bmssIGkpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGlmIChpIDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjaHVuay5jaGFyQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGUoY2h1bmspIHtcbiAgICAgICAgdmFyIHBhcnNlciA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IocGFyc2VyLCBcIkNhbm5vdCB3cml0ZSBhZnRlciBjbG9zZS4gQXNzaWduIGFuIG9ucmVhZHkgaGFuZGxlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5kKHBhcnNlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY2h1bmsgPSBjaHVuay50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGMgPSBcIlwiO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgYyA9IGNoYXJBdChjaHVuaywgaSsrKTtcbiAgICAgICAgICAgIHBhcnNlci5jID0gYztcbiAgICAgICAgICAgIGlmICghYykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnNlci50cmFja1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmxpbmUrKztcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNvbHVtbiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXIuY29sdW1uKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChwYXJzZXIuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFMuQkVHSU46XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQkVHSU5fV0hJVEVTUEFDRTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiXFx1RkVGRlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBiZWdpbldoaXRlU3BhY2UocGFyc2VyLCBjKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLkJFR0lOX1dISVRFU1BBQ0U6XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luV2hpdGVTcGFjZShwYXJzZXIsIGMpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuVEVYVDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci5zYXdSb290ICYmICFwYXJzZXIuY2xvc2VkUm9vdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0aSA9IGkgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGMgJiYgYyAhPT0gXCI8XCIgJiYgYyAhPT0gXCImXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gY2hhckF0KGNodW5rLCBpKyspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjICYmIHBhcnNlci50cmFja1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5wb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmxpbmUrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5jb2x1bW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNvbHVtbisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnRleHROb2RlICs9IGNodW5rLnN1YnN0cmluZyhzdGFydGksIGkgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCI8XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICEocGFyc2VyLnNhd1Jvb3QgJiYgcGFyc2VyLmNsb3NlZFJvb3QgJiYgIXBhcnNlci5zdHJpY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fV0FLQTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGFydFRhZ1Bvc2l0aW9uID0gcGFyc2VyLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1doaXRlc3BhY2UoYykgJiYgKCFwYXJzZXIuc2F3Um9vdCB8fCBwYXJzZXIuY2xvc2VkUm9vdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJUZXh0IGRhdGEgb3V0c2lkZSBvZiByb290IG5vZGUuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiJlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUX0VOVElUWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci50ZXh0Tm9kZSArPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5TQ1JJUFQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgbm9uLXN0cmljdFxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCI8XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUX0VORElORztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuU0NSSVBUX0VORElORzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNMT1NFX1RBRztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gXCI8XCIgKyBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLk9QRU5fV0FLQTpcbiAgICAgICAgICAgICAgICAgICAgLy8gZWl0aGVyIGEgLywgPywgISwgb3IgdGV4dCBpcyBjb21pbmcgbmV4dC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiIVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNHTUxfREVDTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3YWl0IGZvciBpdC4uLlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzTWF0Y2gobmFtZVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1RBRztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSBcIi9cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DTE9TRV9UQUc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIudGFnTmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCI/XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuUFJPQ19JTlNUO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0TmFtZSA9IHBhcnNlci5wcm9jSW5zdEJvZHkgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiVW5lbmNvZGVkIDxcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSB3YXMgc29tZSB3aGl0ZXNwYWNlLCB0aGVuIGFkZCB0aGF0IGluLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci5zdGFydFRhZ1Bvc2l0aW9uICsgMSA8IHBhcnNlci5wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWQgPSBwYXJzZXIucG9zaXRpb24gLSBwYXJzZXIuc3RhcnRUYWdQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gbmV3IEFycmF5KHBhZCkuam9pbihcIiBcIikgKyBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnRleHROb2RlICs9IFwiPFwiICsgYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuU0dNTF9ERUNMOlxuICAgICAgICAgICAgICAgICAgICBpZiAoKHBhcnNlci5zZ21sRGVjbCArIGMpLnRvVXBwZXJDYXNlKCkgPT09IENEQVRBKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsIFwib25vcGVuY2RhdGFcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5jZGF0YSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyc2VyLnNnbWxEZWNsICsgYyA9PT0gXCItLVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuY29tbWVudCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwYXJzZXIuc2dtbERlY2wgKyBjKS50b1VwcGVyQ2FzZSgpID09PSBET0NUWVBFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLmRvY3R5cGUgfHwgcGFyc2VyLnNhd1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJJbmFwcHJvcHJpYXRlbHkgbG9jYXRlZCBkb2N0eXBlIGRlY2xhcmF0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmRvY3R5cGUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSBcIj5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9uc2dtbGRlY2xhcmF0aW9uXCIsIHBhcnNlci5zZ21sRGVjbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUXVvdGUoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0dNTF9ERUNMX1FVT1RFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCArPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLlNHTUxfREVDTF9RVU9URUQ6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBwYXJzZXIucSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TR01MX0RFQ0w7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIucSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5ET0NUWVBFOlxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbmRvY3R5cGVcIiwgcGFyc2VyLmRvY3R5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmRvY3R5cGUgPSB0cnVlOyAvLyBqdXN0IHJlbWVtYmVyIHRoYXQgd2Ugc2F3IGl0LlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmRvY3R5cGUgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIltcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRV9EVEQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1F1b3RlKGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFX1FVT1RFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIucSA9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLkRPQ1RZUEVfUVVPVEVEOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZXIuZG9jdHlwZSArPSBjO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gcGFyc2VyLnEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5xID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuRE9DVFlQRV9EVEQ6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5kb2N0eXBlICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUXVvdGUoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRV9EVERfUVVPVEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnEgPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5ET0NUWVBFX0RURF9RVU9URUQ6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5kb2N0eXBlICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBwYXJzZXIucSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFX0RURDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5xID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuQ09NTUVOVDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiLVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlRfRU5ESU5HO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuQ09NTUVOVF9FTkRJTkc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIi1cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DT01NRU5UX0VOREVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgPSB0ZXh0b3B0cyhwYXJzZXIub3B0LCBwYXJzZXIuY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsIFwib25jb21tZW50XCIsIHBhcnNlci5jb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5jb21tZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5jb21tZW50ICs9IFwiLVwiICsgYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuQ09NTUVOVF9FTkRFRDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgIT09IFwiPlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJNYWxmb3JtZWQgY29tbWVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IDwhLS0gYmxhaCAtLSBibG9vIC0tPiBpbiBub24tc3RyaWN0IG1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCBpcyBhIGNvbW1lbnQgb2YgXCIgYmxhaCAtLSBibG9vIFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuY29tbWVudCArPSBcIi0tXCIgKyBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DT01NRU5UO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5DREFUQTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBX0VORElORztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5DREFUQV9FTkRJTkc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DREFUQV9FTkRJTkdfMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSBcIl1cIiArIGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5DREFUQV9FTkRJTkdfMjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLmNkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9uY2RhdGFcIiwgcGFyc2VyLmNkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbmNsb3NlY2RhdGFcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuY2RhdGEgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuY2RhdGEgKz0gXCJdXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuY2RhdGEgKz0gXCJdXVwiICsgYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0RBVEE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLlBST0NfSU5TVDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVF9FTkRJTkc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVF9CT0RZO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0TmFtZSArPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5QUk9DX0lOU1RfQk9EWTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXIucHJvY0luc3RCb2R5ICYmIGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCI/XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuUFJPQ19JTlNUX0VORElORztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5wcm9jSW5zdEJvZHkgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuUFJPQ19JTlNUX0VORElORzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsIFwib25wcm9jZXNzaW5naW5zdHJ1Y3Rpb25cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHBhcnNlci5wcm9jSW5zdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogcGFyc2VyLnByb2NJbnN0Qm9keSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0TmFtZSA9IHBhcnNlci5wcm9jSW5zdEJvZHkgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0Qm9keSArPSBcIj9cIiArIGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVF9CT0RZO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5PUEVOX1RBRzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWF0Y2gobmFtZUJvZHksIGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIudGFnTmFtZSArPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VGFnKHBhcnNlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuVGFnKHBhcnNlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSBcIi9cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9UQUdfU0xBU0g7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJJbnZhbGlkIGNoYXJhY3RlciBpbiB0YWcgbmFtZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLk9QRU5fVEFHX1NMQVNIOlxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlVGFnKHBhcnNlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJGb3J3YXJkLXNsYXNoIGluIG9wZW5pbmcgdGFnIG5vdCBmb2xsb3dlZCBieSA+XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLkFUVFJJQjpcbiAgICAgICAgICAgICAgICAgICAgLy8gaGF2ZW4ndCByZWFkIHRoZSBhdHRyaWJ1dGUgbmFtZSB5ZXQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuVGFnKHBhcnNlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9UQUdfU0xBU0g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNNYXRjaChuYW1lU3RhcnQsIGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfTkFNRTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIkludmFsaWQgYXR0cmlidXRlIG5hbWVcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLkFUVFJJQl9OQU1FOlxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJBdHRyaWJ1dGUgd2l0aG91dCB2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9IHBhcnNlci5hdHRyaWJOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmliKHBhcnNlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuVGFnKHBhcnNlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9OQU1FX1NBV19XSElURTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc01hdGNoKG5hbWVCb2R5LCBjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIkludmFsaWQgYXR0cmlidXRlIG5hbWVcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLkFUVFJJQl9OQU1FX1NBV19XSElURTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiPVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiQXR0cmlidXRlIHdpdGhvdXQgdmFsdWVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIudGFnLmF0dHJpYnV0ZXNbcGFyc2VyLmF0dHJpYk5hbWVdID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsIFwib25hdHRyaWJ1dGVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHBhcnNlci5hdHRyaWJOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuVGFnKHBhcnNlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc01hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfTkFNRTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIkludmFsaWQgYXR0cmlidXRlIG5hbWVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNRdW90ZShjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnEgPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVfUVVPVEVEO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiVW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVfVU5RVU9URUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfUVVPVEVEOlxuICAgICAgICAgICAgICAgICAgICBpZiAoYyAhPT0gcGFyc2VyLnEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIiZcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX0VOVElUWV9RO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlICs9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhdHRyaWIocGFyc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnEgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9DTE9TRUQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfQ0xPU0VEOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSBcIj5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fVEFHX1NMQVNIO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzTWF0Y2gobmFtZVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiTm8gd2hpdGVzcGFjZSBiZXR3ZWVuIGF0dHJpYnV0ZXNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfTkFNRTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIkludmFsaWQgYXR0cmlidXRlIG5hbWVcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9VTlFVT1RFRDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0F0dHJpYkVuZChjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiJlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVfRU5USVRZX1U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYihwYXJzZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5DTE9TRV9UQUc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VyLnRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vdE1hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnNjcmlwdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc2NyaXB0ICs9IFwiPC9cIiArIGM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiSW52YWxpZCB0YWduYW1lIGluIGNsb3NpbmcgdGFnLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIudGFnTmFtZSA9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlVGFnKHBhcnNlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNNYXRjaChuYW1lQm9keSwgYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci50YWdOYW1lICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyc2VyLnNjcmlwdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCArPSBcIjwvXCIgKyBwYXJzZXIudGFnTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJJbnZhbGlkIHRhZ25hbWUgaW4gY2xvc2luZyB0YWdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNMT1NFX1RBR19TQVdfV0hJVEU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLkNMT1NFX1RBR19TQVdfV0hJVEU6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIj5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VUYWcocGFyc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIkludmFsaWQgY2hhcmFjdGVycyBpbiBjbG9zaW5nIHRhZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuVEVYVF9FTlRJVFk6XG4gICAgICAgICAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfUTpcbiAgICAgICAgICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX0VOVElUWV9VOlxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuU3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBidWZmZXI7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocGFyc2VyLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFMuVEVYVF9FTlRJVFk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuU3RhdGUgPSBTLlRFWFQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gXCJ0ZXh0Tm9kZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfUTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5TdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX1FVT1RFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBcImF0dHJpYlZhbHVlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX0VOVElUWV9VOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblN0YXRlID0gUy5BVFRSSUJfVkFMVUVfVU5RVU9URUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gXCJhdHRyaWJWYWx1ZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIjtcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci5vcHQudW5wYXJzZWRFbnRpdGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZWRFbnRpdHkgPSBwYXJzZUVudGl0eShwYXJzZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5lbnRpdHkgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IHJldHVyblN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci53cml0ZShwYXJzZWRFbnRpdHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyW2J1ZmZlcl0gKz0gcGFyc2VFbnRpdHkocGFyc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuZW50aXR5ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSByZXR1cm5TdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc01hdGNoKHBhcnNlci5lbnRpdHkubGVuZ3RoID8gZW50aXR5Qm9keSA6IGVudGl0eVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmVudGl0eSArPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiSW52YWxpZCBjaGFyYWN0ZXIgaW4gZW50aXR5IG5hbWVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJbYnVmZmVyXSArPSBcIiZcIiArIHBhcnNlci5lbnRpdHkgKyBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmVudGl0eSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSByZXR1cm5TdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwYXJzZXIsIFwiVW5rbm93biBzdGF0ZTogXCIgKyBwYXJzZXIuc3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSAvLyB3aGlsZVxuICAgICAgICBpZiAocGFyc2VyLnBvc2l0aW9uID49IHBhcnNlci5idWZmZXJDaGVja1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICBjaGVja0J1ZmZlckxlbmd0aChwYXJzZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZXI7XG4gICAgfVxuICAgIC8qISBodHRwOi8vbXRocy5iZS9mcm9tY29kZXBvaW50IHYwLjEuMCBieSBAbWF0aGlhcyAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKCFTdHJpbmcuZnJvbUNvZGVQb2ludCkge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gICAgICAgICAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgICAgICAgICAgdmFyIGZyb21Db2RlUG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIE1BWF9TSVpFID0gMHg0MDAwO1xuICAgICAgICAgICAgICAgIHZhciBjb2RlVW5pdHMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgaGlnaFN1cnJvZ2F0ZTtcbiAgICAgICAgICAgICAgICB2YXIgbG93U3Vycm9nYXRlO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29kZVBvaW50ID0gTnVtYmVyKGFyZ3VtZW50c1tpbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGNvZGVQb2ludCkgfHwgLy8gYE5hTmAsIGArSW5maW5pdHlgLCBvciBgLUluZmluaXR5YFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50IDwgMCB8fCAvLyBub3QgYSB2YWxpZCBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA+IDB4MTBmZmZmIHx8IC8vIG5vdCBhIHZhbGlkIFVuaWNvZGUgY29kZSBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvb3IoY29kZVBvaW50KSAhPT0gY29kZVBvaW50IC8vIG5vdCBhbiBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIkludmFsaWQgY29kZSBwb2ludDogXCIgKyBjb2RlUG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCTVAgY29kZSBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZVVuaXRzLnB1c2goY29kZVBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzdHJhbCBjb2RlIHBvaW50OyBzcGxpdCBpbiBzdXJyb2dhdGUgaGFsdmVzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaWdoU3Vycm9nYXRlID0gKGNvZGVQb2ludCA+PiAxMCkgKyAweGQ4MDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dTdXJyb2dhdGUgPSAoY29kZVBvaW50ICUgMHg0MDApICsgMHhkYzAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZVVuaXRzLnB1c2goaGlnaFN1cnJvZ2F0ZSwgbG93U3Vycm9nYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggKyAxID09PSBsZW5ndGggfHwgY29kZVVuaXRzLmxlbmd0aCA+IE1BWF9TSVpFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNvZGVVbml0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlVW5pdHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmluZywgXCJmcm9tQ29kZVBvaW50XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZyb21Db2RlUG9pbnQsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBTdHJpbmcuZnJvbUNvZGVQb2ludCA9IGZyb21Db2RlUG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIHJldHVybiBzYXg7XG59O1xuY29uc3Qgc2F4ID0gLyoqICNfX1BVUkVfXyAqLyBpbml0aWFsaXplU2F4KCk7XG5leHBvcnRzLnNheCA9IHNheDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/sax-js/sax.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/signal.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/signal.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.raceWithSignal = raceWithSignal;\nasync function raceWithSignal(promise, signal) {\n    if (signal === undefined) {\n        return promise;\n    }\n    let listener;\n    return Promise.race([\n        promise.catch((err) => {\n            if (!signal?.aborted) {\n                throw err;\n            }\n            else {\n                return undefined;\n            }\n        }),\n        new Promise((_, reject) => {\n            listener = () => {\n                reject(new Error(\"Aborted\"));\n            };\n            signal.addEventListener(\"abort\", listener);\n            // Must be here inside the promise to avoid a race condition\n            if (signal.aborted) {\n                reject(new Error(\"Aborted\"));\n            }\n        }),\n    ]).finally(() => signal.removeEventListener(\"abort\", listener));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvc2lnbmFsLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9zaWduYWwuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yYWNlV2l0aFNpZ25hbCA9IHJhY2VXaXRoU2lnbmFsO1xuYXN5bmMgZnVuY3Rpb24gcmFjZVdpdGhTaWduYWwocHJvbWlzZSwgc2lnbmFsKSB7XG4gICAgaWYgKHNpZ25hbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBsZXQgbGlzdGVuZXI7XG4gICAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgICAgIHByb21pc2UuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKCFzaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkFib3J0ZWRcIikpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgLy8gTXVzdCBiZSBoZXJlIGluc2lkZSB0aGUgcHJvbWlzZSB0byBhdm9pZCBhIHJhY2UgY29uZGl0aW9uXG4gICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQWJvcnRlZFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgIF0pLmZpbmFsbHkoKCkgPT4gc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBsaXN0ZW5lcikpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/signal.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/stream.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsyncGeneratorWithSetup = exports.IterableReadableStream = void 0;\nexports.atee = atee;\nexports.concat = concat;\nexports.pipeGeneratorWithSetup = pipeGeneratorWithSetup;\nconst config_js_1 = __webpack_require__(/*! ../runnables/config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\nconst index_js_1 = __webpack_require__(/*! ../singletons/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/index.cjs\");\nconst signal_js_1 = __webpack_require__(/*! ./signal.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/signal.cjs\");\n/*\n * Support async iterator syntax for ReadableStreams in all environments.\n * Source: https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nclass IterableReadableStream extends ReadableStream {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"reader\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    ensureReader() {\n        if (!this.reader) {\n            this.reader = this.getReader();\n        }\n    }\n    async next() {\n        this.ensureReader();\n        try {\n            const result = await this.reader.read();\n            if (result.done) {\n                this.reader.releaseLock(); // release lock when stream becomes closed\n                return {\n                    done: true,\n                    value: undefined,\n                };\n            }\n            else {\n                return {\n                    done: false,\n                    value: result.value,\n                };\n            }\n        }\n        catch (e) {\n            this.reader.releaseLock(); // release lock when stream becomes errored\n            throw e;\n        }\n    }\n    async return() {\n        this.ensureReader();\n        // If wrapped in a Node stream, cancel is already called.\n        if (this.locked) {\n            const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n            this.reader.releaseLock(); // release lock first\n            await cancelPromise; // now await it\n        }\n        return { done: true, value: undefined };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async throw(e) {\n        this.ensureReader();\n        if (this.locked) {\n            const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n            this.reader.releaseLock(); // release lock first\n            await cancelPromise; // now await it\n        }\n        throw e;\n    }\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore Not present in Node 18 types, required in latest Node 22\n    async [Symbol.asyncDispose]() {\n        await this.return();\n    }\n    static fromReadableStream(stream) {\n        // From https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams#reading_the_stream\n        const reader = stream.getReader();\n        return new IterableReadableStream({\n            start(controller) {\n                return pump();\n                function pump() {\n                    return reader.read().then(({ done, value }) => {\n                        // When no more data needs to be consumed, close the stream\n                        if (done) {\n                            controller.close();\n                            return;\n                        }\n                        // Enqueue the next data chunk into our target stream\n                        controller.enqueue(value);\n                        return pump();\n                    });\n                }\n            },\n            cancel() {\n                reader.releaseLock();\n            },\n        });\n    }\n    static fromAsyncGenerator(generator) {\n        return new IterableReadableStream({\n            async pull(controller) {\n                const { value, done } = await generator.next();\n                // When no more data needs to be consumed, close the stream\n                if (done) {\n                    controller.close();\n                }\n                // Fix: `else if (value)` will hang the streaming when nullish value (e.g. empty string) is pulled\n                controller.enqueue(value);\n            },\n            async cancel(reason) {\n                await generator.return(reason);\n            },\n        });\n    }\n}\nexports.IterableReadableStream = IterableReadableStream;\nfunction atee(iter, length = 2) {\n    const buffers = Array.from({ length }, () => []);\n    return buffers.map(async function* makeIter(buffer) {\n        while (true) {\n            if (buffer.length === 0) {\n                const result = await iter.next();\n                for (const buffer of buffers) {\n                    buffer.push(result);\n                }\n            }\n            else if (buffer[0].done) {\n                return;\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                yield buffer.shift().value;\n            }\n        }\n    });\n}\nfunction concat(first, second) {\n    if (Array.isArray(first) && Array.isArray(second)) {\n        return first.concat(second);\n    }\n    else if (typeof first === \"string\" && typeof second === \"string\") {\n        return (first + second);\n    }\n    else if (typeof first === \"number\" && typeof second === \"number\") {\n        return (first + second);\n    }\n    else if (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    \"concat\" in first &&\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        typeof first.concat === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return first.concat(second);\n    }\n    else if (typeof first === \"object\" && typeof second === \"object\") {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const chunk = { ...first };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        for (const [key, value] of Object.entries(second)) {\n            if (key in chunk && !Array.isArray(chunk[key])) {\n                chunk[key] = concat(chunk[key], value);\n            }\n            else {\n                chunk[key] = value;\n            }\n        }\n        return chunk;\n    }\n    else {\n        throw new Error(`Cannot concat ${typeof first} and ${typeof second}`);\n    }\n}\nclass AsyncGeneratorWithSetup {\n    constructor(params) {\n        Object.defineProperty(this, \"generator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"setup\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"signal\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"firstResult\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"firstResultUsed\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        this.generator = params.generator;\n        this.config = params.config;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.signal = params.signal ?? this.config?.signal;\n        // setup is a promise that resolves only after the first iterator value\n        // is available. this is useful when setup of several piped generators\n        // needs to happen in logical order, ie. in the order in which input to\n        // to each generator is available.\n        this.setup = new Promise((resolve, reject) => {\n            void index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig((0, config_js_1.pickRunnableConfigKeys)(params.config), async () => {\n                this.firstResult = params.generator.next();\n                if (params.startSetup) {\n                    this.firstResult.then(params.startSetup).then(resolve, reject);\n                }\n                else {\n                    this.firstResult.then((_result) => resolve(undefined), reject);\n                }\n            }, true);\n        });\n    }\n    async next(...args) {\n        this.signal?.throwIfAborted();\n        if (!this.firstResultUsed) {\n            this.firstResultUsed = true;\n            return this.firstResult;\n        }\n        return index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig((0, config_js_1.pickRunnableConfigKeys)(this.config), this.signal\n            ? async () => {\n                return (0, signal_js_1.raceWithSignal)(this.generator.next(...args), this.signal);\n            }\n            : async () => {\n                return this.generator.next(...args);\n            }, true);\n    }\n    async return(value) {\n        return this.generator.return(value);\n    }\n    async throw(e) {\n        return this.generator.throw(e);\n    }\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore Not present in Node 18 types, required in latest Node 22\n    async [Symbol.asyncDispose]() {\n        await this.return();\n    }\n}\nexports.AsyncGeneratorWithSetup = AsyncGeneratorWithSetup;\nasync function pipeGeneratorWithSetup(to, generator, startSetup, signal, ...args) {\n    const gen = new AsyncGeneratorWithSetup({\n        generator,\n        startSetup,\n        signal,\n    });\n    const setup = await gen.setup;\n    return { output: to(gen, setup, ...args), setup };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvc3RyZWFtLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwrQkFBK0IsR0FBRyw4QkFBOEI7QUFDaEUsWUFBWTtBQUNaLGNBQWM7QUFDZCw4QkFBOEI7QUFDOUIsb0JBQW9CLG1CQUFPLENBQUMsK0ZBQXlCO0FBQ3JELG1CQUFtQixtQkFBTyxDQUFDLCtGQUF5QjtBQUNwRCxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RCx1Q0FBdUM7QUFDdkMsaUNBQWlDO0FBQ2pDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsdUNBQXVDO0FBQ3ZDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGNBQWMsTUFBTSxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL3N0cmVhbS5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzeW5jR2VuZXJhdG9yV2l0aFNldHVwID0gZXhwb3J0cy5JdGVyYWJsZVJlYWRhYmxlU3RyZWFtID0gdm9pZCAwO1xuZXhwb3J0cy5hdGVlID0gYXRlZTtcbmV4cG9ydHMuY29uY2F0ID0gY29uY2F0O1xuZXhwb3J0cy5waXBlR2VuZXJhdG9yV2l0aFNldHVwID0gcGlwZUdlbmVyYXRvcldpdGhTZXR1cDtcbmNvbnN0IGNvbmZpZ19qc18xID0gcmVxdWlyZShcIi4uL3J1bm5hYmxlcy9jb25maWcuY2pzXCIpO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9zaW5nbGV0b25zL2luZGV4LmNqc1wiKTtcbmNvbnN0IHNpZ25hbF9qc18xID0gcmVxdWlyZShcIi4vc2lnbmFsLmNqc1wiKTtcbi8qXG4gKiBTdXBwb3J0IGFzeW5jIGl0ZXJhdG9yIHN5bnRheCBmb3IgUmVhZGFibGVTdHJlYW1zIGluIGFsbCBlbnZpcm9ubWVudHMuXG4gKiBTb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9NYXR0aWFzQnVlbGVucy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9wdWxsLzEyMiNpc3N1ZWNvbW1lbnQtMTYyNzM1NDQ5MFxuICovXG5jbGFzcyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtIGV4dGVuZHMgUmVhZGFibGVTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWFkZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW5zdXJlUmVhZGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMucmVhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRlciA9IHRoaXMuZ2V0UmVhZGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbmV4dCgpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVSZWFkZXIoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZGVyLnJlbGVhc2VMb2NrKCk7IC8vIHJlbGVhc2UgbG9jayB3aGVuIHN0cmVhbSBiZWNvbWVzIGNsb3NlZFxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnJlbGVhc2VMb2NrKCk7IC8vIHJlbGVhc2UgbG9jayB3aGVuIHN0cmVhbSBiZWNvbWVzIGVycm9yZWRcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmV0dXJuKCkge1xuICAgICAgICB0aGlzLmVuc3VyZVJlYWRlcigpO1xuICAgICAgICAvLyBJZiB3cmFwcGVkIGluIGEgTm9kZSBzdHJlYW0sIGNhbmNlbCBpcyBhbHJlYWR5IGNhbGxlZC5cbiAgICAgICAgaWYgKHRoaXMubG9ja2VkKSB7XG4gICAgICAgICAgICBjb25zdCBjYW5jZWxQcm9taXNlID0gdGhpcy5yZWFkZXIuY2FuY2VsKCk7IC8vIGNhbmNlbCBmaXJzdCwgYnV0IGRvbid0IGF3YWl0IHlldFxuICAgICAgICAgICAgdGhpcy5yZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIGZpcnN0XG4gICAgICAgICAgICBhd2FpdCBjYW5jZWxQcm9taXNlOyAvLyBub3cgYXdhaXQgaXRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgYXN5bmMgdGhyb3coZSkge1xuICAgICAgICB0aGlzLmVuc3VyZVJlYWRlcigpO1xuICAgICAgICBpZiAodGhpcy5sb2NrZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbFByb21pc2UgPSB0aGlzLnJlYWRlci5jYW5jZWwoKTsgLy8gY2FuY2VsIGZpcnN0LCBidXQgZG9uJ3QgYXdhaXQgeWV0XG4gICAgICAgICAgICB0aGlzLnJlYWRlci5yZWxlYXNlTG9jaygpOyAvLyByZWxlYXNlIGxvY2sgZmlyc3RcbiAgICAgICAgICAgIGF3YWl0IGNhbmNlbFByb21pc2U7IC8vIG5vdyBhd2FpdCBpdFxuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgLy8gQHRzLWlnbm9yZSBOb3QgcHJlc2VudCBpbiBOb2RlIDE4IHR5cGVzLCByZXF1aXJlZCBpbiBsYXRlc3QgTm9kZSAyMlxuICAgIGFzeW5jIFtTeW1ib2wuYXN5bmNEaXNwb3NlXSgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZXR1cm4oKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21SZWFkYWJsZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgLy8gRnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3RyZWFtc19BUEkvVXNpbmdfcmVhZGFibGVfc3RyZWFtcyNyZWFkaW5nX3RoZV9zdHJlYW1cbiAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgICByZXR1cm4gbmV3IEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwdW1wKCk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcHVtcCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkKCkudGhlbigoeyBkb25lLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIG5vIG1vcmUgZGF0YSBuZWVkcyB0byBiZSBjb25zdW1lZCwgY2xvc2UgdGhlIHN0cmVhbVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5xdWV1ZSB0aGUgbmV4dCBkYXRhIGNodW5rIGludG8gb3VyIHRhcmdldCBzdHJlYW1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHVtcCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FuY2VsKCkge1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQXN5bmNHZW5lcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgSXRlcmFibGVSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBnZW5lcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gbm8gbW9yZSBkYXRhIG5lZWRzIHRvIGJlIGNvbnN1bWVkLCBjbG9zZSB0aGUgc3RyZWFtXG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGaXg6IGBlbHNlIGlmICh2YWx1ZSlgIHdpbGwgaGFuZyB0aGUgc3RyZWFtaW5nIHdoZW4gbnVsbGlzaCB2YWx1ZSAoZS5nLiBlbXB0eSBzdHJpbmcpIGlzIHB1bGxlZFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN5bmMgY2FuY2VsKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IGdlbmVyYXRvci5yZXR1cm4ocmVhc29uKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSXRlcmFibGVSZWFkYWJsZVN0cmVhbSA9IEl0ZXJhYmxlUmVhZGFibGVTdHJlYW07XG5mdW5jdGlvbiBhdGVlKGl0ZXIsIGxlbmd0aCA9IDIpIHtcbiAgICBjb25zdCBidWZmZXJzID0gQXJyYXkuZnJvbSh7IGxlbmd0aCB9LCAoKSA9PiBbXSk7XG4gICAgcmV0dXJuIGJ1ZmZlcnMubWFwKGFzeW5jIGZ1bmN0aW9uKiBtYWtlSXRlcihidWZmZXIpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaXRlci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBidWZmZXIgb2YgYnVmZmVycykge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJ1ZmZlclswXS5kb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICB5aWVsZCBidWZmZXIuc2hpZnQoKS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gY29uY2F0KGZpcnN0LCBzZWNvbmQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaXJzdCkgJiYgQXJyYXkuaXNBcnJheShzZWNvbmQpKSB7XG4gICAgICAgIHJldHVybiBmaXJzdC5jb25jYXQoc2Vjb25kKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGZpcnN0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBzZWNvbmQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIChmaXJzdCArIHNlY29uZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBmaXJzdCA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2Ygc2Vjb25kID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiAoZmlyc3QgKyBzZWNvbmQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIFwiY29uY2F0XCIgaW4gZmlyc3QgJiZcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgdHlwZW9mIGZpcnN0LmNvbmNhdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBmaXJzdC5jb25jYXQoc2Vjb25kKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGZpcnN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBzZWNvbmQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgY2h1bmsgPSB7IC4uLmZpcnN0IH07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHNlY29uZCkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gY2h1bmsgJiYgIUFycmF5LmlzQXJyYXkoY2h1bmtba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBjaHVua1trZXldID0gY29uY2F0KGNodW5rW2tleV0sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNodW5rW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2h1bms7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb25jYXQgJHt0eXBlb2YgZmlyc3R9IGFuZCAke3R5cGVvZiBzZWNvbmR9YCk7XG4gICAgfVxufVxuY2xhc3MgQXN5bmNHZW5lcmF0b3JXaXRoU2V0dXAge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZW5lcmF0b3JcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2V0dXBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29uZmlnXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNpZ25hbFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmaXJzdFJlc3VsdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmaXJzdFJlc3VsdFVzZWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdlbmVyYXRvciA9IHBhcmFtcy5nZW5lcmF0b3I7XG4gICAgICAgIHRoaXMuY29uZmlnID0gcGFyYW1zLmNvbmZpZztcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgdGhpcy5zaWduYWwgPSBwYXJhbXMuc2lnbmFsID8/IHRoaXMuY29uZmlnPy5zaWduYWw7XG4gICAgICAgIC8vIHNldHVwIGlzIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIG9ubHkgYWZ0ZXIgdGhlIGZpcnN0IGl0ZXJhdG9yIHZhbHVlXG4gICAgICAgIC8vIGlzIGF2YWlsYWJsZS4gdGhpcyBpcyB1c2VmdWwgd2hlbiBzZXR1cCBvZiBzZXZlcmFsIHBpcGVkIGdlbmVyYXRvcnNcbiAgICAgICAgLy8gbmVlZHMgdG8gaGFwcGVuIGluIGxvZ2ljYWwgb3JkZXIsIGllLiBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggaW5wdXQgdG9cbiAgICAgICAgLy8gdG8gZWFjaCBnZW5lcmF0b3IgaXMgYXZhaWxhYmxlLlxuICAgICAgICB0aGlzLnNldHVwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdm9pZCBpbmRleF9qc18xLkFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24ucnVuV2l0aENvbmZpZygoMCwgY29uZmlnX2pzXzEucGlja1J1bm5hYmxlQ29uZmlnS2V5cykocGFyYW1zLmNvbmZpZyksIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0UmVzdWx0ID0gcGFyYW1zLmdlbmVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5zdGFydFNldHVwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RSZXN1bHQudGhlbihwYXJhbXMuc3RhcnRTZXR1cCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJzdFJlc3VsdC50aGVuKChfcmVzdWx0KSA9PiByZXNvbHZlKHVuZGVmaW5lZCksIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBuZXh0KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgIGlmICghdGhpcy5maXJzdFJlc3VsdFVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RSZXN1bHRVc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpcnN0UmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleF9qc18xLkFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24ucnVuV2l0aENvbmZpZygoMCwgY29uZmlnX2pzXzEucGlja1J1bm5hYmxlQ29uZmlnS2V5cykodGhpcy5jb25maWcpLCB0aGlzLnNpZ25hbFxuICAgICAgICAgICAgPyBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBzaWduYWxfanNfMS5yYWNlV2l0aFNpZ25hbCkodGhpcy5nZW5lcmF0b3IubmV4dCguLi5hcmdzKSwgdGhpcy5zaWduYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdG9yLm5leHQoLi4uYXJncyk7XG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICB9XG4gICAgYXN5bmMgcmV0dXJuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRvci5yZXR1cm4odmFsdWUpO1xuICAgIH1cbiAgICBhc3luYyB0aHJvdyhlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRvci50aHJvdyhlKTtcbiAgICB9XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAvLyBAdHMtaWdub3JlIE5vdCBwcmVzZW50IGluIE5vZGUgMTggdHlwZXMsIHJlcXVpcmVkIGluIGxhdGVzdCBOb2RlIDIyXG4gICAgYXN5bmMgW1N5bWJvbC5hc3luY0Rpc3Bvc2VdKCkge1xuICAgICAgICBhd2FpdCB0aGlzLnJldHVybigpO1xuICAgIH1cbn1cbmV4cG9ydHMuQXN5bmNHZW5lcmF0b3JXaXRoU2V0dXAgPSBBc3luY0dlbmVyYXRvcldpdGhTZXR1cDtcbmFzeW5jIGZ1bmN0aW9uIHBpcGVHZW5lcmF0b3JXaXRoU2V0dXAodG8sIGdlbmVyYXRvciwgc3RhcnRTZXR1cCwgc2lnbmFsLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgZ2VuID0gbmV3IEFzeW5jR2VuZXJhdG9yV2l0aFNldHVwKHtcbiAgICAgICAgZ2VuZXJhdG9yLFxuICAgICAgICBzdGFydFNldHVwLFxuICAgICAgICBzaWduYWwsXG4gICAgfSk7XG4gICAgY29uc3Qgc2V0dXAgPSBhd2FpdCBnZW4uc2V0dXA7XG4gICAgcmV0dXJuIHsgb3V0cHV0OiB0byhnZW4sIHNldHVwLCAuLi5hcmdzKSwgc2V0dXAgfTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/tiktoken.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/tiktoken.cjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getEncoding = getEncoding;\nexports.encodingForModel = encodingForModel;\nconst lite_1 = __webpack_require__(/*! js-tiktoken/lite */ \"(rsc)/./node_modules/js-tiktoken/dist/lite.cjs\");\nconst async_caller_js_1 = __webpack_require__(/*! ./async_caller.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.cjs\");\nconst cache = {};\nconst caller = /* #__PURE__ */ new async_caller_js_1.AsyncCaller({});\nasync function getEncoding(encoding) {\n    if (!(encoding in cache)) {\n        cache[encoding] = caller\n            .fetch(`https://tiktoken.pages.dev/js/${encoding}.json`)\n            .then((res) => res.json())\n            .then((data) => new lite_1.Tiktoken(data))\n            .catch((e) => {\n            delete cache[encoding];\n            throw e;\n        });\n    }\n    return await cache[encoding];\n}\nasync function encodingForModel(model) {\n    return getEncoding((0, lite_1.getEncodingNameForModel)(model));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvdGlrdG9rZW4uY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQix3QkFBd0I7QUFDeEIsZUFBZSxtQkFBTyxDQUFDLHdFQUFrQjtBQUN6QywwQkFBMEIsbUJBQU8sQ0FBQyw0RkFBb0I7QUFDdEQ7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy90aWt0b2tlbi5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEVuY29kaW5nID0gZ2V0RW5jb2Rpbmc7XG5leHBvcnRzLmVuY29kaW5nRm9yTW9kZWwgPSBlbmNvZGluZ0Zvck1vZGVsO1xuY29uc3QgbGl0ZV8xID0gcmVxdWlyZShcImpzLXRpa3Rva2VuL2xpdGVcIik7XG5jb25zdCBhc3luY19jYWxsZXJfanNfMSA9IHJlcXVpcmUoXCIuL2FzeW5jX2NhbGxlci5janNcIik7XG5jb25zdCBjYWNoZSA9IHt9O1xuY29uc3QgY2FsbGVyID0gLyogI19fUFVSRV9fICovIG5ldyBhc3luY19jYWxsZXJfanNfMS5Bc3luY0NhbGxlcih7fSk7XG5hc3luYyBmdW5jdGlvbiBnZXRFbmNvZGluZyhlbmNvZGluZykge1xuICAgIGlmICghKGVuY29kaW5nIGluIGNhY2hlKSkge1xuICAgICAgICBjYWNoZVtlbmNvZGluZ10gPSBjYWxsZXJcbiAgICAgICAgICAgIC5mZXRjaChgaHR0cHM6Ly90aWt0b2tlbi5wYWdlcy5kZXYvanMvJHtlbmNvZGluZ30uanNvbmApXG4gICAgICAgICAgICAudGhlbigocmVzKSA9PiByZXMuanNvbigpKVxuICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IG5ldyBsaXRlXzEuVGlrdG9rZW4oZGF0YSkpXG4gICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtlbmNvZGluZ107XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IGNhY2hlW2VuY29kaW5nXTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGVuY29kaW5nRm9yTW9kZWwobW9kZWwpIHtcbiAgICByZXR1cm4gZ2V0RW5jb2RpbmcoKDAsIGxpdGVfMS5nZXRFbmNvZGluZ05hbWVGb3JNb2RlbCkobW9kZWwpKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/tiktoken.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/types/index.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/types/index.cjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./zod.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.cjs\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvdHlwZXMvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyxnRkFBVyIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL3R5cGVzL2luZGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3pvZC5janNcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/types/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/types/zod.cjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isZodSchemaV4 = isZodSchemaV4;\nexports.isZodSchemaV3 = isZodSchemaV3;\nexports.isZodSchema = isZodSchema;\nexports.isInteropZodSchema = isInteropZodSchema;\nexports.interopSafeParseAsync = interopSafeParseAsync;\nexports.interopParseAsync = interopParseAsync;\nexports.interopSafeParse = interopSafeParse;\nexports.interopParse = interopParse;\nexports.getSchemaDescription = getSchemaDescription;\nexports.isShapelessZodSchema = isShapelessZodSchema;\nexports.isSimpleStringZodSchema = isSimpleStringZodSchema;\nexports.isZodObjectV3 = isZodObjectV3;\nexports.isZodObjectV4 = isZodObjectV4;\nexports.isZodArrayV4 = isZodArrayV4;\nexports.isInteropZodObject = isInteropZodObject;\nexports.getInteropZodObjectShape = getInteropZodObjectShape;\nexports.extendInteropZodObject = extendInteropZodObject;\nexports.interopZodObjectPartial = interopZodObjectPartial;\nexports.interopZodObjectStrict = interopZodObjectStrict;\nexports.interopZodObjectPassthrough = interopZodObjectPassthrough;\nexports.getInteropZodDefaultGetter = getInteropZodDefaultGetter;\nexports.interopZodTransformInputSchema = interopZodTransformInputSchema;\nconst core_1 = __webpack_require__(/*! zod/v4/core */ \"(rsc)/./node_modules/zod/v4/core/index.cjs\");\nfunction isZodSchemaV4(schema) {\n    if (typeof schema !== \"object\" || schema === null) {\n        return false;\n    }\n    const obj = schema;\n    if (!(\"_zod\" in obj)) {\n        return false;\n    }\n    const zod = obj._zod;\n    return (typeof zod === \"object\" &&\n        zod !== null &&\n        \"def\" in zod);\n}\nfunction isZodSchemaV3(schema) {\n    if (typeof schema !== \"object\" || schema === null) {\n        return false;\n    }\n    const obj = schema;\n    if (!(\"_def\" in obj) || \"_zod\" in obj) {\n        return false;\n    }\n    const def = obj._def;\n    return (typeof def === \"object\" &&\n        def != null &&\n        \"typeName\" in def);\n}\n/** Backward compatible isZodSchema for Zod 3 */\nfunction isZodSchema(schema) {\n    if (isZodSchemaV4(schema)) {\n        console.warn(\"[WARNING] Attempting to use Zod 4 schema in a context where Zod 3 schema is expected. This may cause unexpected behavior.\");\n    }\n    return isZodSchemaV3(schema);\n}\n/**\n * Given either a Zod schema, or plain object, determine if the input is a Zod schema.\n *\n * @param {unknown} input\n * @returns {boolean} Whether or not the provided input is a Zod schema.\n */\nfunction isInteropZodSchema(input) {\n    if (!input) {\n        return false;\n    }\n    if (typeof input !== \"object\") {\n        return false;\n    }\n    if (Array.isArray(input)) {\n        return false;\n    }\n    if (isZodSchemaV4(input) ||\n        isZodSchemaV3(input)) {\n        return true;\n    }\n    return false;\n}\n/**\n * Asynchronously parses the input using the provided Zod schema (v3 or v4) and returns a safe parse result.\n * This function handles both Zod v3 and v4 schemas, returning a result object indicating success or failure.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {Promise<InteropZodSafeParseResult<T>>} A promise that resolves to a safe parse result object.\n * @throws {Error} If the schema is not a recognized Zod v3 or v4 schema.\n */\nasync function interopSafeParseAsync(schema, input) {\n    if (isZodSchemaV4(schema)) {\n        try {\n            const data = await (0, core_1.parseAsync)(schema, input);\n            return {\n                success: true,\n                data,\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error,\n            };\n        }\n    }\n    if (isZodSchemaV3(schema)) {\n        return schema.safeParse(input);\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n/**\n * Asynchronously parses the input using the provided Zod schema (v3 or v4) and returns the parsed value.\n * Throws an error if parsing fails or if the schema is not a recognized Zod v3 or v4 schema.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {Promise<T>} A promise that resolves to the parsed value.\n * @throws {Error} If parsing fails or the schema is not a recognized Zod v3 or v4 schema.\n */\nasync function interopParseAsync(schema, input) {\n    if (isZodSchemaV4(schema)) {\n        return (0, core_1.parse)(schema, input);\n    }\n    if (isZodSchemaV3(schema)) {\n        return schema.parse(input);\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n/**\n * Safely parses the input using the provided Zod schema (v3 or v4) and returns a result object\n * indicating success or failure. This function is compatible with both Zod v3 and v4 schemas.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {InteropZodSafeParseResult<T>} An object with either the parsed data (on success)\n *   or the error (on failure).\n * @throws {Error} If the schema is not a recognized Zod v3 or v4 schema.\n */\nfunction interopSafeParse(schema, input) {\n    if (isZodSchemaV4(schema)) {\n        try {\n            const data = (0, core_1.parse)(schema, input);\n            return {\n                success: true,\n                data,\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error,\n            };\n        }\n    }\n    if (isZodSchemaV3(schema)) {\n        return schema.safeParse(input);\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n/**\n * Parses the input using the provided Zod schema (v3 or v4) and returns the parsed value.\n * Throws an error if parsing fails or if the schema is not a recognized Zod v3 or v4 schema.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {T} The parsed value.\n * @throws {Error} If parsing fails or the schema is not a recognized Zod v3 or v4 schema.\n */\nfunction interopParse(schema, input) {\n    if (isZodSchemaV4(schema)) {\n        return (0, core_1.parse)(schema, input);\n    }\n    if (isZodSchemaV3(schema)) {\n        return schema.parse(input);\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n/**\n * Retrieves the description from a schema definition (v3, v4, or plain object), if available.\n *\n * @param {unknown} schema - The schema to extract the description from.\n * @returns {string | undefined} The description of the schema, or undefined if not present.\n */\nfunction getSchemaDescription(schema) {\n    if (isZodSchemaV4(schema)) {\n        return core_1.globalRegistry.get(schema)?.description;\n    }\n    if (isZodSchemaV3(schema)) {\n        return schema.description;\n    }\n    if (\"description\" in schema && typeof schema.description === \"string\") {\n        return schema.description;\n    }\n    return undefined;\n}\n/**\n * Determines if the provided Zod schema is \"shapeless\".\n * A shapeless schema is one that does not define any object shape,\n * such as ZodString, ZodNumber, ZodBoolean, ZodAny, etc.\n * For ZodObject, it must have no shape keys to be considered shapeless.\n * ZodRecord schemas are considered shapeless since they define dynamic\n * key-value mappings without fixed keys.\n *\n * @param schema The Zod schema to check.\n * @returns {boolean} True if the schema is shapeless, false otherwise.\n */\nfunction isShapelessZodSchema(schema) {\n    if (!isInteropZodSchema(schema)) {\n        return false;\n    }\n    // Check for v3 schemas\n    if (isZodSchemaV3(schema)) {\n        // @ts-expect-error - zod v3 types are not compatible with zod v4 types\n        const def = schema._def;\n        // ZodObject is only shaped if it has actual shape keys\n        if (def.typeName === \"ZodObject\") {\n            const obj = schema;\n            return !obj.shape || Object.keys(obj.shape).length === 0;\n        }\n        // ZodRecord is shapeless (dynamic key-value mapping)\n        if (def.typeName === \"ZodRecord\") {\n            return true;\n        }\n    }\n    // Check for v4 schemas\n    if (isZodSchemaV4(schema)) {\n        const def = schema._zod.def;\n        // Object type is only shaped if it has actual shape keys\n        if (def.type === \"object\") {\n            const obj = schema;\n            return !obj.shape || Object.keys(obj.shape).length === 0;\n        }\n        // Record type is shapeless (dynamic key-value mapping)\n        if (def.type === \"record\") {\n            return true;\n        }\n    }\n    // For other schemas, check if they have a `shape` property\n    // If they don't have shape, they're likely shapeless\n    if (typeof schema === \"object\" && schema !== null && !(\"shape\" in schema)) {\n        return true;\n    }\n    return false;\n}\n/**\n * Determines if the provided Zod schema should be treated as a simple string schema\n * that maps to DynamicTool. This aligns with the type-level constraint of\n * InteropZodType<string | undefined> which only matches basic string schemas.\n * If the provided schema is just z.string(), we can make the determination that\n * the tool is just a generic string tool that doesn't require any input validation.\n *\n * This function only returns true for basic ZodString schemas, including:\n * - Basic string schemas (z.string())\n * - String schemas with validations (z.string().min(1), z.string().email(), etc.)\n *\n * This function returns false for everything else, including:\n * - String schemas with defaults (z.string().default(\"value\"))\n * - Branded string schemas (z.string().brand<\"UserId\">())\n * - String schemas with catch operations (z.string().catch(\"default\"))\n * - Optional/nullable string schemas (z.string().optional())\n * - Transformed schemas (z.string().transform() or z.object().transform())\n * - Object or record schemas, even if they're empty\n * - Any other schema type\n *\n * @param schema The Zod schema to check.\n * @returns {boolean} True if the schema is a basic ZodString, false otherwise.\n */\nfunction isSimpleStringZodSchema(schema) {\n    if (!isInteropZodSchema(schema)) {\n        return false;\n    }\n    // For v3 schemas\n    if (isZodSchemaV3(schema)) {\n        // @ts-expect-error - zod v3 types are not compatible with zod v4 types\n        const def = schema._def;\n        // Only accept basic ZodString\n        return def.typeName === \"ZodString\";\n    }\n    // For v4 schemas\n    if (isZodSchemaV4(schema)) {\n        const def = schema._zod.def;\n        // Only accept basic string type\n        return def.type === \"string\";\n    }\n    return false;\n}\nfunction isZodObjectV3(obj) {\n    // Zod v3 object schemas have _def.typeName === \"ZodObject\"\n    if (typeof obj === \"object\" &&\n        obj !== null &&\n        \"_def\" in obj &&\n        typeof obj._def === \"object\" &&\n        obj._def !== null &&\n        \"typeName\" in obj._def &&\n        obj._def.typeName === \"ZodObject\") {\n        return true;\n    }\n    return false;\n}\nfunction isZodObjectV4(obj) {\n    if (!isZodSchemaV4(obj))\n        return false;\n    // Zod v4 object schemas have _zod.def.type === \"object\"\n    if (typeof obj === \"object\" &&\n        obj !== null &&\n        \"_zod\" in obj &&\n        typeof obj._zod === \"object\" &&\n        obj._zod !== null &&\n        \"def\" in obj._zod &&\n        typeof obj._zod.def === \"object\" &&\n        obj._zod.def !== null &&\n        \"type\" in obj._zod.def &&\n        obj._zod.def.type === \"object\") {\n        return true;\n    }\n    return false;\n}\nfunction isZodArrayV4(obj) {\n    if (!isZodSchemaV4(obj))\n        return false;\n    // Zod v4 array schemas have _zod.def.type === \"array\"\n    if (typeof obj === \"object\" &&\n        obj !== null &&\n        \"_zod\" in obj &&\n        typeof obj._zod === \"object\" &&\n        obj._zod !== null &&\n        \"def\" in obj._zod &&\n        typeof obj._zod.def === \"object\" &&\n        obj._zod.def !== null &&\n        \"type\" in obj._zod.def &&\n        obj._zod.def.type === \"array\") {\n        return true;\n    }\n    return false;\n}\n/**\n * Determines if the provided value is an InteropZodObject (Zod v3 or v4 object schema).\n *\n * @param obj The value to check.\n * @returns {boolean} True if the value is a Zod v3 or v4 object schema, false otherwise.\n */\nfunction isInteropZodObject(obj) {\n    if (isZodObjectV3(obj))\n        return true;\n    if (isZodObjectV4(obj))\n        return true;\n    return false;\n}\n/**\n * Retrieves the shape (fields) of a Zod object schema, supporting both Zod v3 and v4.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @returns {InteropZodObjectShape<T>} The shape of the object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nfunction getInteropZodObjectShape(schema) {\n    if (isZodSchemaV3(schema)) {\n        return schema.shape;\n    }\n    if (isZodSchemaV4(schema)) {\n        return schema._zod.def.shape;\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodObject or z4.$ZodObject\");\n}\n/**\n * Extends a Zod object schema with additional fields, supporting both Zod v3 and v4.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @param {InteropZodObjectShape} extension - The fields to add to the schema.\n * @returns {InteropZodObject} The extended Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nfunction extendInteropZodObject(schema, extension) {\n    if (isZodSchemaV3(schema)) {\n        return schema.extend(extension);\n    }\n    if (isZodSchemaV4(schema)) {\n        return core_1.util.extend(schema, extension);\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodObject or z4.$ZodObject\");\n}\n/**\n * Returns a partial version of a Zod object schema, making all fields optional.\n * Supports both Zod v3 and v4.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @returns {InteropZodObject} The partial Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nfunction interopZodObjectPartial(schema) {\n    if (isZodSchemaV3(schema)) {\n        // z3: .partial() exists and works as expected\n        return schema.partial();\n    }\n    if (isZodSchemaV4(schema)) {\n        // z4: util.partial exists and works as expected\n        return core_1.util.partial(core_1.$ZodOptional, schema, undefined);\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodObject or z4.$ZodObject\");\n}\n/**\n * Returns a strict version of a Zod object schema, disallowing unknown keys.\n * Supports both Zod v3 and v4 object schemas. If `recursive` is true, applies strictness\n * recursively to all nested object schemas and arrays of object schemas.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @param {boolean} [recursive=false] - Whether to apply strictness recursively to nested objects/arrays.\n * @returns {InteropZodObject} The strict Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nfunction interopZodObjectStrict(schema, recursive = false) {\n    if (isZodSchemaV3(schema)) {\n        // TODO: v3 schemas aren't recursively handled here\n        // (currently not necessary since zodToJsonSchema handles this)\n        return schema.strict();\n    }\n    if (isZodObjectV4(schema)) {\n        const outputShape = schema._zod.def.shape;\n        if (recursive) {\n            for (const [key, keySchema] of Object.entries(schema._zod.def.shape)) {\n                // If the shape key is a v4 object schema, we need to make it strict\n                if (isZodObjectV4(keySchema)) {\n                    const outputSchema = interopZodObjectStrict(keySchema, recursive);\n                    outputShape[key] = outputSchema;\n                }\n                // If the shape key is a v4 array schema, we need to make the element\n                // schema strict if it's an object schema\n                else if (isZodArrayV4(keySchema)) {\n                    let elementSchema = keySchema._zod.def.element;\n                    if (isZodObjectV4(elementSchema)) {\n                        elementSchema = interopZodObjectStrict(elementSchema, recursive);\n                    }\n                    outputShape[key] = (0, core_1.clone)(keySchema, {\n                        ...keySchema._zod.def,\n                        element: elementSchema,\n                    });\n                }\n                // Otherwise, just use the keySchema\n                else {\n                    outputShape[key] = keySchema;\n                }\n                // Assign meta fields to the keySchema\n                const meta = core_1.globalRegistry.get(keySchema);\n                if (meta)\n                    core_1.globalRegistry.add(outputShape[key], meta);\n            }\n        }\n        const modifiedSchema = (0, core_1.clone)(schema, {\n            ...schema._zod.def,\n            shape: outputShape,\n            catchall: (0, core_1._never)(core_1.$ZodNever),\n        });\n        const meta = core_1.globalRegistry.get(schema);\n        if (meta)\n            core_1.globalRegistry.add(modifiedSchema, meta);\n        return modifiedSchema;\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodObject or z4.$ZodObject\");\n}\n/**\n * Returns a passthrough version of a Zod object schema, allowing unknown keys.\n * Supports both Zod v3 and v4 object schemas. If `recursive` is true, applies passthrough\n * recursively to all nested object schemas and arrays of object schemas.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @param {boolean} [recursive=false] - Whether to apply passthrough recursively to nested objects/arrays.\n * @returns {InteropZodObject} The passthrough Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nfunction interopZodObjectPassthrough(schema, recursive = false) {\n    if (isZodObjectV3(schema)) {\n        // TODO: v3 schemas aren't recursively handled here\n        // (currently not necessary since zodToJsonSchema handles this)\n        return schema.passthrough();\n    }\n    if (isZodObjectV4(schema)) {\n        const outputShape = schema._zod.def.shape;\n        if (recursive) {\n            for (const [key, keySchema] of Object.entries(schema._zod.def.shape)) {\n                // If the shape key is a v4 object schema, we need to make it passthrough\n                if (isZodObjectV4(keySchema)) {\n                    const outputSchema = interopZodObjectPassthrough(keySchema, recursive);\n                    outputShape[key] = outputSchema;\n                }\n                // If the shape key is a v4 array schema, we need to make the element\n                // schema passthrough if it's an object schema\n                else if (isZodArrayV4(keySchema)) {\n                    let elementSchema = keySchema._zod.def.element;\n                    if (isZodObjectV4(elementSchema)) {\n                        elementSchema = interopZodObjectPassthrough(elementSchema, recursive);\n                    }\n                    outputShape[key] = (0, core_1.clone)(keySchema, {\n                        ...keySchema._zod.def,\n                        element: elementSchema,\n                    });\n                }\n                // Otherwise, just use the keySchema\n                else {\n                    outputShape[key] = keySchema;\n                }\n                // Assign meta fields to the keySchema\n                const meta = core_1.globalRegistry.get(keySchema);\n                if (meta)\n                    core_1.globalRegistry.add(outputShape[key], meta);\n            }\n        }\n        const modifiedSchema = (0, core_1.clone)(schema, {\n            ...schema._zod.def,\n            shape: outputShape,\n            catchall: (0, core_1._unknown)(core_1.$ZodUnknown),\n        });\n        const meta = core_1.globalRegistry.get(schema);\n        if (meta)\n            core_1.globalRegistry.add(modifiedSchema, meta);\n        return modifiedSchema;\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodObject or z4.$ZodObject\");\n}\n/**\n * Returns a getter function for the default value of a Zod schema, if one is defined.\n * Supports both Zod v3 and v4 schemas. If the schema has a default value,\n * the returned function will return that value when called. If no default is defined,\n * returns undefined.\n *\n * @template T - The type of the Zod schema.\n * @param {T} schema - The Zod schema instance (either v3 or v4).\n * @returns {(() => InferInteropZodOutput<T>) | undefined} A function that returns the default value, or undefined if no default is set.\n */\nfunction getInteropZodDefaultGetter(schema) {\n    if (isZodSchemaV3(schema)) {\n        try {\n            const defaultValue = schema.parse(undefined);\n            return () => defaultValue;\n        }\n        catch {\n            return undefined;\n        }\n    }\n    if (isZodSchemaV4(schema)) {\n        try {\n            const defaultValue = (0, core_1.parse)(schema, undefined);\n            return () => defaultValue;\n        }\n        catch {\n            return undefined;\n        }\n    }\n    return undefined;\n}\nfunction isZodTransformV3(schema) {\n    return (isZodSchemaV3(schema) &&\n        \"typeName\" in schema._def &&\n        schema._def.typeName === \"ZodEffects\");\n}\nfunction isZodTransformV4(schema) {\n    return isZodSchemaV4(schema) && schema._zod.def.type === \"pipe\";\n}\n/**\n * Returns the input type of a Zod transform schema, for both v3 and v4.\n * If the schema is not a transform, returns undefined. If `recursive` is true,\n * recursively processes nested object schemas and arrays of object schemas.\n *\n * @param schema - The Zod schema instance (v3 or v4)\n * @param {boolean} [recursive=false] - Whether to recursively process nested objects/arrays.\n * @returns The input Zod schema of the transform, or undefined if not a transform\n */\nfunction interopZodTransformInputSchema(schema, recursive = false) {\n    // Zod v3: ._def.schema is the input schema for ZodEffects (transform)\n    if (isZodSchemaV3(schema)) {\n        if (isZodTransformV3(schema)) {\n            return interopZodTransformInputSchema(schema._def.schema, recursive);\n        }\n        // TODO: v3 schemas aren't recursively handled here\n        // (currently not necessary since zodToJsonSchema handles this)\n        return schema;\n    }\n    // Zod v4: _def.type is the input schema for ZodEffects (transform)\n    if (isZodSchemaV4(schema)) {\n        let outputSchema = schema;\n        if (isZodTransformV4(schema)) {\n            outputSchema = interopZodTransformInputSchema(schema._zod.def.in, recursive);\n        }\n        if (recursive) {\n            // Handle nested object schemas\n            if (isZodObjectV4(outputSchema)) {\n                const outputShape = outputSchema._zod.def.shape;\n                for (const [key, keySchema] of Object.entries(outputSchema._zod.def.shape)) {\n                    outputShape[key] = interopZodTransformInputSchema(keySchema, recursive);\n                }\n                outputSchema = (0, core_1.clone)(outputSchema, {\n                    ...outputSchema._zod.def,\n                    shape: outputShape,\n                });\n            }\n            // Handle nested array schemas\n            else if (isZodArrayV4(outputSchema)) {\n                const elementSchema = interopZodTransformInputSchema(outputSchema._zod.def.element, recursive);\n                outputSchema = (0, core_1.clone)(outputSchema, {\n                    ...outputSchema._zod.def,\n                    element: elementSchema,\n                });\n            }\n        }\n        const meta = core_1.globalRegistry.get(schema);\n        if (meta)\n            core_1.globalRegistry.add(outputSchema, meta);\n        return outputSchema;\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvdHlwZXMvem9kLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQiwwQkFBMEI7QUFDMUIsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6Qix3QkFBd0I7QUFDeEIsb0JBQW9CO0FBQ3BCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsK0JBQStCO0FBQy9CLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCLDBCQUEwQjtBQUMxQixnQ0FBZ0M7QUFDaEMsOEJBQThCO0FBQzlCLCtCQUErQjtBQUMvQiw4QkFBOEI7QUFDOUIsbUNBQW1DO0FBQ25DLGtDQUFrQztBQUNsQyxzQ0FBc0M7QUFDdEMsZUFBZSxtQkFBTyxDQUFDLCtEQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLFNBQVM7QUFDcEIsYUFBYSx1Q0FBdUM7QUFDcEQsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsU0FBUztBQUNwQixhQUFhLFlBQVk7QUFDekIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsU0FBUztBQUNwQixhQUFhLDhCQUE4QjtBQUMzQztBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLFNBQVM7QUFDcEIsYUFBYSxHQUFHO0FBQ2hCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSwwQkFBMEI7QUFDdkMsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLHVCQUF1QjtBQUNsQyxhQUFhLGtCQUFrQjtBQUMvQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxrQkFBa0I7QUFDL0IsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsU0FBUztBQUNwQixhQUFhLGtCQUFrQjtBQUMvQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFNBQVM7QUFDcEIsYUFBYSxrQkFBa0I7QUFDL0IsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLDhDQUE4QztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvdHlwZXMvem9kLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNab2RTY2hlbWFWNCA9IGlzWm9kU2NoZW1hVjQ7XG5leHBvcnRzLmlzWm9kU2NoZW1hVjMgPSBpc1pvZFNjaGVtYVYzO1xuZXhwb3J0cy5pc1pvZFNjaGVtYSA9IGlzWm9kU2NoZW1hO1xuZXhwb3J0cy5pc0ludGVyb3Bab2RTY2hlbWEgPSBpc0ludGVyb3Bab2RTY2hlbWE7XG5leHBvcnRzLmludGVyb3BTYWZlUGFyc2VBc3luYyA9IGludGVyb3BTYWZlUGFyc2VBc3luYztcbmV4cG9ydHMuaW50ZXJvcFBhcnNlQXN5bmMgPSBpbnRlcm9wUGFyc2VBc3luYztcbmV4cG9ydHMuaW50ZXJvcFNhZmVQYXJzZSA9IGludGVyb3BTYWZlUGFyc2U7XG5leHBvcnRzLmludGVyb3BQYXJzZSA9IGludGVyb3BQYXJzZTtcbmV4cG9ydHMuZ2V0U2NoZW1hRGVzY3JpcHRpb24gPSBnZXRTY2hlbWFEZXNjcmlwdGlvbjtcbmV4cG9ydHMuaXNTaGFwZWxlc3Nab2RTY2hlbWEgPSBpc1NoYXBlbGVzc1pvZFNjaGVtYTtcbmV4cG9ydHMuaXNTaW1wbGVTdHJpbmdab2RTY2hlbWEgPSBpc1NpbXBsZVN0cmluZ1pvZFNjaGVtYTtcbmV4cG9ydHMuaXNab2RPYmplY3RWMyA9IGlzWm9kT2JqZWN0VjM7XG5leHBvcnRzLmlzWm9kT2JqZWN0VjQgPSBpc1pvZE9iamVjdFY0O1xuZXhwb3J0cy5pc1pvZEFycmF5VjQgPSBpc1pvZEFycmF5VjQ7XG5leHBvcnRzLmlzSW50ZXJvcFpvZE9iamVjdCA9IGlzSW50ZXJvcFpvZE9iamVjdDtcbmV4cG9ydHMuZ2V0SW50ZXJvcFpvZE9iamVjdFNoYXBlID0gZ2V0SW50ZXJvcFpvZE9iamVjdFNoYXBlO1xuZXhwb3J0cy5leHRlbmRJbnRlcm9wWm9kT2JqZWN0ID0gZXh0ZW5kSW50ZXJvcFpvZE9iamVjdDtcbmV4cG9ydHMuaW50ZXJvcFpvZE9iamVjdFBhcnRpYWwgPSBpbnRlcm9wWm9kT2JqZWN0UGFydGlhbDtcbmV4cG9ydHMuaW50ZXJvcFpvZE9iamVjdFN0cmljdCA9IGludGVyb3Bab2RPYmplY3RTdHJpY3Q7XG5leHBvcnRzLmludGVyb3Bab2RPYmplY3RQYXNzdGhyb3VnaCA9IGludGVyb3Bab2RPYmplY3RQYXNzdGhyb3VnaDtcbmV4cG9ydHMuZ2V0SW50ZXJvcFpvZERlZmF1bHRHZXR0ZXIgPSBnZXRJbnRlcm9wWm9kRGVmYXVsdEdldHRlcjtcbmV4cG9ydHMuaW50ZXJvcFpvZFRyYW5zZm9ybUlucHV0U2NoZW1hID0gaW50ZXJvcFpvZFRyYW5zZm9ybUlucHV0U2NoZW1hO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcInpvZC92NC9jb3JlXCIpO1xuZnVuY3Rpb24gaXNab2RTY2hlbWFWNChzY2hlbWEpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSAhPT0gXCJvYmplY3RcIiB8fCBzY2hlbWEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBvYmogPSBzY2hlbWE7XG4gICAgaWYgKCEoXCJfem9kXCIgaW4gb2JqKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHpvZCA9IG9iai5fem9kO1xuICAgIHJldHVybiAodHlwZW9mIHpvZCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICB6b2QgIT09IG51bGwgJiZcbiAgICAgICAgXCJkZWZcIiBpbiB6b2QpO1xufVxuZnVuY3Rpb24gaXNab2RTY2hlbWFWMyhzY2hlbWEpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSAhPT0gXCJvYmplY3RcIiB8fCBzY2hlbWEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBvYmogPSBzY2hlbWE7XG4gICAgaWYgKCEoXCJfZGVmXCIgaW4gb2JqKSB8fCBcIl96b2RcIiBpbiBvYmopIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBkZWYgPSBvYmouX2RlZjtcbiAgICByZXR1cm4gKHR5cGVvZiBkZWYgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgZGVmICE9IG51bGwgJiZcbiAgICAgICAgXCJ0eXBlTmFtZVwiIGluIGRlZik7XG59XG4vKiogQmFja3dhcmQgY29tcGF0aWJsZSBpc1pvZFNjaGVtYSBmb3IgWm9kIDMgKi9cbmZ1bmN0aW9uIGlzWm9kU2NoZW1hKHNjaGVtYSkge1xuICAgIGlmIChpc1pvZFNjaGVtYVY0KHNjaGVtYSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1dBUk5JTkddIEF0dGVtcHRpbmcgdG8gdXNlIFpvZCA0IHNjaGVtYSBpbiBhIGNvbnRleHQgd2hlcmUgWm9kIDMgc2NoZW1hIGlzIGV4cGVjdGVkLiBUaGlzIG1heSBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW9yLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzWm9kU2NoZW1hVjMoc2NoZW1hKTtcbn1cbi8qKlxuICogR2l2ZW4gZWl0aGVyIGEgWm9kIHNjaGVtYSwgb3IgcGxhaW4gb2JqZWN0LCBkZXRlcm1pbmUgaWYgdGhlIGlucHV0IGlzIGEgWm9kIHNjaGVtYS5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd259IGlucHV0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIHByb3ZpZGVkIGlucHV0IGlzIGEgWm9kIHNjaGVtYS5cbiAqL1xuZnVuY3Rpb24gaXNJbnRlcm9wWm9kU2NoZW1hKGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXNab2RTY2hlbWFWNChpbnB1dCkgfHxcbiAgICAgICAgaXNab2RTY2hlbWFWMyhpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgcGFyc2VzIHRoZSBpbnB1dCB1c2luZyB0aGUgcHJvdmlkZWQgWm9kIHNjaGVtYSAodjMgb3IgdjQpIGFuZCByZXR1cm5zIGEgc2FmZSBwYXJzZSByZXN1bHQuXG4gKiBUaGlzIGZ1bmN0aW9uIGhhbmRsZXMgYm90aCBab2QgdjMgYW5kIHY0IHNjaGVtYXMsIHJldHVybmluZyBhIHJlc3VsdCBvYmplY3QgaW5kaWNhdGluZyBzdWNjZXNzIG9yIGZhaWx1cmUuXG4gKlxuICogQHRlbXBsYXRlIFQgLSBUaGUgZXhwZWN0ZWQgb3V0cHV0IHR5cGUgb2YgdGhlIHNjaGVtYS5cbiAqIEBwYXJhbSB7SW50ZXJvcFpvZFR5cGU8VD59IHNjaGVtYSAtIFRoZSBab2Qgc2NoZW1hICh2MyBvciB2NCkgdG8gdXNlIGZvciBwYXJzaW5nLlxuICogQHBhcmFtIHt1bmtub3dufSBpbnB1dCAtIFRoZSBpbnB1dCB2YWx1ZSB0byBwYXJzZS5cbiAqIEByZXR1cm5zIHtQcm9taXNlPEludGVyb3Bab2RTYWZlUGFyc2VSZXN1bHQ8VD4+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHNhZmUgcGFyc2UgcmVzdWx0IG9iamVjdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc2NoZW1hIGlzIG5vdCBhIHJlY29nbml6ZWQgWm9kIHYzIG9yIHY0IHNjaGVtYS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaW50ZXJvcFNhZmVQYXJzZUFzeW5jKHNjaGVtYSwgaW5wdXQpIHtcbiAgICBpZiAoaXNab2RTY2hlbWFWNChzY2hlbWEpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgKDAsIGNvcmVfMS5wYXJzZUFzeW5jKShzY2hlbWEsIGlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNab2RTY2hlbWFWMyhzY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuc2FmZVBhcnNlKGlucHV0KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2NoZW1hIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgejMuWm9kVHlwZSBvciB6NC4kWm9kVHlwZVwiKTtcbn1cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgcGFyc2VzIHRoZSBpbnB1dCB1c2luZyB0aGUgcHJvdmlkZWQgWm9kIHNjaGVtYSAodjMgb3IgdjQpIGFuZCByZXR1cm5zIHRoZSBwYXJzZWQgdmFsdWUuXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgcGFyc2luZyBmYWlscyBvciBpZiB0aGUgc2NoZW1hIGlzIG5vdCBhIHJlY29nbml6ZWQgWm9kIHYzIG9yIHY0IHNjaGVtYS5cbiAqXG4gKiBAdGVtcGxhdGUgVCAtIFRoZSBleHBlY3RlZCBvdXRwdXQgdHlwZSBvZiB0aGUgc2NoZW1hLlxuICogQHBhcmFtIHtJbnRlcm9wWm9kVHlwZTxUPn0gc2NoZW1hIC0gVGhlIFpvZCBzY2hlbWEgKHYzIG9yIHY0KSB0byB1c2UgZm9yIHBhcnNpbmcuXG4gKiBAcGFyYW0ge3Vua25vd259IGlucHV0IC0gVGhlIGlucHV0IHZhbHVlIHRvIHBhcnNlLlxuICogQHJldHVybnMge1Byb21pc2U8VD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBwYXJzZWQgdmFsdWUuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgcGFyc2luZyBmYWlscyBvciB0aGUgc2NoZW1hIGlzIG5vdCBhIHJlY29nbml6ZWQgWm9kIHYzIG9yIHY0IHNjaGVtYS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaW50ZXJvcFBhcnNlQXN5bmMoc2NoZW1hLCBpbnB1dCkge1xuICAgIGlmIChpc1pvZFNjaGVtYVY0KHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuICgwLCBjb3JlXzEucGFyc2UpKHNjaGVtYSwgaW5wdXQpO1xuICAgIH1cbiAgICBpZiAoaXNab2RTY2hlbWFWMyhzY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEucGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTY2hlbWEgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiB6My5ab2RUeXBlIG9yIHo0LiRab2RUeXBlXCIpO1xufVxuLyoqXG4gKiBTYWZlbHkgcGFyc2VzIHRoZSBpbnB1dCB1c2luZyB0aGUgcHJvdmlkZWQgWm9kIHNjaGVtYSAodjMgb3IgdjQpIGFuZCByZXR1cm5zIGEgcmVzdWx0IG9iamVjdFxuICogaW5kaWNhdGluZyBzdWNjZXNzIG9yIGZhaWx1cmUuIFRoaXMgZnVuY3Rpb24gaXMgY29tcGF0aWJsZSB3aXRoIGJvdGggWm9kIHYzIGFuZCB2NCBzY2hlbWFzLlxuICpcbiAqIEB0ZW1wbGF0ZSBUIC0gVGhlIGV4cGVjdGVkIG91dHB1dCB0eXBlIG9mIHRoZSBzY2hlbWEuXG4gKiBAcGFyYW0ge0ludGVyb3Bab2RUeXBlPFQ+fSBzY2hlbWEgLSBUaGUgWm9kIHNjaGVtYSAodjMgb3IgdjQpIHRvIHVzZSBmb3IgcGFyc2luZy5cbiAqIEBwYXJhbSB7dW5rbm93bn0gaW5wdXQgLSBUaGUgaW5wdXQgdmFsdWUgdG8gcGFyc2UuXG4gKiBAcmV0dXJucyB7SW50ZXJvcFpvZFNhZmVQYXJzZVJlc3VsdDxUPn0gQW4gb2JqZWN0IHdpdGggZWl0aGVyIHRoZSBwYXJzZWQgZGF0YSAob24gc3VjY2VzcylcbiAqICAgb3IgdGhlIGVycm9yIChvbiBmYWlsdXJlKS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc2NoZW1hIGlzIG5vdCBhIHJlY29nbml6ZWQgWm9kIHYzIG9yIHY0IHNjaGVtYS5cbiAqL1xuZnVuY3Rpb24gaW50ZXJvcFNhZmVQYXJzZShzY2hlbWEsIGlucHV0KSB7XG4gICAgaWYgKGlzWm9kU2NoZW1hVjQoc2NoZW1hKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9ICgwLCBjb3JlXzEucGFyc2UpKHNjaGVtYSwgaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc1pvZFNjaGVtYVYzKHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5zYWZlUGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTY2hlbWEgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiB6My5ab2RUeXBlIG9yIHo0LiRab2RUeXBlXCIpO1xufVxuLyoqXG4gKiBQYXJzZXMgdGhlIGlucHV0IHVzaW5nIHRoZSBwcm92aWRlZCBab2Qgc2NoZW1hICh2MyBvciB2NCkgYW5kIHJldHVybnMgdGhlIHBhcnNlZCB2YWx1ZS5cbiAqIFRocm93cyBhbiBlcnJvciBpZiBwYXJzaW5nIGZhaWxzIG9yIGlmIHRoZSBzY2hlbWEgaXMgbm90IGEgcmVjb2duaXplZCBab2QgdjMgb3IgdjQgc2NoZW1hLlxuICpcbiAqIEB0ZW1wbGF0ZSBUIC0gVGhlIGV4cGVjdGVkIG91dHB1dCB0eXBlIG9mIHRoZSBzY2hlbWEuXG4gKiBAcGFyYW0ge0ludGVyb3Bab2RUeXBlPFQ+fSBzY2hlbWEgLSBUaGUgWm9kIHNjaGVtYSAodjMgb3IgdjQpIHRvIHVzZSBmb3IgcGFyc2luZy5cbiAqIEBwYXJhbSB7dW5rbm93bn0gaW5wdXQgLSBUaGUgaW5wdXQgdmFsdWUgdG8gcGFyc2UuXG4gKiBAcmV0dXJucyB7VH0gVGhlIHBhcnNlZCB2YWx1ZS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBwYXJzaW5nIGZhaWxzIG9yIHRoZSBzY2hlbWEgaXMgbm90IGEgcmVjb2duaXplZCBab2QgdjMgb3IgdjQgc2NoZW1hLlxuICovXG5mdW5jdGlvbiBpbnRlcm9wUGFyc2Uoc2NoZW1hLCBpbnB1dCkge1xuICAgIGlmIChpc1pvZFNjaGVtYVY0KHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuICgwLCBjb3JlXzEucGFyc2UpKHNjaGVtYSwgaW5wdXQpO1xuICAgIH1cbiAgICBpZiAoaXNab2RTY2hlbWFWMyhzY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEucGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTY2hlbWEgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiB6My5ab2RUeXBlIG9yIHo0LiRab2RUeXBlXCIpO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGRlc2NyaXB0aW9uIGZyb20gYSBzY2hlbWEgZGVmaW5pdGlvbiAodjMsIHY0LCBvciBwbGFpbiBvYmplY3QpLCBpZiBhdmFpbGFibGUuXG4gKlxuICogQHBhcmFtIHt1bmtub3dufSBzY2hlbWEgLSBUaGUgc2NoZW1hIHRvIGV4dHJhY3QgdGhlIGRlc2NyaXB0aW9uIGZyb20uXG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSBUaGUgZGVzY3JpcHRpb24gb2YgdGhlIHNjaGVtYSwgb3IgdW5kZWZpbmVkIGlmIG5vdCBwcmVzZW50LlxuICovXG5mdW5jdGlvbiBnZXRTY2hlbWFEZXNjcmlwdGlvbihzY2hlbWEpIHtcbiAgICBpZiAoaXNab2RTY2hlbWFWNChzY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiBjb3JlXzEuZ2xvYmFsUmVnaXN0cnkuZ2V0KHNjaGVtYSk/LmRlc2NyaXB0aW9uO1xuICAgIH1cbiAgICBpZiAoaXNab2RTY2hlbWFWMyhzY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuZGVzY3JpcHRpb247XG4gICAgfVxuICAgIGlmIChcImRlc2NyaXB0aW9uXCIgaW4gc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEuZGVzY3JpcHRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5kZXNjcmlwdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgcHJvdmlkZWQgWm9kIHNjaGVtYSBpcyBcInNoYXBlbGVzc1wiLlxuICogQSBzaGFwZWxlc3Mgc2NoZW1hIGlzIG9uZSB0aGF0IGRvZXMgbm90IGRlZmluZSBhbnkgb2JqZWN0IHNoYXBlLFxuICogc3VjaCBhcyBab2RTdHJpbmcsIFpvZE51bWJlciwgWm9kQm9vbGVhbiwgWm9kQW55LCBldGMuXG4gKiBGb3IgWm9kT2JqZWN0LCBpdCBtdXN0IGhhdmUgbm8gc2hhcGUga2V5cyB0byBiZSBjb25zaWRlcmVkIHNoYXBlbGVzcy5cbiAqIFpvZFJlY29yZCBzY2hlbWFzIGFyZSBjb25zaWRlcmVkIHNoYXBlbGVzcyBzaW5jZSB0aGV5IGRlZmluZSBkeW5hbWljXG4gKiBrZXktdmFsdWUgbWFwcGluZ3Mgd2l0aG91dCBmaXhlZCBrZXlzLlxuICpcbiAqIEBwYXJhbSBzY2hlbWEgVGhlIFpvZCBzY2hlbWEgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc2NoZW1hIGlzIHNoYXBlbGVzcywgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1NoYXBlbGVzc1pvZFNjaGVtYShzY2hlbWEpIHtcbiAgICBpZiAoIWlzSW50ZXJvcFpvZFNjaGVtYShzY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgZm9yIHYzIHNjaGVtYXNcbiAgICBpZiAoaXNab2RTY2hlbWFWMyhzY2hlbWEpKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSB6b2QgdjMgdHlwZXMgYXJlIG5vdCBjb21wYXRpYmxlIHdpdGggem9kIHY0IHR5cGVzXG4gICAgICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fZGVmO1xuICAgICAgICAvLyBab2RPYmplY3QgaXMgb25seSBzaGFwZWQgaWYgaXQgaGFzIGFjdHVhbCBzaGFwZSBrZXlzXG4gICAgICAgIGlmIChkZWYudHlwZU5hbWUgPT09IFwiWm9kT2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IHNjaGVtYTtcbiAgICAgICAgICAgIHJldHVybiAhb2JqLnNoYXBlIHx8IE9iamVjdC5rZXlzKG9iai5zaGFwZSkubGVuZ3RoID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFpvZFJlY29yZCBpcyBzaGFwZWxlc3MgKGR5bmFtaWMga2V5LXZhbHVlIG1hcHBpbmcpXG4gICAgICAgIGlmIChkZWYudHlwZU5hbWUgPT09IFwiWm9kUmVjb3JkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENoZWNrIGZvciB2NCBzY2hlbWFzXG4gICAgaWYgKGlzWm9kU2NoZW1hVjQoc2NoZW1hKSkge1xuICAgICAgICBjb25zdCBkZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAgICAgIC8vIE9iamVjdCB0eXBlIGlzIG9ubHkgc2hhcGVkIGlmIGl0IGhhcyBhY3R1YWwgc2hhcGUga2V5c1xuICAgICAgICBpZiAoZGVmLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IHNjaGVtYTtcbiAgICAgICAgICAgIHJldHVybiAhb2JqLnNoYXBlIHx8IE9iamVjdC5rZXlzKG9iai5zaGFwZSkubGVuZ3RoID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY29yZCB0eXBlIGlzIHNoYXBlbGVzcyAoZHluYW1pYyBrZXktdmFsdWUgbWFwcGluZylcbiAgICAgICAgaWYgKGRlZi50eXBlID09PSBcInJlY29yZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBGb3Igb3RoZXIgc2NoZW1hcywgY2hlY2sgaWYgdGhleSBoYXZlIGEgYHNoYXBlYCBwcm9wZXJ0eVxuICAgIC8vIElmIHRoZXkgZG9uJ3QgaGF2ZSBzaGFwZSwgdGhleSdyZSBsaWtlbHkgc2hhcGVsZXNzXG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwib2JqZWN0XCIgJiYgc2NoZW1hICE9PSBudWxsICYmICEoXCJzaGFwZVwiIGluIHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgcHJvdmlkZWQgWm9kIHNjaGVtYSBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIHNpbXBsZSBzdHJpbmcgc2NoZW1hXG4gKiB0aGF0IG1hcHMgdG8gRHluYW1pY1Rvb2wuIFRoaXMgYWxpZ25zIHdpdGggdGhlIHR5cGUtbGV2ZWwgY29uc3RyYWludCBvZlxuICogSW50ZXJvcFpvZFR5cGU8c3RyaW5nIHwgdW5kZWZpbmVkPiB3aGljaCBvbmx5IG1hdGNoZXMgYmFzaWMgc3RyaW5nIHNjaGVtYXMuXG4gKiBJZiB0aGUgcHJvdmlkZWQgc2NoZW1hIGlzIGp1c3Qgei5zdHJpbmcoKSwgd2UgY2FuIG1ha2UgdGhlIGRldGVybWluYXRpb24gdGhhdFxuICogdGhlIHRvb2wgaXMganVzdCBhIGdlbmVyaWMgc3RyaW5nIHRvb2wgdGhhdCBkb2Vzbid0IHJlcXVpcmUgYW55IGlucHV0IHZhbGlkYXRpb24uXG4gKlxuICogVGhpcyBmdW5jdGlvbiBvbmx5IHJldHVybnMgdHJ1ZSBmb3IgYmFzaWMgWm9kU3RyaW5nIHNjaGVtYXMsIGluY2x1ZGluZzpcbiAqIC0gQmFzaWMgc3RyaW5nIHNjaGVtYXMgKHouc3RyaW5nKCkpXG4gKiAtIFN0cmluZyBzY2hlbWFzIHdpdGggdmFsaWRhdGlvbnMgKHouc3RyaW5nKCkubWluKDEpLCB6LnN0cmluZygpLmVtYWlsKCksIGV0Yy4pXG4gKlxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGZhbHNlIGZvciBldmVyeXRoaW5nIGVsc2UsIGluY2x1ZGluZzpcbiAqIC0gU3RyaW5nIHNjaGVtYXMgd2l0aCBkZWZhdWx0cyAoei5zdHJpbmcoKS5kZWZhdWx0KFwidmFsdWVcIikpXG4gKiAtIEJyYW5kZWQgc3RyaW5nIHNjaGVtYXMgKHouc3RyaW5nKCkuYnJhbmQ8XCJVc2VySWRcIj4oKSlcbiAqIC0gU3RyaW5nIHNjaGVtYXMgd2l0aCBjYXRjaCBvcGVyYXRpb25zICh6LnN0cmluZygpLmNhdGNoKFwiZGVmYXVsdFwiKSlcbiAqIC0gT3B0aW9uYWwvbnVsbGFibGUgc3RyaW5nIHNjaGVtYXMgKHouc3RyaW5nKCkub3B0aW9uYWwoKSlcbiAqIC0gVHJhbnNmb3JtZWQgc2NoZW1hcyAoei5zdHJpbmcoKS50cmFuc2Zvcm0oKSBvciB6Lm9iamVjdCgpLnRyYW5zZm9ybSgpKVxuICogLSBPYmplY3Qgb3IgcmVjb3JkIHNjaGVtYXMsIGV2ZW4gaWYgdGhleSdyZSBlbXB0eVxuICogLSBBbnkgb3RoZXIgc2NoZW1hIHR5cGVcbiAqXG4gKiBAcGFyYW0gc2NoZW1hIFRoZSBab2Qgc2NoZW1hIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNjaGVtYSBpcyBhIGJhc2ljIFpvZFN0cmluZywgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1NpbXBsZVN0cmluZ1pvZFNjaGVtYShzY2hlbWEpIHtcbiAgICBpZiAoIWlzSW50ZXJvcFpvZFNjaGVtYShzY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gRm9yIHYzIHNjaGVtYXNcbiAgICBpZiAoaXNab2RTY2hlbWFWMyhzY2hlbWEpKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSB6b2QgdjMgdHlwZXMgYXJlIG5vdCBjb21wYXRpYmxlIHdpdGggem9kIHY0IHR5cGVzXG4gICAgICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fZGVmO1xuICAgICAgICAvLyBPbmx5IGFjY2VwdCBiYXNpYyBab2RTdHJpbmdcbiAgICAgICAgcmV0dXJuIGRlZi50eXBlTmFtZSA9PT0gXCJab2RTdHJpbmdcIjtcbiAgICB9XG4gICAgLy8gRm9yIHY0IHNjaGVtYXNcbiAgICBpZiAoaXNab2RTY2hlbWFWNChzY2hlbWEpKSB7XG4gICAgICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICAgICAgLy8gT25seSBhY2NlcHQgYmFzaWMgc3RyaW5nIHR5cGVcbiAgICAgICAgcmV0dXJuIGRlZi50eXBlID09PSBcInN0cmluZ1wiO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1pvZE9iamVjdFYzKG9iaikge1xuICAgIC8vIFpvZCB2MyBvYmplY3Qgc2NoZW1hcyBoYXZlIF9kZWYudHlwZU5hbWUgPT09IFwiWm9kT2JqZWN0XCJcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBvYmogIT09IG51bGwgJiZcbiAgICAgICAgXCJfZGVmXCIgaW4gb2JqICYmXG4gICAgICAgIHR5cGVvZiBvYmouX2RlZiA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBvYmouX2RlZiAhPT0gbnVsbCAmJlxuICAgICAgICBcInR5cGVOYW1lXCIgaW4gb2JqLl9kZWYgJiZcbiAgICAgICAgb2JqLl9kZWYudHlwZU5hbWUgPT09IFwiWm9kT2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzWm9kT2JqZWN0VjQob2JqKSB7XG4gICAgaWYgKCFpc1pvZFNjaGVtYVY0KG9iaikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBab2QgdjQgb2JqZWN0IHNjaGVtYXMgaGF2ZSBfem9kLmRlZi50eXBlID09PSBcIm9iamVjdFwiXG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgb2JqICE9PSBudWxsICYmXG4gICAgICAgIFwiX3pvZFwiIGluIG9iaiAmJlxuICAgICAgICB0eXBlb2Ygb2JqLl96b2QgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgb2JqLl96b2QgIT09IG51bGwgJiZcbiAgICAgICAgXCJkZWZcIiBpbiBvYmouX3pvZCAmJlxuICAgICAgICB0eXBlb2Ygb2JqLl96b2QuZGVmID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIG9iai5fem9kLmRlZiAhPT0gbnVsbCAmJlxuICAgICAgICBcInR5cGVcIiBpbiBvYmouX3pvZC5kZWYgJiZcbiAgICAgICAgb2JqLl96b2QuZGVmLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzWm9kQXJyYXlWNChvYmopIHtcbiAgICBpZiAoIWlzWm9kU2NoZW1hVjQob2JqKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIFpvZCB2NCBhcnJheSBzY2hlbWFzIGhhdmUgX3pvZC5kZWYudHlwZSA9PT0gXCJhcnJheVwiXG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgb2JqICE9PSBudWxsICYmXG4gICAgICAgIFwiX3pvZFwiIGluIG9iaiAmJlxuICAgICAgICB0eXBlb2Ygb2JqLl96b2QgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgb2JqLl96b2QgIT09IG51bGwgJiZcbiAgICAgICAgXCJkZWZcIiBpbiBvYmouX3pvZCAmJlxuICAgICAgICB0eXBlb2Ygb2JqLl96b2QuZGVmID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIG9iai5fem9kLmRlZiAhPT0gbnVsbCAmJlxuICAgICAgICBcInR5cGVcIiBpbiBvYmouX3pvZC5kZWYgJiZcbiAgICAgICAgb2JqLl96b2QuZGVmLnR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBhbiBJbnRlcm9wWm9kT2JqZWN0IChab2QgdjMgb3IgdjQgb2JqZWN0IHNjaGVtYSkuXG4gKlxuICogQHBhcmFtIG9iaiBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBab2QgdjMgb3IgdjQgb2JqZWN0IHNjaGVtYSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0ludGVyb3Bab2RPYmplY3Qob2JqKSB7XG4gICAgaWYgKGlzWm9kT2JqZWN0VjMob2JqKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGlzWm9kT2JqZWN0VjQob2JqKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHNoYXBlIChmaWVsZHMpIG9mIGEgWm9kIG9iamVjdCBzY2hlbWEsIHN1cHBvcnRpbmcgYm90aCBab2QgdjMgYW5kIHY0LlxuICpcbiAqIEB0ZW1wbGF0ZSBUIC0gVGhlIHR5cGUgb2YgdGhlIFpvZCBvYmplY3Qgc2NoZW1hLlxuICogQHBhcmFtIHtUfSBzY2hlbWEgLSBUaGUgWm9kIG9iamVjdCBzY2hlbWEgaW5zdGFuY2UgKGVpdGhlciB2MyBvciB2NCkuXG4gKiBAcmV0dXJucyB7SW50ZXJvcFpvZE9iamVjdFNoYXBlPFQ+fSBUaGUgc2hhcGUgb2YgdGhlIG9iamVjdCBzY2hlbWEuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHNjaGVtYSBpcyBub3QgYSBab2QgdjMgb3IgdjQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBnZXRJbnRlcm9wWm9kT2JqZWN0U2hhcGUoc2NoZW1hKSB7XG4gICAgaWYgKGlzWm9kU2NoZW1hVjMoc2NoZW1hKSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLnNoYXBlO1xuICAgIH1cbiAgICBpZiAoaXNab2RTY2hlbWFWNChzY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuX3pvZC5kZWYuc2hhcGU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlNjaGVtYSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIHozLlpvZE9iamVjdCBvciB6NC4kWm9kT2JqZWN0XCIpO1xufVxuLyoqXG4gKiBFeHRlbmRzIGEgWm9kIG9iamVjdCBzY2hlbWEgd2l0aCBhZGRpdGlvbmFsIGZpZWxkcywgc3VwcG9ydGluZyBib3RoIFpvZCB2MyBhbmQgdjQuXG4gKlxuICogQHRlbXBsYXRlIFQgLSBUaGUgdHlwZSBvZiB0aGUgWm9kIG9iamVjdCBzY2hlbWEuXG4gKiBAcGFyYW0ge1R9IHNjaGVtYSAtIFRoZSBab2Qgb2JqZWN0IHNjaGVtYSBpbnN0YW5jZSAoZWl0aGVyIHYzIG9yIHY0KS5cbiAqIEBwYXJhbSB7SW50ZXJvcFpvZE9iamVjdFNoYXBlfSBleHRlbnNpb24gLSBUaGUgZmllbGRzIHRvIGFkZCB0byB0aGUgc2NoZW1hLlxuICogQHJldHVybnMge0ludGVyb3Bab2RPYmplY3R9IFRoZSBleHRlbmRlZCBab2Qgb2JqZWN0IHNjaGVtYS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc2NoZW1hIGlzIG5vdCBhIFpvZCB2MyBvciB2NCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZEludGVyb3Bab2RPYmplY3Qoc2NoZW1hLCBleHRlbnNpb24pIHtcbiAgICBpZiAoaXNab2RTY2hlbWFWMyhzY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuZXh0ZW5kKGV4dGVuc2lvbik7XG4gICAgfVxuICAgIGlmIChpc1pvZFNjaGVtYVY0KHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIGNvcmVfMS51dGlsLmV4dGVuZChzY2hlbWEsIGV4dGVuc2lvbik7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlNjaGVtYSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIHozLlpvZE9iamVjdCBvciB6NC4kWm9kT2JqZWN0XCIpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgcGFydGlhbCB2ZXJzaW9uIG9mIGEgWm9kIG9iamVjdCBzY2hlbWEsIG1ha2luZyBhbGwgZmllbGRzIG9wdGlvbmFsLlxuICogU3VwcG9ydHMgYm90aCBab2QgdjMgYW5kIHY0LlxuICpcbiAqIEB0ZW1wbGF0ZSBUIC0gVGhlIHR5cGUgb2YgdGhlIFpvZCBvYmplY3Qgc2NoZW1hLlxuICogQHBhcmFtIHtUfSBzY2hlbWEgLSBUaGUgWm9kIG9iamVjdCBzY2hlbWEgaW5zdGFuY2UgKGVpdGhlciB2MyBvciB2NCkuXG4gKiBAcmV0dXJucyB7SW50ZXJvcFpvZE9iamVjdH0gVGhlIHBhcnRpYWwgWm9kIG9iamVjdCBzY2hlbWEuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHNjaGVtYSBpcyBub3QgYSBab2QgdjMgb3IgdjQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpbnRlcm9wWm9kT2JqZWN0UGFydGlhbChzY2hlbWEpIHtcbiAgICBpZiAoaXNab2RTY2hlbWFWMyhzY2hlbWEpKSB7XG4gICAgICAgIC8vIHozOiAucGFydGlhbCgpIGV4aXN0cyBhbmQgd29ya3MgYXMgZXhwZWN0ZWRcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5wYXJ0aWFsKCk7XG4gICAgfVxuICAgIGlmIChpc1pvZFNjaGVtYVY0KHNjaGVtYSkpIHtcbiAgICAgICAgLy8gejQ6IHV0aWwucGFydGlhbCBleGlzdHMgYW5kIHdvcmtzIGFzIGV4cGVjdGVkXG4gICAgICAgIHJldHVybiBjb3JlXzEudXRpbC5wYXJ0aWFsKGNvcmVfMS4kWm9kT3B0aW9uYWwsIHNjaGVtYSwgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2NoZW1hIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgejMuWm9kT2JqZWN0IG9yIHo0LiRab2RPYmplY3RcIik7XG59XG4vKipcbiAqIFJldHVybnMgYSBzdHJpY3QgdmVyc2lvbiBvZiBhIFpvZCBvYmplY3Qgc2NoZW1hLCBkaXNhbGxvd2luZyB1bmtub3duIGtleXMuXG4gKiBTdXBwb3J0cyBib3RoIFpvZCB2MyBhbmQgdjQgb2JqZWN0IHNjaGVtYXMuIElmIGByZWN1cnNpdmVgIGlzIHRydWUsIGFwcGxpZXMgc3RyaWN0bmVzc1xuICogcmVjdXJzaXZlbHkgdG8gYWxsIG5lc3RlZCBvYmplY3Qgc2NoZW1hcyBhbmQgYXJyYXlzIG9mIG9iamVjdCBzY2hlbWFzLlxuICpcbiAqIEB0ZW1wbGF0ZSBUIC0gVGhlIHR5cGUgb2YgdGhlIFpvZCBvYmplY3Qgc2NoZW1hLlxuICogQHBhcmFtIHtUfSBzY2hlbWEgLSBUaGUgWm9kIG9iamVjdCBzY2hlbWEgaW5zdGFuY2UgKGVpdGhlciB2MyBvciB2NCkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWN1cnNpdmU9ZmFsc2VdIC0gV2hldGhlciB0byBhcHBseSBzdHJpY3RuZXNzIHJlY3Vyc2l2ZWx5IHRvIG5lc3RlZCBvYmplY3RzL2FycmF5cy5cbiAqIEByZXR1cm5zIHtJbnRlcm9wWm9kT2JqZWN0fSBUaGUgc3RyaWN0IFpvZCBvYmplY3Qgc2NoZW1hLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBzY2hlbWEgaXMgbm90IGEgWm9kIHYzIG9yIHY0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaW50ZXJvcFpvZE9iamVjdFN0cmljdChzY2hlbWEsIHJlY3Vyc2l2ZSA9IGZhbHNlKSB7XG4gICAgaWYgKGlzWm9kU2NoZW1hVjMoc2NoZW1hKSkge1xuICAgICAgICAvLyBUT0RPOiB2MyBzY2hlbWFzIGFyZW4ndCByZWN1cnNpdmVseSBoYW5kbGVkIGhlcmVcbiAgICAgICAgLy8gKGN1cnJlbnRseSBub3QgbmVjZXNzYXJ5IHNpbmNlIHpvZFRvSnNvblNjaGVtYSBoYW5kbGVzIHRoaXMpXG4gICAgICAgIHJldHVybiBzY2hlbWEuc3RyaWN0KCk7XG4gICAgfVxuICAgIGlmIChpc1pvZE9iamVjdFY0KHNjaGVtYSkpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBzY2hlbWEuX3pvZC5kZWYuc2hhcGU7XG4gICAgICAgIGlmIChyZWN1cnNpdmUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwga2V5U2NoZW1hXSBvZiBPYmplY3QuZW50cmllcyhzY2hlbWEuX3pvZC5kZWYuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHNoYXBlIGtleSBpcyBhIHY0IG9iamVjdCBzY2hlbWEsIHdlIG5lZWQgdG8gbWFrZSBpdCBzdHJpY3RcbiAgICAgICAgICAgICAgICBpZiAoaXNab2RPYmplY3RWNChrZXlTY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dFNjaGVtYSA9IGludGVyb3Bab2RPYmplY3RTdHJpY3Qoa2V5U2NoZW1hLCByZWN1cnNpdmUpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRTaGFwZVtrZXldID0gb3V0cHV0U2NoZW1hO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc2hhcGUga2V5IGlzIGEgdjQgYXJyYXkgc2NoZW1hLCB3ZSBuZWVkIHRvIG1ha2UgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBzY2hlbWEgc3RyaWN0IGlmIGl0J3MgYW4gb2JqZWN0IHNjaGVtYVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzWm9kQXJyYXlWNChrZXlTY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbGVtZW50U2NoZW1hID0ga2V5U2NoZW1hLl96b2QuZGVmLmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1pvZE9iamVjdFY0KGVsZW1lbnRTY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50U2NoZW1hID0gaW50ZXJvcFpvZE9iamVjdFN0cmljdChlbGVtZW50U2NoZW1hLCByZWN1cnNpdmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFNoYXBlW2tleV0gPSAoMCwgY29yZV8xLmNsb25lKShrZXlTY2hlbWEsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmtleVNjaGVtYS5fem9kLmRlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRTY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGp1c3QgdXNlIHRoZSBrZXlTY2hlbWFcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0U2hhcGVba2V5XSA9IGtleVNjaGVtYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQXNzaWduIG1ldGEgZmllbGRzIHRvIHRoZSBrZXlTY2hlbWFcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhID0gY29yZV8xLmdsb2JhbFJlZ2lzdHJ5LmdldChrZXlTY2hlbWEpO1xuICAgICAgICAgICAgICAgIGlmIChtZXRhKVxuICAgICAgICAgICAgICAgICAgICBjb3JlXzEuZ2xvYmFsUmVnaXN0cnkuYWRkKG91dHB1dFNoYXBlW2tleV0sIG1ldGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkU2NoZW1hID0gKDAsIGNvcmVfMS5jbG9uZSkoc2NoZW1hLCB7XG4gICAgICAgICAgICAuLi5zY2hlbWEuX3pvZC5kZWYsXG4gICAgICAgICAgICBzaGFwZTogb3V0cHV0U2hhcGUsXG4gICAgICAgICAgICBjYXRjaGFsbDogKDAsIGNvcmVfMS5fbmV2ZXIpKGNvcmVfMS4kWm9kTmV2ZXIpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbWV0YSA9IGNvcmVfMS5nbG9iYWxSZWdpc3RyeS5nZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKG1ldGEpXG4gICAgICAgICAgICBjb3JlXzEuZ2xvYmFsUmVnaXN0cnkuYWRkKG1vZGlmaWVkU2NoZW1hLCBtZXRhKTtcbiAgICAgICAgcmV0dXJuIG1vZGlmaWVkU2NoZW1hO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTY2hlbWEgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiB6My5ab2RPYmplY3Qgb3IgejQuJFpvZE9iamVjdFwiKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHBhc3N0aHJvdWdoIHZlcnNpb24gb2YgYSBab2Qgb2JqZWN0IHNjaGVtYSwgYWxsb3dpbmcgdW5rbm93biBrZXlzLlxuICogU3VwcG9ydHMgYm90aCBab2QgdjMgYW5kIHY0IG9iamVjdCBzY2hlbWFzLiBJZiBgcmVjdXJzaXZlYCBpcyB0cnVlLCBhcHBsaWVzIHBhc3N0aHJvdWdoXG4gKiByZWN1cnNpdmVseSB0byBhbGwgbmVzdGVkIG9iamVjdCBzY2hlbWFzIGFuZCBhcnJheXMgb2Ygb2JqZWN0IHNjaGVtYXMuXG4gKlxuICogQHRlbXBsYXRlIFQgLSBUaGUgdHlwZSBvZiB0aGUgWm9kIG9iamVjdCBzY2hlbWEuXG4gKiBAcGFyYW0ge1R9IHNjaGVtYSAtIFRoZSBab2Qgb2JqZWN0IHNjaGVtYSBpbnN0YW5jZSAoZWl0aGVyIHYzIG9yIHY0KS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlY3Vyc2l2ZT1mYWxzZV0gLSBXaGV0aGVyIHRvIGFwcGx5IHBhc3N0aHJvdWdoIHJlY3Vyc2l2ZWx5IHRvIG5lc3RlZCBvYmplY3RzL2FycmF5cy5cbiAqIEByZXR1cm5zIHtJbnRlcm9wWm9kT2JqZWN0fSBUaGUgcGFzc3Rocm91Z2ggWm9kIG9iamVjdCBzY2hlbWEuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHNjaGVtYSBpcyBub3QgYSBab2QgdjMgb3IgdjQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpbnRlcm9wWm9kT2JqZWN0UGFzc3Rocm91Z2goc2NoZW1hLCByZWN1cnNpdmUgPSBmYWxzZSkge1xuICAgIGlmIChpc1pvZE9iamVjdFYzKHNjaGVtYSkpIHtcbiAgICAgICAgLy8gVE9ETzogdjMgc2NoZW1hcyBhcmVuJ3QgcmVjdXJzaXZlbHkgaGFuZGxlZCBoZXJlXG4gICAgICAgIC8vIChjdXJyZW50bHkgbm90IG5lY2Vzc2FyeSBzaW5jZSB6b2RUb0pzb25TY2hlbWEgaGFuZGxlcyB0aGlzKVxuICAgICAgICByZXR1cm4gc2NoZW1hLnBhc3N0aHJvdWdoKCk7XG4gICAgfVxuICAgIGlmIChpc1pvZE9iamVjdFY0KHNjaGVtYSkpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBzY2hlbWEuX3pvZC5kZWYuc2hhcGU7XG4gICAgICAgIGlmIChyZWN1cnNpdmUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwga2V5U2NoZW1hXSBvZiBPYmplY3QuZW50cmllcyhzY2hlbWEuX3pvZC5kZWYuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHNoYXBlIGtleSBpcyBhIHY0IG9iamVjdCBzY2hlbWEsIHdlIG5lZWQgdG8gbWFrZSBpdCBwYXNzdGhyb3VnaFxuICAgICAgICAgICAgICAgIGlmIChpc1pvZE9iamVjdFY0KGtleVNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0U2NoZW1hID0gaW50ZXJvcFpvZE9iamVjdFBhc3N0aHJvdWdoKGtleVNjaGVtYSwgcmVjdXJzaXZlKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0U2hhcGVba2V5XSA9IG91dHB1dFNjaGVtYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHNoYXBlIGtleSBpcyBhIHY0IGFycmF5IHNjaGVtYSwgd2UgbmVlZCB0byBtYWtlIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gc2NoZW1hIHBhc3N0aHJvdWdoIGlmIGl0J3MgYW4gb2JqZWN0IHNjaGVtYVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzWm9kQXJyYXlWNChrZXlTY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbGVtZW50U2NoZW1hID0ga2V5U2NoZW1hLl96b2QuZGVmLmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1pvZE9iamVjdFY0KGVsZW1lbnRTY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50U2NoZW1hID0gaW50ZXJvcFpvZE9iamVjdFBhc3N0aHJvdWdoKGVsZW1lbnRTY2hlbWEsIHJlY3Vyc2l2ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0U2hhcGVba2V5XSA9ICgwLCBjb3JlXzEuY2xvbmUpKGtleVNjaGVtYSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ua2V5U2NoZW1hLl96b2QuZGVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudFNjaGVtYSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwganVzdCB1c2UgdGhlIGtleVNjaGVtYVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRTaGFwZVtrZXldID0ga2V5U2NoZW1hO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBc3NpZ24gbWV0YSBmaWVsZHMgdG8gdGhlIGtleVNjaGVtYVxuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBjb3JlXzEuZ2xvYmFsUmVnaXN0cnkuZ2V0KGtleVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGEpXG4gICAgICAgICAgICAgICAgICAgIGNvcmVfMS5nbG9iYWxSZWdpc3RyeS5hZGQob3V0cHV0U2hhcGVba2V5XSwgbWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kaWZpZWRTY2hlbWEgPSAoMCwgY29yZV8xLmNsb25lKShzY2hlbWEsIHtcbiAgICAgICAgICAgIC4uLnNjaGVtYS5fem9kLmRlZixcbiAgICAgICAgICAgIHNoYXBlOiBvdXRwdXRTaGFwZSxcbiAgICAgICAgICAgIGNhdGNoYWxsOiAoMCwgY29yZV8xLl91bmtub3duKShjb3JlXzEuJFpvZFVua25vd24pLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbWV0YSA9IGNvcmVfMS5nbG9iYWxSZWdpc3RyeS5nZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKG1ldGEpXG4gICAgICAgICAgICBjb3JlXzEuZ2xvYmFsUmVnaXN0cnkuYWRkKG1vZGlmaWVkU2NoZW1hLCBtZXRhKTtcbiAgICAgICAgcmV0dXJuIG1vZGlmaWVkU2NoZW1hO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTY2hlbWEgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiB6My5ab2RPYmplY3Qgb3IgejQuJFpvZE9iamVjdFwiKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIGdldHRlciBmdW5jdGlvbiBmb3IgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBab2Qgc2NoZW1hLCBpZiBvbmUgaXMgZGVmaW5lZC5cbiAqIFN1cHBvcnRzIGJvdGggWm9kIHYzIGFuZCB2NCBzY2hlbWFzLiBJZiB0aGUgc2NoZW1hIGhhcyBhIGRlZmF1bHQgdmFsdWUsXG4gKiB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhhdCB2YWx1ZSB3aGVuIGNhbGxlZC4gSWYgbm8gZGVmYXVsdCBpcyBkZWZpbmVkLFxuICogcmV0dXJucyB1bmRlZmluZWQuXG4gKlxuICogQHRlbXBsYXRlIFQgLSBUaGUgdHlwZSBvZiB0aGUgWm9kIHNjaGVtYS5cbiAqIEBwYXJhbSB7VH0gc2NoZW1hIC0gVGhlIFpvZCBzY2hlbWEgaW5zdGFuY2UgKGVpdGhlciB2MyBvciB2NCkuXG4gKiBAcmV0dXJucyB7KCgpID0+IEluZmVySW50ZXJvcFpvZE91dHB1dDxUPikgfCB1bmRlZmluZWR9IEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlLCBvciB1bmRlZmluZWQgaWYgbm8gZGVmYXVsdCBpcyBzZXQuXG4gKi9cbmZ1bmN0aW9uIGdldEludGVyb3Bab2REZWZhdWx0R2V0dGVyKHNjaGVtYSkge1xuICAgIGlmIChpc1pvZFNjaGVtYVYzKHNjaGVtYSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHNjaGVtYS5wYXJzZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc1pvZFNjaGVtYVY0KHNjaGVtYSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9ICgwLCBjb3JlXzEucGFyc2UpKHNjaGVtYSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNab2RUcmFuc2Zvcm1WMyhzY2hlbWEpIHtcbiAgICByZXR1cm4gKGlzWm9kU2NoZW1hVjMoc2NoZW1hKSAmJlxuICAgICAgICBcInR5cGVOYW1lXCIgaW4gc2NoZW1hLl9kZWYgJiZcbiAgICAgICAgc2NoZW1hLl9kZWYudHlwZU5hbWUgPT09IFwiWm9kRWZmZWN0c1wiKTtcbn1cbmZ1bmN0aW9uIGlzWm9kVHJhbnNmb3JtVjQoc2NoZW1hKSB7XG4gICAgcmV0dXJuIGlzWm9kU2NoZW1hVjQoc2NoZW1hKSAmJiBzY2hlbWEuX3pvZC5kZWYudHlwZSA9PT0gXCJwaXBlXCI7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGlucHV0IHR5cGUgb2YgYSBab2QgdHJhbnNmb3JtIHNjaGVtYSwgZm9yIGJvdGggdjMgYW5kIHY0LlxuICogSWYgdGhlIHNjaGVtYSBpcyBub3QgYSB0cmFuc2Zvcm0sIHJldHVybnMgdW5kZWZpbmVkLiBJZiBgcmVjdXJzaXZlYCBpcyB0cnVlLFxuICogcmVjdXJzaXZlbHkgcHJvY2Vzc2VzIG5lc3RlZCBvYmplY3Qgc2NoZW1hcyBhbmQgYXJyYXlzIG9mIG9iamVjdCBzY2hlbWFzLlxuICpcbiAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgWm9kIHNjaGVtYSBpbnN0YW5jZSAodjMgb3IgdjQpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWN1cnNpdmU9ZmFsc2VdIC0gV2hldGhlciB0byByZWN1cnNpdmVseSBwcm9jZXNzIG5lc3RlZCBvYmplY3RzL2FycmF5cy5cbiAqIEByZXR1cm5zIFRoZSBpbnB1dCBab2Qgc2NoZW1hIG9mIHRoZSB0cmFuc2Zvcm0sIG9yIHVuZGVmaW5lZCBpZiBub3QgYSB0cmFuc2Zvcm1cbiAqL1xuZnVuY3Rpb24gaW50ZXJvcFpvZFRyYW5zZm9ybUlucHV0U2NoZW1hKHNjaGVtYSwgcmVjdXJzaXZlID0gZmFsc2UpIHtcbiAgICAvLyBab2QgdjM6IC5fZGVmLnNjaGVtYSBpcyB0aGUgaW5wdXQgc2NoZW1hIGZvciBab2RFZmZlY3RzICh0cmFuc2Zvcm0pXG4gICAgaWYgKGlzWm9kU2NoZW1hVjMoc2NoZW1hKSkge1xuICAgICAgICBpZiAoaXNab2RUcmFuc2Zvcm1WMyhzY2hlbWEpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJvcFpvZFRyYW5zZm9ybUlucHV0U2NoZW1hKHNjaGVtYS5fZGVmLnNjaGVtYSwgcmVjdXJzaXZlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiB2MyBzY2hlbWFzIGFyZW4ndCByZWN1cnNpdmVseSBoYW5kbGVkIGhlcmVcbiAgICAgICAgLy8gKGN1cnJlbnRseSBub3QgbmVjZXNzYXJ5IHNpbmNlIHpvZFRvSnNvblNjaGVtYSBoYW5kbGVzIHRoaXMpXG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuICAgIC8vIFpvZCB2NDogX2RlZi50eXBlIGlzIHRoZSBpbnB1dCBzY2hlbWEgZm9yIFpvZEVmZmVjdHMgKHRyYW5zZm9ybSlcbiAgICBpZiAoaXNab2RTY2hlbWFWNChzY2hlbWEpKSB7XG4gICAgICAgIGxldCBvdXRwdXRTY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIGlmIChpc1pvZFRyYW5zZm9ybVY0KHNjaGVtYSkpIHtcbiAgICAgICAgICAgIG91dHB1dFNjaGVtYSA9IGludGVyb3Bab2RUcmFuc2Zvcm1JbnB1dFNjaGVtYShzY2hlbWEuX3pvZC5kZWYuaW4sIHJlY3Vyc2l2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIG5lc3RlZCBvYmplY3Qgc2NoZW1hc1xuICAgICAgICAgICAgaWYgKGlzWm9kT2JqZWN0VjQob3V0cHV0U2NoZW1hKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gb3V0cHV0U2NoZW1hLl96b2QuZGVmLnNoYXBlO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwga2V5U2NoZW1hXSBvZiBPYmplY3QuZW50cmllcyhvdXRwdXRTY2hlbWEuX3pvZC5kZWYuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFNoYXBlW2tleV0gPSBpbnRlcm9wWm9kVHJhbnNmb3JtSW5wdXRTY2hlbWEoa2V5U2NoZW1hLCByZWN1cnNpdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXRTY2hlbWEgPSAoMCwgY29yZV8xLmNsb25lKShvdXRwdXRTY2hlbWEsIHtcbiAgICAgICAgICAgICAgICAgICAgLi4ub3V0cHV0U2NoZW1hLl96b2QuZGVmLFxuICAgICAgICAgICAgICAgICAgICBzaGFwZTogb3V0cHV0U2hhcGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIYW5kbGUgbmVzdGVkIGFycmF5IHNjaGVtYXNcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzWm9kQXJyYXlWNChvdXRwdXRTY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudFNjaGVtYSA9IGludGVyb3Bab2RUcmFuc2Zvcm1JbnB1dFNjaGVtYShvdXRwdXRTY2hlbWEuX3pvZC5kZWYuZWxlbWVudCwgcmVjdXJzaXZlKTtcbiAgICAgICAgICAgICAgICBvdXRwdXRTY2hlbWEgPSAoMCwgY29yZV8xLmNsb25lKShvdXRwdXRTY2hlbWEsIHtcbiAgICAgICAgICAgICAgICAgICAgLi4ub3V0cHV0U2NoZW1hLl96b2QuZGVmLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50U2NoZW1hLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSBjb3JlXzEuZ2xvYmFsUmVnaXN0cnkuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGlmIChtZXRhKVxuICAgICAgICAgICAgY29yZV8xLmdsb2JhbFJlZ2lzdHJ5LmFkZChvdXRwdXRTY2hlbWEsIG1ldGEpO1xuICAgICAgICByZXR1cm4gb3V0cHV0U2NoZW1hO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTY2hlbWEgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiB6My5ab2RUeXBlIG9yIHo0LiRab2RUeXBlXCIpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/documents.cjs":
/*!****************************************************!*\
  !*** ./node_modules/@langchain/core/documents.cjs ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/documents/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/documents/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2RvY3VtZW50cy5janMiLCJtYXBwaW5ncyI6IkFBQUEsdUlBQXNEIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2RvY3VtZW50cy5janMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvZG9jdW1lbnRzL2luZGV4LmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/documents.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/embeddings.cjs":
/*!*****************************************************!*\
  !*** ./node_modules/@langchain/core/embeddings.cjs ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/embeddings.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/embeddings.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2VtYmVkZGluZ3MuY2pzIiwibWFwcGluZ3MiOiJBQUFBLDZIQUFpRCIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9lbWJlZGRpbmdzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9lbWJlZGRpbmdzLmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/embeddings.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/language_models/base.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/language_models/base.cjs ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/language_models/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/language_models/base.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2xhbmd1YWdlX21vZGVscy9iYXNlLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSxrSkFBNEQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbGFuZ3VhZ2VfbW9kZWxzL2Jhc2UuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vZGlzdC9sYW5ndWFnZV9tb2RlbHMvYmFzZS5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/language_models/base.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/language_models/chat_models.cjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@langchain/core/language_models/chat_models.cjs ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/language_models/chat_models.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/language_models/chat_models.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2xhbmd1YWdlX21vZGVscy9jaGF0X21vZGVscy5janMiLCJtYXBwaW5ncyI6IkFBQUEsZ0tBQW1FIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2xhbmd1YWdlX21vZGVscy9jaGF0X21vZGVscy5janMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9kaXN0L2xhbmd1YWdlX21vZGVscy9jaGF0X21vZGVscy5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/language_models/chat_models.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/language_models/llms.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/language_models/llms.cjs ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/language_models/llms.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/language_models/llms.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2xhbmd1YWdlX21vZGVscy9sbG1zLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSxrSkFBNEQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbGFuZ3VhZ2VfbW9kZWxzL2xsbXMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vZGlzdC9sYW5ndWFnZV9tb2RlbHMvbGxtcy5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/language_models/llms.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/load/serializable.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/load/serializable.cjs ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/load/serializable.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2xvYWQvc2VyaWFsaXphYmxlLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSw0SUFBeUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbG9hZC9zZXJpYWxpemFibGUuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vZGlzdC9sb2FkL3NlcmlhbGl6YWJsZS5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/load/serializable.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/messages.cjs":
/*!***************************************************!*\
  !*** ./node_modules/@langchain/core/messages.cjs ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/messages/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL21lc3NhZ2VzLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSxxSUFBcUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbWVzc2FnZXMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L21lc3NhZ2VzL2luZGV4LmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/messages.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAX: () => (/* reexport safe */ _max_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   NIL: () => (/* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   parse: () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   stringify: () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   v1: () => (/* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   v1ToV6: () => (/* reexport safe */ _v1ToV6_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   v3: () => (/* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   v4: () => (/* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   v5: () => (/* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   v6: () => (/* reexport safe */ _v6_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]),\n/* harmony export */   v6ToV1: () => (/* reexport safe */ _v6ToV1_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]),\n/* harmony export */   v7: () => (/* reexport safe */ _v7_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"]),\n/* harmony export */   validate: () => (/* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"]),\n/* harmony export */   version: () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _max_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./max.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/max.js\");\n/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nil.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/nil.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/parse.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./v1.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v1.js\");\n/* harmony import */ var _v1ToV6_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./v1ToV6.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v1ToV6.js\");\n/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./v3.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v3.js\");\n/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./v4.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./v5.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v5.js\");\n/* harmony import */ var _v6_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./v6.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v6.js\");\n/* harmony import */ var _v6ToV1_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./v6ToV1.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v6ToV1.js\");\n/* harmony import */ var _v7_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./v7.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v7.js\");\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/validate.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./version.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/version.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQztBQUNBO0FBQ0k7QUFDUTtBQUNkO0FBQ1E7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNRO0FBQ1I7QUFDWSIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGRlZmF1bHQgYXMgTUFYIH0gZnJvbSAnLi9tYXguanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBOSUwgfSBmcm9tICcuL25pbC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHBhcnNlIH0gZnJvbSAnLi9wYXJzZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjEgfSBmcm9tICcuL3YxLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjFUb1Y2IH0gZnJvbSAnLi92MVRvVjYuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2MyB9IGZyb20gJy4vdjMuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2NCB9IGZyb20gJy4vdjQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2NSB9IGZyb20gJy4vdjUuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2NiB9IGZyb20gJy4vdjYuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2NlRvVjEgfSBmcm9tICcuL3Y2VG9WMS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY3IH0gZnJvbSAnLi92Ny5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHZhbGlkYXRlIH0gZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24uanMnOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/max.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/max.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('ffffffff-ffff-ffff-ffff-ffffffffffff');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbWF4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxzQ0FBc0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9tYXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgJ2ZmZmZmZmZmLWZmZmYtZmZmZi1mZmZmLWZmZmZmZmZmZmZmZic7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/max.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/md5.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/md5.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n  return node_crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('md5').update(bytes).digest();\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbWQ1LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFNBQVMsNkRBQWlCO0FBQzFCO0FBQ0EsaUVBQWUsR0FBRyIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL21kNS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3J5cHRvIGZyb20gJ25vZGU6Y3J5cHRvJztcbmZ1bmN0aW9uIG1kNShieXRlcykge1xuICBpZiAoQXJyYXkuaXNBcnJheShieXRlcykpIHtcbiAgICBieXRlcyA9IEJ1ZmZlci5mcm9tKGJ5dGVzKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgYnl0ZXMgPSBCdWZmZXIuZnJvbShieXRlcywgJ3V0ZjgnKTtcbiAgfVxuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ21kNScpLnVwZGF0ZShieXRlcykuZGlnZXN0KCk7XG59XG5leHBvcnQgZGVmYXVsdCBtZDU7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/md5.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/native.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/native.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  randomUUID: (node_crypto__WEBPACK_IMPORTED_MODULE_0___default().randomUUID)\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmF0aXZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNqQyxpRUFBZTtBQUNmLGNBQWMsK0RBQWlCO0FBQy9CLENBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9uYXRpdmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdub2RlOmNyeXB0byc7XG5leHBvcnQgZGVmYXVsdCB7XG4gIHJhbmRvbVVVSUQ6IGNyeXB0by5yYW5kb21VVUlEXG59OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/native.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/nil.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/nil.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('00000000-0000-0000-0000-000000000000');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxzQ0FBc0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9uaWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCc7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/nil.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/parse.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/parse.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/validate.js\");\n\nfunction parse(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n  let v;\n  const arr = new Uint8Array(16);\n\n  // Parse ########-....-....-....-............\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff;\n\n  // Parse ........-####-....-....-............\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff;\n\n  // Parse ........-....-####-....-............\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff;\n\n  // Parse ........-....-....-####-............\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff;\n\n  // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcGFyc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUM7QUFDckM7QUFDQSxPQUFPLHdEQUFRO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLEtBQUsiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9wYXJzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5mdW5jdGlvbiBwYXJzZSh1dWlkKSB7XG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG4gIGxldCB2O1xuICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSgxNik7XG5cbiAgLy8gUGFyc2UgIyMjIyMjIyMtLi4uLi0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG4gIGFyclswXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgwLCA4KSwgMTYpKSA+Pj4gMjQ7XG4gIGFyclsxXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzJdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclszXSA9IHYgJiAweGZmO1xuXG4gIC8vIFBhcnNlIC4uLi4uLi4uLSMjIyMtLi4uLi0uLi4uLS4uLi4uLi4uLi4uLlxuICBhcnJbNF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoOSwgMTMpLCAxNikpID4+PiA4O1xuICBhcnJbNV0gPSB2ICYgMHhmZjtcblxuICAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLSMjIyMtLi4uLi0uLi4uLi4uLi4uLi5cbiAgYXJyWzZdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE0LCAxOCksIDE2KSkgPj4+IDg7XG4gIGFycls3XSA9IHYgJiAweGZmO1xuXG4gIC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tLi4uLi0jIyMjLS4uLi4uLi4uLi4uLlxuICBhcnJbOF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTksIDIzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzldID0gdiAmIDB4ZmY7XG5cbiAgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLS4uLi4tIyMjIyMjIyMjIyMjXG4gIC8vIChVc2UgXCIvXCIgdG8gYXZvaWQgMzItYml0IHRydW5jYXRpb24gd2hlbiBiaXQtc2hpZnRpbmcgaGlnaC1vcmRlciBieXRlcylcbiAgYXJyWzEwXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgyNCwgMzYpLCAxNikpIC8gMHgxMDAwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMV0gPSB2IC8gMHgxMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTJdID0gdiA+Pj4gMjQgJiAweGZmO1xuICBhcnJbMTNdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMTRdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclsxNV0gPSB2ICYgMHhmZjtcbiAgcmV0dXJuIGFycjtcbn1cbmV4cG9ydCBkZWZhdWx0IHBhcnNlOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/parse.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/regex.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/regex.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcmVnZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWMsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLFVBQVUsR0FBRyw4RUFBOEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9yZWdleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLThdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMHxmZmZmZmZmZi1mZmZmLWZmZmYtZmZmZi1mZmZmZmZmZmZmZmYpJC9pOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/regex.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/rng.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/rng.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\nlet poolPtr = rnds8Pool.length;\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    node_crypto__WEBPACK_IMPORTED_MODULE_0___default().randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcm5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNqQyx1Q0FBdUM7QUFDdkM7QUFDZTtBQUNmO0FBQ0EsSUFBSSxpRUFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9ybmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdub2RlOmNyeXB0byc7XG5jb25zdCBybmRzOFBvb2wgPSBuZXcgVWludDhBcnJheSgyNTYpOyAvLyAjIG9mIHJhbmRvbSB2YWx1ZXMgdG8gcHJlLWFsbG9jYXRlXG5sZXQgcG9vbFB0ciA9IHJuZHM4UG9vbC5sZW5ndGg7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBybmcoKSB7XG4gIGlmIChwb29sUHRyID4gcm5kczhQb29sLmxlbmd0aCAtIDE2KSB7XG4gICAgY3J5cHRvLnJhbmRvbUZpbGxTeW5jKHJuZHM4UG9vbCk7XG4gICAgcG9vbFB0ciA9IDA7XG4gIH1cbiAgcmV0dXJuIHJuZHM4UG9vbC5zbGljZShwb29sUHRyLCBwb29sUHRyICs9IDE2KTtcbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/rng.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/sha1.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/sha1.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n  return node_crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('sha1').update(bytes).digest();\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc2hhMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxTQUFTLDZEQUFpQjtBQUMxQjtBQUNBLGlFQUFlLElBQUkiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9zaGExLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnbm9kZTpjcnlwdG8nO1xuZnVuY3Rpb24gc2hhMShieXRlcykge1xuICBpZiAoQXJyYXkuaXNBcnJheShieXRlcykpIHtcbiAgICBieXRlcyA9IEJ1ZmZlci5mcm9tKGJ5dGVzKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgYnl0ZXMgPSBCdWZmZXIuZnJvbShieXRlcywgJ3V0ZjgnKTtcbiAgfVxuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoYnl0ZXMpLmRpZ2VzdCgpO1xufVxuZXhwb3J0IGRlZmF1bHQgc2hhMTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/sha1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/validate.js\");\n\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  //\n  // Note to future-self: No, you can't remove the `toLowerCase()` call.\n  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset);\n  // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n  return uuid;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc3RyaW5naWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHdEQUFRO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxTQUFTIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc3RyaW5naWZ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG5jb25zdCBieXRlVG9IZXggPSBbXTtcbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnNsaWNlKDEpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1bnNhZmVTdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XG4gIC8vIE5vdGU6IEJlIGNhcmVmdWwgZWRpdGluZyB0aGlzIGNvZGUhICBJdCdzIGJlZW4gdHVuZWQgZm9yIHBlcmZvcm1hbmNlXG4gIC8vIGFuZCB3b3JrcyBpbiB3YXlzIHlvdSBtYXkgbm90IGV4cGVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzQzNFxuICAvL1xuICAvLyBOb3RlIHRvIGZ1dHVyZS1zZWxmOiBObywgeW91IGNhbid0IHJlbW92ZSB0aGUgYHRvTG93ZXJDYXNlKClgIGNhbGwuXG4gIC8vIFJFRjogaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNjc3I2lzc3VlY29tbWVudC0xNzU3MzUxMzUxXG4gIHJldHVybiAoYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV0pLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XG4gIGNvbnN0IHV1aWQgPSB1bnNhZmVTdHJpbmdpZnkoYXJyLCBvZmZzZXQpO1xuICAvLyBDb25zaXN0ZW5jeSBjaGVjayBmb3IgdmFsaWQgVVVJRC4gIElmIHRoaXMgdGhyb3dzLCBpdCdzIGxpa2VseSBkdWUgdG8gb25lXG4gIC8vIG9mIHRoZSBmb2xsb3dpbmc6XG4gIC8vIC0gT25lIG9yIG1vcmUgaW5wdXQgYXJyYXkgdmFsdWVzIGRvbid0IG1hcCB0byBhIGhleCBvY3RldCAobGVhZGluZyB0b1xuICAvLyBcInVuZGVmaW5lZFwiIGluIHRoZSB1dWlkKVxuICAvLyAtIEludmFsaWQgaW5wdXQgdmFsdWVzIGZvciB0aGUgUkZDIGB2ZXJzaW9uYCBvciBgdmFyaWFudGAgZmllbGRzXG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG4gIHJldHVybiB1dWlkO1xufVxuZXhwb3J0IGRlZmF1bHQgc3RyaW5naWZ5OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v1.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v1.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nlet _nodeId;\nlet _clockseq;\n\n// Previous uuid creation time\nlet _lastMSecs = 0;\nlet _lastNSecs = 0;\n\n// See https://github.com/uuidjs/uuid for API details\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node;\n  let clockseq = options.clockseq;\n\n  // v1 only: Use cached `node` and `clockseq` values\n  if (!options._v6) {\n    if (!node) {\n      node = _nodeId;\n    }\n    if (clockseq == null) {\n      clockseq = _clockseq;\n    }\n  }\n\n  // Handle cases where we need entropy.  We do this lazily to minimize issues\n  // related to insufficient system entropy.  See #189\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n    // Randomize node\n    if (node == null) {\n      node = [seedBytes[0], seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n\n      // v1 only: cache node value for reuse\n      if (!_nodeId && !options._v6) {\n        // per RFC4122 4.5: Set MAC multicast bit (v1 only)\n        node[0] |= 0x01; // Set multicast bit\n\n        _nodeId = node;\n      }\n    }\n\n    // Randomize clockseq\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n      if (_clockseq === undefined && !options._v6) {\n        _clockseq = clockseq;\n      }\n    }\n  }\n\n  // v1 & v6 timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so time is\n  // handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(b);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ3NCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELCtDQUFHOztBQUUzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0EsZ0JBQWdCLDhEQUFlO0FBQy9CO0FBQ0EsaUVBQWUsRUFBRSIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3YxLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuXG4vLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4vL1xuLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbi8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbmxldCBfbm9kZUlkO1xubGV0IF9jbG9ja3NlcTtcblxuLy8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG5sZXQgX2xhc3RNU2VjcyA9IDA7XG5sZXQgX2xhc3ROU2VjcyA9IDA7XG5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQgZm9yIEFQSSBkZXRhaWxzXG5mdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBsZXQgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgY29uc3QgYiA9IGJ1ZiB8fCBuZXcgQXJyYXkoMTYpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGV0IG5vZGUgPSBvcHRpb25zLm5vZGU7XG4gIGxldCBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXE7XG5cbiAgLy8gdjEgb25seTogVXNlIGNhY2hlZCBgbm9kZWAgYW5kIGBjbG9ja3NlcWAgdmFsdWVzXG4gIGlmICghb3B0aW9ucy5fdjYpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIG5vZGUgPSBfbm9kZUlkO1xuICAgIH1cbiAgICBpZiAoY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgICAgY2xvY2tzZXEgPSBfY2xvY2tzZXE7XG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIGNhc2VzIHdoZXJlIHdlIG5lZWQgZW50cm9weS4gIFdlIGRvIHRoaXMgbGF6aWx5IHRvIG1pbmltaXplIGlzc3Vlc1xuICAvLyByZWxhdGVkIHRvIGluc3VmZmljaWVudCBzeXN0ZW0gZW50cm9weS4gIFNlZSAjMTg5XG4gIGlmIChub2RlID09IG51bGwgfHwgY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgIGNvbnN0IHNlZWRCeXRlcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgICAvLyBSYW5kb21pemUgbm9kZVxuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIG5vZGUgPSBbc2VlZEJ5dGVzWzBdLCBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XV07XG5cbiAgICAgIC8vIHYxIG9ubHk6IGNhY2hlIG5vZGUgdmFsdWUgZm9yIHJldXNlXG4gICAgICBpZiAoIV9ub2RlSWQgJiYgIW9wdGlvbnMuX3Y2KSB7XG4gICAgICAgIC8vIHBlciBSRkM0MTIyIDQuNTogU2V0IE1BQyBtdWx0aWNhc3QgYml0ICh2MSBvbmx5KVxuICAgICAgICBub2RlWzBdIHw9IDB4MDE7IC8vIFNldCBtdWx0aWNhc3QgYml0XG5cbiAgICAgICAgX25vZGVJZCA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmFuZG9taXplIGNsb2Nrc2VxXG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgICBpZiAoX2Nsb2Nrc2VxID09PSB1bmRlZmluZWQgJiYgIW9wdGlvbnMuX3Y2KSB7XG4gICAgICAgIF9jbG9ja3NlcSA9IGNsb2Nrc2VxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHYxICYgdjYgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvIHRpbWUgaXNcbiAgLy8gaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuICBsZXQgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1zZWNzIDogRGF0ZS5ub3coKTtcblxuICAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG4gIGxldCBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTtcblxuICAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG4gIGNvbnN0IGR0ID0gbXNlY3MgLSBfbGFzdE1TZWNzICsgKG5zZWNzIC0gX2xhc3ROU2VjcykgLyAxMDAwMDtcblxuICAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG4gIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gIH1cblxuICAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAvLyB0aW1lIGludGVydmFsXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9XG5cbiAgLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1dWlkLnYxKCk6IENhbid0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlY1wiKTtcbiAgfVxuICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7XG5cbiAgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG4gIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwO1xuXG4gIC8vIGB0aW1lX2xvd2BcbiAgY29uc3QgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XG4gIGJbaSsrXSA9IHRsID4+PiAyNCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdGwgJiAweGZmO1xuXG4gIC8vIGB0aW1lX21pZGBcbiAgY29uc3QgdG1oID0gbXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwICYgMHhmZmZmZmZmO1xuICBiW2krK10gPSB0bWggPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bWggJiAweGZmO1xuXG4gIC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMjQgJiAweGYgfCAweDEwOyAvLyBpbmNsdWRlIHZlcnNpb25cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7XG5cbiAgLy8gYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgIChQZXIgNC4yLjIgLSBpbmNsdWRlIHZhcmlhbnQpXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDtcblxuICAvLyBgY2xvY2tfc2VxX2xvd2BcbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmO1xuXG4gIC8vIGBub2RlYFxuICBmb3IgKGxldCBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuICByZXR1cm4gYnVmIHx8IHVuc2FmZVN0cmluZ2lmeShiKTtcbn1cbmV4cG9ydCBkZWZhdWx0IHYxOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v1ToV6.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v1ToV6.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ v1ToV6)\n/* harmony export */ });\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/parse.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n/**\n * Convert a v1 UUID to a v6 UUID\n *\n * @param {string|Uint8Array} uuid - The v1 UUID to convert to v6\n * @returns {string|Uint8Array} The v6 UUID as the same type as the `uuid` arg\n * (string or Uint8Array)\n */\nfunction v1ToV6(uuid) {\n  const v1Bytes = typeof uuid === 'string' ? (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid) : uuid;\n  const v6Bytes = _v1ToV6(v1Bytes);\n  return typeof uuid === 'string' ? (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(v6Bytes) : v6Bytes;\n}\n\n// Do the field transformation needed for v1 -> v6\nfunction _v1ToV6(v1Bytes, randomize = false) {\n  return Uint8Array.of((v1Bytes[6] & 0x0f) << 4 | v1Bytes[7] >> 4 & 0x0f, (v1Bytes[7] & 0x0f) << 4 | (v1Bytes[4] & 0xf0) >> 4, (v1Bytes[4] & 0x0f) << 4 | (v1Bytes[5] & 0xf0) >> 4, (v1Bytes[5] & 0x0f) << 4 | (v1Bytes[0] & 0xf0) >> 4, (v1Bytes[0] & 0x0f) << 4 | (v1Bytes[1] & 0xf0) >> 4, (v1Bytes[1] & 0x0f) << 4 | (v1Bytes[2] & 0xf0) >> 4, 0x60 | v1Bytes[2] & 0x0f, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjFUb1Y2LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQjtBQUNrQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNlO0FBQ2YsNkNBQTZDLHFEQUFLO0FBQ2xEO0FBQ0Esb0NBQW9DLDhEQUFlO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjFUb1Y2LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXJzZSBmcm9tICcuL3BhcnNlLmpzJztcbmltcG9ydCB7IHVuc2FmZVN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcblxuLyoqXG4gKiBDb252ZXJ0IGEgdjEgVVVJRCB0byBhIHY2IFVVSURcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xVaW50OEFycmF5fSB1dWlkIC0gVGhlIHYxIFVVSUQgdG8gY29udmVydCB0byB2NlxuICogQHJldHVybnMge3N0cmluZ3xVaW50OEFycmF5fSBUaGUgdjYgVVVJRCBhcyB0aGUgc2FtZSB0eXBlIGFzIHRoZSBgdXVpZGAgYXJnXG4gKiAoc3RyaW5nIG9yIFVpbnQ4QXJyYXkpXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHYxVG9WNih1dWlkKSB7XG4gIGNvbnN0IHYxQnl0ZXMgPSB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgPyBwYXJzZSh1dWlkKSA6IHV1aWQ7XG4gIGNvbnN0IHY2Qnl0ZXMgPSBfdjFUb1Y2KHYxQnl0ZXMpO1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnID8gdW5zYWZlU3RyaW5naWZ5KHY2Qnl0ZXMpIDogdjZCeXRlcztcbn1cblxuLy8gRG8gdGhlIGZpZWxkIHRyYW5zZm9ybWF0aW9uIG5lZWRlZCBmb3IgdjEgLT4gdjZcbmZ1bmN0aW9uIF92MVRvVjYodjFCeXRlcywgcmFuZG9taXplID0gZmFsc2UpIHtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkub2YoKHYxQnl0ZXNbNl0gJiAweDBmKSA8PCA0IHwgdjFCeXRlc1s3XSA+PiA0ICYgMHgwZiwgKHYxQnl0ZXNbN10gJiAweDBmKSA8PCA0IHwgKHYxQnl0ZXNbNF0gJiAweGYwKSA+PiA0LCAodjFCeXRlc1s0XSAmIDB4MGYpIDw8IDQgfCAodjFCeXRlc1s1XSAmIDB4ZjApID4+IDQsICh2MUJ5dGVzWzVdICYgMHgwZikgPDwgNCB8ICh2MUJ5dGVzWzBdICYgMHhmMCkgPj4gNCwgKHYxQnl0ZXNbMF0gJiAweDBmKSA8PCA0IHwgKHYxQnl0ZXNbMV0gJiAweGYwKSA+PiA0LCAodjFCeXRlc1sxXSAmIDB4MGYpIDw8IDQgfCAodjFCeXRlc1syXSAmIDB4ZjApID4+IDQsIDB4NjAgfCB2MUJ5dGVzWzJdICYgMHgwZiwgdjFCeXRlc1szXSwgdjFCeXRlc1s4XSwgdjFCeXRlc1s5XSwgdjFCeXRlc1sxMF0sIHYxQnl0ZXNbMTFdLCB2MUJ5dGVzWzEyXSwgdjFCeXRlc1sxM10sIHYxQnl0ZXNbMTRdLCB2MUJ5dGVzWzE1XSk7XG59Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v1ToV6.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v3.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v3.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/md5.js\");\n\n\nconst v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ0E7QUFDM0IsV0FBVyxtREFBRyxhQUFhLCtDQUFHO0FBQzlCLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92My5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdjM1IGZyb20gJy4vdjM1LmpzJztcbmltcG9ydCBtZDUgZnJvbSAnLi9tZDUuanMnO1xuY29uc3QgdjMgPSB2MzUoJ3YzJywgMHgzMCwgbWQ1KTtcbmV4cG9ydCBkZWZhdWx0IHYzOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v3.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v35.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v35.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DNS: () => (/* binding */ DNS),\n/* harmony export */   URL: () => (/* binding */ URL),\n/* harmony export */   \"default\": () => (/* binding */ v35)\n/* harmony export */ });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/parse.js\");\n\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n  return bytes;\n}\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nfunction v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var _namespace;\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n    if (typeof namespace === 'string') {\n      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(namespace);\n    }\n    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    }\n\n    // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n    if (buf) {\n      offset = offset || 0;\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n      return buf;\n    }\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(bytes);\n  }\n\n  // Function#name is not settable on some platforms (#270)\n  try {\n    generateUUID.name = name;\n  } catch (err) {}\n\n  // For CommonJS default export support\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjM1LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWlEO0FBQ2xCO0FBQy9CO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1E7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscURBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4REFBZTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92MzUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuaW1wb3J0IHBhcnNlIGZyb20gJy4vcGFyc2UuanMnO1xuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHIpIHtcbiAgc3RyID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpOyAvLyBVVEY4IGVzY2FwZVxuXG4gIGNvbnN0IGJ5dGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgYnl0ZXMucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuZXhwb3J0IGNvbnN0IEROUyA9ICc2YmE3YjgxMC05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0IGNvbnN0IFVSTCA9ICc2YmE3YjgxMS05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdjM1KG5hbWUsIHZlcnNpb24sIGhhc2hmdW5jKSB7XG4gIGZ1bmN0aW9uIGdlbmVyYXRlVVVJRCh2YWx1ZSwgbmFtZXNwYWNlLCBidWYsIG9mZnNldCkge1xuICAgIHZhciBfbmFtZXNwYWNlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWVzcGFjZSA9IHBhcnNlKG5hbWVzcGFjZSk7XG4gICAgfVxuICAgIGlmICgoKF9uYW1lc3BhY2UgPSBuYW1lc3BhY2UpID09PSBudWxsIHx8IF9uYW1lc3BhY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9uYW1lc3BhY2UubGVuZ3RoKSAhPT0gMTYpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignTmFtZXNwYWNlIG11c3QgYmUgYXJyYXktbGlrZSAoMTYgaXRlcmFibGUgaW50ZWdlciB2YWx1ZXMsIDAtMjU1KScpO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgaGFzaCBvZiBuYW1lc3BhY2UgYW5kIHZhbHVlLCBQZXIgNC4zXG4gICAgLy8gRnV0dXJlOiBVc2Ugc3ByZWFkIHN5bnRheCB3aGVuIHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zLCBlLmcuIGBieXRlcyA9XG4gICAgLy8gaGFzaGZ1bmMoWy4uLm5hbWVzcGFjZSwgLi4uIHZhbHVlXSlgXG4gICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTYgKyB2YWx1ZS5sZW5ndGgpO1xuICAgIGJ5dGVzLnNldChuYW1lc3BhY2UpO1xuICAgIGJ5dGVzLnNldCh2YWx1ZSwgbmFtZXNwYWNlLmxlbmd0aCk7XG4gICAgYnl0ZXMgPSBoYXNoZnVuYyhieXRlcyk7XG4gICAgYnl0ZXNbNl0gPSBieXRlc1s2XSAmIDB4MGYgfCB2ZXJzaW9uO1xuICAgIGJ5dGVzWzhdID0gYnl0ZXNbOF0gJiAweDNmIHwgMHg4MDtcbiAgICBpZiAoYnVmKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlc1tpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIHJldHVybiB1bnNhZmVTdHJpbmdpZnkoYnl0ZXMpO1xuICB9XG5cbiAgLy8gRnVuY3Rpb24jbmFtZSBpcyBub3Qgc2V0dGFibGUgb24gc29tZSBwbGF0Zm9ybXMgKCMyNzApXG4gIHRyeSB7XG4gICAgZ2VuZXJhdGVVVUlELm5hbWUgPSBuYW1lO1xuICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgLy8gRm9yIENvbW1vbkpTIGRlZmF1bHQgZXhwb3J0IHN1cHBvcnRcbiAgZ2VuZXJhdGVVVUlELkROUyA9IEROUztcbiAgZ2VuZXJhdGVVVUlELlVSTCA9IFVSTDtcbiAgcmV0dXJuIGdlbmVyYXRlVVVJRDtcbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v35.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v4.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v4.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n  if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n    return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n  }\n  options = options || {};\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    offset = offset || 0;\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n    return buf;\n  }\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpQztBQUNOO0FBQ3NCO0FBQ2pEO0FBQ0EsTUFBTSxrREFBTTtBQUNaLFdBQVcsa0RBQU07QUFDakI7QUFDQTtBQUNBLGlEQUFpRCwrQ0FBRzs7QUFFcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBZTtBQUN4QjtBQUNBLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92NC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbmF0aXZlIGZyb20gJy4vbmF0aXZlLmpzJztcbmltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgaWYgKG5hdGl2ZS5yYW5kb21VVUlEICYmICFidWYgJiYgIW9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmF0aXZlLnJhbmRvbVVVSUQoKTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3Qgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwO1xuXG4gIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICBpZiAoYnVmKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSBybmRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xuICB9XG4gIHJldHVybiB1bnNhZmVTdHJpbmdpZnkocm5kcyk7XG59XG5leHBvcnQgZGVmYXVsdCB2NDsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v4.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v5.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v5.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/sha1.js\");\n\n\nconst v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ0U7QUFDN0IsV0FBVyxtREFBRyxhQUFhLGdEQUFJO0FBQy9CLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92NS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdjM1IGZyb20gJy4vdjM1LmpzJztcbmltcG9ydCBzaGExIGZyb20gJy4vc2hhMS5qcyc7XG5jb25zdCB2NSA9IHYzNSgndjUnLCAweDUwLCBzaGExKTtcbmV4cG9ydCBkZWZhdWx0IHY1OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v5.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v6.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v6.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ v6)\n/* harmony export */ });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v1.js\");\n/* harmony import */ var _v1ToV6_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v1ToV6.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v1ToV6.js\");\n\n\n\n\n/**\n *\n * @param {object} options\n * @param {Uint8Array=} buf\n * @param {number=} offset\n * @returns\n */\nfunction v6(options = {}, buf, offset = 0) {\n  // v6 is v1 with different field layout, so we start with a v1 UUID, albeit\n  // with slightly different behavior around how the clock_seq and node fields\n  // are randomized, which is why we call v1 with _v6: true.\n  let bytes = (0,_v1_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    ...options,\n    _v6: true\n  }, new Uint8Array(16));\n\n  // Reorder the fields to v6 layout.\n  bytes = (0,_v1ToV6_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(bytes);\n\n  // Return as a byte array if requested\n  if (buf) {\n    for (let i = 0; i < 16; i++) {\n      buf[offset + i] = bytes[i];\n    }\n    return buf;\n  }\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(bytes);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpRDtBQUN4QjtBQUNROztBQUVqQztBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsYUFBYTtBQUN4QixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxjQUFjLGtEQUFFO0FBQ2hCO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsVUFBVSxzREFBTTs7QUFFaEI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBZTtBQUN4QiIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3Y2LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVuc2FmZVN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmltcG9ydCB2MSBmcm9tICcuL3YxLmpzJztcbmltcG9ydCB2MVRvVjYgZnJvbSAnLi92MVRvVjYuanMnO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtVaW50OEFycmF5PX0gYnVmXG4gKiBAcGFyYW0ge251bWJlcj19IG9mZnNldFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdjYob3B0aW9ucyA9IHt9LCBidWYsIG9mZnNldCA9IDApIHtcbiAgLy8gdjYgaXMgdjEgd2l0aCBkaWZmZXJlbnQgZmllbGQgbGF5b3V0LCBzbyB3ZSBzdGFydCB3aXRoIGEgdjEgVVVJRCwgYWxiZWl0XG4gIC8vIHdpdGggc2xpZ2h0bHkgZGlmZmVyZW50IGJlaGF2aW9yIGFyb3VuZCBob3cgdGhlIGNsb2NrX3NlcSBhbmQgbm9kZSBmaWVsZHNcbiAgLy8gYXJlIHJhbmRvbWl6ZWQsIHdoaWNoIGlzIHdoeSB3ZSBjYWxsIHYxIHdpdGggX3Y2OiB0cnVlLlxuICBsZXQgYnl0ZXMgPSB2MSh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBfdjY6IHRydWVcbiAgfSwgbmV3IFVpbnQ4QXJyYXkoMTYpKTtcblxuICAvLyBSZW9yZGVyIHRoZSBmaWVsZHMgdG8gdjYgbGF5b3V0LlxuICBieXRlcyA9IHYxVG9WNihieXRlcyk7XG5cbiAgLy8gUmV0dXJuIGFzIGEgYnl0ZSBhcnJheSBpZiByZXF1ZXN0ZWRcbiAgaWYgKGJ1Zikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgYnVmW29mZnNldCArIGldID0gYnl0ZXNbaV07XG4gICAgfVxuICAgIHJldHVybiBidWY7XG4gIH1cbiAgcmV0dXJuIHVuc2FmZVN0cmluZ2lmeShieXRlcyk7XG59Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v6.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v6ToV1.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v6ToV1.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ v6ToV1)\n/* harmony export */ });\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/parse.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n/**\n * Convert a v6 UUID to a v1 UUID\n *\n * @param {string|Uint8Array} uuid - The v6 UUID to convert to v6\n * @returns {string|Uint8Array} The v1 UUID as the same type as the `uuid` arg\n * (string or Uint8Array)\n */\nfunction v6ToV1(uuid) {\n  const v6Bytes = typeof uuid === 'string' ? (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid) : uuid;\n  const v1Bytes = _v6ToV1(v6Bytes);\n  return typeof uuid === 'string' ? (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(v1Bytes) : v1Bytes;\n}\n\n// Do the field transformation needed for v6 -> v1\nfunction _v6ToV1(v6Bytes) {\n  return Uint8Array.of((v6Bytes[3] & 0x0f) << 4 | v6Bytes[4] >> 4 & 0x0f, (v6Bytes[4] & 0x0f) << 4 | (v6Bytes[5] & 0xf0) >> 4, (v6Bytes[5] & 0x0f) << 4 | v6Bytes[6] & 0x0f, v6Bytes[7], (v6Bytes[1] & 0x0f) << 4 | (v6Bytes[2] & 0xf0) >> 4, (v6Bytes[2] & 0x0f) << 4 | (v6Bytes[3] & 0xf0) >> 4, 0x10 | (v6Bytes[0] & 0xf0) >> 4, (v6Bytes[0] & 0x0f) << 4 | (v6Bytes[1] & 0xf0) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjZUb1YxLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQjtBQUNrQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNlO0FBQ2YsNkNBQTZDLHFEQUFLO0FBQ2xEO0FBQ0Esb0NBQW9DLDhEQUFlO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjZUb1YxLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXJzZSBmcm9tICcuL3BhcnNlLmpzJztcbmltcG9ydCB7IHVuc2FmZVN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcblxuLyoqXG4gKiBDb252ZXJ0IGEgdjYgVVVJRCB0byBhIHYxIFVVSURcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xVaW50OEFycmF5fSB1dWlkIC0gVGhlIHY2IFVVSUQgdG8gY29udmVydCB0byB2NlxuICogQHJldHVybnMge3N0cmluZ3xVaW50OEFycmF5fSBUaGUgdjEgVVVJRCBhcyB0aGUgc2FtZSB0eXBlIGFzIHRoZSBgdXVpZGAgYXJnXG4gKiAoc3RyaW5nIG9yIFVpbnQ4QXJyYXkpXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHY2VG9WMSh1dWlkKSB7XG4gIGNvbnN0IHY2Qnl0ZXMgPSB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgPyBwYXJzZSh1dWlkKSA6IHV1aWQ7XG4gIGNvbnN0IHYxQnl0ZXMgPSBfdjZUb1YxKHY2Qnl0ZXMpO1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnID8gdW5zYWZlU3RyaW5naWZ5KHYxQnl0ZXMpIDogdjFCeXRlcztcbn1cblxuLy8gRG8gdGhlIGZpZWxkIHRyYW5zZm9ybWF0aW9uIG5lZWRlZCBmb3IgdjYgLT4gdjFcbmZ1bmN0aW9uIF92NlRvVjEodjZCeXRlcykge1xuICByZXR1cm4gVWludDhBcnJheS5vZigodjZCeXRlc1szXSAmIDB4MGYpIDw8IDQgfCB2NkJ5dGVzWzRdID4+IDQgJiAweDBmLCAodjZCeXRlc1s0XSAmIDB4MGYpIDw8IDQgfCAodjZCeXRlc1s1XSAmIDB4ZjApID4+IDQsICh2NkJ5dGVzWzVdICYgMHgwZikgPDwgNCB8IHY2Qnl0ZXNbNl0gJiAweDBmLCB2NkJ5dGVzWzddLCAodjZCeXRlc1sxXSAmIDB4MGYpIDw8IDQgfCAodjZCeXRlc1syXSAmIDB4ZjApID4+IDQsICh2NkJ5dGVzWzJdICYgMHgwZikgPDwgNCB8ICh2NkJ5dGVzWzNdICYgMHhmMCkgPj4gNCwgMHgxMCB8ICh2NkJ5dGVzWzBdICYgMHhmMCkgPj4gNCwgKHY2Qnl0ZXNbMF0gJiAweDBmKSA8PCA0IHwgKHY2Qnl0ZXNbMV0gJiAweGYwKSA+PiA0LCB2NkJ5dGVzWzhdLCB2NkJ5dGVzWzldLCB2NkJ5dGVzWzEwXSwgdjZCeXRlc1sxMV0sIHY2Qnl0ZXNbMTJdLCB2NkJ5dGVzWzEzXSwgdjZCeXRlc1sxNF0sIHY2Qnl0ZXNbMTVdKTtcbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v6ToV1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v7.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v7.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n/**\n * UUID V7 - Unix Epoch time-based UUID\n *\n * The IETF has published RFC9562, introducing 3 new UUID versions (6,7,8). This\n * implementation of V7 is based on the accepted, though not yet approved,\n * revisions.\n *\n * RFC 9562:https://www.rfc-editor.org/rfc/rfc9562.html Universally Unique\n * IDentifiers (UUIDs)\n\n *\n * Sample V7 value:\n * https://www.rfc-editor.org/rfc/rfc9562.html#name-example-of-a-uuidv7-value\n *\n * Monotonic Bit Layout: RFC rfc9562.6.2 Method 1, Dedicated Counter Bits ref:\n *     https://www.rfc-editor.org/rfc/rfc9562.html#section-6.2-5.1\n *\n *   0                   1                   2                   3 0 1 2 3 4 5 6\n *   7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |                          unix_ts_ms                           |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |          unix_ts_ms           |  ver  |        seq_hi         |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |var|               seq_low               |        rand         |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |                             rand                              |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * seq is a 31 bit serialized counter; comprised of 12 bit seq_hi and 19 bit\n * seq_low, and randomly initialized upon timestamp change. 31 bit counter size\n * was selected as any bitwise operations in node are done as _signed_ 32 bit\n * ints. we exclude the sign bit.\n */\n\nlet _seqLow = null;\nlet _seqHigh = null;\nlet _msecs = 0;\nfunction v7(options, buf, offset) {\n  options = options || {};\n\n  // initialize buffer and pointer\n  let i = buf && offset || 0;\n  const b = buf || new Uint8Array(16);\n\n  // rnds is Uint8Array(16) filled with random bytes\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n  // milliseconds since unix epoch, 1970-01-01 00:00\n  const msecs = options.msecs !== undefined ? options.msecs : Date.now();\n\n  // seq is user provided 31 bit counter\n  let seq = options.seq !== undefined ? options.seq : null;\n\n  // initialize local seq high/low parts\n  let seqHigh = _seqHigh;\n  let seqLow = _seqLow;\n\n  // check if clock has advanced and user has not provided msecs\n  if (msecs > _msecs && options.msecs === undefined) {\n    _msecs = msecs;\n\n    // unless user provided seq, reset seq parts\n    if (seq !== null) {\n      seqHigh = null;\n      seqLow = null;\n    }\n  }\n\n  // if we have a user provided seq\n  if (seq !== null) {\n    // trim provided seq to 31 bits of value, avoiding overflow\n    if (seq > 0x7fffffff) {\n      seq = 0x7fffffff;\n    }\n\n    // split provided seq into high/low parts\n    seqHigh = seq >>> 19 & 0xfff;\n    seqLow = seq & 0x7ffff;\n  }\n\n  // randomly initialize seq\n  if (seqHigh === null || seqLow === null) {\n    seqHigh = rnds[6] & 0x7f;\n    seqHigh = seqHigh << 8 | rnds[7];\n    seqLow = rnds[8] & 0x3f; // pad for var\n    seqLow = seqLow << 8 | rnds[9];\n    seqLow = seqLow << 5 | rnds[10] >>> 3;\n  }\n\n  // increment seq if within msecs window\n  if (msecs + 10000 > _msecs && seq === null) {\n    if (++seqLow > 0x7ffff) {\n      seqLow = 0;\n      if (++seqHigh > 0xfff) {\n        seqHigh = 0;\n\n        // increment internal _msecs. this allows us to continue incrementing\n        // while staying monotonic. Note, once we hit 10k milliseconds beyond system\n        // clock, we will reset breaking monotonicity (after (2^31)*10000 generations)\n        _msecs++;\n      }\n    }\n  } else {\n    // resetting; we have advanced more than\n    // 10k milliseconds beyond system clock\n    _msecs = msecs;\n  }\n  _seqHigh = seqHigh;\n  _seqLow = seqLow;\n\n  // [bytes 0-5] 48 bits of local timestamp\n  b[i++] = _msecs / 0x10000000000 & 0xff;\n  b[i++] = _msecs / 0x100000000 & 0xff;\n  b[i++] = _msecs / 0x1000000 & 0xff;\n  b[i++] = _msecs / 0x10000 & 0xff;\n  b[i++] = _msecs / 0x100 & 0xff;\n  b[i++] = _msecs & 0xff;\n\n  // [byte 6] - set 4 bits of version (7) with first 4 bits seq_hi\n  b[i++] = seqHigh >>> 4 & 0x0f | 0x70;\n\n  // [byte 7] remaining 8 bits of seq_hi\n  b[i++] = seqHigh & 0xff;\n\n  // [byte 8] - variant (2 bits), first 6 bits seq_low\n  b[i++] = seqLow >>> 13 & 0x3f | 0x80;\n\n  // [byte 9] 8 bits seq_low\n  b[i++] = seqLow >>> 5 & 0xff;\n\n  // [byte 10] remaining 5 bits seq_low, 3 bits random\n  b[i++] = seqLow << 3 & 0xff | rnds[10] & 0x07;\n\n  // [bytes 11-15] always random\n  b[i++] = rnds[11];\n  b[i++] = rnds[12];\n  b[i++] = rnds[13];\n  b[i++] = rnds[14];\n  b[i++] = rnds[15];\n  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(b);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v7);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ3NCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQsK0NBQUc7O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4REFBZTtBQUMvQjtBQUNBLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92Ny5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcm5nIGZyb20gJy4vcm5nLmpzJztcbmltcG9ydCB7IHVuc2FmZVN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcblxuLyoqXG4gKiBVVUlEIFY3IC0gVW5peCBFcG9jaCB0aW1lLWJhc2VkIFVVSURcbiAqXG4gKiBUaGUgSUVURiBoYXMgcHVibGlzaGVkIFJGQzk1NjIsIGludHJvZHVjaW5nIDMgbmV3IFVVSUQgdmVyc2lvbnMgKDYsNyw4KS4gVGhpc1xuICogaW1wbGVtZW50YXRpb24gb2YgVjcgaXMgYmFzZWQgb24gdGhlIGFjY2VwdGVkLCB0aG91Z2ggbm90IHlldCBhcHByb3ZlZCxcbiAqIHJldmlzaW9ucy5cbiAqXG4gKiBSRkMgOTU2MjpodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTU2Mi5odG1sIFVuaXZlcnNhbGx5IFVuaXF1ZVxuICogSURlbnRpZmllcnMgKFVVSURzKVxuXG4gKlxuICogU2FtcGxlIFY3IHZhbHVlOlxuICogaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzk1NjIuaHRtbCNuYW1lLWV4YW1wbGUtb2YtYS11dWlkdjctdmFsdWVcbiAqXG4gKiBNb25vdG9uaWMgQml0IExheW91dDogUkZDIHJmYzk1NjIuNi4yIE1ldGhvZCAxLCBEZWRpY2F0ZWQgQ291bnRlciBCaXRzIHJlZjpcbiAqICAgICBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTU2Mi5odG1sI3NlY3Rpb24tNi4yLTUuMVxuICpcbiAqICAgMCAgICAgICAgICAgICAgICAgICAxICAgICAgICAgICAgICAgICAgIDIgICAgICAgICAgICAgICAgICAgMyAwIDEgMiAzIDQgNSA2XG4gKiAgIDcgOCA5IDAgMSAyIDMgNCA1IDYgNyA4IDkgMCAxIDIgMyA0IDUgNiA3IDggOSAwIDFcbiAqICArLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstK1xuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXhfdHNfbXMgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLStcbiAqICB8ICAgICAgICAgIHVuaXhfdHNfbXMgICAgICAgICAgIHwgIHZlciAgfCAgICAgICAgc2VxX2hpICAgICAgICAgfFxuICogICstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rXG4gKiAgfHZhcnwgICAgICAgICAgICAgICBzZXFfbG93ICAgICAgICAgICAgICAgfCAgICAgICAgcmFuZCAgICAgICAgIHxcbiAqICArLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstK1xuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLStcbiAqXG4gKiBzZXEgaXMgYSAzMSBiaXQgc2VyaWFsaXplZCBjb3VudGVyOyBjb21wcmlzZWQgb2YgMTIgYml0IHNlcV9oaSBhbmQgMTkgYml0XG4gKiBzZXFfbG93LCBhbmQgcmFuZG9tbHkgaW5pdGlhbGl6ZWQgdXBvbiB0aW1lc3RhbXAgY2hhbmdlLiAzMSBiaXQgY291bnRlciBzaXplXG4gKiB3YXMgc2VsZWN0ZWQgYXMgYW55IGJpdHdpc2Ugb3BlcmF0aW9ucyBpbiBub2RlIGFyZSBkb25lIGFzIF9zaWduZWRfIDMyIGJpdFxuICogaW50cy4gd2UgZXhjbHVkZSB0aGUgc2lnbiBiaXQuXG4gKi9cblxubGV0IF9zZXFMb3cgPSBudWxsO1xubGV0IF9zZXFIaWdoID0gbnVsbDtcbmxldCBfbXNlY3MgPSAwO1xuZnVuY3Rpb24gdjcob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gaW5pdGlhbGl6ZSBidWZmZXIgYW5kIHBvaW50ZXJcbiAgbGV0IGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gIGNvbnN0IGIgPSBidWYgfHwgbmV3IFVpbnQ4QXJyYXkoMTYpO1xuXG4gIC8vIHJuZHMgaXMgVWludDhBcnJheSgxNikgZmlsbGVkIHdpdGggcmFuZG9tIGJ5dGVzXG4gIGNvbnN0IHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpO1xuXG4gIC8vIG1pbGxpc2Vjb25kcyBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwXG4gIGNvbnN0IG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IERhdGUubm93KCk7XG5cbiAgLy8gc2VxIGlzIHVzZXIgcHJvdmlkZWQgMzEgYml0IGNvdW50ZXJcbiAgbGV0IHNlcSA9IG9wdGlvbnMuc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnNlcSA6IG51bGw7XG5cbiAgLy8gaW5pdGlhbGl6ZSBsb2NhbCBzZXEgaGlnaC9sb3cgcGFydHNcbiAgbGV0IHNlcUhpZ2ggPSBfc2VxSGlnaDtcbiAgbGV0IHNlcUxvdyA9IF9zZXFMb3c7XG5cbiAgLy8gY2hlY2sgaWYgY2xvY2sgaGFzIGFkdmFuY2VkIGFuZCB1c2VyIGhhcyBub3QgcHJvdmlkZWQgbXNlY3NcbiAgaWYgKG1zZWNzID4gX21zZWNzICYmIG9wdGlvbnMubXNlY3MgPT09IHVuZGVmaW5lZCkge1xuICAgIF9tc2VjcyA9IG1zZWNzO1xuXG4gICAgLy8gdW5sZXNzIHVzZXIgcHJvdmlkZWQgc2VxLCByZXNldCBzZXEgcGFydHNcbiAgICBpZiAoc2VxICE9PSBudWxsKSB7XG4gICAgICBzZXFIaWdoID0gbnVsbDtcbiAgICAgIHNlcUxvdyA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgd2UgaGF2ZSBhIHVzZXIgcHJvdmlkZWQgc2VxXG4gIGlmIChzZXEgIT09IG51bGwpIHtcbiAgICAvLyB0cmltIHByb3ZpZGVkIHNlcSB0byAzMSBiaXRzIG9mIHZhbHVlLCBhdm9pZGluZyBvdmVyZmxvd1xuICAgIGlmIChzZXEgPiAweDdmZmZmZmZmKSB7XG4gICAgICBzZXEgPSAweDdmZmZmZmZmO1xuICAgIH1cblxuICAgIC8vIHNwbGl0IHByb3ZpZGVkIHNlcSBpbnRvIGhpZ2gvbG93IHBhcnRzXG4gICAgc2VxSGlnaCA9IHNlcSA+Pj4gMTkgJiAweGZmZjtcbiAgICBzZXFMb3cgPSBzZXEgJiAweDdmZmZmO1xuICB9XG5cbiAgLy8gcmFuZG9tbHkgaW5pdGlhbGl6ZSBzZXFcbiAgaWYgKHNlcUhpZ2ggPT09IG51bGwgfHwgc2VxTG93ID09PSBudWxsKSB7XG4gICAgc2VxSGlnaCA9IHJuZHNbNl0gJiAweDdmO1xuICAgIHNlcUhpZ2ggPSBzZXFIaWdoIDw8IDggfCBybmRzWzddO1xuICAgIHNlcUxvdyA9IHJuZHNbOF0gJiAweDNmOyAvLyBwYWQgZm9yIHZhclxuICAgIHNlcUxvdyA9IHNlcUxvdyA8PCA4IHwgcm5kc1s5XTtcbiAgICBzZXFMb3cgPSBzZXFMb3cgPDwgNSB8IHJuZHNbMTBdID4+PiAzO1xuICB9XG5cbiAgLy8gaW5jcmVtZW50IHNlcSBpZiB3aXRoaW4gbXNlY3Mgd2luZG93XG4gIGlmIChtc2VjcyArIDEwMDAwID4gX21zZWNzICYmIHNlcSA9PT0gbnVsbCkge1xuICAgIGlmICgrK3NlcUxvdyA+IDB4N2ZmZmYpIHtcbiAgICAgIHNlcUxvdyA9IDA7XG4gICAgICBpZiAoKytzZXFIaWdoID4gMHhmZmYpIHtcbiAgICAgICAgc2VxSGlnaCA9IDA7XG5cbiAgICAgICAgLy8gaW5jcmVtZW50IGludGVybmFsIF9tc2Vjcy4gdGhpcyBhbGxvd3MgdXMgdG8gY29udGludWUgaW5jcmVtZW50aW5nXG4gICAgICAgIC8vIHdoaWxlIHN0YXlpbmcgbW9ub3RvbmljLiBOb3RlLCBvbmNlIHdlIGhpdCAxMGsgbWlsbGlzZWNvbmRzIGJleW9uZCBzeXN0ZW1cbiAgICAgICAgLy8gY2xvY2ssIHdlIHdpbGwgcmVzZXQgYnJlYWtpbmcgbW9ub3RvbmljaXR5IChhZnRlciAoMl4zMSkqMTAwMDAgZ2VuZXJhdGlvbnMpXG4gICAgICAgIF9tc2VjcysrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyByZXNldHRpbmc7IHdlIGhhdmUgYWR2YW5jZWQgbW9yZSB0aGFuXG4gICAgLy8gMTBrIG1pbGxpc2Vjb25kcyBiZXlvbmQgc3lzdGVtIGNsb2NrXG4gICAgX21zZWNzID0gbXNlY3M7XG4gIH1cbiAgX3NlcUhpZ2ggPSBzZXFIaWdoO1xuICBfc2VxTG93ID0gc2VxTG93O1xuXG4gIC8vIFtieXRlcyAwLTVdIDQ4IGJpdHMgb2YgbG9jYWwgdGltZXN0YW1wXG4gIGJbaSsrXSA9IF9tc2VjcyAvIDB4MTAwMDAwMDAwMDAgJiAweGZmO1xuICBiW2krK10gPSBfbXNlY3MgLyAweDEwMDAwMDAwMCAmIDB4ZmY7XG4gIGJbaSsrXSA9IF9tc2VjcyAvIDB4MTAwMDAwMCAmIDB4ZmY7XG4gIGJbaSsrXSA9IF9tc2VjcyAvIDB4MTAwMDAgJiAweGZmO1xuICBiW2krK10gPSBfbXNlY3MgLyAweDEwMCAmIDB4ZmY7XG4gIGJbaSsrXSA9IF9tc2VjcyAmIDB4ZmY7XG5cbiAgLy8gW2J5dGUgNl0gLSBzZXQgNCBiaXRzIG9mIHZlcnNpb24gKDcpIHdpdGggZmlyc3QgNCBiaXRzIHNlcV9oaVxuICBiW2krK10gPSBzZXFIaWdoID4+PiA0ICYgMHgwZiB8IDB4NzA7XG5cbiAgLy8gW2J5dGUgN10gcmVtYWluaW5nIDggYml0cyBvZiBzZXFfaGlcbiAgYltpKytdID0gc2VxSGlnaCAmIDB4ZmY7XG5cbiAgLy8gW2J5dGUgOF0gLSB2YXJpYW50ICgyIGJpdHMpLCBmaXJzdCA2IGJpdHMgc2VxX2xvd1xuICBiW2krK10gPSBzZXFMb3cgPj4+IDEzICYgMHgzZiB8IDB4ODA7XG5cbiAgLy8gW2J5dGUgOV0gOCBiaXRzIHNlcV9sb3dcbiAgYltpKytdID0gc2VxTG93ID4+PiA1ICYgMHhmZjtcblxuICAvLyBbYnl0ZSAxMF0gcmVtYWluaW5nIDUgYml0cyBzZXFfbG93LCAzIGJpdHMgcmFuZG9tXG4gIGJbaSsrXSA9IHNlcUxvdyA8PCAzICYgMHhmZiB8IHJuZHNbMTBdICYgMHgwNztcblxuICAvLyBbYnl0ZXMgMTEtMTVdIGFsd2F5cyByYW5kb21cbiAgYltpKytdID0gcm5kc1sxMV07XG4gIGJbaSsrXSA9IHJuZHNbMTJdO1xuICBiW2krK10gPSBybmRzWzEzXTtcbiAgYltpKytdID0gcm5kc1sxNF07XG4gIGJbaSsrXSA9IHJuZHNbMTVdO1xuICByZXR1cm4gYnVmIHx8IHVuc2FmZVN0cmluZ2lmeShiKTtcbn1cbmV4cG9ydCBkZWZhdWx0IHY3OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v7.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/validate.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/validate.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/regex.js\");\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmFsaWRhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0I7QUFDL0I7QUFDQSxxQ0FBcUMsaURBQUs7QUFDMUM7QUFDQSxpRUFBZSxRQUFRIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmFsaWRhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJFR0VYIGZyb20gJy4vcmVnZXguanMnO1xuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIFJFR0VYLnRlc3QodXVpZCk7XG59XG5leHBvcnQgZGVmYXVsdCB2YWxpZGF0ZTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/validate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/version.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/version.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/validate.js\");\n\nfunction version(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n  return parseInt(uuid.slice(14, 15), 16);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (version);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxQztBQUNyQztBQUNBLE9BQU8sd0RBQVE7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLE9BQU8iLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92ZXJzaW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbmZ1bmN0aW9uIHZlcnNpb24odXVpZCkge1xuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbnZhbGlkIFVVSUQnKTtcbiAgfVxuICByZXR1cm4gcGFyc2VJbnQodXVpZC5zbGljZSgxNCwgMTUpLCAxNik7XG59XG5leHBvcnQgZGVmYXVsdCB2ZXJzaW9uOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/version.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/output_parsers.cjs":
/*!*********************************************************!*\
  !*** ./node_modules/@langchain/core/output_parsers.cjs ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/output_parsers/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL291dHB1dF9wYXJzZXJzLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSxpSkFBMkQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvb3V0cHV0X3BhcnNlcnMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L291dHB1dF9wYXJzZXJzL2luZGV4LmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/output_parsers.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/output_parsers/openai_tools.cjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@langchain/core/output_parsers/openai_tools.cjs ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/output_parsers/openai_tools/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/openai_tools/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL291dHB1dF9wYXJzZXJzL29wZW5haV90b29scy5janMiLCJtYXBwaW5ncyI6IkFBQUEsNEtBQXlFIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL291dHB1dF9wYXJzZXJzL29wZW5haV90b29scy5janMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9kaXN0L291dHB1dF9wYXJzZXJzL29wZW5haV90b29scy9pbmRleC5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/output_parsers/openai_tools.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/outputs.cjs":
/*!**************************************************!*\
  !*** ./node_modules/@langchain/core/outputs.cjs ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/outputs.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/outputs.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL291dHB1dHMuY2pzIiwibWFwcGluZ3MiOiJBQUFBLHVIQUE4QyIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9vdXRwdXRzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9vdXRwdXRzLmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/outputs.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/retrievers.cjs":
/*!*****************************************************!*\
  !*** ./node_modules/@langchain/core/retrievers.cjs ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/retrievers/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/retrievers/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3JldHJpZXZlcnMuY2pzIiwibWFwcGluZ3MiOiJBQUFBLHlJQUF1RCIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9yZXRyaWV2ZXJzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9yZXRyaWV2ZXJzL2luZGV4LmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/retrievers.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/runnables.cjs":
/*!****************************************************!*\
  !*** ./node_modules/@langchain/core/runnables.cjs ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/runnables/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlcy5janMiLCJtYXBwaW5ncyI6IkFBQUEsdUlBQXNEIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlcy5janMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvcnVubmFibGVzL2luZGV4LmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/runnables.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/runnables/remote.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/runnables/remote.cjs ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/runnables/remote.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/remote.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlcy9yZW1vdGUuY2pzIiwibWFwcGluZ3MiOiJBQUFBLDBJQUF3RCIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXMvcmVtb3RlLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Rpc3QvcnVubmFibGVzL3JlbW90ZS5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/runnables/remote.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/stores.cjs":
/*!*************************************************!*\
  !*** ./node_modules/@langchain/core/stores.cjs ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/stores.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/stores.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3N0b3Jlcy5janMiLCJtYXBwaW5ncyI6IkFBQUEscUhBQTZDIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3N0b3Jlcy5janMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3Qvc3RvcmVzLmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/stores.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/tools.cjs":
/*!************************************************!*\
  !*** ./node_modules/@langchain/core/tools.cjs ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/tools/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tools/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3Rvb2xzLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSwrSEFBa0QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvdG9vbHMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L3Rvb2xzL2luZGV4LmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/tools.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/utils/async_caller.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/utils/async_caller.cjs ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/utils/async_caller.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2FzeW5jX2NhbGxlci5janMiLCJtYXBwaW5ncyI6IkFBQUEsOElBQTBEIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2FzeW5jX2NhbGxlci5janMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9kaXN0L3V0aWxzL2FzeW5jX2NhbGxlci5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/utils/async_caller.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/utils/chunk_array.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/utils/chunk_array.cjs ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/utils/chunk_array.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/chunk_array.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2NodW5rX2FycmF5LmNqcyIsIm1hcHBpbmdzIjoiQUFBQSw0SUFBeUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvdXRpbHMvY2h1bmtfYXJyYXkuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vZGlzdC91dGlscy9jaHVua19hcnJheS5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/utils/chunk_array.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/utils/env.cjs":
/*!****************************************************!*\
  !*** ./node_modules/@langchain/core/utils/env.cjs ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/utils/env.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/env.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2Vudi5janMiLCJtYXBwaW5ncyI6IkFBQUEsNEhBQWlEIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2Vudi5janMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9kaXN0L3V0aWxzL2Vudi5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/utils/env.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/utils/function_calling.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/utils/function_calling.cjs ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/utils/function_calling.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/function_calling.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2Z1bmN0aW9uX2NhbGxpbmcuY2pzIiwibWFwcGluZ3MiOiJBQUFBLHNKQUE4RCIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS91dGlscy9mdW5jdGlvbl9jYWxsaW5nLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Rpc3QvdXRpbHMvZnVuY3Rpb25fY2FsbGluZy5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/utils/function_calling.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/utils/json_schema.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/utils/json_schema.cjs ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/utils/json_schema.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_schema.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2pzb25fc2NoZW1hLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSw0SUFBeUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvdXRpbHMvanNvbl9zY2hlbWEuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vZGlzdC91dGlscy9qc29uX3NjaGVtYS5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/utils/json_schema.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/utils/stream.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/@langchain/core/utils/stream.cjs ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3V0aWxzL3N0cmVhbS5janMiLCJtYXBwaW5ncyI6IkFBQUEsa0lBQW9EIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3V0aWxzL3N0cmVhbS5janMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9kaXN0L3V0aWxzL3N0cmVhbS5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/utils/stream.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/utils/types.cjs":
/*!******************************************************!*\
  !*** ./node_modules/@langchain/core/utils/types.cjs ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/utils/types/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3V0aWxzL3R5cGVzLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSw0SUFBeUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvdXRpbHMvdHlwZXMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vZGlzdC91dGlscy90eXBlcy9pbmRleC5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/utils/types.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/auth.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/auth.cjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ensureAuthOptionScopes = exports.aiPlatformScope = exports.ApiKeyGoogleAuth = exports.GoogleAbstractedFetchClient = void 0;\nconst stream_js_1 = __webpack_require__(/*! ./utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/stream.cjs\");\nclass GoogleAbstractedFetchClient {\n    async _buildData(res, opts) {\n        switch (opts.responseType) {\n            case \"json\":\n                return res.json();\n            case \"stream\":\n                return new stream_js_1.ReadableJsonStream(res.body);\n            default:\n                return res.blob();\n        }\n    }\n    async _request(url, opts, additionalHeaders) {\n        if (url == null)\n            throw new Error(\"Missing URL\");\n        const fetchOptions = {\n            method: opts.method,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...(opts.headers ?? {}),\n                ...(additionalHeaders ?? {}),\n            },\n        };\n        if (opts.data !== undefined) {\n            if (typeof opts.data === \"string\") {\n                fetchOptions.body = opts.data;\n            }\n            else {\n                fetchOptions.body = JSON.stringify(opts.data);\n            }\n        }\n        const res = await fetch(url, fetchOptions);\n        if (!res.ok) {\n            const resText = await res.text();\n            const error = new Error(`Google request failed with status code ${res.status}: ${resText}`);\n            /* eslint-disable @typescript-eslint/no-explicit-any */\n            error.response = res;\n            error.details = {\n                url,\n                opts,\n                fetchOptions,\n                result: res,\n            };\n            /* eslint-enable @typescript-eslint/no-explicit-any */\n            throw error;\n        }\n        const data = await this._buildData(res, opts);\n        return {\n            data,\n            config: {},\n            status: res.status,\n            statusText: res.statusText,\n            headers: res.headers,\n            request: { responseURL: res.url },\n        };\n    }\n}\nexports.GoogleAbstractedFetchClient = GoogleAbstractedFetchClient;\nclass ApiKeyGoogleAuth extends GoogleAbstractedFetchClient {\n    constructor(apiKey) {\n        super();\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.apiKey = apiKey;\n    }\n    get clientType() {\n        return \"apiKey\";\n    }\n    getProjectId() {\n        throw new Error(\"APIs that require a project ID cannot use an API key\");\n        // Perhaps we could implement this if needed:\n        // https://cloud.google.com/docs/authentication/api-keys#get-info\n    }\n    request(opts) {\n        const authHeader = {\n            \"X-Goog-Api-Key\": this.apiKey,\n        };\n        return this._request(opts.url, opts, authHeader);\n    }\n}\nexports.ApiKeyGoogleAuth = ApiKeyGoogleAuth;\nfunction aiPlatformScope(platform) {\n    switch (platform) {\n        case \"gai\":\n            return [\"https://www.googleapis.com/auth/generative-language\"];\n        default:\n            return [\"https://www.googleapis.com/auth/cloud-platform\"];\n    }\n}\nexports.aiPlatformScope = aiPlatformScope;\nfunction ensureAuthOptionScopes(authOption, scopeProperty, scopesOrPlatform) {\n    // If the property is already set, return it\n    if (authOption && Object.hasOwn(authOption, scopeProperty)) {\n        return authOption;\n    }\n    // Otherwise add it\n    const scopes = Array.isArray(scopesOrPlatform)\n        ? scopesOrPlatform\n        : aiPlatformScope(scopesOrPlatform ?? \"gcp\");\n    return {\n        [scopeProperty]: scopes,\n        ...(authOption ?? {}),\n    };\n}\nexports.ensureAuthOptionScopes = ensureAuthOptionScopes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvYXV0aC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsOEJBQThCLEdBQUcsdUJBQXVCLEdBQUcsd0JBQXdCLEdBQUcsbUNBQW1DO0FBQ3pILG9CQUFvQixtQkFBTyxDQUFDLCtGQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsMkNBQTJDO0FBQzNDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsV0FBVyxJQUFJLFFBQVE7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSw4QkFBOEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vZGlzdC9hdXRoLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5zdXJlQXV0aE9wdGlvblNjb3BlcyA9IGV4cG9ydHMuYWlQbGF0Zm9ybVNjb3BlID0gZXhwb3J0cy5BcGlLZXlHb29nbGVBdXRoID0gZXhwb3J0cy5Hb29nbGVBYnN0cmFjdGVkRmV0Y2hDbGllbnQgPSB2b2lkIDA7XG5jb25zdCBzdHJlYW1fanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL3N0cmVhbS5janNcIik7XG5jbGFzcyBHb29nbGVBYnN0cmFjdGVkRmV0Y2hDbGllbnQge1xuICAgIGFzeW5jIF9idWlsZERhdGEocmVzLCBvcHRzKSB7XG4gICAgICAgIHN3aXRjaCAob3B0cy5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJqc29uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5qc29uKCk7XG4gICAgICAgICAgICBjYXNlIFwic3RyZWFtXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzdHJlYW1fanNfMS5SZWFkYWJsZUpzb25TdHJlYW0ocmVzLmJvZHkpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmJsb2IoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfcmVxdWVzdCh1cmwsIG9wdHMsIGFkZGl0aW9uYWxIZWFkZXJzKSB7XG4gICAgICAgIGlmICh1cmwgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgVVJMXCIpO1xuICAgICAgICBjb25zdCBmZXRjaE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtZXRob2Q6IG9wdHMubWV0aG9kLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIC4uLihvcHRzLmhlYWRlcnMgPz8ge30pLFxuICAgICAgICAgICAgICAgIC4uLihhZGRpdGlvbmFsSGVhZGVycyA/PyB7fSksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0cy5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0cy5kYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgZmV0Y2hPcHRpb25zLmJvZHkgPSBvcHRzLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmZXRjaE9wdGlvbnMuYm9keSA9IEpTT04uc3RyaW5naWZ5KG9wdHMuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsLCBmZXRjaE9wdGlvbnMpO1xuICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgY29uc3QgcmVzVGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgR29vZ2xlIHJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJHtyZXMuc3RhdHVzfTogJHtyZXNUZXh0fWApO1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuICAgICAgICAgICAgZXJyb3IucmVzcG9uc2UgPSByZXM7XG4gICAgICAgICAgICBlcnJvci5kZXRhaWxzID0ge1xuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBvcHRzLFxuICAgICAgICAgICAgICAgIGZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHJlcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl9idWlsZERhdGEocmVzLCBvcHRzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBjb25maWc6IHt9LFxuICAgICAgICAgICAgc3RhdHVzOiByZXMuc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVzLnN0YXR1c1RleHQsXG4gICAgICAgICAgICBoZWFkZXJzOiByZXMuaGVhZGVycyxcbiAgICAgICAgICAgIHJlcXVlc3Q6IHsgcmVzcG9uc2VVUkw6IHJlcy51cmwgfSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkdvb2dsZUFic3RyYWN0ZWRGZXRjaENsaWVudCA9IEdvb2dsZUFic3RyYWN0ZWRGZXRjaENsaWVudDtcbmNsYXNzIEFwaUtleUdvb2dsZUF1dGggZXh0ZW5kcyBHb29nbGVBYnN0cmFjdGVkRmV0Y2hDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKGFwaUtleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcGlLZXlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBhcGlLZXk7XG4gICAgfVxuICAgIGdldCBjbGllbnRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJhcGlLZXlcIjtcbiAgICB9XG4gICAgZ2V0UHJvamVjdElkKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBUElzIHRoYXQgcmVxdWlyZSBhIHByb2plY3QgSUQgY2Fubm90IHVzZSBhbiBBUEkga2V5XCIpO1xuICAgICAgICAvLyBQZXJoYXBzIHdlIGNvdWxkIGltcGxlbWVudCB0aGlzIGlmIG5lZWRlZDpcbiAgICAgICAgLy8gaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2RvY3MvYXV0aGVudGljYXRpb24vYXBpLWtleXMjZ2V0LWluZm9cbiAgICB9XG4gICAgcmVxdWVzdChvcHRzKSB7XG4gICAgICAgIGNvbnN0IGF1dGhIZWFkZXIgPSB7XG4gICAgICAgICAgICBcIlgtR29vZy1BcGktS2V5XCI6IHRoaXMuYXBpS2V5LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdChvcHRzLnVybCwgb3B0cywgYXV0aEhlYWRlcik7XG4gICAgfVxufVxuZXhwb3J0cy5BcGlLZXlHb29nbGVBdXRoID0gQXBpS2V5R29vZ2xlQXV0aDtcbmZ1bmN0aW9uIGFpUGxhdGZvcm1TY29wZShwbGF0Zm9ybSkge1xuICAgIHN3aXRjaCAocGxhdGZvcm0pIHtcbiAgICAgICAgY2FzZSBcImdhaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFtcImh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvZ2VuZXJhdGl2ZS1sYW5ndWFnZVwiXTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBbXCJodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2Nsb3VkLXBsYXRmb3JtXCJdO1xuICAgIH1cbn1cbmV4cG9ydHMuYWlQbGF0Zm9ybVNjb3BlID0gYWlQbGF0Zm9ybVNjb3BlO1xuZnVuY3Rpb24gZW5zdXJlQXV0aE9wdGlvblNjb3BlcyhhdXRoT3B0aW9uLCBzY29wZVByb3BlcnR5LCBzY29wZXNPclBsYXRmb3JtKSB7XG4gICAgLy8gSWYgdGhlIHByb3BlcnR5IGlzIGFscmVhZHkgc2V0LCByZXR1cm4gaXRcbiAgICBpZiAoYXV0aE9wdGlvbiAmJiBPYmplY3QuaGFzT3duKGF1dGhPcHRpb24sIHNjb3BlUHJvcGVydHkpKSB7XG4gICAgICAgIHJldHVybiBhdXRoT3B0aW9uO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UgYWRkIGl0XG4gICAgY29uc3Qgc2NvcGVzID0gQXJyYXkuaXNBcnJheShzY29wZXNPclBsYXRmb3JtKVxuICAgICAgICA/IHNjb3Blc09yUGxhdGZvcm1cbiAgICAgICAgOiBhaVBsYXRmb3JtU2NvcGUoc2NvcGVzT3JQbGF0Zm9ybSA/PyBcImdjcFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBbc2NvcGVQcm9wZXJ0eV06IHNjb3BlcyxcbiAgICAgICAgLi4uKGF1dGhPcHRpb24gPz8ge30pLFxuICAgIH07XG59XG5leHBvcnRzLmVuc3VyZUF1dGhPcHRpb25TY29wZXMgPSBlbnN1cmVBdXRoT3B0aW9uU2NvcGVzO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/auth.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/chat_models.cjs":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/chat_models.cjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChatGoogleBase = exports.ChatConnection = void 0;\nconst env_1 = __webpack_require__(/*! @langchain/core/utils/env */ \"(rsc)/./node_modules/@langchain/core/utils/env.cjs\");\nconst chat_models_1 = __webpack_require__(/*! @langchain/core/language_models/chat_models */ \"(rsc)/./node_modules/@langchain/core/language_models/chat_models.cjs\");\nconst outputs_1 = __webpack_require__(/*! @langchain/core/outputs */ \"(rsc)/./node_modules/@langchain/core/outputs.cjs\");\nconst messages_1 = __webpack_require__(/*! @langchain/core/messages */ \"(rsc)/./node_modules/@langchain/core/messages.cjs\");\nconst runnables_1 = __webpack_require__(/*! @langchain/core/runnables */ \"(rsc)/./node_modules/@langchain/core/runnables.cjs\");\nconst openai_tools_1 = __webpack_require__(/*! @langchain/core/output_parsers/openai_tools */ \"(rsc)/./node_modules/@langchain/core/output_parsers/openai_tools.cjs\");\nconst stream_1 = __webpack_require__(/*! @langchain/core/utils/stream */ \"(rsc)/./node_modules/@langchain/core/utils/stream.cjs\");\nconst common_js_1 = __webpack_require__(/*! ./utils/common.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/common.cjs\");\nconst connection_js_1 = __webpack_require__(/*! ./connection.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/connection.cjs\");\nconst gemini_js_1 = __webpack_require__(/*! ./utils/gemini.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/gemini.cjs\");\nconst auth_js_1 = __webpack_require__(/*! ./auth.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/auth.cjs\");\nconst failed_handler_js_1 = __webpack_require__(/*! ./utils/failed_handler.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/failed_handler.cjs\");\nconst zod_to_gemini_parameters_js_1 = __webpack_require__(/*! ./utils/zod_to_gemini_parameters.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/zod_to_gemini_parameters.cjs\");\nclass ChatConnection extends connection_js_1.AbstractGoogleLLMConnection {\n    constructor(fields, caller, client, streaming) {\n        super(fields, caller, client, streaming);\n        Object.defineProperty(this, \"convertSystemMessageToHumanContent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.convertSystemMessageToHumanContent =\n            fields?.convertSystemMessageToHumanContent;\n    }\n    get useSystemInstruction() {\n        return typeof this.convertSystemMessageToHumanContent === \"boolean\"\n            ? !this.convertSystemMessageToHumanContent\n            : this.computeUseSystemInstruction;\n    }\n    get computeUseSystemInstruction() {\n        // This works on models from April 2024 and later\n        //   Vertex AI: gemini-1.5-pro and gemini-1.0-002 and later\n        //   AI Studio: gemini-1.5-pro-latest\n        if (this.modelFamily === \"palm\") {\n            return false;\n        }\n        else if (this.modelName === \"gemini-1.0-pro-001\") {\n            return false;\n        }\n        else if (this.modelName.startsWith(\"gemini-pro-vision\")) {\n            return false;\n        }\n        else if (this.modelName.startsWith(\"gemini-1.0-pro-vision\")) {\n            return false;\n        }\n        else if (this.modelName === \"gemini-pro\" && this.platform === \"gai\") {\n            // on AI Studio gemini-pro is still pointing at gemini-1.0-pro-001\n            return false;\n        }\n        return true;\n    }\n    computeGoogleSearchToolAdjustmentFromModel() {\n        if (this.modelName.startsWith(\"gemini-1.0\")) {\n            return \"googleSearchRetrieval\";\n        }\n        else if (this.modelName.startsWith(\"gemini-1.5\")) {\n            return \"googleSearchRetrieval\";\n        }\n        else {\n            return \"googleSearch\";\n        }\n    }\n    computeGoogleSearchToolAdjustment(apiConfig) {\n        const adj = apiConfig.googleSearchToolAdjustment;\n        if (adj === undefined || adj === true) {\n            return this.computeGoogleSearchToolAdjustmentFromModel();\n        }\n        else {\n            return adj;\n        }\n    }\n    buildGeminiAPI() {\n        const apiConfig = this.apiConfig ?? {};\n        const googleSearchToolAdjustment = this.computeGoogleSearchToolAdjustment(apiConfig);\n        const geminiConfig = {\n            useSystemInstruction: this.useSystemInstruction,\n            googleSearchToolAdjustment,\n            ...apiConfig,\n        };\n        return (0, gemini_js_1.getGeminiAPI)(geminiConfig);\n    }\n    get api() {\n        switch (this.apiName) {\n            case \"google\":\n                return this.buildGeminiAPI();\n            default:\n                return super.api;\n        }\n    }\n}\nexports.ChatConnection = ChatConnection;\n/**\n * Integration with a Google chat model.\n */\nclass ChatGoogleBase extends chat_models_1.BaseChatModel {\n    // Used for tracing, replace with the same name as your class\n    static lc_name() {\n        return \"ChatGoogle\";\n    }\n    get lc_secrets() {\n        return {\n            authOptions: \"GOOGLE_AUTH_OPTIONS\",\n        };\n    }\n    constructor(fields) {\n        super((0, failed_handler_js_1.ensureParams)(fields));\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        // Set based on modelName\n        Object.defineProperty(this, \"model\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"modelName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"gemini-pro\"\n        });\n        Object.defineProperty(this, \"temperature\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0.7\n        });\n        Object.defineProperty(this, \"maxOutputTokens\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 1024\n        });\n        Object.defineProperty(this, \"topP\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0.8\n        });\n        Object.defineProperty(this, \"topK\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 40\n        });\n        Object.defineProperty(this, \"presencePenalty\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"frequencyPenalty\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"stopSequences\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"logprobs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"topLogprobs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"safetySettings\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        // May intentionally be undefined, meaning to compute this.\n        Object.defineProperty(this, \"convertSystemMessageToHumanContent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"safetyHandler\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"streamUsage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"streaming\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"connection\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"streamedConnection\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        (0, common_js_1.copyAndValidateModelParamsInto)(fields, this);\n        this.safetyHandler =\n            fields?.safetyHandler ?? new gemini_js_1.DefaultGeminiSafetyHandler();\n        this.streamUsage = fields?.streamUsage ?? this.streamUsage;\n        const client = this.buildClient(fields);\n        this.buildConnection(fields ?? {}, client);\n    }\n    getLsParams(options) {\n        const params = this.invocationParams(options);\n        return {\n            ls_provider: \"google_vertexai\",\n            ls_model_name: this.model,\n            ls_model_type: \"chat\",\n            ls_temperature: params.temperature ?? undefined,\n            ls_max_tokens: params.maxOutputTokens ?? undefined,\n            ls_stop: options.stop,\n        };\n    }\n    buildApiKeyClient(apiKey) {\n        return new auth_js_1.ApiKeyGoogleAuth(apiKey);\n    }\n    buildApiKey(fields) {\n        if (fields?.platformType !== \"gcp\") {\n            return fields?.apiKey ?? (0, env_1.getEnvironmentVariable)(\"GOOGLE_API_KEY\");\n        }\n        else {\n            // GCP doesn't support API Keys\n            return undefined;\n        }\n    }\n    buildClient(fields) {\n        const apiKey = this.buildApiKey(fields);\n        if (apiKey) {\n            return this.buildApiKeyClient(apiKey);\n        }\n        else {\n            return this.buildAbstractedClient(fields);\n        }\n    }\n    buildConnection(fields, client) {\n        this.connection = new ChatConnection({ ...fields, ...this }, this.caller, client, false);\n        this.streamedConnection = new ChatConnection({ ...fields, ...this }, this.caller, client, true);\n    }\n    get platform() {\n        return this.connection.platform;\n    }\n    bindTools(tools, kwargs) {\n        return this.bind({ tools: (0, common_js_1.convertToGeminiTools)(tools), ...kwargs });\n    }\n    // Replace\n    _llmType() {\n        return \"chat_integration\";\n    }\n    /**\n     * Get the parameters used to invoke the model\n     */\n    invocationParams(options) {\n        return (0, common_js_1.copyAIModelParams)(this, options);\n    }\n    async _generate(messages, options, runManager) {\n        const parameters = this.invocationParams(options);\n        if (this.streaming) {\n            const stream = this._streamResponseChunks(messages, options, runManager);\n            let finalChunk = null;\n            for await (const chunk of stream) {\n                finalChunk = !finalChunk ? chunk : (0, stream_1.concat)(finalChunk, chunk);\n            }\n            if (!finalChunk) {\n                throw new Error(\"No chunks were returned from the stream.\");\n            }\n            return {\n                generations: [finalChunk],\n            };\n        }\n        const response = await this.connection.request(messages, parameters, options, runManager);\n        const ret = this.connection.api.responseToChatResult(response);\n        const chunk = ret?.generations?.[0];\n        if (chunk) {\n            await runManager?.handleLLMNewToken(chunk.text || \"\");\n        }\n        return ret;\n    }\n    async *_streamResponseChunks(_messages, options, runManager) {\n        // Make the call as a streaming request\n        const parameters = this.invocationParams(options);\n        const response = await this.streamedConnection.request(_messages, parameters, options, runManager);\n        // Get the streaming parser of the response\n        const stream = response.data;\n        let usageMetadata;\n        // Loop until the end of the stream\n        // During the loop, yield each time we get a chunk from the streaming parser\n        // that is either available or added to the queue\n        while (!stream.streamDone) {\n            const output = await stream.nextChunk();\n            await runManager?.handleCustomEvent(`google-chunk-${this.constructor.name}`, {\n                output,\n            });\n            if (output &&\n                output.usageMetadata &&\n                this.streamUsage !== false &&\n                options.streamUsage !== false) {\n                usageMetadata = {\n                    input_tokens: output.usageMetadata.promptTokenCount,\n                    output_tokens: output.usageMetadata.candidatesTokenCount,\n                    total_tokens: output.usageMetadata.totalTokenCount,\n                };\n            }\n            const chunk = output !== null\n                ? this.connection.api.responseToChatGeneration({ data: output })\n                : new outputs_1.ChatGenerationChunk({\n                    text: \"\",\n                    generationInfo: { finishReason: \"stop\" },\n                    message: new messages_1.AIMessageChunk({\n                        content: \"\",\n                        usage_metadata: usageMetadata,\n                    }),\n                });\n            if (chunk) {\n                yield chunk;\n                await runManager?.handleLLMNewToken(chunk.text ?? \"\", undefined, undefined, undefined, undefined, { chunk });\n            }\n        }\n    }\n    /** @ignore */\n    _combineLLMOutput() {\n        return [];\n    }\n    withStructuredOutput(outputSchema, config) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const schema = outputSchema;\n        const name = config?.name;\n        const method = config?.method;\n        const includeRaw = config?.includeRaw;\n        if (method === \"jsonMode\") {\n            throw new Error(`Google only supports \"functionCalling\" as a method.`);\n        }\n        let functionName = name ?? \"extract\";\n        let outputParser;\n        let tools;\n        if (isZodSchema(schema)) {\n            const jsonSchema = (0, zod_to_gemini_parameters_js_1.zodToGeminiParameters)(schema);\n            tools = [\n                {\n                    functionDeclarations: [\n                        {\n                            name: functionName,\n                            description: jsonSchema.description ?? \"A function available to call.\",\n                            parameters: jsonSchema,\n                        },\n                    ],\n                },\n            ];\n            outputParser = new openai_tools_1.JsonOutputKeyToolsParser({\n                returnSingle: true,\n                keyName: functionName,\n                zodSchema: schema,\n            });\n        }\n        else {\n            let geminiFunctionDefinition;\n            if (typeof schema.name === \"string\" &&\n                typeof schema.parameters === \"object\" &&\n                schema.parameters != null) {\n                geminiFunctionDefinition = schema;\n                functionName = schema.name;\n            }\n            else {\n                geminiFunctionDefinition = {\n                    name: functionName,\n                    description: schema.description ?? \"\",\n                    parameters: schema,\n                };\n            }\n            tools = [\n                {\n                    functionDeclarations: [geminiFunctionDefinition],\n                },\n            ];\n            outputParser = new openai_tools_1.JsonOutputKeyToolsParser({\n                returnSingle: true,\n                keyName: functionName,\n            });\n        }\n        const llm = this.bind({\n            tools,\n            tool_choice: functionName,\n        });\n        if (!includeRaw) {\n            return llm.pipe(outputParser).withConfig({\n                runName: \"ChatGoogleStructuredOutput\",\n            });\n        }\n        const parserAssign = runnables_1.RunnablePassthrough.assign({\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            parsed: (input, config) => outputParser.invoke(input.raw, config),\n        });\n        const parserNone = runnables_1.RunnablePassthrough.assign({\n            parsed: () => null,\n        });\n        const parsedWithFallback = parserAssign.withFallbacks({\n            fallbacks: [parserNone],\n        });\n        return runnables_1.RunnableSequence.from([\n            {\n                raw: llm,\n            },\n            parsedWithFallback,\n        ]).withConfig({\n            runName: \"StructuredOutputRunnable\",\n        });\n    }\n}\nexports.ChatGoogleBase = ChatGoogleBase;\nfunction isZodSchema(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ninput) {\n    // Check for a characteristic method of Zod schemas\n    return typeof input?.parse === \"function\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvY2hhdF9tb2RlbHMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLHNCQUFzQjtBQUMvQyxjQUFjLG1CQUFPLENBQUMscUZBQTJCO0FBQ2pELHNCQUFzQixtQkFBTyxDQUFDLHlIQUE2QztBQUMzRSxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBeUI7QUFDbkQsbUJBQW1CLG1CQUFPLENBQUMsbUZBQTBCO0FBQ3JELG9CQUFvQixtQkFBTyxDQUFDLHFGQUEyQjtBQUN2RCx1QkFBdUIsbUJBQU8sQ0FBQyx5SEFBNkM7QUFDNUUsaUJBQWlCLG1CQUFPLENBQUMsMkZBQThCO0FBQ3ZELG9CQUFvQixtQkFBTyxDQUFDLCtGQUFvQjtBQUNoRCx3QkFBd0IsbUJBQU8sQ0FBQywyRkFBa0I7QUFDbEQsb0JBQW9CLG1CQUFPLENBQUMsK0ZBQW9CO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3RDLDRCQUE0QixtQkFBTyxDQUFDLCtHQUE0QjtBQUNoRSxzQ0FBc0MsbUJBQU8sQ0FBQyxtSUFBc0M7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvQkFBb0I7QUFDbkUsdURBQXVELG9CQUFvQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdFQUFnRTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxzQkFBc0I7QUFDdEY7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxjQUFjO0FBQy9FO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLG9IQUFvSCxPQUFPO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvY2hhdF9tb2RlbHMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaGF0R29vZ2xlQmFzZSA9IGV4cG9ydHMuQ2hhdENvbm5lY3Rpb24gPSB2b2lkIDA7XG5jb25zdCBlbnZfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvdXRpbHMvZW52XCIpO1xuY29uc3QgY2hhdF9tb2RlbHNfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvbGFuZ3VhZ2VfbW9kZWxzL2NoYXRfbW9kZWxzXCIpO1xuY29uc3Qgb3V0cHV0c18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9vdXRwdXRzXCIpO1xuY29uc3QgbWVzc2FnZXNfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvbWVzc2FnZXNcIik7XG5jb25zdCBydW5uYWJsZXNfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCIpO1xuY29uc3Qgb3BlbmFpX3Rvb2xzXzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL291dHB1dF9wYXJzZXJzL29wZW5haV90b29sc1wiKTtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS91dGlscy9zdHJlYW1cIik7XG5jb25zdCBjb21tb25fanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2NvbW1vbi5janNcIik7XG5jb25zdCBjb25uZWN0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aW9uLmNqc1wiKTtcbmNvbnN0IGdlbWluaV9qc18xID0gcmVxdWlyZShcIi4vdXRpbHMvZ2VtaW5pLmNqc1wiKTtcbmNvbnN0IGF1dGhfanNfMSA9IHJlcXVpcmUoXCIuL2F1dGguY2pzXCIpO1xuY29uc3QgZmFpbGVkX2hhbmRsZXJfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2ZhaWxlZF9oYW5kbGVyLmNqc1wiKTtcbmNvbnN0IHpvZF90b19nZW1pbmlfcGFyYW1ldGVyc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMvem9kX3RvX2dlbWluaV9wYXJhbWV0ZXJzLmNqc1wiKTtcbmNsYXNzIENoYXRDb25uZWN0aW9uIGV4dGVuZHMgY29ubmVjdGlvbl9qc18xLkFic3RyYWN0R29vZ2xlTExNQ29ubmVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCBjYWxsZXIsIGNsaWVudCwgc3RyZWFtaW5nKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcywgY2FsbGVyLCBjbGllbnQsIHN0cmVhbWluZyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnZlcnRTeXN0ZW1NZXNzYWdlVG9IdW1hbkNvbnRlbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb252ZXJ0U3lzdGVtTWVzc2FnZVRvSHVtYW5Db250ZW50ID1cbiAgICAgICAgICAgIGZpZWxkcz8uY29udmVydFN5c3RlbU1lc3NhZ2VUb0h1bWFuQ29udGVudDtcbiAgICB9XG4gICAgZ2V0IHVzZVN5c3RlbUluc3RydWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuY29udmVydFN5c3RlbU1lc3NhZ2VUb0h1bWFuQ29udGVudCA9PT0gXCJib29sZWFuXCJcbiAgICAgICAgICAgID8gIXRoaXMuY29udmVydFN5c3RlbU1lc3NhZ2VUb0h1bWFuQ29udGVudFxuICAgICAgICAgICAgOiB0aGlzLmNvbXB1dGVVc2VTeXN0ZW1JbnN0cnVjdGlvbjtcbiAgICB9XG4gICAgZ2V0IGNvbXB1dGVVc2VTeXN0ZW1JbnN0cnVjdGlvbigpIHtcbiAgICAgICAgLy8gVGhpcyB3b3JrcyBvbiBtb2RlbHMgZnJvbSBBcHJpbCAyMDI0IGFuZCBsYXRlclxuICAgICAgICAvLyAgIFZlcnRleCBBSTogZ2VtaW5pLTEuNS1wcm8gYW5kIGdlbWluaS0xLjAtMDAyIGFuZCBsYXRlclxuICAgICAgICAvLyAgIEFJIFN0dWRpbzogZ2VtaW5pLTEuNS1wcm8tbGF0ZXN0XG4gICAgICAgIGlmICh0aGlzLm1vZGVsRmFtaWx5ID09PSBcInBhbG1cIikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubW9kZWxOYW1lID09PSBcImdlbWluaS0xLjAtcHJvLTAwMVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5tb2RlbE5hbWUuc3RhcnRzV2l0aChcImdlbWluaS1wcm8tdmlzaW9uXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5tb2RlbE5hbWUuc3RhcnRzV2l0aChcImdlbWluaS0xLjAtcHJvLXZpc2lvblwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubW9kZWxOYW1lID09PSBcImdlbWluaS1wcm9cIiAmJiB0aGlzLnBsYXRmb3JtID09PSBcImdhaVwiKSB7XG4gICAgICAgICAgICAvLyBvbiBBSSBTdHVkaW8gZ2VtaW5pLXBybyBpcyBzdGlsbCBwb2ludGluZyBhdCBnZW1pbmktMS4wLXByby0wMDFcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29tcHV0ZUdvb2dsZVNlYXJjaFRvb2xBZGp1c3RtZW50RnJvbU1vZGVsKCkge1xuICAgICAgICBpZiAodGhpcy5tb2RlbE5hbWUuc3RhcnRzV2l0aChcImdlbWluaS0xLjBcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBcImdvb2dsZVNlYXJjaFJldHJpZXZhbFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubW9kZWxOYW1lLnN0YXJ0c1dpdGgoXCJnZW1pbmktMS41XCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJnb29nbGVTZWFyY2hSZXRyaWV2YWxcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcImdvb2dsZVNlYXJjaFwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXB1dGVHb29nbGVTZWFyY2hUb29sQWRqdXN0bWVudChhcGlDb25maWcpIHtcbiAgICAgICAgY29uc3QgYWRqID0gYXBpQ29uZmlnLmdvb2dsZVNlYXJjaFRvb2xBZGp1c3RtZW50O1xuICAgICAgICBpZiAoYWRqID09PSB1bmRlZmluZWQgfHwgYWRqID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlR29vZ2xlU2VhcmNoVG9vbEFkanVzdG1lbnRGcm9tTW9kZWwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhZGo7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnVpbGRHZW1pbmlBUEkoKSB7XG4gICAgICAgIGNvbnN0IGFwaUNvbmZpZyA9IHRoaXMuYXBpQ29uZmlnID8/IHt9O1xuICAgICAgICBjb25zdCBnb29nbGVTZWFyY2hUb29sQWRqdXN0bWVudCA9IHRoaXMuY29tcHV0ZUdvb2dsZVNlYXJjaFRvb2xBZGp1c3RtZW50KGFwaUNvbmZpZyk7XG4gICAgICAgIGNvbnN0IGdlbWluaUNvbmZpZyA9IHtcbiAgICAgICAgICAgIHVzZVN5c3RlbUluc3RydWN0aW9uOiB0aGlzLnVzZVN5c3RlbUluc3RydWN0aW9uLFxuICAgICAgICAgICAgZ29vZ2xlU2VhcmNoVG9vbEFkanVzdG1lbnQsXG4gICAgICAgICAgICAuLi5hcGlDb25maWcsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAoMCwgZ2VtaW5pX2pzXzEuZ2V0R2VtaW5pQVBJKShnZW1pbmlDb25maWcpO1xuICAgIH1cbiAgICBnZXQgYXBpKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuYXBpTmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcImdvb2dsZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkR2VtaW5pQVBJKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBzdXBlci5hcGk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkNoYXRDb25uZWN0aW9uID0gQ2hhdENvbm5lY3Rpb247XG4vKipcbiAqIEludGVncmF0aW9uIHdpdGggYSBHb29nbGUgY2hhdCBtb2RlbC5cbiAqL1xuY2xhc3MgQ2hhdEdvb2dsZUJhc2UgZXh0ZW5kcyBjaGF0X21vZGVsc18xLkJhc2VDaGF0TW9kZWwge1xuICAgIC8vIFVzZWQgZm9yIHRyYWNpbmcsIHJlcGxhY2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHlvdXIgY2xhc3NcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2hhdEdvb2dsZVwiO1xuICAgIH1cbiAgICBnZXQgbGNfc2VjcmV0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGF1dGhPcHRpb25zOiBcIkdPT0dMRV9BVVRIX09QVElPTlNcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKCgwLCBmYWlsZWRfaGFuZGxlcl9qc18xLmVuc3VyZVBhcmFtcykoZmllbGRzKSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2V0IGJhc2VkIG9uIG1vZGVsTmFtZVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtb2RlbFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtb2RlbE5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiZ2VtaW5pLXByb1wiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0ZW1wZXJhdHVyZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMC43XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhPdXRwdXRUb2tlbnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDEwMjRcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvcFBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDAuOFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9wS1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogNDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByZXNlbmNlUGVuYWx0eVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmcmVxdWVuY3lQZW5hbHR5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0b3BTZXF1ZW5jZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsb2dwcm9ic1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3BMb2dwcm9ic1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2FmZXR5U2V0dGluZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBNYXkgaW50ZW50aW9uYWxseSBiZSB1bmRlZmluZWQsIG1lYW5pbmcgdG8gY29tcHV0ZSB0aGlzLlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb252ZXJ0U3lzdGVtTWVzc2FnZVRvSHVtYW5Db250ZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNhZmV0eUhhbmRsZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RyZWFtVXNhZ2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0cmVhbWluZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbm5lY3Rpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RyZWFtZWRDb25uZWN0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgICgwLCBjb21tb25fanNfMS5jb3B5QW5kVmFsaWRhdGVNb2RlbFBhcmFtc0ludG8pKGZpZWxkcywgdGhpcyk7XG4gICAgICAgIHRoaXMuc2FmZXR5SGFuZGxlciA9XG4gICAgICAgICAgICBmaWVsZHM/LnNhZmV0eUhhbmRsZXIgPz8gbmV3IGdlbWluaV9qc18xLkRlZmF1bHRHZW1pbmlTYWZldHlIYW5kbGVyKCk7XG4gICAgICAgIHRoaXMuc3RyZWFtVXNhZ2UgPSBmaWVsZHM/LnN0cmVhbVVzYWdlID8/IHRoaXMuc3RyZWFtVXNhZ2U7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuYnVpbGRDbGllbnQoZmllbGRzKTtcbiAgICAgICAgdGhpcy5idWlsZENvbm5lY3Rpb24oZmllbGRzID8/IHt9LCBjbGllbnQpO1xuICAgIH1cbiAgICBnZXRMc1BhcmFtcyhvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuaW52b2NhdGlvblBhcmFtcyhvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxzX3Byb3ZpZGVyOiBcImdvb2dsZV92ZXJ0ZXhhaVwiLFxuICAgICAgICAgICAgbHNfbW9kZWxfbmFtZTogdGhpcy5tb2RlbCxcbiAgICAgICAgICAgIGxzX21vZGVsX3R5cGU6IFwiY2hhdFwiLFxuICAgICAgICAgICAgbHNfdGVtcGVyYXR1cmU6IHBhcmFtcy50ZW1wZXJhdHVyZSA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICBsc19tYXhfdG9rZW5zOiBwYXJhbXMubWF4T3V0cHV0VG9rZW5zID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxzX3N0b3A6IG9wdGlvbnMuc3RvcCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYnVpbGRBcGlLZXlDbGllbnQoYXBpS2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgYXV0aF9qc18xLkFwaUtleUdvb2dsZUF1dGgoYXBpS2V5KTtcbiAgICB9XG4gICAgYnVpbGRBcGlLZXkoZmllbGRzKSB7XG4gICAgICAgIGlmIChmaWVsZHM/LnBsYXRmb3JtVHlwZSAhPT0gXCJnY3BcIikge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkcz8uYXBpS2V5ID8/ICgwLCBlbnZfMS5nZXRFbnZpcm9ubWVudFZhcmlhYmxlKShcIkdPT0dMRV9BUElfS0VZXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gR0NQIGRvZXNuJ3Qgc3VwcG9ydCBBUEkgS2V5c1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBidWlsZENsaWVudChmaWVsZHMpIHtcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gdGhpcy5idWlsZEFwaUtleShmaWVsZHMpO1xuICAgICAgICBpZiAoYXBpS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZEFwaUtleUNsaWVudChhcGlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRBYnN0cmFjdGVkQ2xpZW50KGZpZWxkcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnVpbGRDb25uZWN0aW9uKGZpZWxkcywgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG5ldyBDaGF0Q29ubmVjdGlvbih7IC4uLmZpZWxkcywgLi4udGhpcyB9LCB0aGlzLmNhbGxlciwgY2xpZW50LCBmYWxzZSk7XG4gICAgICAgIHRoaXMuc3RyZWFtZWRDb25uZWN0aW9uID0gbmV3IENoYXRDb25uZWN0aW9uKHsgLi4uZmllbGRzLCAuLi50aGlzIH0sIHRoaXMuY2FsbGVyLCBjbGllbnQsIHRydWUpO1xuICAgIH1cbiAgICBnZXQgcGxhdGZvcm0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24ucGxhdGZvcm07XG4gICAgfVxuICAgIGJpbmRUb29scyh0b29scywga3dhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmQoeyB0b29sczogKDAsIGNvbW1vbl9qc18xLmNvbnZlcnRUb0dlbWluaVRvb2xzKSh0b29scyksIC4uLmt3YXJncyB9KTtcbiAgICB9XG4gICAgLy8gUmVwbGFjZVxuICAgIF9sbG1UeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJjaGF0X2ludGVncmF0aW9uXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcGFyYW1ldGVycyB1c2VkIHRvIGludm9rZSB0aGUgbW9kZWxcbiAgICAgKi9cbiAgICBpbnZvY2F0aW9uUGFyYW1zKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBjb21tb25fanNfMS5jb3B5QUlNb2RlbFBhcmFtcykodGhpcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIF9nZW5lcmF0ZShtZXNzYWdlcywgb3B0aW9ucywgcnVuTWFuYWdlcikge1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gdGhpcy5pbnZvY2F0aW9uUGFyYW1zKG9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5zdHJlYW1pbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX3N0cmVhbVJlc3BvbnNlQ2h1bmtzKG1lc3NhZ2VzLCBvcHRpb25zLCBydW5NYW5hZ2VyKTtcbiAgICAgICAgICAgIGxldCBmaW5hbENodW5rID0gbnVsbDtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgZmluYWxDaHVuayA9ICFmaW5hbENodW5rID8gY2h1bmsgOiAoMCwgc3RyZWFtXzEuY29uY2F0KShmaW5hbENodW5rLCBjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZpbmFsQ2h1bmspIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjaHVua3Mgd2VyZSByZXR1cm5lZCBmcm9tIHRoZSBzdHJlYW0uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBnZW5lcmF0aW9uczogW2ZpbmFsQ2h1bmtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5yZXF1ZXN0KG1lc3NhZ2VzLCBwYXJhbWV0ZXJzLCBvcHRpb25zLCBydW5NYW5hZ2VyKTtcbiAgICAgICAgY29uc3QgcmV0ID0gdGhpcy5jb25uZWN0aW9uLmFwaS5yZXNwb25zZVRvQ2hhdFJlc3VsdChyZXNwb25zZSk7XG4gICAgICAgIGNvbnN0IGNodW5rID0gcmV0Py5nZW5lcmF0aW9ucz8uWzBdO1xuICAgICAgICBpZiAoY2h1bmspIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUxMTU5ld1Rva2VuKGNodW5rLnRleHQgfHwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgYXN5bmMgKl9zdHJlYW1SZXNwb25zZUNodW5rcyhfbWVzc2FnZXMsIG9wdGlvbnMsIHJ1bk1hbmFnZXIpIHtcbiAgICAgICAgLy8gTWFrZSB0aGUgY2FsbCBhcyBhIHN0cmVhbWluZyByZXF1ZXN0XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB0aGlzLmludm9jYXRpb25QYXJhbXMob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zdHJlYW1lZENvbm5lY3Rpb24ucmVxdWVzdChfbWVzc2FnZXMsIHBhcmFtZXRlcnMsIG9wdGlvbnMsIHJ1bk1hbmFnZXIpO1xuICAgICAgICAvLyBHZXQgdGhlIHN0cmVhbWluZyBwYXJzZXIgb2YgdGhlIHJlc3BvbnNlXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIGxldCB1c2FnZU1ldGFkYXRhO1xuICAgICAgICAvLyBMb29wIHVudGlsIHRoZSBlbmQgb2YgdGhlIHN0cmVhbVxuICAgICAgICAvLyBEdXJpbmcgdGhlIGxvb3AsIHlpZWxkIGVhY2ggdGltZSB3ZSBnZXQgYSBjaHVuayBmcm9tIHRoZSBzdHJlYW1pbmcgcGFyc2VyXG4gICAgICAgIC8vIHRoYXQgaXMgZWl0aGVyIGF2YWlsYWJsZSBvciBhZGRlZCB0byB0aGUgcXVldWVcbiAgICAgICAgd2hpbGUgKCFzdHJlYW0uc3RyZWFtRG9uZSkge1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgc3RyZWFtLm5leHRDaHVuaygpO1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ3VzdG9tRXZlbnQoYGdvb2dsZS1jaHVuay0ke3RoaXMuY29uc3RydWN0b3IubmFtZX1gLCB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAob3V0cHV0ICYmXG4gICAgICAgICAgICAgICAgb3V0cHV0LnVzYWdlTWV0YWRhdGEgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbVVzYWdlICE9PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RyZWFtVXNhZ2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdXNhZ2VNZXRhZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRfdG9rZW5zOiBvdXRwdXQudXNhZ2VNZXRhZGF0YS5wcm9tcHRUb2tlbkNvdW50LFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRfdG9rZW5zOiBvdXRwdXQudXNhZ2VNZXRhZGF0YS5jYW5kaWRhdGVzVG9rZW5Db3VudCxcbiAgICAgICAgICAgICAgICAgICAgdG90YWxfdG9rZW5zOiBvdXRwdXQudXNhZ2VNZXRhZGF0YS50b3RhbFRva2VuQ291bnQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gb3V0cHV0ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyB0aGlzLmNvbm5lY3Rpb24uYXBpLnJlc3BvbnNlVG9DaGF0R2VuZXJhdGlvbih7IGRhdGE6IG91dHB1dCB9KVxuICAgICAgICAgICAgICAgIDogbmV3IG91dHB1dHNfMS5DaGF0R2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbkluZm86IHsgZmluaXNoUmVhc29uOiBcInN0b3BcIiB9LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBuZXcgbWVzc2FnZXNfMS5BSU1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNhZ2VfbWV0YWRhdGE6IHVzYWdlTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlTExNTmV3VG9rZW4oY2h1bmsudGV4dCA/PyBcIlwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgY2h1bmsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICBfY29tYmluZUxMTU91dHB1dCgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB3aXRoU3RydWN0dXJlZE91dHB1dChvdXRwdXRTY2hlbWEsIGNvbmZpZykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBzY2hlbWEgPSBvdXRwdXRTY2hlbWE7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBjb25maWc/Lm5hbWU7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGNvbmZpZz8ubWV0aG9kO1xuICAgICAgICBjb25zdCBpbmNsdWRlUmF3ID0gY29uZmlnPy5pbmNsdWRlUmF3O1xuICAgICAgICBpZiAobWV0aG9kID09PSBcImpzb25Nb2RlXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR29vZ2xlIG9ubHkgc3VwcG9ydHMgXCJmdW5jdGlvbkNhbGxpbmdcIiBhcyBhIG1ldGhvZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZnVuY3Rpb25OYW1lID0gbmFtZSA/PyBcImV4dHJhY3RcIjtcbiAgICAgICAgbGV0IG91dHB1dFBhcnNlcjtcbiAgICAgICAgbGV0IHRvb2xzO1xuICAgICAgICBpZiAoaXNab2RTY2hlbWEoc2NoZW1hKSkge1xuICAgICAgICAgICAgY29uc3QganNvblNjaGVtYSA9ICgwLCB6b2RfdG9fZ2VtaW5pX3BhcmFtZXRlcnNfanNfMS56b2RUb0dlbWluaVBhcmFtZXRlcnMpKHNjaGVtYSk7XG4gICAgICAgICAgICB0b29scyA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBqc29uU2NoZW1hLmRlc2NyaXB0aW9uID8/IFwiQSBmdW5jdGlvbiBhdmFpbGFibGUgdG8gY2FsbC5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBqc29uU2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIG91dHB1dFBhcnNlciA9IG5ldyBvcGVuYWlfdG9vbHNfMS5Kc29uT3V0cHV0S2V5VG9vbHNQYXJzZXIoe1xuICAgICAgICAgICAgICAgIHJldHVyblNpbmdsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBrZXlOYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgem9kU2NoZW1hOiBzY2hlbWEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBnZW1pbmlGdW5jdGlvbkRlZmluaXRpb247XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5uYW1lID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHNjaGVtYS5wYXJhbWV0ZXJzID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgc2NoZW1hLnBhcmFtZXRlcnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdlbWluaUZ1bmN0aW9uRGVmaW5pdGlvbiA9IHNjaGVtYTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSBzY2hlbWEubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlbWluaUZ1bmN0aW9uRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogc2NoZW1hLmRlc2NyaXB0aW9uID8/IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHNjaGVtYSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9vbHMgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uczogW2dlbWluaUZ1bmN0aW9uRGVmaW5pdGlvbl0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBvdXRwdXRQYXJzZXIgPSBuZXcgb3BlbmFpX3Rvb2xzXzEuSnNvbk91dHB1dEtleVRvb2xzUGFyc2VyKHtcbiAgICAgICAgICAgICAgICByZXR1cm5TaW5nbGU6IHRydWUsXG4gICAgICAgICAgICAgICAga2V5TmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGxtID0gdGhpcy5iaW5kKHtcbiAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgdG9vbF9jaG9pY2U6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaW5jbHVkZVJhdykge1xuICAgICAgICAgICAgcmV0dXJuIGxsbS5waXBlKG91dHB1dFBhcnNlcikud2l0aENvbmZpZyh7XG4gICAgICAgICAgICAgICAgcnVuTmFtZTogXCJDaGF0R29vZ2xlU3RydWN0dXJlZE91dHB1dFwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VyQXNzaWduID0gcnVubmFibGVzXzEuUnVubmFibGVQYXNzdGhyb3VnaC5hc3NpZ24oe1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHBhcnNlZDogKGlucHV0LCBjb25maWcpID0+IG91dHB1dFBhcnNlci5pbnZva2UoaW5wdXQucmF3LCBjb25maWcpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGFyc2VyTm9uZSA9IHJ1bm5hYmxlc18xLlJ1bm5hYmxlUGFzc3Rocm91Z2guYXNzaWduKHtcbiAgICAgICAgICAgIHBhcnNlZDogKCkgPT4gbnVsbCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHBhcnNlZFdpdGhGYWxsYmFjayA9IHBhcnNlckFzc2lnbi53aXRoRmFsbGJhY2tzKHtcbiAgICAgICAgICAgIGZhbGxiYWNrczogW3BhcnNlck5vbmVdLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJ1bm5hYmxlc18xLlJ1bm5hYmxlU2VxdWVuY2UuZnJvbShbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmF3OiBsbG0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyc2VkV2l0aEZhbGxiYWNrLFxuICAgICAgICBdKS53aXRoQ29uZmlnKHtcbiAgICAgICAgICAgIHJ1bk5hbWU6IFwiU3RydWN0dXJlZE91dHB1dFJ1bm5hYmxlXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhdEdvb2dsZUJhc2UgPSBDaGF0R29vZ2xlQmFzZTtcbmZ1bmN0aW9uIGlzWm9kU2NoZW1hKFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmlucHV0KSB7XG4gICAgLy8gQ2hlY2sgZm9yIGEgY2hhcmFjdGVyaXN0aWMgbWV0aG9kIG9mIFpvZCBzY2hlbWFzXG4gICAgcmV0dXJuIHR5cGVvZiBpbnB1dD8ucGFyc2UgPT09IFwiZnVuY3Rpb25cIjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/chat_models.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/connection.cjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/connection.cjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GoogleRequestRecorder = exports.GoogleRequestLogger = exports.GoogleRequestCallbackHandler = exports.AbstractGoogleLLMConnection = exports.GoogleAIConnection = exports.GoogleRawConnection = exports.GoogleHostConnection = exports.GoogleConnection = void 0;\nconst env_1 = __webpack_require__(/*! @langchain/core/utils/env */ \"(rsc)/./node_modules/@langchain/core/utils/env.cjs\");\nconst base_1 = __webpack_require__(/*! @langchain/core/callbacks/base */ \"(rsc)/./node_modules/@langchain/core/callbacks/base.cjs\");\nconst index_js_1 = __webpack_require__(/*! ./utils/index.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/index.cjs\");\nconst anthropic_js_1 = __webpack_require__(/*! ./utils/anthropic.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/anthropic.cjs\");\nclass GoogleConnection {\n    constructor(caller, client, streaming) {\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"streaming\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.caller = caller;\n        this.client = client;\n        this.streaming = streaming ?? false;\n    }\n    async _clientInfoHeaders() {\n        const { userAgent, clientLibraryVersion } = await this._getClientInfo();\n        return {\n            \"User-Agent\": userAgent,\n            \"Client-Info\": clientLibraryVersion,\n        };\n    }\n    async _getClientInfo() {\n        const env = await (0, env_1.getRuntimeEnvironment)();\n        const langchain = env?.library ?? \"langchain-js\";\n        // TODO: Add an API for getting the current LangChain version\n        const langchainVersion = \"0\";\n        const moduleName = await this._moduleName();\n        let clientLibraryVersion = `${langchain}/${langchainVersion}`;\n        if (moduleName && moduleName.length) {\n            clientLibraryVersion = `${clientLibraryVersion}-${moduleName}`;\n        }\n        return {\n            userAgent: clientLibraryVersion,\n            clientLibraryVersion: `${langchainVersion}-${moduleName}`,\n        };\n    }\n    async _moduleName() {\n        return this.constructor.name;\n    }\n    async additionalHeaders() {\n        return {};\n    }\n    async _buildOpts(data, _options, requestHeaders = {}) {\n        const url = await this.buildUrl();\n        const method = this.buildMethod();\n        const infoHeaders = (await this._clientInfoHeaders()) ?? {};\n        const additionalHeaders = (await this.additionalHeaders()) ?? {};\n        const headers = {\n            ...infoHeaders,\n            ...additionalHeaders,\n            ...requestHeaders,\n        };\n        const opts = {\n            url,\n            method,\n            headers,\n        };\n        if (data && method === \"POST\") {\n            opts.data = data;\n        }\n        if (this.streaming) {\n            opts.responseType = \"stream\";\n        }\n        else {\n            opts.responseType = \"json\";\n        }\n        return opts;\n    }\n    async _request(data, options, requestHeaders = {}) {\n        const opts = await this._buildOpts(data, options, requestHeaders);\n        const callResponse = await this.caller.callWithOptions({ signal: options?.signal }, async () => this.client.request(opts));\n        const response = callResponse; // Done for typecast safety, I guess\n        return response;\n    }\n}\nexports.GoogleConnection = GoogleConnection;\nclass GoogleHostConnection extends GoogleConnection {\n    constructor(fields, caller, client, streaming) {\n        super(caller, client, streaming);\n        // This does not default to a value intentionally.\n        // Use the \"platform\" getter if you need this.\n        Object.defineProperty(this, \"platformType\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_endpoint\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_location\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiVersion\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"v1\"\n        });\n        this.caller = caller;\n        this.platformType = fields?.platformType;\n        this._endpoint = fields?.endpoint;\n        this._location = fields?.location;\n        this.apiVersion = fields?.apiVersion ?? this.apiVersion;\n        this.client = client;\n    }\n    get platform() {\n        return this.platformType ?? this.computedPlatformType;\n    }\n    get computedPlatformType() {\n        return \"gcp\";\n    }\n    get location() {\n        return this._location ?? this.computedLocation;\n    }\n    get computedLocation() {\n        return \"us-central1\";\n    }\n    get endpoint() {\n        return this._endpoint ?? this.computedEndpoint;\n    }\n    get computedEndpoint() {\n        return `${this.location}-aiplatform.googleapis.com`;\n    }\n    buildMethod() {\n        return \"POST\";\n    }\n}\nexports.GoogleHostConnection = GoogleHostConnection;\nclass GoogleRawConnection extends GoogleHostConnection {\n    async _buildOpts(data, _options, requestHeaders = {}) {\n        const opts = await super._buildOpts(data, _options, requestHeaders);\n        opts.responseType = \"blob\";\n        return opts;\n    }\n}\nexports.GoogleRawConnection = GoogleRawConnection;\nclass GoogleAIConnection extends GoogleHostConnection {\n    constructor(fields, caller, client, streaming) {\n        super(fields, caller, client, streaming);\n        Object.defineProperty(this, \"model\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"modelName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_apiName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiConfig\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.client = client;\n        this.modelName = fields?.model ?? fields?.modelName ?? this.model;\n        this.model = this.modelName;\n        this._apiName = fields?.apiName;\n        this.apiConfig = {\n            safetyHandler: fields?.safetyHandler,\n            ...fields?.apiConfig,\n        };\n    }\n    get modelFamily() {\n        return (0, index_js_1.modelToFamily)(this.model);\n    }\n    get modelPublisher() {\n        return (0, index_js_1.modelToPublisher)(this.model);\n    }\n    get computedAPIName() {\n        // At least at the moment, model publishers and APIs map the same\n        return this.modelPublisher;\n    }\n    get apiName() {\n        return this._apiName ?? this.computedAPIName;\n    }\n    get api() {\n        switch (this.apiName) {\n            case \"google\":\n                return (0, index_js_1.getGeminiAPI)(this.apiConfig);\n            case \"anthropic\":\n                return (0, anthropic_js_1.getAnthropicAPI)(this.apiConfig);\n            default:\n                throw new Error(`Unknown API: ${this.apiName}`);\n        }\n    }\n    get computedPlatformType() {\n        if (this.client.clientType === \"apiKey\") {\n            return \"gai\";\n        }\n        else {\n            return \"gcp\";\n        }\n    }\n    get computedLocation() {\n        switch (this.apiName) {\n            case \"google\":\n                return super.computedLocation;\n            case \"anthropic\":\n                return \"us-east5\";\n            default:\n                throw new Error(`Unknown apiName: ${this.apiName}. Can't get location.`);\n        }\n    }\n    async buildUrlGenerativeLanguage() {\n        const method = await this.buildUrlMethod();\n        const url = `https://generativelanguage.googleapis.com/${this.apiVersion}/models/${this.model}:${method}`;\n        return url;\n    }\n    async buildUrlVertex() {\n        const projectId = await this.client.getProjectId();\n        const method = await this.buildUrlMethod();\n        const publisher = this.modelPublisher;\n        const url = `https://${this.endpoint}/${this.apiVersion}/projects/${projectId}/locations/${this.location}/publishers/${publisher}/models/${this.model}:${method}`;\n        return url;\n    }\n    async buildUrl() {\n        switch (this.platform) {\n            case \"gai\":\n                return this.buildUrlGenerativeLanguage();\n            default:\n                return this.buildUrlVertex();\n        }\n    }\n    async request(input, parameters, options, runManager) {\n        const moduleName = this.constructor.name;\n        const streamingParameters = {\n            ...parameters,\n            streaming: this.streaming,\n        };\n        const data = await this.formatData(input, streamingParameters);\n        await runManager?.handleCustomEvent(`google-request-${moduleName}`, {\n            data,\n            parameters: streamingParameters,\n            options,\n            connection: {\n                ...this,\n                url: await this.buildUrl(),\n                urlMethod: await this.buildUrlMethod(),\n                modelFamily: this.modelFamily,\n                modelPublisher: this.modelPublisher,\n                computedPlatformType: this.computedPlatformType,\n            },\n        });\n        const response = await this._request(data, options);\n        await runManager?.handleCustomEvent(`google-response-${moduleName}`, {\n            response,\n        });\n        return response;\n    }\n}\nexports.GoogleAIConnection = GoogleAIConnection;\nclass AbstractGoogleLLMConnection extends GoogleAIConnection {\n    async buildUrlMethodGemini() {\n        return this.streaming ? \"streamGenerateContent\" : \"generateContent\";\n    }\n    async buildUrlMethodClaude() {\n        return this.streaming ? \"streamRawPredict\" : \"rawPredict\";\n    }\n    async buildUrlMethod() {\n        switch (this.modelFamily) {\n            case \"gemini\":\n                return this.buildUrlMethodGemini();\n            case \"claude\":\n                return this.buildUrlMethodClaude();\n            default:\n                throw new Error(`Unknown model family: ${this.modelFamily}`);\n        }\n    }\n    async formatData(input, parameters) {\n        return this.api.formatData(input, parameters);\n    }\n}\nexports.AbstractGoogleLLMConnection = AbstractGoogleLLMConnection;\nclass GoogleRequestCallbackHandler extends base_1.BaseCallbackHandler {\n    customEventInfo(eventName) {\n        const names = eventName.split(\"-\");\n        return {\n            subEvent: names[1],\n            module: names[2],\n        };\n    }\n    handleCustomEvent(eventName, data, runId, tags, metadata) {\n        if (!eventName) {\n            return undefined;\n        }\n        const eventInfo = this.customEventInfo(eventName);\n        switch (eventInfo.subEvent) {\n            case \"request\":\n                return this.handleCustomRequestEvent(eventName, eventInfo, data, runId, tags, metadata);\n            case \"response\":\n                return this.handleCustomResponseEvent(eventName, eventInfo, data, runId, tags, metadata);\n            case \"chunk\":\n                return this.handleCustomChunkEvent(eventName, eventInfo, data, runId, tags, metadata);\n            default:\n                console.error(`Unexpected eventInfo for ${eventName} ${JSON.stringify(eventInfo, null, 1)}`);\n        }\n    }\n}\nexports.GoogleRequestCallbackHandler = GoogleRequestCallbackHandler;\nclass GoogleRequestLogger extends GoogleRequestCallbackHandler {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"GoogleRequestLogger\"\n        });\n    }\n    log(eventName, data, tags) {\n        const tagStr = tags ? `[${tags}]` : \"[]\";\n        console.log(`${eventName} ${tagStr} ${JSON.stringify(data, null, 1)}`);\n    }\n    handleCustomRequestEvent(eventName, _eventInfo, data, _runId, tags, _metadata) {\n        this.log(eventName, data, tags);\n    }\n    handleCustomResponseEvent(eventName, _eventInfo, data, _runId, tags, _metadata) {\n        this.log(eventName, data, tags);\n    }\n    handleCustomChunkEvent(eventName, _eventInfo, data, _runId, tags, _metadata) {\n        this.log(eventName, data, tags);\n    }\n}\nexports.GoogleRequestLogger = GoogleRequestLogger;\nclass GoogleRequestRecorder extends GoogleRequestCallbackHandler {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"GoogleRequestRecorder\"\n        });\n        Object.defineProperty(this, \"request\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"response\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"chunk\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n    }\n    handleCustomRequestEvent(_eventName, _eventInfo, data, _runId, _tags, _metadata) {\n        this.request = data;\n    }\n    handleCustomResponseEvent(_eventName, _eventInfo, data, _runId, _tags, _metadata) {\n        this.response = data;\n    }\n    handleCustomChunkEvent(_eventName, _eventInfo, data, _runId, _tags, _metadata) {\n        this.chunk.push(data);\n    }\n}\nexports.GoogleRequestRecorder = GoogleRequestRecorder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvY29ubmVjdGlvbi5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcsMkJBQTJCLEdBQUcsb0NBQW9DLEdBQUcsbUNBQW1DLEdBQUcsMEJBQTBCLEdBQUcsMkJBQTJCLEdBQUcsNEJBQTRCLEdBQUcsd0JBQXdCO0FBQzdQLGNBQWMsbUJBQU8sQ0FBQyxxRkFBMkI7QUFDakQsZUFBZSxtQkFBTyxDQUFDLCtGQUFnQztBQUN2RCxtQkFBbUIsbUJBQU8sQ0FBQyw2RkFBbUI7QUFDOUMsdUJBQXVCLG1CQUFPLENBQUMscUdBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtDQUFrQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsR0FBRyxpQkFBaUI7QUFDcEU7QUFDQSxzQ0FBc0MscUJBQXFCLEdBQUcsV0FBVztBQUN6RTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUJBQWlCLEdBQUcsV0FBVztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EsaUVBQWlFLHlCQUF5QjtBQUMxRix1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGFBQWE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZ0JBQWdCLFVBQVUsV0FBVyxHQUFHLE9BQU87QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWMsR0FBRyxnQkFBZ0IsWUFBWSxVQUFVLGFBQWEsY0FBYyxjQUFjLFVBQVUsVUFBVSxXQUFXLEdBQUcsT0FBTztBQUN4SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFdBQVc7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsK0RBQStELFdBQVc7QUFDMUU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsaUJBQWlCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsV0FBVyxFQUFFLG1DQUFtQztBQUMxRztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0NBQWtDLEtBQUs7QUFDdkMsdUJBQXVCLFdBQVcsRUFBRSxRQUFRLEVBQUUsOEJBQThCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvY29ubmVjdGlvbi5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdvb2dsZVJlcXVlc3RSZWNvcmRlciA9IGV4cG9ydHMuR29vZ2xlUmVxdWVzdExvZ2dlciA9IGV4cG9ydHMuR29vZ2xlUmVxdWVzdENhbGxiYWNrSGFuZGxlciA9IGV4cG9ydHMuQWJzdHJhY3RHb29nbGVMTE1Db25uZWN0aW9uID0gZXhwb3J0cy5Hb29nbGVBSUNvbm5lY3Rpb24gPSBleHBvcnRzLkdvb2dsZVJhd0Nvbm5lY3Rpb24gPSBleHBvcnRzLkdvb2dsZUhvc3RDb25uZWN0aW9uID0gZXhwb3J0cy5Hb29nbGVDb25uZWN0aW9uID0gdm9pZCAwO1xuY29uc3QgZW52XzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2VudlwiKTtcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvY2FsbGJhY2tzL2Jhc2VcIik7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4vdXRpbHMvaW5kZXguY2pzXCIpO1xuY29uc3QgYW50aHJvcGljX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy9hbnRocm9waWMuY2pzXCIpO1xuY2xhc3MgR29vZ2xlQ29ubmVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoY2FsbGVyLCBjbGllbnQsIHN0cmVhbWluZykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYWxsZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2xpZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0cmVhbWluZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbGxlciA9IGNhbGxlcjtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIHRoaXMuc3RyZWFtaW5nID0gc3RyZWFtaW5nID8/IGZhbHNlO1xuICAgIH1cbiAgICBhc3luYyBfY2xpZW50SW5mb0hlYWRlcnMoKSB7XG4gICAgICAgIGNvbnN0IHsgdXNlckFnZW50LCBjbGllbnRMaWJyYXJ5VmVyc2lvbiB9ID0gYXdhaXQgdGhpcy5fZ2V0Q2xpZW50SW5mbygpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgXCJVc2VyLUFnZW50XCI6IHVzZXJBZ2VudCxcbiAgICAgICAgICAgIFwiQ2xpZW50LUluZm9cIjogY2xpZW50TGlicmFyeVZlcnNpb24sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIF9nZXRDbGllbnRJbmZvKCkge1xuICAgICAgICBjb25zdCBlbnYgPSBhd2FpdCAoMCwgZW52XzEuZ2V0UnVudGltZUVudmlyb25tZW50KSgpO1xuICAgICAgICBjb25zdCBsYW5nY2hhaW4gPSBlbnY/LmxpYnJhcnkgPz8gXCJsYW5nY2hhaW4tanNcIjtcbiAgICAgICAgLy8gVE9ETzogQWRkIGFuIEFQSSBmb3IgZ2V0dGluZyB0aGUgY3VycmVudCBMYW5nQ2hhaW4gdmVyc2lvblxuICAgICAgICBjb25zdCBsYW5nY2hhaW5WZXJzaW9uID0gXCIwXCI7XG4gICAgICAgIGNvbnN0IG1vZHVsZU5hbWUgPSBhd2FpdCB0aGlzLl9tb2R1bGVOYW1lKCk7XG4gICAgICAgIGxldCBjbGllbnRMaWJyYXJ5VmVyc2lvbiA9IGAke2xhbmdjaGFpbn0vJHtsYW5nY2hhaW5WZXJzaW9ufWA7XG4gICAgICAgIGlmIChtb2R1bGVOYW1lICYmIG1vZHVsZU5hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBjbGllbnRMaWJyYXJ5VmVyc2lvbiA9IGAke2NsaWVudExpYnJhcnlWZXJzaW9ufS0ke21vZHVsZU5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlckFnZW50OiBjbGllbnRMaWJyYXJ5VmVyc2lvbixcbiAgICAgICAgICAgIGNsaWVudExpYnJhcnlWZXJzaW9uOiBgJHtsYW5nY2hhaW5WZXJzaW9ufS0ke21vZHVsZU5hbWV9YCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgX21vZHVsZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgfVxuICAgIGFzeW5jIGFkZGl0aW9uYWxIZWFkZXJzKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGFzeW5jIF9idWlsZE9wdHMoZGF0YSwgX29wdGlvbnMsIHJlcXVlc3RIZWFkZXJzID0ge30pIHtcbiAgICAgICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5idWlsZFVybCgpO1xuICAgICAgICBjb25zdCBtZXRob2QgPSB0aGlzLmJ1aWxkTWV0aG9kKCk7XG4gICAgICAgIGNvbnN0IGluZm9IZWFkZXJzID0gKGF3YWl0IHRoaXMuX2NsaWVudEluZm9IZWFkZXJzKCkpID8/IHt9O1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsSGVhZGVycyA9IChhd2FpdCB0aGlzLmFkZGl0aW9uYWxIZWFkZXJzKCkpID8/IHt9O1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgLi4uaW5mb0hlYWRlcnMsXG4gICAgICAgICAgICAuLi5hZGRpdGlvbmFsSGVhZGVycyxcbiAgICAgICAgICAgIC4uLnJlcXVlc3RIZWFkZXJzLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRhdGEgJiYgbWV0aG9kID09PSBcIlBPU1RcIikge1xuICAgICAgICAgICAgb3B0cy5kYXRhID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdHJlYW1pbmcpIHtcbiAgICAgICAgICAgIG9wdHMucmVzcG9uc2VUeXBlID0gXCJzdHJlYW1cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdHMucmVzcG9uc2VUeXBlID0gXCJqc29uXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgfVxuICAgIGFzeW5jIF9yZXF1ZXN0KGRhdGEsIG9wdGlvbnMsIHJlcXVlc3RIZWFkZXJzID0ge30pIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IGF3YWl0IHRoaXMuX2J1aWxkT3B0cyhkYXRhLCBvcHRpb25zLCByZXF1ZXN0SGVhZGVycyk7XG4gICAgICAgIGNvbnN0IGNhbGxSZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGxXaXRoT3B0aW9ucyh7IHNpZ25hbDogb3B0aW9ucz8uc2lnbmFsIH0sIGFzeW5jICgpID0+IHRoaXMuY2xpZW50LnJlcXVlc3Qob3B0cykpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGNhbGxSZXNwb25zZTsgLy8gRG9uZSBmb3IgdHlwZWNhc3Qgc2FmZXR5LCBJIGd1ZXNzXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG5leHBvcnRzLkdvb2dsZUNvbm5lY3Rpb24gPSBHb29nbGVDb25uZWN0aW9uO1xuY2xhc3MgR29vZ2xlSG9zdENvbm5lY3Rpb24gZXh0ZW5kcyBHb29nbGVDb25uZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIGNhbGxlciwgY2xpZW50LCBzdHJlYW1pbmcpIHtcbiAgICAgICAgc3VwZXIoY2FsbGVyLCBjbGllbnQsIHN0cmVhbWluZyk7XG4gICAgICAgIC8vIFRoaXMgZG9lcyBub3QgZGVmYXVsdCB0byBhIHZhbHVlIGludGVudGlvbmFsbHkuXG4gICAgICAgIC8vIFVzZSB0aGUgXCJwbGF0Zm9ybVwiIGdldHRlciBpZiB5b3UgbmVlZCB0aGlzLlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwbGF0Zm9ybVR5cGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2VuZHBvaW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9sb2NhdGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcGlWZXJzaW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcInYxXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FsbGVyID0gY2FsbGVyO1xuICAgICAgICB0aGlzLnBsYXRmb3JtVHlwZSA9IGZpZWxkcz8ucGxhdGZvcm1UeXBlO1xuICAgICAgICB0aGlzLl9lbmRwb2ludCA9IGZpZWxkcz8uZW5kcG9pbnQ7XG4gICAgICAgIHRoaXMuX2xvY2F0aW9uID0gZmllbGRzPy5sb2NhdGlvbjtcbiAgICAgICAgdGhpcy5hcGlWZXJzaW9uID0gZmllbGRzPy5hcGlWZXJzaW9uID8/IHRoaXMuYXBpVmVyc2lvbjtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIGdldCBwbGF0Zm9ybSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGxhdGZvcm1UeXBlID8/IHRoaXMuY29tcHV0ZWRQbGF0Zm9ybVR5cGU7XG4gICAgfVxuICAgIGdldCBjb21wdXRlZFBsYXRmb3JtVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiZ2NwXCI7XG4gICAgfVxuICAgIGdldCBsb2NhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2F0aW9uID8/IHRoaXMuY29tcHV0ZWRMb2NhdGlvbjtcbiAgICB9XG4gICAgZ2V0IGNvbXB1dGVkTG9jYXRpb24oKSB7XG4gICAgICAgIHJldHVybiBcInVzLWNlbnRyYWwxXCI7XG4gICAgfVxuICAgIGdldCBlbmRwb2ludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZHBvaW50ID8/IHRoaXMuY29tcHV0ZWRFbmRwb2ludDtcbiAgICB9XG4gICAgZ2V0IGNvbXB1dGVkRW5kcG9pbnQoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmxvY2F0aW9ufS1haXBsYXRmb3JtLmdvb2dsZWFwaXMuY29tYDtcbiAgICB9XG4gICAgYnVpbGRNZXRob2QoKSB7XG4gICAgICAgIHJldHVybiBcIlBPU1RcIjtcbiAgICB9XG59XG5leHBvcnRzLkdvb2dsZUhvc3RDb25uZWN0aW9uID0gR29vZ2xlSG9zdENvbm5lY3Rpb247XG5jbGFzcyBHb29nbGVSYXdDb25uZWN0aW9uIGV4dGVuZHMgR29vZ2xlSG9zdENvbm5lY3Rpb24ge1xuICAgIGFzeW5jIF9idWlsZE9wdHMoZGF0YSwgX29wdGlvbnMsIHJlcXVlc3RIZWFkZXJzID0ge30pIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IGF3YWl0IHN1cGVyLl9idWlsZE9wdHMoZGF0YSwgX29wdGlvbnMsIHJlcXVlc3RIZWFkZXJzKTtcbiAgICAgICAgb3B0cy5yZXNwb25zZVR5cGUgPSBcImJsb2JcIjtcbiAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgfVxufVxuZXhwb3J0cy5Hb29nbGVSYXdDb25uZWN0aW9uID0gR29vZ2xlUmF3Q29ubmVjdGlvbjtcbmNsYXNzIEdvb2dsZUFJQ29ubmVjdGlvbiBleHRlbmRzIEdvb2dsZUhvc3RDb25uZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIGNhbGxlciwgY2xpZW50LCBzdHJlYW1pbmcpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzLCBjYWxsZXIsIGNsaWVudCwgc3RyZWFtaW5nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibW9kZWxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibW9kZWxOYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNsaWVudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfYXBpTmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcGlDb25maWdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIHRoaXMubW9kZWxOYW1lID0gZmllbGRzPy5tb2RlbCA/PyBmaWVsZHM/Lm1vZGVsTmFtZSA/PyB0aGlzLm1vZGVsO1xuICAgICAgICB0aGlzLm1vZGVsID0gdGhpcy5tb2RlbE5hbWU7XG4gICAgICAgIHRoaXMuX2FwaU5hbWUgPSBmaWVsZHM/LmFwaU5hbWU7XG4gICAgICAgIHRoaXMuYXBpQ29uZmlnID0ge1xuICAgICAgICAgICAgc2FmZXR5SGFuZGxlcjogZmllbGRzPy5zYWZldHlIYW5kbGVyLFxuICAgICAgICAgICAgLi4uZmllbGRzPy5hcGlDb25maWcsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCBtb2RlbEZhbWlseSgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18xLm1vZGVsVG9GYW1pbHkpKHRoaXMubW9kZWwpO1xuICAgIH1cbiAgICBnZXQgbW9kZWxQdWJsaXNoZXIoKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS5tb2RlbFRvUHVibGlzaGVyKSh0aGlzLm1vZGVsKTtcbiAgICB9XG4gICAgZ2V0IGNvbXB1dGVkQVBJTmFtZSgpIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgYXQgdGhlIG1vbWVudCwgbW9kZWwgcHVibGlzaGVycyBhbmQgQVBJcyBtYXAgdGhlIHNhbWVcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWxQdWJsaXNoZXI7XG4gICAgfVxuICAgIGdldCBhcGlOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBpTmFtZSA/PyB0aGlzLmNvbXB1dGVkQVBJTmFtZTtcbiAgICB9XG4gICAgZ2V0IGFwaSgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmFwaU5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJnb29nbGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuZ2V0R2VtaW5pQVBJKSh0aGlzLmFwaUNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlIFwiYW50aHJvcGljXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBhbnRocm9waWNfanNfMS5nZXRBbnRocm9waWNBUEkpKHRoaXMuYXBpQ29uZmlnKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIEFQSTogJHt0aGlzLmFwaU5hbWV9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNvbXB1dGVkUGxhdGZvcm1UeXBlKCkge1xuICAgICAgICBpZiAodGhpcy5jbGllbnQuY2xpZW50VHlwZSA9PT0gXCJhcGlLZXlcIikge1xuICAgICAgICAgICAgcmV0dXJuIFwiZ2FpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJnY3BcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY29tcHV0ZWRMb2NhdGlvbigpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmFwaU5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJnb29nbGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXIuY29tcHV0ZWRMb2NhdGlvbjtcbiAgICAgICAgICAgIGNhc2UgXCJhbnRocm9waWNcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ1cy1lYXN0NVwiO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYXBpTmFtZTogJHt0aGlzLmFwaU5hbWV9LiBDYW4ndCBnZXQgbG9jYXRpb24uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgYnVpbGRVcmxHZW5lcmF0aXZlTGFuZ3VhZ2UoKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGF3YWl0IHRoaXMuYnVpbGRVcmxNZXRob2QoKTtcbiAgICAgICAgY29uc3QgdXJsID0gYGh0dHBzOi8vZ2VuZXJhdGl2ZWxhbmd1YWdlLmdvb2dsZWFwaXMuY29tLyR7dGhpcy5hcGlWZXJzaW9ufS9tb2RlbHMvJHt0aGlzLm1vZGVsfToke21ldGhvZH1gO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBhc3luYyBidWlsZFVybFZlcnRleCgpIHtcbiAgICAgICAgY29uc3QgcHJvamVjdElkID0gYXdhaXQgdGhpcy5jbGllbnQuZ2V0UHJvamVjdElkKCk7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGF3YWl0IHRoaXMuYnVpbGRVcmxNZXRob2QoKTtcbiAgICAgICAgY29uc3QgcHVibGlzaGVyID0gdGhpcy5tb2RlbFB1Ymxpc2hlcjtcbiAgICAgICAgY29uc3QgdXJsID0gYGh0dHBzOi8vJHt0aGlzLmVuZHBvaW50fS8ke3RoaXMuYXBpVmVyc2lvbn0vcHJvamVjdHMvJHtwcm9qZWN0SWR9L2xvY2F0aW9ucy8ke3RoaXMubG9jYXRpb259L3B1Ymxpc2hlcnMvJHtwdWJsaXNoZXJ9L21vZGVscy8ke3RoaXMubW9kZWx9OiR7bWV0aG9kfWA7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIGFzeW5jIGJ1aWxkVXJsKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMucGxhdGZvcm0pIHtcbiAgICAgICAgICAgIGNhc2UgXCJnYWlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZFVybEdlbmVyYXRpdmVMYW5ndWFnZSgpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZFVybFZlcnRleCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJlcXVlc3QoaW5wdXQsIHBhcmFtZXRlcnMsIG9wdGlvbnMsIHJ1bk1hbmFnZXIpIHtcbiAgICAgICAgY29uc3QgbW9kdWxlTmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgY29uc3Qgc3RyZWFtaW5nUGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgIC4uLnBhcmFtZXRlcnMsXG4gICAgICAgICAgICBzdHJlYW1pbmc6IHRoaXMuc3RyZWFtaW5nLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5mb3JtYXREYXRhKGlucHV0LCBzdHJlYW1pbmdQYXJhbWV0ZXJzKTtcbiAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ3VzdG9tRXZlbnQoYGdvb2dsZS1yZXF1ZXN0LSR7bW9kdWxlTmFtZX1gLCB7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogc3RyZWFtaW5nUGFyYW1ldGVycyxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBjb25uZWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgLi4udGhpcyxcbiAgICAgICAgICAgICAgICB1cmw6IGF3YWl0IHRoaXMuYnVpbGRVcmwoKSxcbiAgICAgICAgICAgICAgICB1cmxNZXRob2Q6IGF3YWl0IHRoaXMuYnVpbGRVcmxNZXRob2QoKSxcbiAgICAgICAgICAgICAgICBtb2RlbEZhbWlseTogdGhpcy5tb2RlbEZhbWlseSxcbiAgICAgICAgICAgICAgICBtb2RlbFB1Ymxpc2hlcjogdGhpcy5tb2RlbFB1Ymxpc2hlcixcbiAgICAgICAgICAgICAgICBjb21wdXRlZFBsYXRmb3JtVHlwZTogdGhpcy5jb21wdXRlZFBsYXRmb3JtVHlwZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX3JlcXVlc3QoZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUN1c3RvbUV2ZW50KGBnb29nbGUtcmVzcG9uc2UtJHttb2R1bGVOYW1lfWAsIHtcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbmV4cG9ydHMuR29vZ2xlQUlDb25uZWN0aW9uID0gR29vZ2xlQUlDb25uZWN0aW9uO1xuY2xhc3MgQWJzdHJhY3RHb29nbGVMTE1Db25uZWN0aW9uIGV4dGVuZHMgR29vZ2xlQUlDb25uZWN0aW9uIHtcbiAgICBhc3luYyBidWlsZFVybE1ldGhvZEdlbWluaSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtaW5nID8gXCJzdHJlYW1HZW5lcmF0ZUNvbnRlbnRcIiA6IFwiZ2VuZXJhdGVDb250ZW50XCI7XG4gICAgfVxuICAgIGFzeW5jIGJ1aWxkVXJsTWV0aG9kQ2xhdWRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1pbmcgPyBcInN0cmVhbVJhd1ByZWRpY3RcIiA6IFwicmF3UHJlZGljdFwiO1xuICAgIH1cbiAgICBhc3luYyBidWlsZFVybE1ldGhvZCgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLm1vZGVsRmFtaWx5KSB7XG4gICAgICAgICAgICBjYXNlIFwiZ2VtaW5pXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRVcmxNZXRob2RHZW1pbmkoKTtcbiAgICAgICAgICAgIGNhc2UgXCJjbGF1ZGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZFVybE1ldGhvZENsYXVkZSgpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbW9kZWwgZmFtaWx5OiAke3RoaXMubW9kZWxGYW1pbHl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZm9ybWF0RGF0YShpbnB1dCwgcGFyYW1ldGVycykge1xuICAgICAgICByZXR1cm4gdGhpcy5hcGkuZm9ybWF0RGF0YShpbnB1dCwgcGFyYW1ldGVycyk7XG4gICAgfVxufVxuZXhwb3J0cy5BYnN0cmFjdEdvb2dsZUxMTUNvbm5lY3Rpb24gPSBBYnN0cmFjdEdvb2dsZUxMTUNvbm5lY3Rpb247XG5jbGFzcyBHb29nbGVSZXF1ZXN0Q2FsbGJhY2tIYW5kbGVyIGV4dGVuZHMgYmFzZV8xLkJhc2VDYWxsYmFja0hhbmRsZXIge1xuICAgIGN1c3RvbUV2ZW50SW5mbyhldmVudE5hbWUpIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBldmVudE5hbWUuc3BsaXQoXCItXCIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3ViRXZlbnQ6IG5hbWVzWzFdLFxuICAgICAgICAgICAgbW9kdWxlOiBuYW1lc1syXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaGFuZGxlQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCBkYXRhLCBydW5JZCwgdGFncywgbWV0YWRhdGEpIHtcbiAgICAgICAgaWYgKCFldmVudE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXZlbnRJbmZvID0gdGhpcy5jdXN0b21FdmVudEluZm8oZXZlbnROYW1lKTtcbiAgICAgICAgc3dpdGNoIChldmVudEluZm8uc3ViRXZlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJyZXF1ZXN0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlQ3VzdG9tUmVxdWVzdEV2ZW50KGV2ZW50TmFtZSwgZXZlbnRJbmZvLCBkYXRhLCBydW5JZCwgdGFncywgbWV0YWRhdGEpO1xuICAgICAgICAgICAgY2FzZSBcInJlc3BvbnNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlQ3VzdG9tUmVzcG9uc2VFdmVudChldmVudE5hbWUsIGV2ZW50SW5mbywgZGF0YSwgcnVuSWQsIHRhZ3MsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIGNhc2UgXCJjaHVua1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUN1c3RvbUNodW5rRXZlbnQoZXZlbnROYW1lLCBldmVudEluZm8sIGRhdGEsIHJ1bklkLCB0YWdzLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFVuZXhwZWN0ZWQgZXZlbnRJbmZvIGZvciAke2V2ZW50TmFtZX0gJHtKU09OLnN0cmluZ2lmeShldmVudEluZm8sIG51bGwsIDEpfWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Hb29nbGVSZXF1ZXN0Q2FsbGJhY2tIYW5kbGVyID0gR29vZ2xlUmVxdWVzdENhbGxiYWNrSGFuZGxlcjtcbmNsYXNzIEdvb2dsZVJlcXVlc3RMb2dnZXIgZXh0ZW5kcyBHb29nbGVSZXF1ZXN0Q2FsbGJhY2tIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJHb29nbGVSZXF1ZXN0TG9nZ2VyXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxvZyhldmVudE5hbWUsIGRhdGEsIHRhZ3MpIHtcbiAgICAgICAgY29uc3QgdGFnU3RyID0gdGFncyA/IGBbJHt0YWdzfV1gIDogXCJbXVwiO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHtldmVudE5hbWV9ICR7dGFnU3RyfSAke0pTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDEpfWApO1xuICAgIH1cbiAgICBoYW5kbGVDdXN0b21SZXF1ZXN0RXZlbnQoZXZlbnROYW1lLCBfZXZlbnRJbmZvLCBkYXRhLCBfcnVuSWQsIHRhZ3MsIF9tZXRhZGF0YSkge1xuICAgICAgICB0aGlzLmxvZyhldmVudE5hbWUsIGRhdGEsIHRhZ3MpO1xuICAgIH1cbiAgICBoYW5kbGVDdXN0b21SZXNwb25zZUV2ZW50KGV2ZW50TmFtZSwgX2V2ZW50SW5mbywgZGF0YSwgX3J1bklkLCB0YWdzLCBfbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5sb2coZXZlbnROYW1lLCBkYXRhLCB0YWdzKTtcbiAgICB9XG4gICAgaGFuZGxlQ3VzdG9tQ2h1bmtFdmVudChldmVudE5hbWUsIF9ldmVudEluZm8sIGRhdGEsIF9ydW5JZCwgdGFncywgX21ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMubG9nKGV2ZW50TmFtZSwgZGF0YSwgdGFncyk7XG4gICAgfVxufVxuZXhwb3J0cy5Hb29nbGVSZXF1ZXN0TG9nZ2VyID0gR29vZ2xlUmVxdWVzdExvZ2dlcjtcbmNsYXNzIEdvb2dsZVJlcXVlc3RSZWNvcmRlciBleHRlbmRzIEdvb2dsZVJlcXVlc3RDYWxsYmFja0hhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcIkdvb2dsZVJlcXVlc3RSZWNvcmRlclwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXF1ZXN0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzcG9uc2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaHVua1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZUN1c3RvbVJlcXVlc3RFdmVudChfZXZlbnROYW1lLCBfZXZlbnRJbmZvLCBkYXRhLCBfcnVuSWQsIF90YWdzLCBfbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gZGF0YTtcbiAgICB9XG4gICAgaGFuZGxlQ3VzdG9tUmVzcG9uc2VFdmVudChfZXZlbnROYW1lLCBfZXZlbnRJbmZvLCBkYXRhLCBfcnVuSWQsIF90YWdzLCBfbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IGRhdGE7XG4gICAgfVxuICAgIGhhbmRsZUN1c3RvbUNodW5rRXZlbnQoX2V2ZW50TmFtZSwgX2V2ZW50SW5mbywgZGF0YSwgX3J1bklkLCBfdGFncywgX21ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuY2h1bmsucHVzaChkYXRhKTtcbiAgICB9XG59XG5leHBvcnRzLkdvb2dsZVJlcXVlc3RSZWNvcmRlciA9IEdvb2dsZVJlcXVlc3RSZWNvcmRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/connection.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/embeddings.cjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/embeddings.cjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseGoogleEmbeddings = void 0;\nconst embeddings_1 = __webpack_require__(/*! @langchain/core/embeddings */ \"(rsc)/./node_modules/@langchain/core/embeddings.cjs\");\nconst chunk_array_1 = __webpack_require__(/*! @langchain/core/utils/chunk_array */ \"(rsc)/./node_modules/@langchain/core/utils/chunk_array.cjs\");\nconst env_1 = __webpack_require__(/*! @langchain/core/utils/env */ \"(rsc)/./node_modules/@langchain/core/utils/env.cjs\");\nconst connection_js_1 = __webpack_require__(/*! ./connection.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/connection.cjs\");\nconst auth_js_1 = __webpack_require__(/*! ./auth.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/auth.cjs\");\nclass EmbeddingsConnection extends connection_js_1.GoogleAIConnection {\n    constructor(fields, caller, client, streaming) {\n        super(fields, caller, client, streaming);\n        Object.defineProperty(this, \"convertSystemMessageToHumanContent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    async buildUrlMethod() {\n        return \"predict\";\n    }\n    get modelPublisher() {\n        // All the embedding models are currently published by \"google\"\n        return \"google\";\n    }\n    async formatData(input, parameters) {\n        return {\n            instances: input,\n            parameters,\n        };\n    }\n}\n/**\n * Enables calls to Google APIs for generating\n * text embeddings.\n */\nclass BaseGoogleEmbeddings extends embeddings_1.Embeddings {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"model\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"connection\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.model = fields.model;\n        this.connection = new EmbeddingsConnection({ ...fields, ...this }, this.caller, this.buildClient(fields), false);\n    }\n    buildApiKeyClient(apiKey) {\n        return new auth_js_1.ApiKeyGoogleAuth(apiKey);\n    }\n    buildApiKey(fields) {\n        return fields?.apiKey ?? (0, env_1.getEnvironmentVariable)(\"GOOGLE_API_KEY\");\n    }\n    buildClient(fields) {\n        const apiKey = this.buildApiKey(fields);\n        if (apiKey) {\n            return this.buildApiKeyClient(apiKey);\n        }\n        else {\n            return this.buildAbstractedClient(fields);\n        }\n    }\n    /**\n     * Takes an array of documents as input and returns a promise that\n     * resolves to a 2D array of embeddings for each document. It splits the\n     * documents into chunks and makes requests to the Google Vertex AI API to\n     * generate embeddings.\n     * @param documents An array of documents to be embedded.\n     * @returns A promise that resolves to a 2D array of embeddings for each document.\n     */\n    async embedDocuments(documents) {\n        const instanceChunks = (0, chunk_array_1.chunkArray)(documents.map((document) => ({\n            content: document,\n        })), 5); // Vertex AI accepts max 5 instances per prediction\n        const parameters = {};\n        const options = {};\n        const responses = await Promise.all(instanceChunks.map((instances) => this.connection.request(instances, parameters, options)));\n        const result = responses\n            ?.map((response) => response?.data?.predictions?.map(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (result) => result.embeddings?.values) ?? [])\n            .flat() ?? [];\n        return result;\n    }\n    /**\n     * Takes a document as input and returns a promise that resolves to an\n     * embedding for the document. It calls the embedDocuments method with the\n     * document as the input.\n     * @param document A document to be embedded.\n     * @returns A promise that resolves to an embedding for the document.\n     */\n    async embedQuery(document) {\n        const data = await this.embedDocuments([document]);\n        return data[0];\n    }\n}\nexports.BaseGoogleEmbeddings = BaseGoogleEmbeddings;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvZW1iZWRkaW5ncy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCO0FBQzVCLHFCQUFxQixtQkFBTyxDQUFDLHVGQUE0QjtBQUN6RCxzQkFBc0IsbUJBQU8sQ0FBQyxxR0FBbUM7QUFDakUsY0FBYyxtQkFBTyxDQUFDLHFGQUEyQjtBQUNqRCx3QkFBd0IsbUJBQU8sQ0FBQywyRkFBa0I7QUFDbEQsa0JBQWtCLG1CQUFPLENBQUMsK0VBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHFEQUFxRCxvQkFBb0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxRQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvZW1iZWRkaW5ncy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhc2VHb29nbGVFbWJlZGRpbmdzID0gdm9pZCAwO1xuY29uc3QgZW1iZWRkaW5nc18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9lbWJlZGRpbmdzXCIpO1xuY29uc3QgY2h1bmtfYXJyYXlfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvdXRpbHMvY2h1bmtfYXJyYXlcIik7XG5jb25zdCBlbnZfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvdXRpbHMvZW52XCIpO1xuY29uc3QgY29ubmVjdGlvbl9qc18xID0gcmVxdWlyZShcIi4vY29ubmVjdGlvbi5janNcIik7XG5jb25zdCBhdXRoX2pzXzEgPSByZXF1aXJlKFwiLi9hdXRoLmNqc1wiKTtcbmNsYXNzIEVtYmVkZGluZ3NDb25uZWN0aW9uIGV4dGVuZHMgY29ubmVjdGlvbl9qc18xLkdvb2dsZUFJQ29ubmVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCBjYWxsZXIsIGNsaWVudCwgc3RyZWFtaW5nKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcywgY2FsbGVyLCBjbGllbnQsIHN0cmVhbWluZyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnZlcnRTeXN0ZW1NZXNzYWdlVG9IdW1hbkNvbnRlbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgYnVpbGRVcmxNZXRob2QoKSB7XG4gICAgICAgIHJldHVybiBcInByZWRpY3RcIjtcbiAgICB9XG4gICAgZ2V0IG1vZGVsUHVibGlzaGVyKCkge1xuICAgICAgICAvLyBBbGwgdGhlIGVtYmVkZGluZyBtb2RlbHMgYXJlIGN1cnJlbnRseSBwdWJsaXNoZWQgYnkgXCJnb29nbGVcIlxuICAgICAgICByZXR1cm4gXCJnb29nbGVcIjtcbiAgICB9XG4gICAgYXN5bmMgZm9ybWF0RGF0YShpbnB1dCwgcGFyYW1ldGVycykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5zdGFuY2VzOiBpbnB1dCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBFbmFibGVzIGNhbGxzIHRvIEdvb2dsZSBBUElzIGZvciBnZW5lcmF0aW5nXG4gKiB0ZXh0IGVtYmVkZGluZ3MuXG4gKi9cbmNsYXNzIEJhc2VHb29nbGVFbWJlZGRpbmdzIGV4dGVuZHMgZW1iZWRkaW5nc18xLkVtYmVkZGluZ3Mge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtb2RlbFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb25uZWN0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubW9kZWwgPSBmaWVsZHMubW9kZWw7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG5ldyBFbWJlZGRpbmdzQ29ubmVjdGlvbih7IC4uLmZpZWxkcywgLi4udGhpcyB9LCB0aGlzLmNhbGxlciwgdGhpcy5idWlsZENsaWVudChmaWVsZHMpLCBmYWxzZSk7XG4gICAgfVxuICAgIGJ1aWxkQXBpS2V5Q2xpZW50KGFwaUtleSkge1xuICAgICAgICByZXR1cm4gbmV3IGF1dGhfanNfMS5BcGlLZXlHb29nbGVBdXRoKGFwaUtleSk7XG4gICAgfVxuICAgIGJ1aWxkQXBpS2V5KGZpZWxkcykge1xuICAgICAgICByZXR1cm4gZmllbGRzPy5hcGlLZXkgPz8gKDAsIGVudl8xLmdldEVudmlyb25tZW50VmFyaWFibGUpKFwiR09PR0xFX0FQSV9LRVlcIik7XG4gICAgfVxuICAgIGJ1aWxkQ2xpZW50KGZpZWxkcykge1xuICAgICAgICBjb25zdCBhcGlLZXkgPSB0aGlzLmJ1aWxkQXBpS2V5KGZpZWxkcyk7XG4gICAgICAgIGlmIChhcGlLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkQXBpS2V5Q2xpZW50KGFwaUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZEFic3RyYWN0ZWRDbGllbnQoZmllbGRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYWtlcyBhbiBhcnJheSBvZiBkb2N1bWVudHMgYXMgaW5wdXQgYW5kIHJldHVybnMgYSBwcm9taXNlIHRoYXRcbiAgICAgKiByZXNvbHZlcyB0byBhIDJEIGFycmF5IG9mIGVtYmVkZGluZ3MgZm9yIGVhY2ggZG9jdW1lbnQuIEl0IHNwbGl0cyB0aGVcbiAgICAgKiBkb2N1bWVudHMgaW50byBjaHVua3MgYW5kIG1ha2VzIHJlcXVlc3RzIHRvIHRoZSBHb29nbGUgVmVydGV4IEFJIEFQSSB0b1xuICAgICAqIGdlbmVyYXRlIGVtYmVkZGluZ3MuXG4gICAgICogQHBhcmFtIGRvY3VtZW50cyBBbiBhcnJheSBvZiBkb2N1bWVudHMgdG8gYmUgZW1iZWRkZWQuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSAyRCBhcnJheSBvZiBlbWJlZGRpbmdzIGZvciBlYWNoIGRvY3VtZW50LlxuICAgICAqL1xuICAgIGFzeW5jIGVtYmVkRG9jdW1lbnRzKGRvY3VtZW50cykge1xuICAgICAgICBjb25zdCBpbnN0YW5jZUNodW5rcyA9ICgwLCBjaHVua19hcnJheV8xLmNodW5rQXJyYXkpKGRvY3VtZW50cy5tYXAoKGRvY3VtZW50KSA9PiAoe1xuICAgICAgICAgICAgY29udGVudDogZG9jdW1lbnQsXG4gICAgICAgIH0pKSwgNSk7IC8vIFZlcnRleCBBSSBhY2NlcHRzIG1heCA1IGluc3RhbmNlcyBwZXIgcHJlZGljdGlvblxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0ge307XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoaW5zdGFuY2VDaHVua3MubWFwKChpbnN0YW5jZXMpID0+IHRoaXMuY29ubmVjdGlvbi5yZXF1ZXN0KGluc3RhbmNlcywgcGFyYW1ldGVycywgb3B0aW9ucykpKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzcG9uc2VzXG4gICAgICAgICAgICA/Lm1hcCgocmVzcG9uc2UpID0+IHJlc3BvbnNlPy5kYXRhPy5wcmVkaWN0aW9ucz8ubWFwKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAocmVzdWx0KSA9PiByZXN1bHQuZW1iZWRkaW5ncz8udmFsdWVzKSA/PyBbXSlcbiAgICAgICAgICAgIC5mbGF0KCkgPz8gW107XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgZG9jdW1lbnQgYXMgaW5wdXQgYW5kIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW5cbiAgICAgKiBlbWJlZGRpbmcgZm9yIHRoZSBkb2N1bWVudC4gSXQgY2FsbHMgdGhlIGVtYmVkRG9jdW1lbnRzIG1ldGhvZCB3aXRoIHRoZVxuICAgICAqIGRvY3VtZW50IGFzIHRoZSBpbnB1dC5cbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQgQSBkb2N1bWVudCB0byBiZSBlbWJlZGRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBlbWJlZGRpbmcgZm9yIHRoZSBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBhc3luYyBlbWJlZFF1ZXJ5KGRvY3VtZW50KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmVtYmVkRG9jdW1lbnRzKFtkb2N1bWVudF0pO1xuICAgICAgICByZXR1cm4gZGF0YVswXTtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VHb29nbGVFbWJlZGRpbmdzID0gQmFzZUdvb2dsZUVtYmVkZGluZ3M7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/embeddings.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/experimental/media.cjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/experimental/media.cjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BlobStoreAIStudioFileBase = exports.AIStudioFileDownloadConnection = exports.AIStudioFileUploadConnection = exports.AIStudioMediaBlob = exports.BlobStoreGoogleCloudStorageBase = exports.GoogleCloudStorageRawConnection = exports.GoogleCloudStorageDownloadConnection = exports.GoogleCloudStorageUploadConnection = exports.GoogleCloudStorageUri = exports.BlobStoreGoogle = exports.GoogleDownloadRawConnection = exports.GoogleDownloadConnection = exports.GoogleMultipartUploadConnection = void 0;\nconst async_caller_1 = __webpack_require__(/*! @langchain/core/utils/async_caller */ \"(rsc)/./node_modules/@langchain/core/utils/async_caller.cjs\");\nconst env_1 = __webpack_require__(/*! @langchain/core/utils/env */ \"(rsc)/./node_modules/@langchain/core/utils/env.cjs\");\nconst media_core_js_1 = __webpack_require__(/*! ./utils/media_core.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/experimental/utils/media_core.cjs\");\nconst connection_js_1 = __webpack_require__(/*! ../connection.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/connection.cjs\");\nconst auth_js_1 = __webpack_require__(/*! ../auth.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/auth.cjs\");\nclass GoogleMultipartUploadConnection extends connection_js_1.GoogleHostConnection {\n    constructor(fields, caller, client) {\n        super(fields, caller, client);\n    }\n    async _body(separator, data, metadata) {\n        const contentType = data.mimetype;\n        const { encoded, encoding } = await data.encode();\n        const body = [\n            `--${separator}`,\n            \"Content-Type: application/json; charset=UTF-8\",\n            \"\",\n            JSON.stringify(metadata),\n            \"\",\n            `--${separator}`,\n            `Content-Type: ${contentType}`,\n            `Content-Transfer-Encoding: ${encoding}`,\n            \"\",\n            encoded,\n            `--${separator}--`,\n        ];\n        return body.join(\"\\n\");\n    }\n    async request(data, metadata, options) {\n        const separator = `separator-${Date.now()}`;\n        const body = await this._body(separator, data, metadata);\n        const requestHeaders = {\n            \"Content-Type\": `multipart/related; boundary=${separator}`,\n            \"X-Goog-Upload-Protocol\": \"multipart\",\n        };\n        const response = this._request(body, options, requestHeaders);\n        return response;\n    }\n}\nexports.GoogleMultipartUploadConnection = GoogleMultipartUploadConnection;\nclass GoogleDownloadConnection extends connection_js_1.GoogleHostConnection {\n    async request(options) {\n        return this._request(undefined, options);\n    }\n}\nexports.GoogleDownloadConnection = GoogleDownloadConnection;\nclass GoogleDownloadRawConnection extends connection_js_1.GoogleRawConnection {\n    buildMethod() {\n        return \"GET\";\n    }\n    async request(options) {\n        return this._request(undefined, options);\n    }\n}\nexports.GoogleDownloadRawConnection = GoogleDownloadRawConnection;\nclass BlobStoreGoogle extends media_core_js_1.BlobStore {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.caller = new async_caller_1.AsyncCaller(fields ?? {});\n        this.client = this.buildClient(fields);\n    }\n    async _set(keyValuePair) {\n        const [, blob] = keyValuePair;\n        const setMetadata = this.buildSetMetadata(keyValuePair);\n        const metadata = setMetadata;\n        const options = {};\n        const connection = this.buildSetConnection(keyValuePair);\n        const response = await connection.request(blob, metadata, options);\n        return response;\n    }\n    async mset(keyValuePairs) {\n        const ret = keyValuePairs.map((keyValue) => this._set(keyValue));\n        await Promise.all(ret);\n    }\n    async _getMetadata(key) {\n        const connection = this.buildGetMetadataConnection(key);\n        const options = {};\n        const response = await connection.request(options);\n        return response.data;\n    }\n    async _getData(key) {\n        const connection = this.buildGetDataConnection(key);\n        const options = {};\n        const response = await connection.request(options);\n        return response.data;\n    }\n    _getMimetypeFromMetadata(metadata) {\n        return metadata.contentType;\n    }\n    async _get(key) {\n        const metadata = await this._getMetadata(key);\n        const data = await this._getData(key);\n        if (data && metadata) {\n            const ret = await media_core_js_1.MediaBlob.fromBlob(data, { metadata, path: key });\n            return ret;\n        }\n        else {\n            return undefined;\n        }\n    }\n    async mget(keys) {\n        const ret = keys.map((key) => this._get(key));\n        return await Promise.all(ret);\n    }\n    async _del(key) {\n        const connection = this.buildDeleteConnection(key);\n        const options = {};\n        await connection.request(options);\n    }\n    async mdelete(keys) {\n        const ret = keys.map((key) => this._del(key));\n        await Promise.all(ret);\n    }\n    // eslint-disable-next-line require-yield\n    async *yieldKeys(_prefix) {\n        // TODO: Implement. Most have an implementation that uses nextToken.\n        throw new Error(\"yieldKeys is not implemented\");\n    }\n}\nexports.BlobStoreGoogle = BlobStoreGoogle;\nclass GoogleCloudStorageUri {\n    constructor(uri) {\n        Object.defineProperty(this, \"bucket\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"path\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const bucketAndPath = GoogleCloudStorageUri.uriToBucketAndPath(uri);\n        this.bucket = bucketAndPath.bucket;\n        this.path = bucketAndPath.path;\n    }\n    get uri() {\n        return `gs://${this.bucket}/${this.path}`;\n    }\n    get isValid() {\n        return (typeof this.bucket !== \"undefined\" && typeof this.path !== \"undefined\");\n    }\n    static uriToBucketAndPath(uri) {\n        const match = this.uriRegexp.exec(uri);\n        if (!match) {\n            throw new Error(`Invalid gs:// URI: ${uri}`);\n        }\n        return {\n            bucket: match[1],\n            path: match[2],\n        };\n    }\n    static isValidUri(uri) {\n        return this.uriRegexp.test(uri);\n    }\n}\nexports.GoogleCloudStorageUri = GoogleCloudStorageUri;\nObject.defineProperty(GoogleCloudStorageUri, \"uriRegexp\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: /gs:\\/\\/([a-z0-9][a-z0-9._-]+[a-z0-9])\\/(.*)/\n});\nclass GoogleCloudStorageUploadConnection extends GoogleMultipartUploadConnection {\n    constructor(fields, caller, client) {\n        super(fields, caller, client);\n        Object.defineProperty(this, \"uri\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.uri = new GoogleCloudStorageUri(fields.uri);\n    }\n    async buildUrl() {\n        return `https://storage.googleapis.com/upload/storage/${this.apiVersion}/b/${this.uri.bucket}/o?uploadType=multipart`;\n    }\n}\nexports.GoogleCloudStorageUploadConnection = GoogleCloudStorageUploadConnection;\nclass GoogleCloudStorageDownloadConnection extends GoogleDownloadConnection {\n    constructor(fields, caller, client) {\n        super(fields, caller, client);\n        Object.defineProperty(this, \"uri\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"method\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"alt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.uri = new GoogleCloudStorageUri(fields.uri);\n        this.method = fields.method;\n        this.alt = fields.alt;\n    }\n    buildMethod() {\n        return this.method;\n    }\n    async buildUrl() {\n        const path = encodeURIComponent(this.uri.path);\n        const ret = `https://storage.googleapis.com/storage/${this.apiVersion}/b/${this.uri.bucket}/o/${path}`;\n        return this.alt ? `${ret}?alt=${this.alt}` : ret;\n    }\n}\nexports.GoogleCloudStorageDownloadConnection = GoogleCloudStorageDownloadConnection;\nclass GoogleCloudStorageRawConnection extends GoogleDownloadRawConnection {\n    constructor(fields, caller, client) {\n        super(fields, caller, client);\n        Object.defineProperty(this, \"uri\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.uri = new GoogleCloudStorageUri(fields.uri);\n    }\n    async buildUrl() {\n        const path = encodeURIComponent(this.uri.path);\n        const ret = `https://storage.googleapis.com/storage/${this.apiVersion}/b/${this.uri.bucket}/o/${path}?alt=media`;\n        return ret;\n    }\n}\nexports.GoogleCloudStorageRawConnection = GoogleCloudStorageRawConnection;\nclass BlobStoreGoogleCloudStorageBase extends BlobStoreGoogle {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"params\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.params = fields;\n        this.defaultStoreOptions = {\n            ...this.defaultStoreOptions,\n            pathPrefix: fields.uriPrefix.uri,\n        };\n    }\n    buildSetConnection([key, _blob]) {\n        const params = {\n            ...this.params,\n            uri: key,\n        };\n        return new GoogleCloudStorageUploadConnection(params, this.caller, this.client);\n    }\n    buildSetMetadata([key, blob]) {\n        const uri = new GoogleCloudStorageUri(key);\n        const ret = {\n            name: uri.path,\n            metadata: blob.metadata,\n            contentType: blob.mimetype,\n        };\n        return ret;\n    }\n    buildGetMetadataConnection(key) {\n        const params = {\n            uri: key,\n            method: \"GET\",\n            alt: undefined,\n        };\n        return new GoogleCloudStorageDownloadConnection(params, this.caller, this.client);\n    }\n    buildGetDataConnection(key) {\n        const params = {\n            uri: key,\n        };\n        return new GoogleCloudStorageRawConnection(params, this.caller, this.client);\n    }\n    buildDeleteConnection(key) {\n        const params = {\n            uri: key,\n            method: \"DELETE\",\n            alt: undefined,\n        };\n        return new GoogleCloudStorageDownloadConnection(params, this.caller, this.client);\n    }\n}\nexports.BlobStoreGoogleCloudStorageBase = BlobStoreGoogleCloudStorageBase;\nclass AIStudioMediaBlob extends media_core_js_1.MediaBlob {\n    _valueAsDate(value) {\n        if (!value) {\n            return new Date(0);\n        }\n        return new Date(value);\n    }\n    _metadataFieldAsDate(field) {\n        return this._valueAsDate(this.metadata?.[field]);\n    }\n    get createDate() {\n        return this._metadataFieldAsDate(\"createTime\");\n    }\n    get updateDate() {\n        return this._metadataFieldAsDate(\"updateTime\");\n    }\n    get expirationDate() {\n        return this._metadataFieldAsDate(\"expirationTime\");\n    }\n    get isExpired() {\n        const now = new Date().toISOString();\n        const exp = this.metadata?.expirationTime ?? now;\n        return exp <= now;\n    }\n}\nexports.AIStudioMediaBlob = AIStudioMediaBlob;\nclass AIStudioFileUploadConnection extends GoogleMultipartUploadConnection {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"apiVersion\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"v1beta\"\n        });\n    }\n    async buildUrl() {\n        return `https://generativelanguage.googleapis.com/upload/${this.apiVersion}/files`;\n    }\n}\nexports.AIStudioFileUploadConnection = AIStudioFileUploadConnection;\nclass AIStudioFileDownloadConnection extends GoogleDownloadConnection {\n    constructor(fields, caller, client) {\n        super(fields, caller, client);\n        Object.defineProperty(this, \"method\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiVersion\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"v1beta\"\n        });\n        this.method = fields.method;\n        this.name = fields.name;\n    }\n    buildMethod() {\n        return this.method;\n    }\n    async buildUrl() {\n        return `https://generativelanguage.googleapis.com/${this.apiVersion}/files/${this.name}`;\n    }\n}\nexports.AIStudioFileDownloadConnection = AIStudioFileDownloadConnection;\nclass BlobStoreAIStudioFileBase extends BlobStoreGoogle {\n    constructor(fields) {\n        const params = {\n            defaultStoreOptions: {\n                pathPrefix: \"https://generativelanguage.googleapis.com/v1beta/files/\",\n                actionIfInvalid: \"removePath\",\n            },\n            ...fields,\n        };\n        super(params);\n        Object.defineProperty(this, \"params\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"retryTime\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 1000\n        });\n        this.params = params;\n        this.retryTime = params?.retryTime ?? this.retryTime ?? 1000;\n    }\n    _pathToName(path) {\n        return path.split(\"/\").pop() ?? path;\n    }\n    buildApiKeyClient(apiKey) {\n        return new auth_js_1.ApiKeyGoogleAuth(apiKey);\n    }\n    buildApiKey(fields) {\n        return fields?.apiKey ?? (0, env_1.getEnvironmentVariable)(\"GOOGLE_API_KEY\");\n    }\n    buildClient(fields) {\n        const apiKey = this.buildApiKey(fields);\n        if (apiKey) {\n            return this.buildApiKeyClient(apiKey);\n        }\n        else {\n            // TODO: Test that you can use OAuth to access\n            return this.buildAbstractedClient(fields);\n        }\n    }\n    async _regetMetadata(key) {\n        // Sleep for some time period\n        // eslint-disable-next-line no-promise-executor-return\n        await new Promise((resolve) => setTimeout(resolve, this.retryTime));\n        // Fetch the latest metadata\n        return this._getMetadata(key);\n    }\n    async _set([key, blob]) {\n        const response = (await super._set([\n            key,\n            blob,\n        ]));\n        let file = response.data?.file ?? { state: \"FAILED\" };\n        while (file.state === \"PROCESSING\" && file.uri && this.retryTime > 0) {\n            file = await this._regetMetadata(file.uri);\n        }\n        // The response should contain the name (and valid URI), so we need to\n        // update the blob with this. We can't return a new blob, since mset()\n        // doesn't return anything.\n        /* eslint-disable no-param-reassign */\n        blob.path = file.uri;\n        blob.metadata = {\n            ...blob.metadata,\n            ...file,\n        };\n        /* eslint-enable no-param-reassign */\n        return response;\n    }\n    buildSetConnection([_key, _blob]) {\n        return new AIStudioFileUploadConnection(this.params, this.caller, this.client);\n    }\n    buildSetMetadata([_key, _blob]) {\n        return {};\n    }\n    buildGetMetadataConnection(key) {\n        const params = {\n            ...this.params,\n            method: \"GET\",\n            name: this._pathToName(key),\n        };\n        return new AIStudioFileDownloadConnection(params, this.caller, this.client);\n    }\n    buildGetDataConnection(_key) {\n        throw new Error(\"AI Studio File API does not provide data\");\n    }\n    async _get(key) {\n        const metadata = await this._getMetadata(key);\n        if (metadata) {\n            const contentType = metadata?.mimeType ?? \"application/octet-stream\";\n            // TODO - Get the actual data (and other metadata) from an optional backing store\n            const data = {\n                value: \"\",\n                type: contentType,\n            };\n            return new media_core_js_1.MediaBlob({\n                path: key,\n                data,\n                metadata,\n            });\n        }\n        else {\n            return undefined;\n        }\n    }\n    buildDeleteConnection(key) {\n        const params = {\n            ...this.params,\n            method: \"DELETE\",\n            name: this._pathToName(key),\n        };\n        return new AIStudioFileDownloadConnection(params, this.caller, this.client);\n    }\n}\nexports.BlobStoreAIStudioFileBase = BlobStoreAIStudioFileBase;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvZXhwZXJpbWVudGFsL21lZGlhLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQ0FBaUMsR0FBRyxzQ0FBc0MsR0FBRyxvQ0FBb0MsR0FBRyx5QkFBeUIsR0FBRyx1Q0FBdUMsR0FBRyx1Q0FBdUMsR0FBRyw0Q0FBNEMsR0FBRywwQ0FBMEMsR0FBRyw2QkFBNkIsR0FBRyx1QkFBdUIsR0FBRyxtQ0FBbUMsR0FBRyxnQ0FBZ0MsR0FBRyx1Q0FBdUM7QUFDMWUsdUJBQXVCLG1CQUFPLENBQUMsdUdBQW9DO0FBQ25FLGNBQWMsbUJBQU8sQ0FBQyxxRkFBMkI7QUFDakQsd0JBQXdCLG1CQUFPLENBQUMsb0hBQXdCO0FBQ3hELHdCQUF3QixtQkFBTyxDQUFDLDRGQUFtQjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQyxnRkFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0IsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCLDZCQUE2QixZQUFZO0FBQ3pDLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXO0FBQ2xEO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVyxVQUFVO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxxQkFBcUI7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVksR0FBRyxVQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELElBQUk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxnQkFBZ0IsS0FBSyxnQkFBZ0I7QUFDckc7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsZ0JBQWdCLEtBQUssZ0JBQWdCLEtBQUssS0FBSztBQUM3Ryw2QkFBNkIsSUFBSSxPQUFPLFNBQVM7QUFDakQ7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGdCQUFnQixLQUFLLGdCQUFnQixLQUFLLEtBQUs7QUFDN0c7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1FQUFtRSxnQkFBZ0I7QUFDbkY7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxnQkFBZ0IsU0FBUyxVQUFVO0FBQy9GO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9kaXN0L2V4cGVyaW1lbnRhbC9tZWRpYS5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJsb2JTdG9yZUFJU3R1ZGlvRmlsZUJhc2UgPSBleHBvcnRzLkFJU3R1ZGlvRmlsZURvd25sb2FkQ29ubmVjdGlvbiA9IGV4cG9ydHMuQUlTdHVkaW9GaWxlVXBsb2FkQ29ubmVjdGlvbiA9IGV4cG9ydHMuQUlTdHVkaW9NZWRpYUJsb2IgPSBleHBvcnRzLkJsb2JTdG9yZUdvb2dsZUNsb3VkU3RvcmFnZUJhc2UgPSBleHBvcnRzLkdvb2dsZUNsb3VkU3RvcmFnZVJhd0Nvbm5lY3Rpb24gPSBleHBvcnRzLkdvb2dsZUNsb3VkU3RvcmFnZURvd25sb2FkQ29ubmVjdGlvbiA9IGV4cG9ydHMuR29vZ2xlQ2xvdWRTdG9yYWdlVXBsb2FkQ29ubmVjdGlvbiA9IGV4cG9ydHMuR29vZ2xlQ2xvdWRTdG9yYWdlVXJpID0gZXhwb3J0cy5CbG9iU3RvcmVHb29nbGUgPSBleHBvcnRzLkdvb2dsZURvd25sb2FkUmF3Q29ubmVjdGlvbiA9IGV4cG9ydHMuR29vZ2xlRG93bmxvYWRDb25uZWN0aW9uID0gZXhwb3J0cy5Hb29nbGVNdWx0aXBhcnRVcGxvYWRDb25uZWN0aW9uID0gdm9pZCAwO1xuY29uc3QgYXN5bmNfY2FsbGVyXzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2FzeW5jX2NhbGxlclwiKTtcbmNvbnN0IGVudl8xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS91dGlscy9lbnZcIik7XG5jb25zdCBtZWRpYV9jb3JlX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy9tZWRpYV9jb3JlLmNqc1wiKTtcbmNvbnN0IGNvbm5lY3Rpb25fanNfMSA9IHJlcXVpcmUoXCIuLi9jb25uZWN0aW9uLmNqc1wiKTtcbmNvbnN0IGF1dGhfanNfMSA9IHJlcXVpcmUoXCIuLi9hdXRoLmNqc1wiKTtcbmNsYXNzIEdvb2dsZU11bHRpcGFydFVwbG9hZENvbm5lY3Rpb24gZXh0ZW5kcyBjb25uZWN0aW9uX2pzXzEuR29vZ2xlSG9zdENvbm5lY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgY2FsbGVyLCBjbGllbnQpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzLCBjYWxsZXIsIGNsaWVudCk7XG4gICAgfVxuICAgIGFzeW5jIF9ib2R5KHNlcGFyYXRvciwgZGF0YSwgbWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSBkYXRhLm1pbWV0eXBlO1xuICAgICAgICBjb25zdCB7IGVuY29kZWQsIGVuY29kaW5nIH0gPSBhd2FpdCBkYXRhLmVuY29kZSgpO1xuICAgICAgICBjb25zdCBib2R5ID0gW1xuICAgICAgICAgICAgYC0tJHtzZXBhcmF0b3J9YCxcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PVVURi04XCIsXG4gICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpLFxuICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgIGAtLSR7c2VwYXJhdG9yfWAsXG4gICAgICAgICAgICBgQ29udGVudC1UeXBlOiAke2NvbnRlbnRUeXBlfWAsXG4gICAgICAgICAgICBgQ29udGVudC1UcmFuc2Zlci1FbmNvZGluZzogJHtlbmNvZGluZ31gLFxuICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgIGVuY29kZWQsXG4gICAgICAgICAgICBgLS0ke3NlcGFyYXRvcn0tLWAsXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBib2R5LmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICAgIGFzeW5jIHJlcXVlc3QoZGF0YSwgbWV0YWRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2VwYXJhdG9yID0gYHNlcGFyYXRvci0ke0RhdGUubm93KCl9YDtcbiAgICAgICAgY29uc3QgYm9keSA9IGF3YWl0IHRoaXMuX2JvZHkoc2VwYXJhdG9yLCBkYXRhLCBtZXRhZGF0YSk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RIZWFkZXJzID0ge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogYG11bHRpcGFydC9yZWxhdGVkOyBib3VuZGFyeT0ke3NlcGFyYXRvcn1gLFxuICAgICAgICAgICAgXCJYLUdvb2ctVXBsb2FkLVByb3RvY29sXCI6IFwibXVsdGlwYXJ0XCIsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5fcmVxdWVzdChib2R5LCBvcHRpb25zLCByZXF1ZXN0SGVhZGVycyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG5leHBvcnRzLkdvb2dsZU11bHRpcGFydFVwbG9hZENvbm5lY3Rpb24gPSBHb29nbGVNdWx0aXBhcnRVcGxvYWRDb25uZWN0aW9uO1xuY2xhc3MgR29vZ2xlRG93bmxvYWRDb25uZWN0aW9uIGV4dGVuZHMgY29ubmVjdGlvbl9qc18xLkdvb2dsZUhvc3RDb25uZWN0aW9uIHtcbiAgICBhc3luYyByZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QodW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLkdvb2dsZURvd25sb2FkQ29ubmVjdGlvbiA9IEdvb2dsZURvd25sb2FkQ29ubmVjdGlvbjtcbmNsYXNzIEdvb2dsZURvd25sb2FkUmF3Q29ubmVjdGlvbiBleHRlbmRzIGNvbm5lY3Rpb25fanNfMS5Hb29nbGVSYXdDb25uZWN0aW9uIHtcbiAgICBidWlsZE1ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuIFwiR0VUXCI7XG4gICAgfVxuICAgIGFzeW5jIHJlcXVlc3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCh1bmRlZmluZWQsIG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuR29vZ2xlRG93bmxvYWRSYXdDb25uZWN0aW9uID0gR29vZ2xlRG93bmxvYWRSYXdDb25uZWN0aW9uO1xuY2xhc3MgQmxvYlN0b3JlR29vZ2xlIGV4dGVuZHMgbWVkaWFfY29yZV9qc18xLkJsb2JTdG9yZSB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhbGxlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjbGllbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYWxsZXIgPSBuZXcgYXN5bmNfY2FsbGVyXzEuQXN5bmNDYWxsZXIoZmllbGRzID8/IHt9KTtcbiAgICAgICAgdGhpcy5jbGllbnQgPSB0aGlzLmJ1aWxkQ2xpZW50KGZpZWxkcyk7XG4gICAgfVxuICAgIGFzeW5jIF9zZXQoa2V5VmFsdWVQYWlyKSB7XG4gICAgICAgIGNvbnN0IFssIGJsb2JdID0ga2V5VmFsdWVQYWlyO1xuICAgICAgICBjb25zdCBzZXRNZXRhZGF0YSA9IHRoaXMuYnVpbGRTZXRNZXRhZGF0YShrZXlWYWx1ZVBhaXIpO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHNldE1ldGFkYXRhO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB0aGlzLmJ1aWxkU2V0Q29ubmVjdGlvbihrZXlWYWx1ZVBhaXIpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvbm5lY3Rpb24ucmVxdWVzdChibG9iLCBtZXRhZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgbXNldChrZXlWYWx1ZVBhaXJzKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGtleVZhbHVlUGFpcnMubWFwKChrZXlWYWx1ZSkgPT4gdGhpcy5fc2V0KGtleVZhbHVlKSk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJldCk7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRNZXRhZGF0YShrZXkpIHtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHRoaXMuYnVpbGRHZXRNZXRhZGF0YUNvbm5lY3Rpb24oa2V5KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvbm5lY3Rpb24ucmVxdWVzdChvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIGFzeW5jIF9nZXREYXRhKGtleSkge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gdGhpcy5idWlsZEdldERhdGFDb25uZWN0aW9uKGtleSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb25uZWN0aW9uLnJlcXVlc3Qob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICBfZ2V0TWltZXR5cGVGcm9tTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhLmNvbnRlbnRUeXBlO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0KGtleSkge1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMuX2dldE1ldGFkYXRhKGtleSk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl9nZXREYXRhKGtleSk7XG4gICAgICAgIGlmIChkYXRhICYmIG1ldGFkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBhd2FpdCBtZWRpYV9jb3JlX2pzXzEuTWVkaWFCbG9iLmZyb21CbG9iKGRhdGEsIHsgbWV0YWRhdGEsIHBhdGg6IGtleSB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG1nZXQoa2V5cykge1xuICAgICAgICBjb25zdCByZXQgPSBrZXlzLm1hcCgoa2V5KSA9PiB0aGlzLl9nZXQoa2V5KSk7XG4gICAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChyZXQpO1xuICAgIH1cbiAgICBhc3luYyBfZGVsKGtleSkge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gdGhpcy5idWlsZERlbGV0ZUNvbm5lY3Rpb24oa2V5KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgICAgICBhd2FpdCBjb25uZWN0aW9uLnJlcXVlc3Qob3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIG1kZWxldGUoa2V5cykge1xuICAgICAgICBjb25zdCByZXQgPSBrZXlzLm1hcCgoa2V5KSA9PiB0aGlzLl9kZWwoa2V5KSk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJldCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLXlpZWxkXG4gICAgYXN5bmMgKnlpZWxkS2V5cyhfcHJlZml4KSB7XG4gICAgICAgIC8vIFRPRE86IEltcGxlbWVudC4gTW9zdCBoYXZlIGFuIGltcGxlbWVudGF0aW9uIHRoYXQgdXNlcyBuZXh0VG9rZW4uXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInlpZWxkS2V5cyBpcyBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxufVxuZXhwb3J0cy5CbG9iU3RvcmVHb29nbGUgPSBCbG9iU3RvcmVHb29nbGU7XG5jbGFzcyBHb29nbGVDbG91ZFN0b3JhZ2VVcmkge1xuICAgIGNvbnN0cnVjdG9yKHVyaSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJidWNrZXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGF0aFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBidWNrZXRBbmRQYXRoID0gR29vZ2xlQ2xvdWRTdG9yYWdlVXJpLnVyaVRvQnVja2V0QW5kUGF0aCh1cmkpO1xuICAgICAgICB0aGlzLmJ1Y2tldCA9IGJ1Y2tldEFuZFBhdGguYnVja2V0O1xuICAgICAgICB0aGlzLnBhdGggPSBidWNrZXRBbmRQYXRoLnBhdGg7XG4gICAgfVxuICAgIGdldCB1cmkoKSB7XG4gICAgICAgIHJldHVybiBgZ3M6Ly8ke3RoaXMuYnVja2V0fS8ke3RoaXMucGF0aH1gO1xuICAgIH1cbiAgICBnZXQgaXNWYWxpZCgpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgdGhpcy5idWNrZXQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHRoaXMucGF0aCAhPT0gXCJ1bmRlZmluZWRcIik7XG4gICAgfVxuICAgIHN0YXRpYyB1cmlUb0J1Y2tldEFuZFBhdGgodXJpKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy51cmlSZWdleHAuZXhlYyh1cmkpO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZ3M6Ly8gVVJJOiAke3VyaX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnVja2V0OiBtYXRjaFsxXSxcbiAgICAgICAgICAgIHBhdGg6IG1hdGNoWzJdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgaXNWYWxpZFVyaSh1cmkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXJpUmVnZXhwLnRlc3QodXJpKTtcbiAgICB9XG59XG5leHBvcnRzLkdvb2dsZUNsb3VkU3RvcmFnZVVyaSA9IEdvb2dsZUNsb3VkU3RvcmFnZVVyaTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShHb29nbGVDbG91ZFN0b3JhZ2VVcmksIFwidXJpUmVnZXhwXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogL2dzOlxcL1xcLyhbYS16MC05XVthLXowLTkuXy1dK1thLXowLTldKVxcLyguKikvXG59KTtcbmNsYXNzIEdvb2dsZUNsb3VkU3RvcmFnZVVwbG9hZENvbm5lY3Rpb24gZXh0ZW5kcyBHb29nbGVNdWx0aXBhcnRVcGxvYWRDb25uZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIGNhbGxlciwgY2xpZW50KSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcywgY2FsbGVyLCBjbGllbnQpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1cmlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cmkgPSBuZXcgR29vZ2xlQ2xvdWRTdG9yYWdlVXJpKGZpZWxkcy51cmkpO1xuICAgIH1cbiAgICBhc3luYyBidWlsZFVybCgpIHtcbiAgICAgICAgcmV0dXJuIGBodHRwczovL3N0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vdXBsb2FkL3N0b3JhZ2UvJHt0aGlzLmFwaVZlcnNpb259L2IvJHt0aGlzLnVyaS5idWNrZXR9L28/dXBsb2FkVHlwZT1tdWx0aXBhcnRgO1xuICAgIH1cbn1cbmV4cG9ydHMuR29vZ2xlQ2xvdWRTdG9yYWdlVXBsb2FkQ29ubmVjdGlvbiA9IEdvb2dsZUNsb3VkU3RvcmFnZVVwbG9hZENvbm5lY3Rpb247XG5jbGFzcyBHb29nbGVDbG91ZFN0b3JhZ2VEb3dubG9hZENvbm5lY3Rpb24gZXh0ZW5kcyBHb29nbGVEb3dubG9hZENvbm5lY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgY2FsbGVyLCBjbGllbnQpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzLCBjYWxsZXIsIGNsaWVudCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVyaVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRob2RcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYWx0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXJpID0gbmV3IEdvb2dsZUNsb3VkU3RvcmFnZVVyaShmaWVsZHMudXJpKTtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBmaWVsZHMubWV0aG9kO1xuICAgICAgICB0aGlzLmFsdCA9IGZpZWxkcy5hbHQ7XG4gICAgfVxuICAgIGJ1aWxkTWV0aG9kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRob2Q7XG4gICAgfVxuICAgIGFzeW5jIGJ1aWxkVXJsKCkge1xuICAgICAgICBjb25zdCBwYXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMudXJpLnBhdGgpO1xuICAgICAgICBjb25zdCByZXQgPSBgaHR0cHM6Ly9zdG9yYWdlLmdvb2dsZWFwaXMuY29tL3N0b3JhZ2UvJHt0aGlzLmFwaVZlcnNpb259L2IvJHt0aGlzLnVyaS5idWNrZXR9L28vJHtwYXRofWA7XG4gICAgICAgIHJldHVybiB0aGlzLmFsdCA/IGAke3JldH0/YWx0PSR7dGhpcy5hbHR9YCA6IHJldDtcbiAgICB9XG59XG5leHBvcnRzLkdvb2dsZUNsb3VkU3RvcmFnZURvd25sb2FkQ29ubmVjdGlvbiA9IEdvb2dsZUNsb3VkU3RvcmFnZURvd25sb2FkQ29ubmVjdGlvbjtcbmNsYXNzIEdvb2dsZUNsb3VkU3RvcmFnZVJhd0Nvbm5lY3Rpb24gZXh0ZW5kcyBHb29nbGVEb3dubG9hZFJhd0Nvbm5lY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgY2FsbGVyLCBjbGllbnQpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzLCBjYWxsZXIsIGNsaWVudCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVyaVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVyaSA9IG5ldyBHb29nbGVDbG91ZFN0b3JhZ2VVcmkoZmllbGRzLnVyaSk7XG4gICAgfVxuICAgIGFzeW5jIGJ1aWxkVXJsKCkge1xuICAgICAgICBjb25zdCBwYXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMudXJpLnBhdGgpO1xuICAgICAgICBjb25zdCByZXQgPSBgaHR0cHM6Ly9zdG9yYWdlLmdvb2dsZWFwaXMuY29tL3N0b3JhZ2UvJHt0aGlzLmFwaVZlcnNpb259L2IvJHt0aGlzLnVyaS5idWNrZXR9L28vJHtwYXRofT9hbHQ9bWVkaWFgO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cbmV4cG9ydHMuR29vZ2xlQ2xvdWRTdG9yYWdlUmF3Q29ubmVjdGlvbiA9IEdvb2dsZUNsb3VkU3RvcmFnZVJhd0Nvbm5lY3Rpb247XG5jbGFzcyBCbG9iU3RvcmVHb29nbGVDbG91ZFN0b3JhZ2VCYXNlIGV4dGVuZHMgQmxvYlN0b3JlR29vZ2xlIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGFyYW1zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGFyYW1zID0gZmllbGRzO1xuICAgICAgICB0aGlzLmRlZmF1bHRTdG9yZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAuLi50aGlzLmRlZmF1bHRTdG9yZU9wdGlvbnMsXG4gICAgICAgICAgICBwYXRoUHJlZml4OiBmaWVsZHMudXJpUHJlZml4LnVyaSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYnVpbGRTZXRDb25uZWN0aW9uKFtrZXksIF9ibG9iXSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICAuLi50aGlzLnBhcmFtcyxcbiAgICAgICAgICAgIHVyaToga2V5LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IEdvb2dsZUNsb3VkU3RvcmFnZVVwbG9hZENvbm5lY3Rpb24ocGFyYW1zLCB0aGlzLmNhbGxlciwgdGhpcy5jbGllbnQpO1xuICAgIH1cbiAgICBidWlsZFNldE1ldGFkYXRhKFtrZXksIGJsb2JdKSB7XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBHb29nbGVDbG91ZFN0b3JhZ2VVcmkoa2V5KTtcbiAgICAgICAgY29uc3QgcmV0ID0ge1xuICAgICAgICAgICAgbmFtZTogdXJpLnBhdGgsXG4gICAgICAgICAgICBtZXRhZGF0YTogYmxvYi5tZXRhZGF0YSxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBibG9iLm1pbWV0eXBlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBidWlsZEdldE1ldGFkYXRhQ29ubmVjdGlvbihrZXkpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgdXJpOiBrZXksXG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBhbHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBHb29nbGVDbG91ZFN0b3JhZ2VEb3dubG9hZENvbm5lY3Rpb24ocGFyYW1zLCB0aGlzLmNhbGxlciwgdGhpcy5jbGllbnQpO1xuICAgIH1cbiAgICBidWlsZEdldERhdGFDb25uZWN0aW9uKGtleSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICB1cmk6IGtleSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBHb29nbGVDbG91ZFN0b3JhZ2VSYXdDb25uZWN0aW9uKHBhcmFtcywgdGhpcy5jYWxsZXIsIHRoaXMuY2xpZW50KTtcbiAgICB9XG4gICAgYnVpbGREZWxldGVDb25uZWN0aW9uKGtleSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICB1cmk6IGtleSxcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGFsdDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IEdvb2dsZUNsb3VkU3RvcmFnZURvd25sb2FkQ29ubmVjdGlvbihwYXJhbXMsIHRoaXMuY2FsbGVyLCB0aGlzLmNsaWVudCk7XG4gICAgfVxufVxuZXhwb3J0cy5CbG9iU3RvcmVHb29nbGVDbG91ZFN0b3JhZ2VCYXNlID0gQmxvYlN0b3JlR29vZ2xlQ2xvdWRTdG9yYWdlQmFzZTtcbmNsYXNzIEFJU3R1ZGlvTWVkaWFCbG9iIGV4dGVuZHMgbWVkaWFfY29yZV9qc18xLk1lZGlhQmxvYiB7XG4gICAgX3ZhbHVlQXNEYXRlKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuICAgIH1cbiAgICBfbWV0YWRhdGFGaWVsZEFzRGF0ZShmaWVsZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVBc0RhdGUodGhpcy5tZXRhZGF0YT8uW2ZpZWxkXSk7XG4gICAgfVxuICAgIGdldCBjcmVhdGVEYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWV0YWRhdGFGaWVsZEFzRGF0ZShcImNyZWF0ZVRpbWVcIik7XG4gICAgfVxuICAgIGdldCB1cGRhdGVEYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWV0YWRhdGFGaWVsZEFzRGF0ZShcInVwZGF0ZVRpbWVcIik7XG4gICAgfVxuICAgIGdldCBleHBpcmF0aW9uRGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21ldGFkYXRhRmllbGRBc0RhdGUoXCJleHBpcmF0aW9uVGltZVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRXhwaXJlZCgpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICBjb25zdCBleHAgPSB0aGlzLm1ldGFkYXRhPy5leHBpcmF0aW9uVGltZSA/PyBub3c7XG4gICAgICAgIHJldHVybiBleHAgPD0gbm93O1xuICAgIH1cbn1cbmV4cG9ydHMuQUlTdHVkaW9NZWRpYUJsb2IgPSBBSVN0dWRpb01lZGlhQmxvYjtcbmNsYXNzIEFJU3R1ZGlvRmlsZVVwbG9hZENvbm5lY3Rpb24gZXh0ZW5kcyBHb29nbGVNdWx0aXBhcnRVcGxvYWRDb25uZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXBpVmVyc2lvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJ2MWJldGFcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgYnVpbGRVcmwoKSB7XG4gICAgICAgIHJldHVybiBgaHR0cHM6Ly9nZW5lcmF0aXZlbGFuZ3VhZ2UuZ29vZ2xlYXBpcy5jb20vdXBsb2FkLyR7dGhpcy5hcGlWZXJzaW9ufS9maWxlc2A7XG4gICAgfVxufVxuZXhwb3J0cy5BSVN0dWRpb0ZpbGVVcGxvYWRDb25uZWN0aW9uID0gQUlTdHVkaW9GaWxlVXBsb2FkQ29ubmVjdGlvbjtcbmNsYXNzIEFJU3R1ZGlvRmlsZURvd25sb2FkQ29ubmVjdGlvbiBleHRlbmRzIEdvb2dsZURvd25sb2FkQ29ubmVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCBjYWxsZXIsIGNsaWVudCkge1xuICAgICAgICBzdXBlcihmaWVsZHMsIGNhbGxlciwgY2xpZW50KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0aG9kXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXBpVmVyc2lvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJ2MWJldGFcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBmaWVsZHMubWV0aG9kO1xuICAgICAgICB0aGlzLm5hbWUgPSBmaWVsZHMubmFtZTtcbiAgICB9XG4gICAgYnVpbGRNZXRob2QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ldGhvZDtcbiAgICB9XG4gICAgYXN5bmMgYnVpbGRVcmwoKSB7XG4gICAgICAgIHJldHVybiBgaHR0cHM6Ly9nZW5lcmF0aXZlbGFuZ3VhZ2UuZ29vZ2xlYXBpcy5jb20vJHt0aGlzLmFwaVZlcnNpb259L2ZpbGVzLyR7dGhpcy5uYW1lfWA7XG4gICAgfVxufVxuZXhwb3J0cy5BSVN0dWRpb0ZpbGVEb3dubG9hZENvbm5lY3Rpb24gPSBBSVN0dWRpb0ZpbGVEb3dubG9hZENvbm5lY3Rpb247XG5jbGFzcyBCbG9iU3RvcmVBSVN0dWRpb0ZpbGVCYXNlIGV4dGVuZHMgQmxvYlN0b3JlR29vZ2xlIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgZGVmYXVsdFN0b3JlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHBhdGhQcmVmaXg6IFwiaHR0cHM6Ly9nZW5lcmF0aXZlbGFuZ3VhZ2UuZ29vZ2xlYXBpcy5jb20vdjFiZXRhL2ZpbGVzL1wiLFxuICAgICAgICAgICAgICAgIGFjdGlvbklmSW52YWxpZDogXCJyZW1vdmVQYXRoXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICB9O1xuICAgICAgICBzdXBlcihwYXJhbXMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwYXJhbXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmV0cnlUaW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAxMDAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5yZXRyeVRpbWUgPSBwYXJhbXM/LnJldHJ5VGltZSA/PyB0aGlzLnJldHJ5VGltZSA/PyAxMDAwO1xuICAgIH1cbiAgICBfcGF0aFRvTmFtZShwYXRoKSB7XG4gICAgICAgIHJldHVybiBwYXRoLnNwbGl0KFwiL1wiKS5wb3AoKSA/PyBwYXRoO1xuICAgIH1cbiAgICBidWlsZEFwaUtleUNsaWVudChhcGlLZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhdXRoX2pzXzEuQXBpS2V5R29vZ2xlQXV0aChhcGlLZXkpO1xuICAgIH1cbiAgICBidWlsZEFwaUtleShmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkcz8uYXBpS2V5ID8/ICgwLCBlbnZfMS5nZXRFbnZpcm9ubWVudFZhcmlhYmxlKShcIkdPT0dMRV9BUElfS0VZXCIpO1xuICAgIH1cbiAgICBidWlsZENsaWVudChmaWVsZHMpIHtcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gdGhpcy5idWlsZEFwaUtleShmaWVsZHMpO1xuICAgICAgICBpZiAoYXBpS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZEFwaUtleUNsaWVudChhcGlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVE9ETzogVGVzdCB0aGF0IHlvdSBjYW4gdXNlIE9BdXRoIHRvIGFjY2Vzc1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRBYnN0cmFjdGVkQ2xpZW50KGZpZWxkcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX3JlZ2V0TWV0YWRhdGEoa2V5KSB7XG4gICAgICAgIC8vIFNsZWVwIGZvciBzb21lIHRpbWUgcGVyaW9kXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9taXNlLWV4ZWN1dG9yLXJldHVyblxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aGlzLnJldHJ5VGltZSkpO1xuICAgICAgICAvLyBGZXRjaCB0aGUgbGF0ZXN0IG1ldGFkYXRhXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRNZXRhZGF0YShrZXkpO1xuICAgIH1cbiAgICBhc3luYyBfc2V0KFtrZXksIGJsb2JdKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gKGF3YWl0IHN1cGVyLl9zZXQoW1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgYmxvYixcbiAgICAgICAgXSkpO1xuICAgICAgICBsZXQgZmlsZSA9IHJlc3BvbnNlLmRhdGE/LmZpbGUgPz8geyBzdGF0ZTogXCJGQUlMRURcIiB9O1xuICAgICAgICB3aGlsZSAoZmlsZS5zdGF0ZSA9PT0gXCJQUk9DRVNTSU5HXCIgJiYgZmlsZS51cmkgJiYgdGhpcy5yZXRyeVRpbWUgPiAwKSB7XG4gICAgICAgICAgICBmaWxlID0gYXdhaXQgdGhpcy5fcmVnZXRNZXRhZGF0YShmaWxlLnVyaSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHJlc3BvbnNlIHNob3VsZCBjb250YWluIHRoZSBuYW1lIChhbmQgdmFsaWQgVVJJKSwgc28gd2UgbmVlZCB0b1xuICAgICAgICAvLyB1cGRhdGUgdGhlIGJsb2Igd2l0aCB0aGlzLiBXZSBjYW4ndCByZXR1cm4gYSBuZXcgYmxvYiwgc2luY2UgbXNldCgpXG4gICAgICAgIC8vIGRvZXNuJ3QgcmV0dXJuIGFueXRoaW5nLlxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuICAgICAgICBibG9iLnBhdGggPSBmaWxlLnVyaTtcbiAgICAgICAgYmxvYi5tZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIC4uLmJsb2IubWV0YWRhdGEsXG4gICAgICAgICAgICAuLi5maWxlLFxuICAgICAgICB9O1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYnVpbGRTZXRDb25uZWN0aW9uKFtfa2V5LCBfYmxvYl0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBSVN0dWRpb0ZpbGVVcGxvYWRDb25uZWN0aW9uKHRoaXMucGFyYW1zLCB0aGlzLmNhbGxlciwgdGhpcy5jbGllbnQpO1xuICAgIH1cbiAgICBidWlsZFNldE1ldGFkYXRhKFtfa2V5LCBfYmxvYl0pIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBidWlsZEdldE1ldGFkYXRhQ29ubmVjdGlvbihrZXkpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgLi4udGhpcy5wYXJhbXMsXG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBuYW1lOiB0aGlzLl9wYXRoVG9OYW1lKGtleSksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgQUlTdHVkaW9GaWxlRG93bmxvYWRDb25uZWN0aW9uKHBhcmFtcywgdGhpcy5jYWxsZXIsIHRoaXMuY2xpZW50KTtcbiAgICB9XG4gICAgYnVpbGRHZXREYXRhQ29ubmVjdGlvbihfa2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFJIFN0dWRpbyBGaWxlIEFQSSBkb2VzIG5vdCBwcm92aWRlIGRhdGFcIik7XG4gICAgfVxuICAgIGFzeW5jIF9nZXQoa2V5KSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5fZ2V0TWV0YWRhdGEoa2V5KTtcbiAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IG1ldGFkYXRhPy5taW1lVHlwZSA/PyBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiO1xuICAgICAgICAgICAgLy8gVE9ETyAtIEdldCB0aGUgYWN0dWFsIGRhdGEgKGFuZCBvdGhlciBtZXRhZGF0YSkgZnJvbSBhbiBvcHRpb25hbCBiYWNraW5nIHN0b3JlXG4gICAgICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBcIlwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IGNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbWVkaWFfY29yZV9qc18xLk1lZGlhQmxvYih7XG4gICAgICAgICAgICAgICAgcGF0aDoga2V5LFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnVpbGREZWxldGVDb25uZWN0aW9uKGtleSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICAuLi50aGlzLnBhcmFtcyxcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuX3BhdGhUb05hbWUoa2V5KSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBBSVN0dWRpb0ZpbGVEb3dubG9hZENvbm5lY3Rpb24ocGFyYW1zLCB0aGlzLmNhbGxlciwgdGhpcy5jbGllbnQpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmxvYlN0b3JlQUlTdHVkaW9GaWxlQmFzZSA9IEJsb2JTdG9yZUFJU3R1ZGlvRmlsZUJhc2U7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/experimental/media.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/experimental/utils/media_core.cjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/experimental/utils/media_core.cjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MediaManager = exports.DataBlobStore = exports.SimpleWebBlobStore = exports.ReadThroughBlobStore = exports.BackedBlobStore = exports.BlobStore = exports.MediaBlob = void 0;\nconst uuid_1 = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/index.js\"); // FIXME - it is importing the wrong uuid, so v6 and v7 aren't implemented\nconst stores_1 = __webpack_require__(/*! @langchain/core/stores */ \"(rsc)/./node_modules/@langchain/core/stores.cjs\");\nconst serializable_1 = __webpack_require__(/*! @langchain/core/load/serializable */ \"(rsc)/./node_modules/@langchain/core/load/serializable.cjs\");\nfunction bytesToString(dataArray) {\n    // Need to handle the array in smaller chunks to deal with stack size limits\n    let ret = \"\";\n    const chunkSize = 102400;\n    for (let i = 0; i < dataArray.length; i += chunkSize) {\n        const chunk = dataArray.subarray(i, i + chunkSize);\n        ret += String.fromCharCode(...chunk);\n    }\n    return ret;\n}\n/**\n * Represents a chunk of data that can be identified by the path where the\n * data is (or will be) located, along with optional metadata about the data.\n */\nclass MediaBlob extends serializable_1.Serializable {\n    constructor(params) {\n        super(params);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\n                \"langchain\",\n                \"google_common\",\n                \"experimental\",\n                \"utils\",\n                \"media_core\",\n            ]\n        });\n        Object.defineProperty(this, \"data\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {\n                value: \"\",\n                type: \"text/plain\",\n            }\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"path\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.data = params.data ?? this.data;\n        this.metadata = params.metadata;\n        this.path = params.path;\n    }\n    get size() {\n        return this.asBytes.length;\n    }\n    get dataType() {\n        return this.data?.type ?? \"\";\n    }\n    get encoding() {\n        const charsetEquals = this.dataType.indexOf(\"charset=\");\n        return charsetEquals === -1\n            ? \"utf-8\"\n            : this.dataType.substring(charsetEquals + 8);\n    }\n    get mimetype() {\n        const semicolon = this.dataType.indexOf(\";\");\n        return semicolon === -1\n            ? this.dataType\n            : this.dataType.substring(0, semicolon);\n    }\n    get asBytes() {\n        if (!this.data) {\n            return Uint8Array.from([]);\n        }\n        const binString = atob(this.data?.value);\n        const ret = new Uint8Array(binString.length);\n        for (let co = 0; co < binString.length; co += 1) {\n            ret[co] = binString.charCodeAt(co);\n        }\n        return ret;\n    }\n    async asString() {\n        return bytesToString(this.asBytes);\n    }\n    async asBase64() {\n        return this.data?.value ?? \"\";\n    }\n    async asDataUrl() {\n        return `data:${this.mimetype};base64,${await this.asBase64()}`;\n    }\n    async asUri() {\n        return this.path ?? (await this.asDataUrl());\n    }\n    async encode() {\n        const dataUrl = await this.asDataUrl();\n        const comma = dataUrl.indexOf(\",\");\n        const encoded = dataUrl.substring(comma + 1);\n        const encoding = dataUrl.indexOf(\"base64\") > -1 ? \"base64\" : \"8bit\";\n        return {\n            encoded,\n            encoding,\n        };\n    }\n    static fromDataUrl(url) {\n        if (!url.startsWith(\"data:\")) {\n            throw new Error(\"Not a data: URL\");\n        }\n        const colon = url.indexOf(\":\");\n        const semicolon = url.indexOf(\";\");\n        const mimeType = url.substring(colon + 1, semicolon);\n        const comma = url.indexOf(\",\");\n        const base64Data = url.substring(comma + 1);\n        const data = {\n            type: mimeType,\n            value: base64Data,\n        };\n        return new MediaBlob({\n            data,\n            path: url,\n        });\n    }\n    static async fromBlob(blob, other) {\n        const valueBuffer = await blob.arrayBuffer();\n        const valueArray = new Uint8Array(valueBuffer);\n        const valueStr = bytesToString(valueArray);\n        const value = btoa(valueStr);\n        return new MediaBlob({\n            ...other,\n            data: {\n                value,\n                type: blob.type,\n            },\n        });\n    }\n}\nexports.MediaBlob = MediaBlob;\n/**\n * A specialized Store that is designed to handle MediaBlobs and use the\n * key that is included in the blob to determine exactly how it is stored.\n *\n * The full details of a MediaBlob may be changed when it is stored.\n * For example, it may get additional or different Metadata. This should be\n * what is returned when the store() method is called.\n *\n * Although BlobStore extends BaseStore, not all of the methods from\n * BaseStore may be implemented (or even possible). Those that are not\n * implemented should be documented and throw an Error if called.\n */\nclass BlobStore extends stores_1.BaseStore {\n    constructor(opts) {\n        super(opts);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"google-common\"]\n        }); // FIXME - What should this be? And why?\n        Object.defineProperty(this, \"defaultStoreOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"defaultFetchOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.defaultStoreOptions = opts?.defaultStoreOptions ?? {};\n        this.defaultFetchOptions = opts?.defaultFetchOptions ?? {};\n    }\n    async _realKey(key) {\n        return typeof key === \"string\" ? key : await key.asUri();\n    }\n    /**\n     * Is the path supported by this BlobStore?\n     *\n     * Although this is async, this is expected to be a relatively fast operation\n     * (ie - you shouldn't make network calls).\n     *\n     * @param path The path to check\n     * @param opts Any options (if needed) that may be used to determine if it is valid\n     * @return If the path is supported\n     */\n    hasValidPath(path, opts) {\n        const prefix = opts?.pathPrefix ?? \"\";\n        const isPrefixed = typeof path !== \"undefined\" && path.startsWith(prefix);\n        return Promise.resolve(isPrefixed);\n    }\n    _blobPathSuffix(blob) {\n        // Get the path currently set and make sure we treat it as a string\n        const blobPath = `${blob.path}`;\n        // Advance past the first set of /\n        let pathStart = blobPath.indexOf(\"/\") + 1;\n        while (blobPath.charAt(pathStart) === \"/\") {\n            pathStart += 1;\n        }\n        // We will use the rest as the path for a replacement\n        return blobPath.substring(pathStart);\n    }\n    async _newBlob(oldBlob, newPath) {\n        const oldPath = oldBlob.path;\n        const metadata = oldBlob?.metadata ?? {};\n        metadata.langchainOldPath = oldPath;\n        const newBlob = new MediaBlob({\n            ...oldBlob,\n            metadata,\n        });\n        if (newPath) {\n            newBlob.path = newPath;\n        }\n        else if (newBlob.path) {\n            delete newBlob.path;\n        }\n        return newBlob;\n    }\n    async _validBlobPrefixPath(blob, opts) {\n        const prefix = opts?.pathPrefix ?? \"\";\n        const suffix = this._blobPathSuffix(blob);\n        const newPath = `${prefix}${suffix}`;\n        return this._newBlob(blob, newPath);\n    }\n    _validBlobPrefixUuidFunction(name) {\n        switch (name) {\n            case \"prefixUuid1\":\n                return (0, uuid_1.v1)();\n            case \"prefixUuid4\":\n                return (0, uuid_1.v4)();\n            // case \"prefixUuid6\": return v6();\n            // case \"prefixUuid7\": return v7();\n            default:\n                throw new Error(`Unknown uuid function: ${name}`);\n        }\n    }\n    async _validBlobPrefixUuid(blob, opts) {\n        const prefix = opts?.pathPrefix ?? \"\";\n        const suffix = this._validBlobPrefixUuidFunction(opts?.actionIfInvalid ?? \"prefixUuid4\");\n        const newPath = `${prefix}${suffix}`;\n        return this._newBlob(blob, newPath);\n    }\n    async _validBlobRemovePath(blob, _opts) {\n        return this._newBlob(blob, undefined);\n    }\n    /**\n     * Based on the blob and options, return a blob that has a valid path\n     * that can be saved.\n     * @param blob\n     * @param opts\n     */\n    async _validStoreBlob(blob, opts) {\n        if (await this.hasValidPath(blob.path, opts)) {\n            return blob;\n        }\n        switch (opts?.actionIfInvalid) {\n            case \"ignore\":\n                return blob;\n            case \"prefixPath\":\n                return this._validBlobPrefixPath(blob, opts);\n            case \"prefixUuid1\":\n            case \"prefixUuid4\":\n            case \"prefixUuid6\":\n            case \"prefixUuid7\":\n                return this._validBlobPrefixUuid(blob, opts);\n            case \"removePath\":\n                return this._validBlobRemovePath(blob, opts);\n            default:\n                return undefined;\n        }\n    }\n    async store(blob, opts = {}) {\n        const allOpts = {\n            ...this.defaultStoreOptions,\n            ...opts,\n        };\n        const validBlob = await this._validStoreBlob(blob, allOpts);\n        if (typeof validBlob !== \"undefined\") {\n            const validKey = await validBlob.asUri();\n            await this.mset([[validKey, validBlob]]);\n            const savedKey = await validBlob.asUri();\n            return await this.fetch(savedKey);\n        }\n        return undefined;\n    }\n    async _missingFetchBlobEmpty(path, _opts) {\n        return new MediaBlob({ path });\n    }\n    async _missingFetchBlob(path, opts) {\n        switch (opts?.actionIfBlobMissing) {\n            case \"emptyBlob\":\n                return this._missingFetchBlobEmpty(path, opts);\n            default:\n                return undefined;\n        }\n    }\n    async fetch(key, opts = {}) {\n        const allOpts = {\n            ...this.defaultFetchOptions,\n            ...opts,\n        };\n        const realKey = await this._realKey(key);\n        const ret = await this.mget([realKey]);\n        return ret?.[0] ?? (await this._missingFetchBlob(realKey, allOpts));\n    }\n}\nexports.BlobStore = BlobStore;\nclass BackedBlobStore extends BlobStore {\n    constructor(opts) {\n        super(opts);\n        Object.defineProperty(this, \"backingStore\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.backingStore = opts.backingStore;\n    }\n    mdelete(keys) {\n        return this.backingStore.mdelete(keys);\n    }\n    mget(keys) {\n        return this.backingStore.mget(keys);\n    }\n    mset(keyValuePairs) {\n        return this.backingStore.mset(keyValuePairs);\n    }\n    yieldKeys(prefix) {\n        return this.backingStore.yieldKeys(prefix);\n    }\n}\nexports.BackedBlobStore = BackedBlobStore;\nclass ReadThroughBlobStore extends BlobStore {\n    constructor(opts) {\n        super(opts);\n        Object.defineProperty(this, \"baseStore\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"backingStore\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.baseStore = opts.baseStore;\n        this.backingStore = opts.backingStore;\n    }\n    async store(blob, opts = {}) {\n        const originalUri = await blob.asUri();\n        const newBlob = await this.backingStore.store(blob, opts);\n        if (newBlob) {\n            await this.baseStore.mset([[originalUri, newBlob]]);\n        }\n        return newBlob;\n    }\n    mdelete(keys) {\n        return this.baseStore.mdelete(keys);\n    }\n    mget(keys) {\n        return this.baseStore.mget(keys);\n    }\n    mset(_keyValuePairs) {\n        throw new Error(\"Do not call ReadThroughBlobStore.mset directly\");\n    }\n    yieldKeys(prefix) {\n        return this.baseStore.yieldKeys(prefix);\n    }\n}\nexports.ReadThroughBlobStore = ReadThroughBlobStore;\nclass SimpleWebBlobStore extends BlobStore {\n    _notImplementedException() {\n        throw new Error(\"Not implemented for SimpleWebBlobStore\");\n    }\n    async hasValidPath(path, _opts) {\n        return ((await super.hasValidPath(path, { pathPrefix: \"https://\" })) ||\n            (await super.hasValidPath(path, { pathPrefix: \"http://\" })));\n    }\n    async _fetch(url) {\n        const ret = new MediaBlob({\n            path: url,\n        });\n        const metadata = {};\n        const fetchOptions = {\n            method: \"GET\",\n        };\n        const res = await fetch(url, fetchOptions);\n        metadata.status = res.status;\n        const headers = {};\n        for (const [key, value] of res.headers.entries()) {\n            headers[key] = value;\n        }\n        metadata.headers = headers;\n        metadata.ok = res.ok;\n        if (res.ok) {\n            const resMediaBlob = await MediaBlob.fromBlob(await res.blob());\n            ret.data = resMediaBlob.data;\n        }\n        ret.metadata = metadata;\n        return ret;\n    }\n    async mget(keys) {\n        const blobMap = keys.map(this._fetch);\n        return await Promise.all(blobMap);\n    }\n    async mdelete(_keys) {\n        this._notImplementedException();\n    }\n    async mset(_keyValuePairs) {\n        this._notImplementedException();\n    }\n    async *yieldKeys(_prefix) {\n        this._notImplementedException();\n        yield \"\";\n    }\n}\nexports.SimpleWebBlobStore = SimpleWebBlobStore;\n/**\n * A blob \"store\" that works with data: URLs that will turn the URL into\n * a blob.\n */\nclass DataBlobStore extends BlobStore {\n    _notImplementedException() {\n        throw new Error(\"Not implemented for DataBlobStore\");\n    }\n    hasValidPath(path, _opts) {\n        return super.hasValidPath(path, { pathPrefix: \"data:\" });\n    }\n    _fetch(url) {\n        return MediaBlob.fromDataUrl(url);\n    }\n    async mget(keys) {\n        const blobMap = keys.map(this._fetch);\n        return blobMap;\n    }\n    async mdelete(_keys) {\n        this._notImplementedException();\n    }\n    async mset(_keyValuePairs) {\n        this._notImplementedException();\n    }\n    async *yieldKeys(_prefix) {\n        this._notImplementedException();\n        yield \"\";\n    }\n}\nexports.DataBlobStore = DataBlobStore;\n/**\n * Responsible for converting a URI (typically a web URL) into a MediaBlob.\n * Allows for aliasing / caching of the requested URI and what it resolves to.\n * This MediaBlob is expected to be usable to provide to an LLM, either\n * through the Base64 of the media or through a canonical URI that the LLM\n * supports.\n */\nclass MediaManager {\n    constructor(config) {\n        Object.defineProperty(this, \"store\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"resolvers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.store = config.store;\n        this.resolvers = config.resolvers;\n    }\n    defaultResolvers() {\n        return [new DataBlobStore({}), new SimpleWebBlobStore({})];\n    }\n    async _isInvalid(blob) {\n        return typeof blob === \"undefined\";\n    }\n    /**\n     * Given the public URI, load what is at this URI and save it\n     * in the store.\n     * @param uri The URI to resolve using the resolver\n     * @return A canonical MediaBlob for this URI\n     */\n    async _resolveAndSave(uri) {\n        let resolvedBlob;\n        const resolvers = this.resolvers || this.defaultResolvers();\n        for (let co = 0; co < resolvers.length; co += 1) {\n            const resolver = resolvers[co];\n            if (await resolver.hasValidPath(uri)) {\n                resolvedBlob = await resolver.fetch(uri);\n            }\n        }\n        if (resolvedBlob) {\n            return await this.store.store(resolvedBlob);\n        }\n        else {\n            return new MediaBlob({});\n        }\n    }\n    async getMediaBlob(uri) {\n        const aliasBlob = await this.store.fetch(uri);\n        const ret = (await this._isInvalid(aliasBlob))\n            ? await this._resolveAndSave(uri)\n            : aliasBlob;\n        return ret;\n    }\n}\nexports.MediaManager = MediaManager;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvZXhwZXJpbWVudGFsL3V0aWxzL21lZGlhX2NvcmUuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLHFCQUFxQixHQUFHLDBCQUEwQixHQUFHLDRCQUE0QixHQUFHLHVCQUF1QixHQUFHLGlCQUFpQixHQUFHLGlCQUFpQjtBQUMxSyxlQUFlLG1CQUFPLENBQUMsb0dBQU0sR0FBRztBQUNoQyxpQkFBaUIsbUJBQU8sQ0FBQywrRUFBd0I7QUFDakQsdUJBQXVCLG1CQUFPLENBQUMscUdBQW1DO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWUsU0FBUyxzQkFBc0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPLEVBQUUsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELEtBQUs7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPLEVBQUUsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCx3QkFBd0I7QUFDMUUsOENBQThDLHVCQUF1QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMscUJBQXFCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9kaXN0L2V4cGVyaW1lbnRhbC91dGlscy9tZWRpYV9jb3JlLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVkaWFNYW5hZ2VyID0gZXhwb3J0cy5EYXRhQmxvYlN0b3JlID0gZXhwb3J0cy5TaW1wbGVXZWJCbG9iU3RvcmUgPSBleHBvcnRzLlJlYWRUaHJvdWdoQmxvYlN0b3JlID0gZXhwb3J0cy5CYWNrZWRCbG9iU3RvcmUgPSBleHBvcnRzLkJsb2JTdG9yZSA9IGV4cG9ydHMuTWVkaWFCbG9iID0gdm9pZCAwO1xuY29uc3QgdXVpZF8xID0gcmVxdWlyZShcInV1aWRcIik7IC8vIEZJWE1FIC0gaXQgaXMgaW1wb3J0aW5nIHRoZSB3cm9uZyB1dWlkLCBzbyB2NiBhbmQgdjcgYXJlbid0IGltcGxlbWVudGVkXG5jb25zdCBzdG9yZXNfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvc3RvcmVzXCIpO1xuY29uc3Qgc2VyaWFsaXphYmxlXzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL2xvYWQvc2VyaWFsaXphYmxlXCIpO1xuZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhkYXRhQXJyYXkpIHtcbiAgICAvLyBOZWVkIHRvIGhhbmRsZSB0aGUgYXJyYXkgaW4gc21hbGxlciBjaHVua3MgdG8gZGVhbCB3aXRoIHN0YWNrIHNpemUgbGltaXRzXG4gICAgbGV0IHJldCA9IFwiXCI7XG4gICAgY29uc3QgY2h1bmtTaXplID0gMTAyNDAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YUFycmF5Lmxlbmd0aDsgaSArPSBjaHVua1NpemUpIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSBkYXRhQXJyYXkuc3ViYXJyYXkoaSwgaSArIGNodW5rU2l6ZSk7XG4gICAgICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmNodW5rKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIGNodW5rIG9mIGRhdGEgdGhhdCBjYW4gYmUgaWRlbnRpZmllZCBieSB0aGUgcGF0aCB3aGVyZSB0aGVcbiAqIGRhdGEgaXMgKG9yIHdpbGwgYmUpIGxvY2F0ZWQsIGFsb25nIHdpdGggb3B0aW9uYWwgbWV0YWRhdGEgYWJvdXQgdGhlIGRhdGEuXG4gKi9cbmNsYXNzIE1lZGlhQmxvYiBleHRlbmRzIHNlcmlhbGl6YWJsZV8xLlNlcmlhbGl6YWJsZSB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIHN1cGVyKHBhcmFtcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXG4gICAgICAgICAgICAgICAgXCJsYW5nY2hhaW5cIixcbiAgICAgICAgICAgICAgICBcImdvb2dsZV9jb21tb25cIixcbiAgICAgICAgICAgICAgICBcImV4cGVyaW1lbnRhbFwiLFxuICAgICAgICAgICAgICAgIFwidXRpbHNcIixcbiAgICAgICAgICAgICAgICBcIm1lZGlhX2NvcmVcIixcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQvcGxhaW5cIixcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldGFkYXRhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBhdGhcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kYXRhID0gcGFyYW1zLmRhdGEgPz8gdGhpcy5kYXRhO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gcGFyYW1zLm1ldGFkYXRhO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXJhbXMucGF0aDtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzQnl0ZXMubGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgZGF0YVR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE/LnR5cGUgPz8gXCJcIjtcbiAgICB9XG4gICAgZ2V0IGVuY29kaW5nKCkge1xuICAgICAgICBjb25zdCBjaGFyc2V0RXF1YWxzID0gdGhpcy5kYXRhVHlwZS5pbmRleE9mKFwiY2hhcnNldD1cIik7XG4gICAgICAgIHJldHVybiBjaGFyc2V0RXF1YWxzID09PSAtMVxuICAgICAgICAgICAgPyBcInV0Zi04XCJcbiAgICAgICAgICAgIDogdGhpcy5kYXRhVHlwZS5zdWJzdHJpbmcoY2hhcnNldEVxdWFscyArIDgpO1xuICAgIH1cbiAgICBnZXQgbWltZXR5cGUoKSB7XG4gICAgICAgIGNvbnN0IHNlbWljb2xvbiA9IHRoaXMuZGF0YVR5cGUuaW5kZXhPZihcIjtcIik7XG4gICAgICAgIHJldHVybiBzZW1pY29sb24gPT09IC0xXG4gICAgICAgICAgICA/IHRoaXMuZGF0YVR5cGVcbiAgICAgICAgICAgIDogdGhpcy5kYXRhVHlwZS5zdWJzdHJpbmcoMCwgc2VtaWNvbG9uKTtcbiAgICB9XG4gICAgZ2V0IGFzQnl0ZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKFtdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiaW5TdHJpbmcgPSBhdG9iKHRoaXMuZGF0YT8udmFsdWUpO1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgVWludDhBcnJheShiaW5TdHJpbmcubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgY28gPSAwOyBjbyA8IGJpblN0cmluZy5sZW5ndGg7IGNvICs9IDEpIHtcbiAgICAgICAgICAgIHJldFtjb10gPSBiaW5TdHJpbmcuY2hhckNvZGVBdChjbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgYXN5bmMgYXNTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBieXRlc1RvU3RyaW5nKHRoaXMuYXNCeXRlcyk7XG4gICAgfVxuICAgIGFzeW5jIGFzQmFzZTY0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhPy52YWx1ZSA/PyBcIlwiO1xuICAgIH1cbiAgICBhc3luYyBhc0RhdGFVcmwoKSB7XG4gICAgICAgIHJldHVybiBgZGF0YToke3RoaXMubWltZXR5cGV9O2Jhc2U2NCwke2F3YWl0IHRoaXMuYXNCYXNlNjQoKX1gO1xuICAgIH1cbiAgICBhc3luYyBhc1VyaSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aCA/PyAoYXdhaXQgdGhpcy5hc0RhdGFVcmwoKSk7XG4gICAgfVxuICAgIGFzeW5jIGVuY29kZSgpIHtcbiAgICAgICAgY29uc3QgZGF0YVVybCA9IGF3YWl0IHRoaXMuYXNEYXRhVXJsKCk7XG4gICAgICAgIGNvbnN0IGNvbW1hID0gZGF0YVVybC5pbmRleE9mKFwiLFwiKTtcbiAgICAgICAgY29uc3QgZW5jb2RlZCA9IGRhdGFVcmwuc3Vic3RyaW5nKGNvbW1hICsgMSk7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0gZGF0YVVybC5pbmRleE9mKFwiYmFzZTY0XCIpID4gLTEgPyBcImJhc2U2NFwiIDogXCI4Yml0XCI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbmNvZGVkLFxuICAgICAgICAgICAgZW5jb2RpbmcsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRGF0YVVybCh1cmwpIHtcbiAgICAgICAgaWYgKCF1cmwuc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSBkYXRhOiBVUkxcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29sb24gPSB1cmwuaW5kZXhPZihcIjpcIik7XG4gICAgICAgIGNvbnN0IHNlbWljb2xvbiA9IHVybC5pbmRleE9mKFwiO1wiKTtcbiAgICAgICAgY29uc3QgbWltZVR5cGUgPSB1cmwuc3Vic3RyaW5nKGNvbG9uICsgMSwgc2VtaWNvbG9uKTtcbiAgICAgICAgY29uc3QgY29tbWEgPSB1cmwuaW5kZXhPZihcIixcIik7XG4gICAgICAgIGNvbnN0IGJhc2U2NERhdGEgPSB1cmwuc3Vic3RyaW5nKGNvbW1hICsgMSk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICB0eXBlOiBtaW1lVHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiBiYXNlNjREYXRhLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IE1lZGlhQmxvYih7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGF0aDogdXJsLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGZyb21CbG9iKGJsb2IsIG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlQnVmZmVyID0gYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpO1xuICAgICAgICBjb25zdCB2YWx1ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodmFsdWVCdWZmZXIpO1xuICAgICAgICBjb25zdCB2YWx1ZVN0ciA9IGJ5dGVzVG9TdHJpbmcodmFsdWVBcnJheSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYnRvYSh2YWx1ZVN0cik7XG4gICAgICAgIHJldHVybiBuZXcgTWVkaWFCbG9iKHtcbiAgICAgICAgICAgIC4uLm90aGVyLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHR5cGU6IGJsb2IudHlwZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuTWVkaWFCbG9iID0gTWVkaWFCbG9iO1xuLyoqXG4gKiBBIHNwZWNpYWxpemVkIFN0b3JlIHRoYXQgaXMgZGVzaWduZWQgdG8gaGFuZGxlIE1lZGlhQmxvYnMgYW5kIHVzZSB0aGVcbiAqIGtleSB0aGF0IGlzIGluY2x1ZGVkIGluIHRoZSBibG9iIHRvIGRldGVybWluZSBleGFjdGx5IGhvdyBpdCBpcyBzdG9yZWQuXG4gKlxuICogVGhlIGZ1bGwgZGV0YWlscyBvZiBhIE1lZGlhQmxvYiBtYXkgYmUgY2hhbmdlZCB3aGVuIGl0IGlzIHN0b3JlZC5cbiAqIEZvciBleGFtcGxlLCBpdCBtYXkgZ2V0IGFkZGl0aW9uYWwgb3IgZGlmZmVyZW50IE1ldGFkYXRhLiBUaGlzIHNob3VsZCBiZVxuICogd2hhdCBpcyByZXR1cm5lZCB3aGVuIHRoZSBzdG9yZSgpIG1ldGhvZCBpcyBjYWxsZWQuXG4gKlxuICogQWx0aG91Z2ggQmxvYlN0b3JlIGV4dGVuZHMgQmFzZVN0b3JlLCBub3QgYWxsIG9mIHRoZSBtZXRob2RzIGZyb21cbiAqIEJhc2VTdG9yZSBtYXkgYmUgaW1wbGVtZW50ZWQgKG9yIGV2ZW4gcG9zc2libGUpLiBUaG9zZSB0aGF0IGFyZSBub3RcbiAqIGltcGxlbWVudGVkIHNob3VsZCBiZSBkb2N1bWVudGVkIGFuZCB0aHJvdyBhbiBFcnJvciBpZiBjYWxsZWQuXG4gKi9cbmNsYXNzIEJsb2JTdG9yZSBleHRlbmRzIHN0b3Jlc18xLkJhc2VTdG9yZSB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5cIiwgXCJnb29nbGUtY29tbW9uXCJdXG4gICAgICAgIH0pOyAvLyBGSVhNRSAtIFdoYXQgc2hvdWxkIHRoaXMgYmU/IEFuZCB3aHk/XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlZmF1bHRTdG9yZU9wdGlvbnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVmYXVsdEZldGNoT3B0aW9uc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRlZmF1bHRTdG9yZU9wdGlvbnMgPSBvcHRzPy5kZWZhdWx0U3RvcmVPcHRpb25zID8/IHt9O1xuICAgICAgICB0aGlzLmRlZmF1bHRGZXRjaE9wdGlvbnMgPSBvcHRzPy5kZWZhdWx0RmV0Y2hPcHRpb25zID8/IHt9O1xuICAgIH1cbiAgICBhc3luYyBfcmVhbEtleShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgPyBrZXkgOiBhd2FpdCBrZXkuYXNVcmkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhlIHBhdGggc3VwcG9ydGVkIGJ5IHRoaXMgQmxvYlN0b3JlP1xuICAgICAqXG4gICAgICogQWx0aG91Z2ggdGhpcyBpcyBhc3luYywgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhIHJlbGF0aXZlbHkgZmFzdCBvcGVyYXRpb25cbiAgICAgKiAoaWUgLSB5b3Ugc2hvdWxkbid0IG1ha2UgbmV0d29yayBjYWxscykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byBjaGVja1xuICAgICAqIEBwYXJhbSBvcHRzIEFueSBvcHRpb25zIChpZiBuZWVkZWQpIHRoYXQgbWF5IGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGl0IGlzIHZhbGlkXG4gICAgICogQHJldHVybiBJZiB0aGUgcGF0aCBpcyBzdXBwb3J0ZWRcbiAgICAgKi9cbiAgICBoYXNWYWxpZFBhdGgocGF0aCwgb3B0cykge1xuICAgICAgICBjb25zdCBwcmVmaXggPSBvcHRzPy5wYXRoUHJlZml4ID8/IFwiXCI7XG4gICAgICAgIGNvbnN0IGlzUHJlZml4ZWQgPSB0eXBlb2YgcGF0aCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwYXRoLnN0YXJ0c1dpdGgocHJlZml4KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpc1ByZWZpeGVkKTtcbiAgICB9XG4gICAgX2Jsb2JQYXRoU3VmZml4KGJsb2IpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBwYXRoIGN1cnJlbnRseSBzZXQgYW5kIG1ha2Ugc3VyZSB3ZSB0cmVhdCBpdCBhcyBhIHN0cmluZ1xuICAgICAgICBjb25zdCBibG9iUGF0aCA9IGAke2Jsb2IucGF0aH1gO1xuICAgICAgICAvLyBBZHZhbmNlIHBhc3QgdGhlIGZpcnN0IHNldCBvZiAvXG4gICAgICAgIGxldCBwYXRoU3RhcnQgPSBibG9iUGF0aC5pbmRleE9mKFwiL1wiKSArIDE7XG4gICAgICAgIHdoaWxlIChibG9iUGF0aC5jaGFyQXQocGF0aFN0YXJ0KSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgIHBhdGhTdGFydCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIHdpbGwgdXNlIHRoZSByZXN0IGFzIHRoZSBwYXRoIGZvciBhIHJlcGxhY2VtZW50XG4gICAgICAgIHJldHVybiBibG9iUGF0aC5zdWJzdHJpbmcocGF0aFN0YXJ0KTtcbiAgICB9XG4gICAgYXN5bmMgX25ld0Jsb2Iob2xkQmxvYiwgbmV3UGF0aCkge1xuICAgICAgICBjb25zdCBvbGRQYXRoID0gb2xkQmxvYi5wYXRoO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IG9sZEJsb2I/Lm1ldGFkYXRhID8/IHt9O1xuICAgICAgICBtZXRhZGF0YS5sYW5nY2hhaW5PbGRQYXRoID0gb2xkUGF0aDtcbiAgICAgICAgY29uc3QgbmV3QmxvYiA9IG5ldyBNZWRpYUJsb2Ioe1xuICAgICAgICAgICAgLi4ub2xkQmxvYixcbiAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5ld1BhdGgpIHtcbiAgICAgICAgICAgIG5ld0Jsb2IucGF0aCA9IG5ld1BhdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3QmxvYi5wYXRoKSB7XG4gICAgICAgICAgICBkZWxldGUgbmV3QmxvYi5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdCbG9iO1xuICAgIH1cbiAgICBhc3luYyBfdmFsaWRCbG9iUHJlZml4UGF0aChibG9iLCBvcHRzKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IG9wdHM/LnBhdGhQcmVmaXggPz8gXCJcIjtcbiAgICAgICAgY29uc3Qgc3VmZml4ID0gdGhpcy5fYmxvYlBhdGhTdWZmaXgoYmxvYik7XG4gICAgICAgIGNvbnN0IG5ld1BhdGggPSBgJHtwcmVmaXh9JHtzdWZmaXh9YDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0Jsb2IoYmxvYiwgbmV3UGF0aCk7XG4gICAgfVxuICAgIF92YWxpZEJsb2JQcmVmaXhVdWlkRnVuY3Rpb24obmFtZSkge1xuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJwcmVmaXhVdWlkMVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdXVpZF8xLnYxKSgpO1xuICAgICAgICAgICAgY2FzZSBcInByZWZpeFV1aWQ0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dWlkXzEudjQpKCk7XG4gICAgICAgICAgICAvLyBjYXNlIFwicHJlZml4VXVpZDZcIjogcmV0dXJuIHY2KCk7XG4gICAgICAgICAgICAvLyBjYXNlIFwicHJlZml4VXVpZDdcIjogcmV0dXJuIHY3KCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB1dWlkIGZ1bmN0aW9uOiAke25hbWV9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX3ZhbGlkQmxvYlByZWZpeFV1aWQoYmxvYiwgb3B0cykge1xuICAgICAgICBjb25zdCBwcmVmaXggPSBvcHRzPy5wYXRoUHJlZml4ID8/IFwiXCI7XG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IHRoaXMuX3ZhbGlkQmxvYlByZWZpeFV1aWRGdW5jdGlvbihvcHRzPy5hY3Rpb25JZkludmFsaWQgPz8gXCJwcmVmaXhVdWlkNFwiKTtcbiAgICAgICAgY29uc3QgbmV3UGF0aCA9IGAke3ByZWZpeH0ke3N1ZmZpeH1gO1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3QmxvYihibG9iLCBuZXdQYXRoKTtcbiAgICB9XG4gICAgYXN5bmMgX3ZhbGlkQmxvYlJlbW92ZVBhdGgoYmxvYiwgX29wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0Jsb2IoYmxvYiwgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmFzZWQgb24gdGhlIGJsb2IgYW5kIG9wdGlvbnMsIHJldHVybiBhIGJsb2IgdGhhdCBoYXMgYSB2YWxpZCBwYXRoXG4gICAgICogdGhhdCBjYW4gYmUgc2F2ZWQuXG4gICAgICogQHBhcmFtIGJsb2JcbiAgICAgKiBAcGFyYW0gb3B0c1xuICAgICAqL1xuICAgIGFzeW5jIF92YWxpZFN0b3JlQmxvYihibG9iLCBvcHRzKSB7XG4gICAgICAgIGlmIChhd2FpdCB0aGlzLmhhc1ZhbGlkUGF0aChibG9iLnBhdGgsIG9wdHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gYmxvYjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKG9wdHM/LmFjdGlvbklmSW52YWxpZCkge1xuICAgICAgICAgICAgY2FzZSBcImlnbm9yZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBibG9iO1xuICAgICAgICAgICAgY2FzZSBcInByZWZpeFBhdGhcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsaWRCbG9iUHJlZml4UGF0aChibG9iLCBvcHRzKTtcbiAgICAgICAgICAgIGNhc2UgXCJwcmVmaXhVdWlkMVwiOlxuICAgICAgICAgICAgY2FzZSBcInByZWZpeFV1aWQ0XCI6XG4gICAgICAgICAgICBjYXNlIFwicHJlZml4VXVpZDZcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwcmVmaXhVdWlkN1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWxpZEJsb2JQcmVmaXhVdWlkKGJsb2IsIG9wdHMpO1xuICAgICAgICAgICAgY2FzZSBcInJlbW92ZVBhdGhcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsaWRCbG9iUmVtb3ZlUGF0aChibG9iLCBvcHRzKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzdG9yZShibG9iLCBvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QgYWxsT3B0cyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuZGVmYXVsdFN0b3JlT3B0aW9ucyxcbiAgICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHZhbGlkQmxvYiA9IGF3YWl0IHRoaXMuX3ZhbGlkU3RvcmVCbG9iKGJsb2IsIGFsbE9wdHMpO1xuICAgICAgICBpZiAodHlwZW9mIHZhbGlkQmxvYiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgY29uc3QgdmFsaWRLZXkgPSBhd2FpdCB2YWxpZEJsb2IuYXNVcmkoKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubXNldChbW3ZhbGlkS2V5LCB2YWxpZEJsb2JdXSk7XG4gICAgICAgICAgICBjb25zdCBzYXZlZEtleSA9IGF3YWl0IHZhbGlkQmxvYi5hc1VyaSgpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmV0Y2goc2F2ZWRLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGFzeW5jIF9taXNzaW5nRmV0Y2hCbG9iRW1wdHkocGF0aCwgX29wdHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZWRpYUJsb2IoeyBwYXRoIH0pO1xuICAgIH1cbiAgICBhc3luYyBfbWlzc2luZ0ZldGNoQmxvYihwYXRoLCBvcHRzKSB7XG4gICAgICAgIHN3aXRjaCAob3B0cz8uYWN0aW9uSWZCbG9iTWlzc2luZykge1xuICAgICAgICAgICAgY2FzZSBcImVtcHR5QmxvYlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9taXNzaW5nRmV0Y2hCbG9iRW1wdHkocGF0aCwgb3B0cyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZmV0Y2goa2V5LCBvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QgYWxsT3B0cyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuZGVmYXVsdEZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlYWxLZXkgPSBhd2FpdCB0aGlzLl9yZWFsS2V5KGtleSk7XG4gICAgICAgIGNvbnN0IHJldCA9IGF3YWl0IHRoaXMubWdldChbcmVhbEtleV0pO1xuICAgICAgICByZXR1cm4gcmV0Py5bMF0gPz8gKGF3YWl0IHRoaXMuX21pc3NpbmdGZXRjaEJsb2IocmVhbEtleSwgYWxsT3B0cykpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmxvYlN0b3JlID0gQmxvYlN0b3JlO1xuY2xhc3MgQmFja2VkQmxvYlN0b3JlIGV4dGVuZHMgQmxvYlN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJiYWNraW5nU3RvcmVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5iYWNraW5nU3RvcmUgPSBvcHRzLmJhY2tpbmdTdG9yZTtcbiAgICB9XG4gICAgbWRlbGV0ZShrZXlzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhY2tpbmdTdG9yZS5tZGVsZXRlKGtleXMpO1xuICAgIH1cbiAgICBtZ2V0KGtleXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFja2luZ1N0b3JlLm1nZXQoa2V5cyk7XG4gICAgfVxuICAgIG1zZXQoa2V5VmFsdWVQYWlycykge1xuICAgICAgICByZXR1cm4gdGhpcy5iYWNraW5nU3RvcmUubXNldChrZXlWYWx1ZVBhaXJzKTtcbiAgICB9XG4gICAgeWllbGRLZXlzKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYWNraW5nU3RvcmUueWllbGRLZXlzKHByZWZpeCk7XG4gICAgfVxufVxuZXhwb3J0cy5CYWNrZWRCbG9iU3RvcmUgPSBCYWNrZWRCbG9iU3RvcmU7XG5jbGFzcyBSZWFkVGhyb3VnaEJsb2JTdG9yZSBleHRlbmRzIEJsb2JTdG9yZSB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYmFzZVN0b3JlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJhY2tpbmdTdG9yZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJhc2VTdG9yZSA9IG9wdHMuYmFzZVN0b3JlO1xuICAgICAgICB0aGlzLmJhY2tpbmdTdG9yZSA9IG9wdHMuYmFja2luZ1N0b3JlO1xuICAgIH1cbiAgICBhc3luYyBzdG9yZShibG9iLCBvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxVcmkgPSBhd2FpdCBibG9iLmFzVXJpKCk7XG4gICAgICAgIGNvbnN0IG5ld0Jsb2IgPSBhd2FpdCB0aGlzLmJhY2tpbmdTdG9yZS5zdG9yZShibG9iLCBvcHRzKTtcbiAgICAgICAgaWYgKG5ld0Jsb2IpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYmFzZVN0b3JlLm1zZXQoW1tvcmlnaW5hbFVyaSwgbmV3QmxvYl1dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3QmxvYjtcbiAgICB9XG4gICAgbWRlbGV0ZShrZXlzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VTdG9yZS5tZGVsZXRlKGtleXMpO1xuICAgIH1cbiAgICBtZ2V0KGtleXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVN0b3JlLm1nZXQoa2V5cyk7XG4gICAgfVxuICAgIG1zZXQoX2tleVZhbHVlUGFpcnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRG8gbm90IGNhbGwgUmVhZFRocm91Z2hCbG9iU3RvcmUubXNldCBkaXJlY3RseVwiKTtcbiAgICB9XG4gICAgeWllbGRLZXlzKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlU3RvcmUueWllbGRLZXlzKHByZWZpeCk7XG4gICAgfVxufVxuZXhwb3J0cy5SZWFkVGhyb3VnaEJsb2JTdG9yZSA9IFJlYWRUaHJvdWdoQmxvYlN0b3JlO1xuY2xhc3MgU2ltcGxlV2ViQmxvYlN0b3JlIGV4dGVuZHMgQmxvYlN0b3JlIHtcbiAgICBfbm90SW1wbGVtZW50ZWRFeGNlcHRpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZCBmb3IgU2ltcGxlV2ViQmxvYlN0b3JlXCIpO1xuICAgIH1cbiAgICBhc3luYyBoYXNWYWxpZFBhdGgocGF0aCwgX29wdHMpIHtcbiAgICAgICAgcmV0dXJuICgoYXdhaXQgc3VwZXIuaGFzVmFsaWRQYXRoKHBhdGgsIHsgcGF0aFByZWZpeDogXCJodHRwczovL1wiIH0pKSB8fFxuICAgICAgICAgICAgKGF3YWl0IHN1cGVyLmhhc1ZhbGlkUGF0aChwYXRoLCB7IHBhdGhQcmVmaXg6IFwiaHR0cDovL1wiIH0pKSk7XG4gICAgfVxuICAgIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IE1lZGlhQmxvYih7XG4gICAgICAgICAgICBwYXRoOiB1cmwsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHt9O1xuICAgICAgICBjb25zdCBmZXRjaE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVybCwgZmV0Y2hPcHRpb25zKTtcbiAgICAgICAgbWV0YWRhdGEuc3RhdHVzID0gcmVzLnN0YXR1cztcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiByZXMuaGVhZGVycy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIG1ldGFkYXRhLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICBtZXRhZGF0YS5vayA9IHJlcy5vaztcbiAgICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICAgICAgY29uc3QgcmVzTWVkaWFCbG9iID0gYXdhaXQgTWVkaWFCbG9iLmZyb21CbG9iKGF3YWl0IHJlcy5ibG9iKCkpO1xuICAgICAgICAgICAgcmV0LmRhdGEgPSByZXNNZWRpYUJsb2IuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXQubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgYXN5bmMgbWdldChrZXlzKSB7XG4gICAgICAgIGNvbnN0IGJsb2JNYXAgPSBrZXlzLm1hcCh0aGlzLl9mZXRjaCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChibG9iTWFwKTtcbiAgICB9XG4gICAgYXN5bmMgbWRlbGV0ZShfa2V5cykge1xuICAgICAgICB0aGlzLl9ub3RJbXBsZW1lbnRlZEV4Y2VwdGlvbigpO1xuICAgIH1cbiAgICBhc3luYyBtc2V0KF9rZXlWYWx1ZVBhaXJzKSB7XG4gICAgICAgIHRoaXMuX25vdEltcGxlbWVudGVkRXhjZXB0aW9uKCk7XG4gICAgfVxuICAgIGFzeW5jICp5aWVsZEtleXMoX3ByZWZpeCkge1xuICAgICAgICB0aGlzLl9ub3RJbXBsZW1lbnRlZEV4Y2VwdGlvbigpO1xuICAgICAgICB5aWVsZCBcIlwiO1xuICAgIH1cbn1cbmV4cG9ydHMuU2ltcGxlV2ViQmxvYlN0b3JlID0gU2ltcGxlV2ViQmxvYlN0b3JlO1xuLyoqXG4gKiBBIGJsb2IgXCJzdG9yZVwiIHRoYXQgd29ya3Mgd2l0aCBkYXRhOiBVUkxzIHRoYXQgd2lsbCB0dXJuIHRoZSBVUkwgaW50b1xuICogYSBibG9iLlxuICovXG5jbGFzcyBEYXRhQmxvYlN0b3JlIGV4dGVuZHMgQmxvYlN0b3JlIHtcbiAgICBfbm90SW1wbGVtZW50ZWRFeGNlcHRpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZCBmb3IgRGF0YUJsb2JTdG9yZVwiKTtcbiAgICB9XG4gICAgaGFzVmFsaWRQYXRoKHBhdGgsIF9vcHRzKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5oYXNWYWxpZFBhdGgocGF0aCwgeyBwYXRoUHJlZml4OiBcImRhdGE6XCIgfSk7XG4gICAgfVxuICAgIF9mZXRjaCh1cmwpIHtcbiAgICAgICAgcmV0dXJuIE1lZGlhQmxvYi5mcm9tRGF0YVVybCh1cmwpO1xuICAgIH1cbiAgICBhc3luYyBtZ2V0KGtleXMpIHtcbiAgICAgICAgY29uc3QgYmxvYk1hcCA9IGtleXMubWFwKHRoaXMuX2ZldGNoKTtcbiAgICAgICAgcmV0dXJuIGJsb2JNYXA7XG4gICAgfVxuICAgIGFzeW5jIG1kZWxldGUoX2tleXMpIHtcbiAgICAgICAgdGhpcy5fbm90SW1wbGVtZW50ZWRFeGNlcHRpb24oKTtcbiAgICB9XG4gICAgYXN5bmMgbXNldChfa2V5VmFsdWVQYWlycykge1xuICAgICAgICB0aGlzLl9ub3RJbXBsZW1lbnRlZEV4Y2VwdGlvbigpO1xuICAgIH1cbiAgICBhc3luYyAqeWllbGRLZXlzKF9wcmVmaXgpIHtcbiAgICAgICAgdGhpcy5fbm90SW1wbGVtZW50ZWRFeGNlcHRpb24oKTtcbiAgICAgICAgeWllbGQgXCJcIjtcbiAgICB9XG59XG5leHBvcnRzLkRhdGFCbG9iU3RvcmUgPSBEYXRhQmxvYlN0b3JlO1xuLyoqXG4gKiBSZXNwb25zaWJsZSBmb3IgY29udmVydGluZyBhIFVSSSAodHlwaWNhbGx5IGEgd2ViIFVSTCkgaW50byBhIE1lZGlhQmxvYi5cbiAqIEFsbG93cyBmb3IgYWxpYXNpbmcgLyBjYWNoaW5nIG9mIHRoZSByZXF1ZXN0ZWQgVVJJIGFuZCB3aGF0IGl0IHJlc29sdmVzIHRvLlxuICogVGhpcyBNZWRpYUJsb2IgaXMgZXhwZWN0ZWQgdG8gYmUgdXNhYmxlIHRvIHByb3ZpZGUgdG8gYW4gTExNLCBlaXRoZXJcbiAqIHRocm91Z2ggdGhlIEJhc2U2NCBvZiB0aGUgbWVkaWEgb3IgdGhyb3VnaCBhIGNhbm9uaWNhbCBVUkkgdGhhdCB0aGUgTExNXG4gKiBzdXBwb3J0cy5cbiAqL1xuY2xhc3MgTWVkaWFNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RvcmVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzb2x2ZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBjb25maWcuc3RvcmU7XG4gICAgICAgIHRoaXMucmVzb2x2ZXJzID0gY29uZmlnLnJlc29sdmVycztcbiAgICB9XG4gICAgZGVmYXVsdFJlc29sdmVycygpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgRGF0YUJsb2JTdG9yZSh7fSksIG5ldyBTaW1wbGVXZWJCbG9iU3RvcmUoe30pXTtcbiAgICB9XG4gICAgYXN5bmMgX2lzSW52YWxpZChibG9iKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgYmxvYiA9PT0gXCJ1bmRlZmluZWRcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gdGhlIHB1YmxpYyBVUkksIGxvYWQgd2hhdCBpcyBhdCB0aGlzIFVSSSBhbmQgc2F2ZSBpdFxuICAgICAqIGluIHRoZSBzdG9yZS5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBVUkkgdG8gcmVzb2x2ZSB1c2luZyB0aGUgcmVzb2x2ZXJcbiAgICAgKiBAcmV0dXJuIEEgY2Fub25pY2FsIE1lZGlhQmxvYiBmb3IgdGhpcyBVUklcbiAgICAgKi9cbiAgICBhc3luYyBfcmVzb2x2ZUFuZFNhdmUodXJpKSB7XG4gICAgICAgIGxldCByZXNvbHZlZEJsb2I7XG4gICAgICAgIGNvbnN0IHJlc29sdmVycyA9IHRoaXMucmVzb2x2ZXJzIHx8IHRoaXMuZGVmYXVsdFJlc29sdmVycygpO1xuICAgICAgICBmb3IgKGxldCBjbyA9IDA7IGNvIDwgcmVzb2x2ZXJzLmxlbmd0aDsgY28gKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSByZXNvbHZlcnNbY29dO1xuICAgICAgICAgICAgaWYgKGF3YWl0IHJlc29sdmVyLmhhc1ZhbGlkUGF0aCh1cmkpKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRCbG9iID0gYXdhaXQgcmVzb2x2ZXIuZmV0Y2godXJpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzb2x2ZWRCbG9iKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zdG9yZS5zdG9yZShyZXNvbHZlZEJsb2IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNZWRpYUJsb2Ioe30pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldE1lZGlhQmxvYih1cmkpIHtcbiAgICAgICAgY29uc3QgYWxpYXNCbG9iID0gYXdhaXQgdGhpcy5zdG9yZS5mZXRjaCh1cmkpO1xuICAgICAgICBjb25zdCByZXQgPSAoYXdhaXQgdGhpcy5faXNJbnZhbGlkKGFsaWFzQmxvYikpXG4gICAgICAgICAgICA/IGF3YWl0IHRoaXMuX3Jlc29sdmVBbmRTYXZlKHVyaSlcbiAgICAgICAgICAgIDogYWxpYXNCbG9iO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cbmV4cG9ydHMuTWVkaWFNYW5hZ2VyID0gTWVkaWFNYW5hZ2VyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/experimental/utils/media_core.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/index.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/index.cjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./chat_models.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/chat_models.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./llms.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/llms.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./embeddings.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/embeddings.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./output_parsers.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/output_parsers.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./auth.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/auth.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./connection.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/connection.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./types.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/types.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/stream.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./utils/common.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/common.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./utils/zod_to_gemini_parameters.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/zod_to_gemini_parameters.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./utils/safety.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/safety.cjs\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyw2RkFBbUI7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLCtFQUFZO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQywyRkFBa0I7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLG1HQUFzQjtBQUMzQyxhQUFhLG1CQUFPLENBQUMsK0VBQVk7QUFDakMsYUFBYSxtQkFBTyxDQUFDLDJGQUFrQjtBQUN2QyxhQUFhLG1CQUFPLENBQUMsaUZBQWE7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLCtGQUFvQjtBQUN6QyxhQUFhLG1CQUFPLENBQUMsK0ZBQW9CO0FBQ3pDLGFBQWEsbUJBQU8sQ0FBQyxtSUFBc0M7QUFDM0QsYUFBYSxtQkFBTyxDQUFDLCtGQUFvQiIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9kaXN0L2luZGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NoYXRfbW9kZWxzLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGxtcy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2VtYmVkZGluZ3MuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9vdXRwdXRfcGFyc2Vycy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2F1dGguY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb25uZWN0aW9uLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi91dGlscy9zdHJlYW0uY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi91dGlscy9jb21tb24uY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi91dGlscy96b2RfdG9fZ2VtaW5pX3BhcmFtZXRlcnMuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi91dGlscy9zYWZldHkuY2pzXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/llms.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/llms.cjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GoogleBaseLLM = void 0;\nconst manager_1 = __webpack_require__(/*! @langchain/core/callbacks/manager */ \"(rsc)/./node_modules/@langchain/core/callbacks/manager.cjs\");\nconst llms_1 = __webpack_require__(/*! @langchain/core/language_models/llms */ \"(rsc)/./node_modules/@langchain/core/language_models/llms.cjs\");\nconst outputs_1 = __webpack_require__(/*! @langchain/core/outputs */ \"(rsc)/./node_modules/@langchain/core/outputs.cjs\");\nconst env_1 = __webpack_require__(/*! @langchain/core/utils/env */ \"(rsc)/./node_modules/@langchain/core/utils/env.cjs\");\nconst connection_js_1 = __webpack_require__(/*! ./connection.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/connection.cjs\");\nconst common_js_1 = __webpack_require__(/*! ./utils/common.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/common.cjs\");\nconst gemini_js_1 = __webpack_require__(/*! ./utils/gemini.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/gemini.cjs\");\nconst auth_js_1 = __webpack_require__(/*! ./auth.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/auth.cjs\");\nconst failed_handler_js_1 = __webpack_require__(/*! ./utils/failed_handler.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/failed_handler.cjs\");\nconst chat_models_js_1 = __webpack_require__(/*! ./chat_models.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/chat_models.cjs\");\nclass GoogleLLMConnection extends connection_js_1.AbstractGoogleLLMConnection {\n    async formatContents(input, _parameters) {\n        const parts = await this.api.messageContentToParts(input);\n        const contents = [\n            {\n                role: \"user\",\n                parts,\n            },\n        ];\n        return contents;\n    }\n}\nclass ProxyChatGoogle extends chat_models_js_1.ChatGoogleBase {\n    constructor(fields) {\n        super(fields);\n    }\n    buildAbstractedClient(fields) {\n        return fields.connection.client;\n    }\n}\n/**\n * Integration with an LLM.\n */\nclass GoogleBaseLLM extends llms_1.LLM {\n    // Used for tracing, replace with the same name as your class\n    static lc_name() {\n        return \"GoogleLLM\";\n    }\n    get lc_secrets() {\n        return {\n            authOptions: \"GOOGLE_AUTH_OPTIONS\",\n        };\n    }\n    constructor(fields) {\n        super((0, failed_handler_js_1.ensureParams)(fields));\n        Object.defineProperty(this, \"originalFields\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"modelName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"gemini-pro\"\n        });\n        Object.defineProperty(this, \"model\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"gemini-pro\"\n        });\n        Object.defineProperty(this, \"temperature\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0.7\n        });\n        Object.defineProperty(this, \"maxOutputTokens\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 1024\n        });\n        Object.defineProperty(this, \"topP\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0.8\n        });\n        Object.defineProperty(this, \"topK\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 40\n        });\n        Object.defineProperty(this, \"stopSequences\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"safetySettings\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"safetyHandler\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"responseMimeType\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"text/plain\"\n        });\n        Object.defineProperty(this, \"connection\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"streamedConnection\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.originalFields = fields;\n        (0, common_js_1.copyAndValidateModelParamsInto)(fields, this);\n        this.safetyHandler =\n            fields?.safetyHandler ?? new gemini_js_1.DefaultGeminiSafetyHandler();\n        const client = this.buildClient(fields);\n        this.buildConnection(fields ?? {}, client);\n    }\n    buildApiKeyClient(apiKey) {\n        return new auth_js_1.ApiKeyGoogleAuth(apiKey);\n    }\n    buildApiKey(fields) {\n        return fields?.apiKey ?? (0, env_1.getEnvironmentVariable)(\"GOOGLE_API_KEY\");\n    }\n    buildClient(fields) {\n        const apiKey = this.buildApiKey(fields);\n        if (apiKey) {\n            return this.buildApiKeyClient(apiKey);\n        }\n        else {\n            return this.buildAbstractedClient(fields);\n        }\n    }\n    buildConnection(fields, client) {\n        this.connection = new GoogleLLMConnection({ ...fields, ...this }, this.caller, client, false);\n        this.streamedConnection = new GoogleLLMConnection({ ...fields, ...this }, this.caller, client, true);\n    }\n    get platform() {\n        return this.connection.platform;\n    }\n    // Replace\n    _llmType() {\n        return \"googlellm\";\n    }\n    formatPrompt(prompt) {\n        return prompt;\n    }\n    /**\n     * For some given input string and options, return a string output.\n     *\n     * Despite the fact that `invoke` is overridden below, we still need this\n     * in order to handle public APi calls to `generate()`.\n     */\n    async _call(prompt, options) {\n        const parameters = (0, common_js_1.copyAIModelParams)(this, options);\n        const result = await this.connection.request(prompt, parameters, options);\n        const ret = this.connection.api.responseToString(result);\n        return ret;\n    }\n    // Normally, you should not override this method and instead should override\n    // _streamResponseChunks. We are doing so here to allow for multimodal inputs into\n    // the LLM.\n    async *_streamIterator(input, options) {\n        // TODO: Refactor callback setup and teardown code into core\n        const prompt = llms_1.BaseLLM._convertInputToPromptValue(input);\n        const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptions(options);\n        const callbackManager_ = await manager_1.CallbackManager.configure(runnableConfig.callbacks, this.callbacks, runnableConfig.tags, this.tags, runnableConfig.metadata, this.metadata, { verbose: this.verbose });\n        const extra = {\n            options: callOptions,\n            invocation_params: this?.invocationParams(callOptions),\n            batch_size: 1,\n        };\n        const runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), [prompt.toString()], undefined, undefined, extra, undefined, undefined, runnableConfig.runName);\n        let generation = new outputs_1.GenerationChunk({\n            text: \"\",\n        });\n        const proxyChat = this.createProxyChat();\n        try {\n            for await (const chunk of proxyChat._streamIterator(input, options)) {\n                const stringValue = this.connection.api.chunkToString(chunk);\n                const generationChunk = new outputs_1.GenerationChunk({\n                    text: stringValue,\n                });\n                generation = generation.concat(generationChunk);\n                yield stringValue;\n            }\n        }\n        catch (err) {\n            await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));\n            throw err;\n        }\n        await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMEnd({\n            generations: [[generation]],\n        })));\n    }\n    async predictMessages(messages, options, _callbacks) {\n        const { content } = messages[0];\n        const result = await this.connection.request(content, {}, options);\n        const ret = this.connection.api.responseToBaseMessage(result);\n        return ret;\n    }\n    /**\n     * Internal implementation detail to allow Google LLMs to support\n     * multimodal input by delegating to the chat model implementation.\n     *\n     * TODO: Replace with something less hacky.\n     */\n    createProxyChat() {\n        return new ProxyChatGoogle({\n            ...this.originalFields,\n            connection: this.connection,\n        });\n    }\n    // TODO: Remove the need to override this - we are doing it to\n    // allow the LLM to handle multimodal types of input.\n    async invoke(input, options) {\n        const stream = await this._streamIterator(input, options);\n        let generatedOutput = \"\";\n        for await (const chunk of stream) {\n            generatedOutput += chunk;\n        }\n        return generatedOutput;\n    }\n}\nexports.GoogleBaseLLM = GoogleBaseLLM;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvbGxtcy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLGtCQUFrQixtQkFBTyxDQUFDLHFHQUFtQztBQUM3RCxlQUFlLG1CQUFPLENBQUMsMkdBQXNDO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLGlGQUF5QjtBQUNuRCxjQUFjLG1CQUFPLENBQUMscUZBQTJCO0FBQ2pELHdCQUF3QixtQkFBTyxDQUFDLDJGQUFrQjtBQUNsRCxvQkFBb0IsbUJBQU8sQ0FBQywrRkFBb0I7QUFDaEQsb0JBQW9CLG1CQUFPLENBQUMsK0ZBQW9CO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3RDLDRCQUE0QixtQkFBTyxDQUFDLCtHQUE0QjtBQUNoRSx5QkFBeUIsbUJBQU8sQ0FBQyw2RkFBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxvQkFBb0I7QUFDeEUsNERBQTRELG9CQUFvQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrTEFBK0wsdUJBQXVCO0FBQ3ROO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQixnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvbGxtcy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdvb2dsZUJhc2VMTE0gPSB2b2lkIDA7XG5jb25zdCBtYW5hZ2VyXzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL2NhbGxiYWNrcy9tYW5hZ2VyXCIpO1xuY29uc3QgbGxtc18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9sYW5ndWFnZV9tb2RlbHMvbGxtc1wiKTtcbmNvbnN0IG91dHB1dHNfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvb3V0cHV0c1wiKTtcbmNvbnN0IGVudl8xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS91dGlscy9lbnZcIik7XG5jb25zdCBjb25uZWN0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aW9uLmNqc1wiKTtcbmNvbnN0IGNvbW1vbl9qc18xID0gcmVxdWlyZShcIi4vdXRpbHMvY29tbW9uLmNqc1wiKTtcbmNvbnN0IGdlbWluaV9qc18xID0gcmVxdWlyZShcIi4vdXRpbHMvZ2VtaW5pLmNqc1wiKTtcbmNvbnN0IGF1dGhfanNfMSA9IHJlcXVpcmUoXCIuL2F1dGguY2pzXCIpO1xuY29uc3QgZmFpbGVkX2hhbmRsZXJfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2ZhaWxlZF9oYW5kbGVyLmNqc1wiKTtcbmNvbnN0IGNoYXRfbW9kZWxzX2pzXzEgPSByZXF1aXJlKFwiLi9jaGF0X21vZGVscy5janNcIik7XG5jbGFzcyBHb29nbGVMTE1Db25uZWN0aW9uIGV4dGVuZHMgY29ubmVjdGlvbl9qc18xLkFic3RyYWN0R29vZ2xlTExNQ29ubmVjdGlvbiB7XG4gICAgYXN5bmMgZm9ybWF0Q29udGVudHMoaW5wdXQsIF9wYXJhbWV0ZXJzKSB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gYXdhaXQgdGhpcy5hcGkubWVzc2FnZUNvbnRlbnRUb1BhcnRzKGlucHV0KTtcbiAgICAgICAgY29uc3QgY29udGVudHMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgICAgICAgcGFydHMsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gY29udGVudHM7XG4gICAgfVxufVxuY2xhc3MgUHJveHlDaGF0R29vZ2xlIGV4dGVuZHMgY2hhdF9tb2RlbHNfanNfMS5DaGF0R29vZ2xlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgfVxuICAgIGJ1aWxkQWJzdHJhY3RlZENsaWVudChmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkcy5jb25uZWN0aW9uLmNsaWVudDtcbiAgICB9XG59XG4vKipcbiAqIEludGVncmF0aW9uIHdpdGggYW4gTExNLlxuICovXG5jbGFzcyBHb29nbGVCYXNlTExNIGV4dGVuZHMgbGxtc18xLkxMTSB7XG4gICAgLy8gVXNlZCBmb3IgdHJhY2luZywgcmVwbGFjZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgeW91ciBjbGFzc1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJHb29nbGVMTE1cIjtcbiAgICB9XG4gICAgZ2V0IGxjX3NlY3JldHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdXRoT3B0aW9uczogXCJHT09HTEVfQVVUSF9PUFRJT05TXCIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcigoMCwgZmFpbGVkX2hhbmRsZXJfanNfMS5lbnN1cmVQYXJhbXMpKGZpZWxkcykpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcmlnaW5hbEZpZWxkc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1vZGVsTmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJnZW1pbmktcHJvXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1vZGVsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImdlbWluaS1wcm9cIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGVtcGVyYXR1cmVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDAuN1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4T3V0cHV0VG9rZW5zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAxMDI0XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3BQXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAwLjhcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvcEtcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDQwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9wU2VxdWVuY2VzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2FmZXR5U2V0dGluZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzYWZldHlIYW5kbGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc3BvbnNlTWltZVR5cGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwidGV4dC9wbGFpblwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb25uZWN0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0cmVhbWVkQ29ubmVjdGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9yaWdpbmFsRmllbGRzID0gZmllbGRzO1xuICAgICAgICAoMCwgY29tbW9uX2pzXzEuY29weUFuZFZhbGlkYXRlTW9kZWxQYXJhbXNJbnRvKShmaWVsZHMsIHRoaXMpO1xuICAgICAgICB0aGlzLnNhZmV0eUhhbmRsZXIgPVxuICAgICAgICAgICAgZmllbGRzPy5zYWZldHlIYW5kbGVyID8/IG5ldyBnZW1pbmlfanNfMS5EZWZhdWx0R2VtaW5pU2FmZXR5SGFuZGxlcigpO1xuICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmJ1aWxkQ2xpZW50KGZpZWxkcyk7XG4gICAgICAgIHRoaXMuYnVpbGRDb25uZWN0aW9uKGZpZWxkcyA/PyB7fSwgY2xpZW50KTtcbiAgICB9XG4gICAgYnVpbGRBcGlLZXlDbGllbnQoYXBpS2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgYXV0aF9qc18xLkFwaUtleUdvb2dsZUF1dGgoYXBpS2V5KTtcbiAgICB9XG4gICAgYnVpbGRBcGlLZXkoZmllbGRzKSB7XG4gICAgICAgIHJldHVybiBmaWVsZHM/LmFwaUtleSA/PyAoMCwgZW52XzEuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSkoXCJHT09HTEVfQVBJX0tFWVwiKTtcbiAgICB9XG4gICAgYnVpbGRDbGllbnQoZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IGFwaUtleSA9IHRoaXMuYnVpbGRBcGlLZXkoZmllbGRzKTtcbiAgICAgICAgaWYgKGFwaUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRBcGlLZXlDbGllbnQoYXBpS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkQWJzdHJhY3RlZENsaWVudChmaWVsZHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJ1aWxkQ29ubmVjdGlvbihmaWVsZHMsIGNsaWVudCkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBuZXcgR29vZ2xlTExNQ29ubmVjdGlvbih7IC4uLmZpZWxkcywgLi4udGhpcyB9LCB0aGlzLmNhbGxlciwgY2xpZW50LCBmYWxzZSk7XG4gICAgICAgIHRoaXMuc3RyZWFtZWRDb25uZWN0aW9uID0gbmV3IEdvb2dsZUxMTUNvbm5lY3Rpb24oeyAuLi5maWVsZHMsIC4uLnRoaXMgfSwgdGhpcy5jYWxsZXIsIGNsaWVudCwgdHJ1ZSk7XG4gICAgfVxuICAgIGdldCBwbGF0Zm9ybSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5wbGF0Zm9ybTtcbiAgICB9XG4gICAgLy8gUmVwbGFjZVxuICAgIF9sbG1UeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJnb29nbGVsbG1cIjtcbiAgICB9XG4gICAgZm9ybWF0UHJvbXB0KHByb21wdCkge1xuICAgICAgICByZXR1cm4gcHJvbXB0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3Igc29tZSBnaXZlbiBpbnB1dCBzdHJpbmcgYW5kIG9wdGlvbnMsIHJldHVybiBhIHN0cmluZyBvdXRwdXQuXG4gICAgICpcbiAgICAgKiBEZXNwaXRlIHRoZSBmYWN0IHRoYXQgYGludm9rZWAgaXMgb3ZlcnJpZGRlbiBiZWxvdywgd2Ugc3RpbGwgbmVlZCB0aGlzXG4gICAgICogaW4gb3JkZXIgdG8gaGFuZGxlIHB1YmxpYyBBUGkgY2FsbHMgdG8gYGdlbmVyYXRlKClgLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKHByb21wdCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gKDAsIGNvbW1vbl9qc18xLmNvcHlBSU1vZGVsUGFyYW1zKSh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLnJlcXVlc3QocHJvbXB0LCBwYXJhbWV0ZXJzLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcmV0ID0gdGhpcy5jb25uZWN0aW9uLmFwaS5yZXNwb25zZVRvU3RyaW5nKHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8vIE5vcm1hbGx5LCB5b3Ugc2hvdWxkIG5vdCBvdmVycmlkZSB0aGlzIG1ldGhvZCBhbmQgaW5zdGVhZCBzaG91bGQgb3ZlcnJpZGVcbiAgICAvLyBfc3RyZWFtUmVzcG9uc2VDaHVua3MuIFdlIGFyZSBkb2luZyBzbyBoZXJlIHRvIGFsbG93IGZvciBtdWx0aW1vZGFsIGlucHV0cyBpbnRvXG4gICAgLy8gdGhlIExMTS5cbiAgICBhc3luYyAqX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIFRPRE86IFJlZmFjdG9yIGNhbGxiYWNrIHNldHVwIGFuZCB0ZWFyZG93biBjb2RlIGludG8gY29yZVxuICAgICAgICBjb25zdCBwcm9tcHQgPSBsbG1zXzEuQmFzZUxMTS5fY29udmVydElucHV0VG9Qcm9tcHRWYWx1ZShpbnB1dCk7XG4gICAgICAgIGNvbnN0IFtydW5uYWJsZUNvbmZpZywgY2FsbE9wdGlvbnNdID0gdGhpcy5fc2VwYXJhdGVSdW5uYWJsZUNvbmZpZ0Zyb21DYWxsT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0IG1hbmFnZXJfMS5DYWxsYmFja01hbmFnZXIuY29uZmlndXJlKHJ1bm5hYmxlQ29uZmlnLmNhbGxiYWNrcywgdGhpcy5jYWxsYmFja3MsIHJ1bm5hYmxlQ29uZmlnLnRhZ3MsIHRoaXMudGFncywgcnVubmFibGVDb25maWcubWV0YWRhdGEsIHRoaXMubWV0YWRhdGEsIHsgdmVyYm9zZTogdGhpcy52ZXJib3NlIH0pO1xuICAgICAgICBjb25zdCBleHRyYSA9IHtcbiAgICAgICAgICAgIG9wdGlvbnM6IGNhbGxPcHRpb25zLFxuICAgICAgICAgICAgaW52b2NhdGlvbl9wYXJhbXM6IHRoaXM/Lmludm9jYXRpb25QYXJhbXMoY2FsbE9wdGlvbnMpLFxuICAgICAgICAgICAgYmF0Y2hfc2l6ZTogMSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlcnMgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVMTE1TdGFydCh0aGlzLnRvSlNPTigpLCBbcHJvbXB0LnRvU3RyaW5nKCldLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZXh0cmEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBydW5uYWJsZUNvbmZpZy5ydW5OYW1lKTtcbiAgICAgICAgbGV0IGdlbmVyYXRpb24gPSBuZXcgb3V0cHV0c18xLkdlbmVyYXRpb25DaHVuayh7XG4gICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHJveHlDaGF0ID0gdGhpcy5jcmVhdGVQcm94eUNoYXQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcHJveHlDaGF0Ll9zdHJlYW1JdGVyYXRvcihpbnB1dCwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdWYWx1ZSA9IHRoaXMuY29ubmVjdGlvbi5hcGkuY2h1bmtUb1N0cmluZyhjaHVuayk7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJhdGlvbkNodW5rID0gbmV3IG91dHB1dHNfMS5HZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBzdHJpbmdWYWx1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBnZW5lcmF0aW9uID0gZ2VuZXJhdGlvbi5jb25jYXQoZ2VuZXJhdGlvbkNodW5rKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBzdHJpbmdWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCgocnVuTWFuYWdlcnMgPz8gW10pLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlTExNRXJyb3IoZXJyKSkpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKChydW5NYW5hZ2VycyA/PyBbXSkubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVMTE1FbmQoe1xuICAgICAgICAgICAgZ2VuZXJhdGlvbnM6IFtbZ2VuZXJhdGlvbl1dLFxuICAgICAgICB9KSkpO1xuICAgIH1cbiAgICBhc3luYyBwcmVkaWN0TWVzc2FnZXMobWVzc2FnZXMsIG9wdGlvbnMsIF9jYWxsYmFja3MpIHtcbiAgICAgICAgY29uc3QgeyBjb250ZW50IH0gPSBtZXNzYWdlc1swXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLnJlcXVlc3QoY29udGVudCwge30sIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCByZXQgPSB0aGlzLmNvbm5lY3Rpb24uYXBpLnJlc3BvbnNlVG9CYXNlTWVzc2FnZShyZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgdG8gYWxsb3cgR29vZ2xlIExMTXMgdG8gc3VwcG9ydFxuICAgICAqIG11bHRpbW9kYWwgaW5wdXQgYnkgZGVsZWdhdGluZyB0byB0aGUgY2hhdCBtb2RlbCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIFRPRE86IFJlcGxhY2Ugd2l0aCBzb21ldGhpbmcgbGVzcyBoYWNreS5cbiAgICAgKi9cbiAgICBjcmVhdGVQcm94eUNoYXQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHlDaGF0R29vZ2xlKHtcbiAgICAgICAgICAgIC4uLnRoaXMub3JpZ2luYWxGaWVsZHMsXG4gICAgICAgICAgICBjb25uZWN0aW9uOiB0aGlzLmNvbm5lY3Rpb24sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUT0RPOiBSZW1vdmUgdGhlIG5lZWQgdG8gb3ZlcnJpZGUgdGhpcyAtIHdlIGFyZSBkb2luZyBpdCB0b1xuICAgIC8vIGFsbG93IHRoZSBMTE0gdG8gaGFuZGxlIG11bHRpbW9kYWwgdHlwZXMgb2YgaW5wdXQuXG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IHRoaXMuX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBvcHRpb25zKTtcbiAgICAgICAgbGV0IGdlbmVyYXRlZE91dHB1dCA9IFwiXCI7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgICBnZW5lcmF0ZWRPdXRwdXQgKz0gY2h1bms7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlZE91dHB1dDtcbiAgICB9XG59XG5leHBvcnRzLkdvb2dsZUJhc2VMTE0gPSBHb29nbGVCYXNlTExNO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/llms.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/output_parsers.cjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/output_parsers.cjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MarkdownGoogleSearchOutputParser = exports.SimpleGoogleSearchOutputParser = exports.BaseGoogleSearchOutputParser = void 0;\nconst output_parsers_1 = __webpack_require__(/*! @langchain/core/output_parsers */ \"(rsc)/./node_modules/@langchain/core/output_parsers.cjs\");\nclass BaseGoogleSearchOutputParser extends output_parsers_1.BaseLLMOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"google_common\", \"output_parsers\"]\n        });\n    }\n    generationToGroundingInfo(generation) {\n        if (\"message\" in generation) {\n            const responseMetadata = generation?.message?.response_metadata;\n            const metadata = responseMetadata?.groundingMetadata;\n            const supports = responseMetadata?.groundingSupport ?? metadata?.groundingSupports ?? [];\n            if (metadata) {\n                return {\n                    metadata,\n                    supports,\n                };\n            }\n        }\n        return undefined;\n    }\n    generationsToGroundingInfo(generations) {\n        for (const generation of generations) {\n            const info = this.generationToGroundingInfo(generation);\n            if (info !== undefined) {\n                return info;\n            }\n        }\n        return undefined;\n    }\n    generationToString(generation) {\n        if (\"message\" in generation) {\n            const content = generation?.message?.content;\n            if (typeof content === \"string\") {\n                return content;\n            }\n            else {\n                return content\n                    .map((c) => {\n                    if (c?.type === \"text\") {\n                        return c?.text ?? \"\";\n                    }\n                    else {\n                        return \"\";\n                    }\n                })\n                    .reduce((previousValue, currentValue) => `${previousValue}${currentValue}`);\n            }\n        }\n        return generation.text;\n    }\n    generationsToString(generations) {\n        return generations\n            .map((generation) => this.generationToString(generation))\n            .reduce((previousValue, currentValue) => `${previousValue}${currentValue}`);\n    }\n    annotateSegment(text, grounding, support, index) {\n        const start = support.segment.startIndex ?? 0;\n        const end = support.segment.endIndex;\n        const textBefore = text.substring(0, start);\n        const textSegment = text.substring(start, end);\n        const textAfter = text.substring(end);\n        const textPrefix = this.segmentPrefix(grounding, support, index) ?? \"\";\n        const textSuffix = this.segmentSuffix(grounding, support, index) ?? \"\";\n        return `${textBefore}${textPrefix}${textSegment}${textSuffix}${textAfter}`;\n    }\n    annotateTextSegments(text, grounding) {\n        // Go through each support info in reverse, since the segment info\n        // is sorted, and we won't need to adjust string indexes this way.\n        let ret = text;\n        for (let co = grounding.supports.length - 1; co >= 0; co -= 1) {\n            const support = grounding.supports[co];\n            ret = this.annotateSegment(ret, grounding, support, co);\n        }\n        return ret;\n    }\n    /**\n     * Google requires us to\n     * \"Display the Search Suggestion exactly as provided without any modifications\"\n     * So this will typically be called from the textSuffix() method to get\n     * a string that renders HTML.\n     * See https://ai.google.dev/gemini-api/docs/grounding/search-suggestions\n     * @param grounding\n     */\n    searchSuggestion(grounding) {\n        return grounding?.metadata?.searchEntryPoint?.renderedContent ?? \"\";\n    }\n    annotateText(text, grounding) {\n        const prefix = this.textPrefix(text, grounding) ?? \"\";\n        const suffix = this.textSuffix(text, grounding) ?? \"\";\n        const body = this.annotateTextSegments(text, grounding);\n        return `${prefix}${body}${suffix}`;\n    }\n    async parseResult(generations, _callbacks) {\n        const text = this.generationsToString(generations);\n        const grounding = this.generationsToGroundingInfo(generations);\n        if (!grounding) {\n            return text;\n        }\n        return this.annotateText(text, grounding);\n    }\n}\nexports.BaseGoogleSearchOutputParser = BaseGoogleSearchOutputParser;\nclass SimpleGoogleSearchOutputParser extends BaseGoogleSearchOutputParser {\n    segmentPrefix(_grounding, _support, _index) {\n        return undefined;\n    }\n    segmentSuffix(_grounding, support, _index) {\n        const indices = support.groundingChunkIndices.map((i) => i + 1);\n        return ` [${indices.join(\", \")}]`;\n    }\n    textPrefix(_text, _grounding) {\n        return \"Google Says:\\n\";\n    }\n    chunkToString(chunk, index) {\n        const info = chunk.retrievedContext ?? chunk.web;\n        return `${index + 1}. ${info.title} - ${info.uri}`;\n    }\n    textSuffix(_text, grounding) {\n        let ret = \"\\n\";\n        const chunks = grounding?.metadata?.groundingChunks ?? [];\n        chunks.forEach((chunk, index) => {\n            ret = `${ret}${this.chunkToString(chunk, index)}\\n`;\n        });\n        return ret;\n    }\n}\nexports.SimpleGoogleSearchOutputParser = SimpleGoogleSearchOutputParser;\nclass MarkdownGoogleSearchOutputParser extends BaseGoogleSearchOutputParser {\n    segmentPrefix(_grounding, _support, _index) {\n        return undefined;\n    }\n    chunkLink(grounding, index) {\n        const chunk = grounding.metadata.groundingChunks[index];\n        const url = chunk.retrievedContext?.uri ?? chunk.web?.uri;\n        const num = index + 1;\n        return `[[${num}](${url})]`;\n    }\n    segmentSuffix(grounding, support, _index) {\n        let ret = \"\";\n        support.groundingChunkIndices.forEach((chunkIndex) => {\n            const link = this.chunkLink(grounding, chunkIndex);\n            ret = `${ret}${link}`;\n        });\n        return ret;\n    }\n    textPrefix(_text, _grounding) {\n        return undefined;\n    }\n    chunkSuffixLink(chunk, index) {\n        const num = index + 1;\n        const info = chunk.retrievedContext ?? chunk.web;\n        const url = info.uri;\n        const site = info.title;\n        return `${num}. [${site}](${url})`;\n    }\n    textSuffix(_text, grounding) {\n        let ret = \"\\n**Search Sources**\\n\";\n        const chunks = grounding.metadata.groundingChunks;\n        chunks.forEach((chunk, index) => {\n            ret = `${ret}${this.chunkSuffixLink(chunk, index)}\\n`;\n        });\n        const search = this.searchSuggestion(grounding);\n        ret = `${ret}\\n${search}`;\n        return ret;\n    }\n}\nexports.MarkdownGoogleSearchOutputParser = MarkdownGoogleSearchOutputParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3Qvb3V0cHV0X3BhcnNlcnMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdDQUF3QyxHQUFHLHNDQUFzQyxHQUFHLG9DQUFvQztBQUN4SCx5QkFBeUIsbUJBQU8sQ0FBQywrRkFBZ0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZ0VBQWdFLGNBQWMsRUFBRSxhQUFhO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGNBQWMsRUFBRSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXLEVBQUUsV0FBVyxFQUFFLFlBQVksRUFBRSxXQUFXLEVBQUUsVUFBVTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPLEVBQUUsS0FBSyxFQUFFLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVSxJQUFJLFlBQVksSUFBSSxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSSxFQUFFLGlDQUFpQztBQUM1RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsSUFBSSxJQUFJLElBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixJQUFJLEVBQUUsS0FBSztBQUNoQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsSUFBSSxLQUFLLEtBQUssSUFBSSxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSSxFQUFFLG1DQUFtQztBQUM5RCxTQUFTO0FBQ1Q7QUFDQSxpQkFBaUIsSUFBSSxJQUFJLE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3Qvb3V0cHV0X3BhcnNlcnMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYXJrZG93bkdvb2dsZVNlYXJjaE91dHB1dFBhcnNlciA9IGV4cG9ydHMuU2ltcGxlR29vZ2xlU2VhcmNoT3V0cHV0UGFyc2VyID0gZXhwb3J0cy5CYXNlR29vZ2xlU2VhcmNoT3V0cHV0UGFyc2VyID0gdm9pZCAwO1xuY29uc3Qgb3V0cHV0X3BhcnNlcnNfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvb3V0cHV0X3BhcnNlcnNcIik7XG5jbGFzcyBCYXNlR29vZ2xlU2VhcmNoT3V0cHV0UGFyc2VyIGV4dGVuZHMgb3V0cHV0X3BhcnNlcnNfMS5CYXNlTExNT3V0cHV0UGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJnb29nbGVfY29tbW9uXCIsIFwib3V0cHV0X3BhcnNlcnNcIl1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdlbmVyYXRpb25Ub0dyb3VuZGluZ0luZm8oZ2VuZXJhdGlvbikge1xuICAgICAgICBpZiAoXCJtZXNzYWdlXCIgaW4gZ2VuZXJhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VNZXRhZGF0YSA9IGdlbmVyYXRpb24/Lm1lc3NhZ2U/LnJlc3BvbnNlX21ldGFkYXRhO1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSByZXNwb25zZU1ldGFkYXRhPy5ncm91bmRpbmdNZXRhZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IHN1cHBvcnRzID0gcmVzcG9uc2VNZXRhZGF0YT8uZ3JvdW5kaW5nU3VwcG9ydCA/PyBtZXRhZGF0YT8uZ3JvdW5kaW5nU3VwcG9ydHMgPz8gW107XG4gICAgICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydHMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZW5lcmF0aW9uc1RvR3JvdW5kaW5nSW5mbyhnZW5lcmF0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IGdlbmVyYXRpb24gb2YgZ2VuZXJhdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSB0aGlzLmdlbmVyYXRpb25Ub0dyb3VuZGluZ0luZm8oZ2VuZXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoaW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2VuZXJhdGlvblRvU3RyaW5nKGdlbmVyYXRpb24pIHtcbiAgICAgICAgaWYgKFwibWVzc2FnZVwiIGluIGdlbmVyYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBnZW5lcmF0aW9uPy5tZXNzYWdlPy5jb250ZW50O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudFxuICAgICAgICAgICAgICAgICAgICAubWFwKChjKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjPy50eXBlID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGM/LnRleHQgPz8gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnJlZHVjZSgocHJldmlvdXNWYWx1ZSwgY3VycmVudFZhbHVlKSA9PiBgJHtwcmV2aW91c1ZhbHVlfSR7Y3VycmVudFZhbHVlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZW5lcmF0aW9uLnRleHQ7XG4gICAgfVxuICAgIGdlbmVyYXRpb25zVG9TdHJpbmcoZ2VuZXJhdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRpb25zXG4gICAgICAgICAgICAubWFwKChnZW5lcmF0aW9uKSA9PiB0aGlzLmdlbmVyYXRpb25Ub1N0cmluZyhnZW5lcmF0aW9uKSlcbiAgICAgICAgICAgIC5yZWR1Y2UoKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRWYWx1ZSkgPT4gYCR7cHJldmlvdXNWYWx1ZX0ke2N1cnJlbnRWYWx1ZX1gKTtcbiAgICB9XG4gICAgYW5ub3RhdGVTZWdtZW50KHRleHQsIGdyb3VuZGluZywgc3VwcG9ydCwgaW5kZXgpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBzdXBwb3J0LnNlZ21lbnQuc3RhcnRJbmRleCA/PyAwO1xuICAgICAgICBjb25zdCBlbmQgPSBzdXBwb3J0LnNlZ21lbnQuZW5kSW5kZXg7XG4gICAgICAgIGNvbnN0IHRleHRCZWZvcmUgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydCk7XG4gICAgICAgIGNvbnN0IHRleHRTZWdtZW50ID0gdGV4dC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgIGNvbnN0IHRleHRBZnRlciA9IHRleHQuc3Vic3RyaW5nKGVuZCk7XG4gICAgICAgIGNvbnN0IHRleHRQcmVmaXggPSB0aGlzLnNlZ21lbnRQcmVmaXgoZ3JvdW5kaW5nLCBzdXBwb3J0LCBpbmRleCkgPz8gXCJcIjtcbiAgICAgICAgY29uc3QgdGV4dFN1ZmZpeCA9IHRoaXMuc2VnbWVudFN1ZmZpeChncm91bmRpbmcsIHN1cHBvcnQsIGluZGV4KSA/PyBcIlwiO1xuICAgICAgICByZXR1cm4gYCR7dGV4dEJlZm9yZX0ke3RleHRQcmVmaXh9JHt0ZXh0U2VnbWVudH0ke3RleHRTdWZmaXh9JHt0ZXh0QWZ0ZXJ9YDtcbiAgICB9XG4gICAgYW5ub3RhdGVUZXh0U2VnbWVudHModGV4dCwgZ3JvdW5kaW5nKSB7XG4gICAgICAgIC8vIEdvIHRocm91Z2ggZWFjaCBzdXBwb3J0IGluZm8gaW4gcmV2ZXJzZSwgc2luY2UgdGhlIHNlZ21lbnQgaW5mb1xuICAgICAgICAvLyBpcyBzb3J0ZWQsIGFuZCB3ZSB3b24ndCBuZWVkIHRvIGFkanVzdCBzdHJpbmcgaW5kZXhlcyB0aGlzIHdheS5cbiAgICAgICAgbGV0IHJldCA9IHRleHQ7XG4gICAgICAgIGZvciAobGV0IGNvID0gZ3JvdW5kaW5nLnN1cHBvcnRzLmxlbmd0aCAtIDE7IGNvID49IDA7IGNvIC09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1cHBvcnQgPSBncm91bmRpbmcuc3VwcG9ydHNbY29dO1xuICAgICAgICAgICAgcmV0ID0gdGhpcy5hbm5vdGF0ZVNlZ21lbnQocmV0LCBncm91bmRpbmcsIHN1cHBvcnQsIGNvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHb29nbGUgcmVxdWlyZXMgdXMgdG9cbiAgICAgKiBcIkRpc3BsYXkgdGhlIFNlYXJjaCBTdWdnZXN0aW9uIGV4YWN0bHkgYXMgcHJvdmlkZWQgd2l0aG91dCBhbnkgbW9kaWZpY2F0aW9uc1wiXG4gICAgICogU28gdGhpcyB3aWxsIHR5cGljYWxseSBiZSBjYWxsZWQgZnJvbSB0aGUgdGV4dFN1ZmZpeCgpIG1ldGhvZCB0byBnZXRcbiAgICAgKiBhIHN0cmluZyB0aGF0IHJlbmRlcnMgSFRNTC5cbiAgICAgKiBTZWUgaHR0cHM6Ly9haS5nb29nbGUuZGV2L2dlbWluaS1hcGkvZG9jcy9ncm91bmRpbmcvc2VhcmNoLXN1Z2dlc3Rpb25zXG4gICAgICogQHBhcmFtIGdyb3VuZGluZ1xuICAgICAqL1xuICAgIHNlYXJjaFN1Z2dlc3Rpb24oZ3JvdW5kaW5nKSB7XG4gICAgICAgIHJldHVybiBncm91bmRpbmc/Lm1ldGFkYXRhPy5zZWFyY2hFbnRyeVBvaW50Py5yZW5kZXJlZENvbnRlbnQgPz8gXCJcIjtcbiAgICB9XG4gICAgYW5ub3RhdGVUZXh0KHRleHQsIGdyb3VuZGluZykge1xuICAgICAgICBjb25zdCBwcmVmaXggPSB0aGlzLnRleHRQcmVmaXgodGV4dCwgZ3JvdW5kaW5nKSA/PyBcIlwiO1xuICAgICAgICBjb25zdCBzdWZmaXggPSB0aGlzLnRleHRTdWZmaXgodGV4dCwgZ3JvdW5kaW5nKSA/PyBcIlwiO1xuICAgICAgICBjb25zdCBib2R5ID0gdGhpcy5hbm5vdGF0ZVRleHRTZWdtZW50cyh0ZXh0LCBncm91bmRpbmcpO1xuICAgICAgICByZXR1cm4gYCR7cHJlZml4fSR7Ym9keX0ke3N1ZmZpeH1gO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZVJlc3VsdChnZW5lcmF0aW9ucywgX2NhbGxiYWNrcykge1xuICAgICAgICBjb25zdCB0ZXh0ID0gdGhpcy5nZW5lcmF0aW9uc1RvU3RyaW5nKGdlbmVyYXRpb25zKTtcbiAgICAgICAgY29uc3QgZ3JvdW5kaW5nID0gdGhpcy5nZW5lcmF0aW9uc1RvR3JvdW5kaW5nSW5mbyhnZW5lcmF0aW9ucyk7XG4gICAgICAgIGlmICghZ3JvdW5kaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hbm5vdGF0ZVRleHQodGV4dCwgZ3JvdW5kaW5nKTtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VHb29nbGVTZWFyY2hPdXRwdXRQYXJzZXIgPSBCYXNlR29vZ2xlU2VhcmNoT3V0cHV0UGFyc2VyO1xuY2xhc3MgU2ltcGxlR29vZ2xlU2VhcmNoT3V0cHV0UGFyc2VyIGV4dGVuZHMgQmFzZUdvb2dsZVNlYXJjaE91dHB1dFBhcnNlciB7XG4gICAgc2VnbWVudFByZWZpeChfZ3JvdW5kaW5nLCBfc3VwcG9ydCwgX2luZGV4KSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHNlZ21lbnRTdWZmaXgoX2dyb3VuZGluZywgc3VwcG9ydCwgX2luZGV4KSB7XG4gICAgICAgIGNvbnN0IGluZGljZXMgPSBzdXBwb3J0Lmdyb3VuZGluZ0NodW5rSW5kaWNlcy5tYXAoKGkpID0+IGkgKyAxKTtcbiAgICAgICAgcmV0dXJuIGAgWyR7aW5kaWNlcy5qb2luKFwiLCBcIil9XWA7XG4gICAgfVxuICAgIHRleHRQcmVmaXgoX3RleHQsIF9ncm91bmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIFwiR29vZ2xlIFNheXM6XFxuXCI7XG4gICAgfVxuICAgIGNodW5rVG9TdHJpbmcoY2h1bmssIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSBjaHVuay5yZXRyaWV2ZWRDb250ZXh0ID8/IGNodW5rLndlYjtcbiAgICAgICAgcmV0dXJuIGAke2luZGV4ICsgMX0uICR7aW5mby50aXRsZX0gLSAke2luZm8udXJpfWA7XG4gICAgfVxuICAgIHRleHRTdWZmaXgoX3RleHQsIGdyb3VuZGluZykge1xuICAgICAgICBsZXQgcmV0ID0gXCJcXG5cIjtcbiAgICAgICAgY29uc3QgY2h1bmtzID0gZ3JvdW5kaW5nPy5tZXRhZGF0YT8uZ3JvdW5kaW5nQ2h1bmtzID8/IFtdO1xuICAgICAgICBjaHVua3MuZm9yRWFjaCgoY2h1bmssIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXQgPSBgJHtyZXR9JHt0aGlzLmNodW5rVG9TdHJpbmcoY2h1bmssIGluZGV4KX1cXG5gO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG59XG5leHBvcnRzLlNpbXBsZUdvb2dsZVNlYXJjaE91dHB1dFBhcnNlciA9IFNpbXBsZUdvb2dsZVNlYXJjaE91dHB1dFBhcnNlcjtcbmNsYXNzIE1hcmtkb3duR29vZ2xlU2VhcmNoT3V0cHV0UGFyc2VyIGV4dGVuZHMgQmFzZUdvb2dsZVNlYXJjaE91dHB1dFBhcnNlciB7XG4gICAgc2VnbWVudFByZWZpeChfZ3JvdW5kaW5nLCBfc3VwcG9ydCwgX2luZGV4KSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNodW5rTGluayhncm91bmRpbmcsIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGNodW5rID0gZ3JvdW5kaW5nLm1ldGFkYXRhLmdyb3VuZGluZ0NodW5rc1tpbmRleF07XG4gICAgICAgIGNvbnN0IHVybCA9IGNodW5rLnJldHJpZXZlZENvbnRleHQ/LnVyaSA/PyBjaHVuay53ZWI/LnVyaTtcbiAgICAgICAgY29uc3QgbnVtID0gaW5kZXggKyAxO1xuICAgICAgICByZXR1cm4gYFtbJHtudW19XSgke3VybH0pXWA7XG4gICAgfVxuICAgIHNlZ21lbnRTdWZmaXgoZ3JvdW5kaW5nLCBzdXBwb3J0LCBfaW5kZXgpIHtcbiAgICAgICAgbGV0IHJldCA9IFwiXCI7XG4gICAgICAgIHN1cHBvcnQuZ3JvdW5kaW5nQ2h1bmtJbmRpY2VzLmZvckVhY2goKGNodW5rSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLmNodW5rTGluayhncm91bmRpbmcsIGNodW5rSW5kZXgpO1xuICAgICAgICAgICAgcmV0ID0gYCR7cmV0fSR7bGlua31gO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgdGV4dFByZWZpeChfdGV4dCwgX2dyb3VuZGluZykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjaHVua1N1ZmZpeExpbmsoY2h1bmssIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IG51bSA9IGluZGV4ICsgMTtcbiAgICAgICAgY29uc3QgaW5mbyA9IGNodW5rLnJldHJpZXZlZENvbnRleHQgPz8gY2h1bmsud2ViO1xuICAgICAgICBjb25zdCB1cmwgPSBpbmZvLnVyaTtcbiAgICAgICAgY29uc3Qgc2l0ZSA9IGluZm8udGl0bGU7XG4gICAgICAgIHJldHVybiBgJHtudW19LiBbJHtzaXRlfV0oJHt1cmx9KWA7XG4gICAgfVxuICAgIHRleHRTdWZmaXgoX3RleHQsIGdyb3VuZGluZykge1xuICAgICAgICBsZXQgcmV0ID0gXCJcXG4qKlNlYXJjaCBTb3VyY2VzKipcXG5cIjtcbiAgICAgICAgY29uc3QgY2h1bmtzID0gZ3JvdW5kaW5nLm1ldGFkYXRhLmdyb3VuZGluZ0NodW5rcztcbiAgICAgICAgY2h1bmtzLmZvckVhY2goKGNodW5rLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgcmV0ID0gYCR7cmV0fSR7dGhpcy5jaHVua1N1ZmZpeExpbmsoY2h1bmssIGluZGV4KX1cXG5gO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2VhcmNoID0gdGhpcy5zZWFyY2hTdWdnZXN0aW9uKGdyb3VuZGluZyk7XG4gICAgICAgIHJldCA9IGAke3JldH1cXG4ke3NlYXJjaH1gO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cbmV4cG9ydHMuTWFya2Rvd25Hb29nbGVTZWFyY2hPdXRwdXRQYXJzZXIgPSBNYXJrZG93bkdvb2dsZVNlYXJjaE91dHB1dFBhcnNlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/output_parsers.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/types-anthropic.cjs":
/*!************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/types-anthropic.cjs ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdHlwZXMtYW50aHJvcGljLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9kaXN0L3R5cGVzLWFudGhyb3BpYy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/types-anthropic.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/types.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/types.cjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GeminiToolAttributes = exports.GeminiSearchToolAttributes = exports.GoogleAISafetyMethod = exports.GoogleAISafetyThreshold = exports.GoogleAISafetyCategory = void 0;\n__exportStar(__webpack_require__(/*! ./types-anthropic.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/types-anthropic.cjs\"), exports);\nexports.GoogleAISafetyCategory = {\n    Harassment: \"HARM_CATEGORY_HARASSMENT\",\n    HARASSMENT: \"HARM_CATEGORY_HARASSMENT\",\n    HARM_CATEGORY_HARASSMENT: \"HARM_CATEGORY_HARASSMENT\",\n    HateSpeech: \"HARM_CATEGORY_HATE_SPEECH\",\n    HATE_SPEECH: \"HARM_CATEGORY_HATE_SPEECH\",\n    HARM_CATEGORY_HATE_SPEECH: \"HARM_CATEGORY_HATE_SPEECH\",\n    SexuallyExplicit: \"HARM_CATEGORY_SEXUALLY_EXPLICIT\",\n    SEXUALLY_EXPLICIT: \"HARM_CATEGORY_SEXUALLY_EXPLICIT\",\n    HARM_CATEGORY_SEXUALLY_EXPLICIT: \"HARM_CATEGORY_SEXUALLY_EXPLICIT\",\n    Dangerous: \"HARM_CATEGORY_DANGEROUS\",\n    DANGEROUS: \"HARM_CATEGORY_DANGEROUS\",\n    HARM_CATEGORY_DANGEROUS: \"HARM_CATEGORY_DANGEROUS\",\n    CivicIntegrity: \"HARM_CATEGORY_CIVIC_INTEGRITY\",\n    CIVIC_INTEGRITY: \"HARM_CATEGORY_CIVIC_INTEGRITY\",\n    HARM_CATEGORY_CIVIC_INTEGRITY: \"HARM_CATEGORY_CIVIC_INTEGRITY\",\n};\nexports.GoogleAISafetyThreshold = {\n    None: \"BLOCK_NONE\",\n    NONE: \"BLOCK_NONE\",\n    BLOCK_NONE: \"BLOCK_NONE\",\n    Few: \"BLOCK_ONLY_HIGH\",\n    FEW: \"BLOCK_ONLY_HIGH\",\n    BLOCK_ONLY_HIGH: \"BLOCK_ONLY_HIGH\",\n    Some: \"BLOCK_MEDIUM_AND_ABOVE\",\n    SOME: \"BLOCK_MEDIUM_AND_ABOVE\",\n    BLOCK_MEDIUM_AND_ABOVE: \"BLOCK_MEDIUM_AND_ABOVE\",\n    Most: \"BLOCK_LOW_AND_ABOVE\",\n    MOST: \"BLOCK_LOW_AND_ABOVE\",\n    BLOCK_LOW_AND_ABOVE: \"BLOCK_LOW_AND_ABOVE\",\n    Off: \"OFF\",\n    OFF: \"OFF\",\n    BLOCK_OFF: \"OFF\",\n};\nexports.GoogleAISafetyMethod = {\n    Severity: \"SEVERITY\",\n    Probability: \"PROBABILITY\",\n};\nexports.GeminiSearchToolAttributes = [\n    \"googleSearchRetrieval\",\n    \"googleSearch\",\n];\nexports.GeminiToolAttributes = [\n    \"functionDeclaration\",\n    \"retrieval\",\n    ...exports.GeminiSearchToolAttributes,\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdHlwZXMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLGtDQUFrQyxHQUFHLDRCQUE0QixHQUFHLCtCQUErQixHQUFHLDhCQUE4QjtBQUNuSyxhQUFhLG1CQUFPLENBQUMscUdBQXVCO0FBQzVDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdHlwZXMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdlbWluaVRvb2xBdHRyaWJ1dGVzID0gZXhwb3J0cy5HZW1pbmlTZWFyY2hUb29sQXR0cmlidXRlcyA9IGV4cG9ydHMuR29vZ2xlQUlTYWZldHlNZXRob2QgPSBleHBvcnRzLkdvb2dsZUFJU2FmZXR5VGhyZXNob2xkID0gZXhwb3J0cy5Hb29nbGVBSVNhZmV0eUNhdGVnb3J5ID0gdm9pZCAwO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVzLWFudGhyb3BpYy5janNcIiksIGV4cG9ydHMpO1xuZXhwb3J0cy5Hb29nbGVBSVNhZmV0eUNhdGVnb3J5ID0ge1xuICAgIEhhcmFzc21lbnQ6IFwiSEFSTV9DQVRFR09SWV9IQVJBU1NNRU5UXCIsXG4gICAgSEFSQVNTTUVOVDogXCJIQVJNX0NBVEVHT1JZX0hBUkFTU01FTlRcIixcbiAgICBIQVJNX0NBVEVHT1JZX0hBUkFTU01FTlQ6IFwiSEFSTV9DQVRFR09SWV9IQVJBU1NNRU5UXCIsXG4gICAgSGF0ZVNwZWVjaDogXCJIQVJNX0NBVEVHT1JZX0hBVEVfU1BFRUNIXCIsXG4gICAgSEFURV9TUEVFQ0g6IFwiSEFSTV9DQVRFR09SWV9IQVRFX1NQRUVDSFwiLFxuICAgIEhBUk1fQ0FURUdPUllfSEFURV9TUEVFQ0g6IFwiSEFSTV9DQVRFR09SWV9IQVRFX1NQRUVDSFwiLFxuICAgIFNleHVhbGx5RXhwbGljaXQ6IFwiSEFSTV9DQVRFR09SWV9TRVhVQUxMWV9FWFBMSUNJVFwiLFxuICAgIFNFWFVBTExZX0VYUExJQ0lUOiBcIkhBUk1fQ0FURUdPUllfU0VYVUFMTFlfRVhQTElDSVRcIixcbiAgICBIQVJNX0NBVEVHT1JZX1NFWFVBTExZX0VYUExJQ0lUOiBcIkhBUk1fQ0FURUdPUllfU0VYVUFMTFlfRVhQTElDSVRcIixcbiAgICBEYW5nZXJvdXM6IFwiSEFSTV9DQVRFR09SWV9EQU5HRVJPVVNcIixcbiAgICBEQU5HRVJPVVM6IFwiSEFSTV9DQVRFR09SWV9EQU5HRVJPVVNcIixcbiAgICBIQVJNX0NBVEVHT1JZX0RBTkdFUk9VUzogXCJIQVJNX0NBVEVHT1JZX0RBTkdFUk9VU1wiLFxuICAgIENpdmljSW50ZWdyaXR5OiBcIkhBUk1fQ0FURUdPUllfQ0lWSUNfSU5URUdSSVRZXCIsXG4gICAgQ0lWSUNfSU5URUdSSVRZOiBcIkhBUk1fQ0FURUdPUllfQ0lWSUNfSU5URUdSSVRZXCIsXG4gICAgSEFSTV9DQVRFR09SWV9DSVZJQ19JTlRFR1JJVFk6IFwiSEFSTV9DQVRFR09SWV9DSVZJQ19JTlRFR1JJVFlcIixcbn07XG5leHBvcnRzLkdvb2dsZUFJU2FmZXR5VGhyZXNob2xkID0ge1xuICAgIE5vbmU6IFwiQkxPQ0tfTk9ORVwiLFxuICAgIE5PTkU6IFwiQkxPQ0tfTk9ORVwiLFxuICAgIEJMT0NLX05PTkU6IFwiQkxPQ0tfTk9ORVwiLFxuICAgIEZldzogXCJCTE9DS19PTkxZX0hJR0hcIixcbiAgICBGRVc6IFwiQkxPQ0tfT05MWV9ISUdIXCIsXG4gICAgQkxPQ0tfT05MWV9ISUdIOiBcIkJMT0NLX09OTFlfSElHSFwiLFxuICAgIFNvbWU6IFwiQkxPQ0tfTUVESVVNX0FORF9BQk9WRVwiLFxuICAgIFNPTUU6IFwiQkxPQ0tfTUVESVVNX0FORF9BQk9WRVwiLFxuICAgIEJMT0NLX01FRElVTV9BTkRfQUJPVkU6IFwiQkxPQ0tfTUVESVVNX0FORF9BQk9WRVwiLFxuICAgIE1vc3Q6IFwiQkxPQ0tfTE9XX0FORF9BQk9WRVwiLFxuICAgIE1PU1Q6IFwiQkxPQ0tfTE9XX0FORF9BQk9WRVwiLFxuICAgIEJMT0NLX0xPV19BTkRfQUJPVkU6IFwiQkxPQ0tfTE9XX0FORF9BQk9WRVwiLFxuICAgIE9mZjogXCJPRkZcIixcbiAgICBPRkY6IFwiT0ZGXCIsXG4gICAgQkxPQ0tfT0ZGOiBcIk9GRlwiLFxufTtcbmV4cG9ydHMuR29vZ2xlQUlTYWZldHlNZXRob2QgPSB7XG4gICAgU2V2ZXJpdHk6IFwiU0VWRVJJVFlcIixcbiAgICBQcm9iYWJpbGl0eTogXCJQUk9CQUJJTElUWVwiLFxufTtcbmV4cG9ydHMuR2VtaW5pU2VhcmNoVG9vbEF0dHJpYnV0ZXMgPSBbXG4gICAgXCJnb29nbGVTZWFyY2hSZXRyaWV2YWxcIixcbiAgICBcImdvb2dsZVNlYXJjaFwiLFxuXTtcbmV4cG9ydHMuR2VtaW5pVG9vbEF0dHJpYnV0ZXMgPSBbXG4gICAgXCJmdW5jdGlvbkRlY2xhcmF0aW9uXCIsXG4gICAgXCJyZXRyaWV2YWxcIixcbiAgICAuLi5leHBvcnRzLkdlbWluaVNlYXJjaFRvb2xBdHRyaWJ1dGVzLFxuXTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/types.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/utils/anthropic.cjs":
/*!************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/utils/anthropic.cjs ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isModelClaude = exports.validateClaudeParams = exports.getAnthropicAPI = void 0;\nconst outputs_1 = __webpack_require__(/*! @langchain/core/outputs */ \"(rsc)/./node_modules/@langchain/core/outputs.cjs\");\nconst messages_1 = __webpack_require__(/*! @langchain/core/messages */ \"(rsc)/./node_modules/@langchain/core/messages.cjs\");\nfunction getAnthropicAPI(config) {\n    function partToString(part) {\n        return \"text\" in part ? part.text : \"\";\n    }\n    function messageToString(message) {\n        const content = message?.content ?? [];\n        const ret = content.reduce((acc, part) => {\n            const str = partToString(part);\n            return acc + str;\n        }, \"\");\n        return ret;\n    }\n    function responseToString(response) {\n        const data = response.data;\n        switch (data?.type) {\n            case \"message\":\n                return messageToString(data);\n            default:\n                throw Error(`Unknown type: ${data?.type}`);\n        }\n    }\n    /**\n     * Normalize the AIMessageChunk.\n     * If the fields are just a string - use that as content.\n     * If the content is an array of just text fields, turn them into a string.\n     * @param fields\n     */\n    function newAIMessageChunk(fields) {\n        if (typeof fields === \"string\") {\n            return new messages_1.AIMessageChunk(fields);\n        }\n        const ret = {\n            ...fields,\n        };\n        if (Array.isArray(fields?.content)) {\n            let str = \"\";\n            fields.content.forEach((val) => {\n                if (str !== undefined && val.type === \"text\") {\n                    str = `${str}${val.text}`;\n                }\n                else {\n                    str = undefined;\n                }\n            });\n            if (str) {\n                ret.content = str;\n            }\n        }\n        return new messages_1.AIMessageChunk(ret);\n    }\n    function textContentToMessageFields(textContent) {\n        return {\n            content: [textContent],\n        };\n    }\n    function toolUseContentToMessageFields(toolUseContent) {\n        const tool = {\n            id: toolUseContent.id,\n            name: toolUseContent.name,\n            type: \"tool_call\",\n            args: toolUseContent.input,\n        };\n        return {\n            content: [],\n            tool_calls: [tool],\n        };\n    }\n    function anthropicContentToMessageFields(anthropicContent) {\n        const type = anthropicContent?.type;\n        switch (type) {\n            case \"text\":\n                return textContentToMessageFields(anthropicContent);\n            case \"tool_use\":\n                return toolUseContentToMessageFields(anthropicContent);\n            default:\n                return undefined;\n        }\n    }\n    function contentToMessage(anthropicContent) {\n        const complexContent = [];\n        const toolCalls = [];\n        anthropicContent.forEach((ac) => {\n            const messageFields = anthropicContentToMessageFields(ac);\n            if (messageFields?.content) {\n                complexContent.push(...messageFields.content);\n            }\n            if (messageFields?.tool_calls) {\n                toolCalls.push(...messageFields.tool_calls);\n            }\n        });\n        const ret = {\n            content: complexContent,\n            tool_calls: toolCalls,\n        };\n        return newAIMessageChunk(ret);\n    }\n    function messageToGenerationInfo(message) {\n        const usage = message?.usage;\n        const usageMetadata = {\n            input_tokens: usage?.input_tokens ?? 0,\n            output_tokens: usage?.output_tokens ?? 0,\n            total_tokens: (usage?.input_tokens ?? 0) + (usage?.output_tokens ?? 0),\n        };\n        return {\n            usage_metadata: usageMetadata,\n            finish_reason: message.stop_reason,\n        };\n    }\n    function messageToChatGeneration(responseMessage) {\n        const content = responseMessage?.content ?? [];\n        const text = messageToString(responseMessage);\n        const message = contentToMessage(content);\n        const generationInfo = messageToGenerationInfo(responseMessage);\n        return new outputs_1.ChatGenerationChunk({\n            text,\n            message,\n            generationInfo,\n        });\n    }\n    function messageStartToChatGeneration(event) {\n        const responseMessage = event.message;\n        return messageToChatGeneration(responseMessage);\n    }\n    function messageDeltaToChatGeneration(event) {\n        const responseMessage = event.delta;\n        return messageToChatGeneration(responseMessage);\n    }\n    function contentBlockStartTextToChatGeneration(event) {\n        const content = event.content_block;\n        const message = contentToMessage([content]);\n        if (!message) {\n            return null;\n        }\n        const text = \"text\" in content ? content.text : \"\";\n        return new outputs_1.ChatGenerationChunk({\n            message,\n            text,\n        });\n    }\n    function contentBlockStartToolUseToChatGeneration(event) {\n        const contentBlock = event.content_block;\n        const text = \"\";\n        const toolChunk = {\n            type: \"tool_call_chunk\",\n            index: event.index,\n            name: contentBlock.name,\n            id: contentBlock.id,\n        };\n        if (typeof contentBlock.input === \"object\" &&\n            Object.keys(contentBlock.input).length > 0) {\n            toolChunk.args = JSON.stringify(contentBlock.input);\n        }\n        const toolChunks = [toolChunk];\n        const content = [\n            {\n                index: event.index,\n                ...contentBlock,\n            },\n        ];\n        const messageFields = {\n            content,\n            tool_call_chunks: toolChunks,\n        };\n        const message = newAIMessageChunk(messageFields);\n        return new outputs_1.ChatGenerationChunk({\n            message,\n            text,\n        });\n    }\n    function contentBlockStartToChatGeneration(event) {\n        switch (event.content_block.type) {\n            case \"text\":\n                return contentBlockStartTextToChatGeneration(event);\n            case \"tool_use\":\n                return contentBlockStartToolUseToChatGeneration(event);\n            default:\n                console.warn(`Unexpected start content_block type: ${JSON.stringify(event)}`);\n                return null;\n        }\n    }\n    function contentBlockDeltaTextToChatGeneration(event) {\n        const delta = event.delta;\n        const text = delta?.text;\n        const message = newAIMessageChunk(text);\n        return new outputs_1.ChatGenerationChunk({\n            message,\n            text,\n        });\n    }\n    function contentBlockDeltaInputJsonDeltaToChatGeneration(event) {\n        const delta = event.delta;\n        const text = \"\";\n        const toolChunks = [\n            {\n                index: event.index,\n                args: delta.partial_json,\n            },\n        ];\n        const content = [\n            {\n                index: event.index,\n                ...delta,\n            },\n        ];\n        const messageFields = {\n            content,\n            tool_call_chunks: toolChunks,\n        };\n        const message = newAIMessageChunk(messageFields);\n        return new outputs_1.ChatGenerationChunk({\n            message,\n            text,\n        });\n    }\n    function contentBlockDeltaToChatGeneration(event) {\n        switch (event.delta.type) {\n            case \"text_delta\":\n                return contentBlockDeltaTextToChatGeneration(event);\n            case \"input_json_delta\":\n                return contentBlockDeltaInputJsonDeltaToChatGeneration(event);\n            default:\n                console.warn(`Unexpected delta content_block type: ${JSON.stringify(event)}`);\n                return null;\n        }\n    }\n    function responseToChatGeneration(response) {\n        const data = response.data;\n        switch (data.type) {\n            case \"message\":\n                return messageToChatGeneration(data);\n            case \"message_start\":\n                return messageStartToChatGeneration(data);\n            case \"message_delta\":\n                return messageDeltaToChatGeneration(data);\n            case \"content_block_start\":\n                return contentBlockStartToChatGeneration(data);\n            case \"content_block_delta\":\n                return contentBlockDeltaToChatGeneration(data);\n            case \"ping\":\n            case \"message_stop\":\n            case \"content_block_stop\":\n                // These are ignorable\n                return null;\n            case \"error\":\n                throw new Error(`Error while streaming results: ${JSON.stringify(data)}`);\n            default:\n                // We don't know what type this is, but Anthropic may have added\n                // new ones without telling us. Don't error, but don't use them.\n                console.warn(\"Unknown data for responseToChatGeneration\", data);\n                // throw new Error(`Unknown response type: ${data.type}`);\n                return null;\n        }\n    }\n    function chunkToString(chunk) {\n        if (chunk === null) {\n            return \"\";\n        }\n        else if (typeof chunk.content === \"string\") {\n            return chunk.content;\n        }\n        else if (chunk.content.length === 0) {\n            return \"\";\n        }\n        else if (chunk.content[0].type === \"text\") {\n            return chunk.content[0].text;\n        }\n        else {\n            throw new Error(`Unexpected chunk: ${chunk}`);\n        }\n    }\n    function responseToBaseMessage(response) {\n        const data = response.data;\n        const content = data?.content ?? [];\n        return contentToMessage(content);\n    }\n    function responseToChatResult(response) {\n        const message = response.data;\n        const generations = [];\n        const gen = responseToChatGeneration(response);\n        if (gen) {\n            generations.push(gen);\n        }\n        const llmOutput = messageToGenerationInfo(message);\n        return {\n            generations,\n            llmOutput,\n        };\n    }\n    function formatAnthropicVersion() {\n        return config?.version ?? \"vertex-2023-10-16\";\n    }\n    function textContentToAnthropicContent(content) {\n        return content;\n    }\n    function extractMimeType(str) {\n        if (str.startsWith(\"data:\")) {\n            return {\n                media_type: str.split(\":\")[1].split(\";\")[0],\n                data: str.split(\",\")[1],\n            };\n        }\n        return null;\n    }\n    function imageContentToAnthropicContent(content) {\n        const dataUrl = content.image_url;\n        const url = typeof dataUrl === \"string\" ? dataUrl : dataUrl?.url;\n        const urlInfo = extractMimeType(url);\n        if (!urlInfo) {\n            return undefined;\n        }\n        return {\n            type: \"image\",\n            source: {\n                type: \"base64\",\n                ...urlInfo,\n            },\n        };\n    }\n    function contentComplexToAnthropicContent(content) {\n        const type = content?.type;\n        switch (type) {\n            case \"text\":\n                return textContentToAnthropicContent(content);\n            case \"image_url\":\n                return imageContentToAnthropicContent(content);\n            default:\n                console.warn(`Unexpected content type: ${type}`);\n                return undefined;\n        }\n    }\n    function contentToAnthropicContent(content) {\n        const ret = [];\n        const ca = typeof content === \"string\" ? [{ type: \"text\", text: content }] : content;\n        ca.forEach((complex) => {\n            const ac = contentComplexToAnthropicContent(complex);\n            if (ac) {\n                ret.push(ac);\n            }\n        });\n        return ret;\n    }\n    function baseRoleToAnthropicMessage(base, role) {\n        const content = contentToAnthropicContent(base.content);\n        return {\n            role,\n            content,\n        };\n    }\n    function toolMessageToAnthropicMessage(base) {\n        const role = \"user\";\n        const toolUseId = base.tool_call_id;\n        const toolContent = contentToAnthropicContent(base.content);\n        const content = [\n            {\n                type: \"tool_result\",\n                tool_use_id: toolUseId,\n                content: toolContent,\n            },\n        ];\n        return {\n            role,\n            content,\n        };\n    }\n    function baseToAnthropicMessage(base) {\n        const type = base._getType();\n        switch (type) {\n            case \"human\":\n                return baseRoleToAnthropicMessage(base, \"user\");\n            case \"ai\":\n                return baseRoleToAnthropicMessage(base, \"assistant\");\n            case \"tool\":\n                return toolMessageToAnthropicMessage(base);\n            default:\n                return undefined;\n        }\n    }\n    function formatMessages(input) {\n        const ret = [];\n        input.forEach((baseMessage) => {\n            const anthropicMessage = baseToAnthropicMessage(baseMessage);\n            if (anthropicMessage) {\n                ret.push(anthropicMessage);\n            }\n        });\n        return ret;\n    }\n    function formatSettings(parameters) {\n        const ret = {\n            stream: parameters?.streaming ?? false,\n            max_tokens: parameters?.maxOutputTokens ?? 8192,\n        };\n        if (parameters.topP) {\n            ret.top_p = parameters.topP;\n        }\n        if (parameters.topK) {\n            ret.top_k = parameters.topK;\n        }\n        if (parameters.temperature) {\n            ret.temperature = parameters.temperature;\n        }\n        if (parameters.stopSequences) {\n            ret.stop_sequences = parameters.stopSequences;\n        }\n        return ret;\n    }\n    function contentComplexArrayToText(contentArray) {\n        let ret = \"\";\n        contentArray.forEach((content) => {\n            const contentType = content?.type;\n            if (contentType === \"text\") {\n                const textContent = content;\n                ret = `${ret}\\n${textContent.text}`;\n            }\n        });\n        return ret;\n    }\n    function formatSystem(input) {\n        let ret = \"\";\n        input.forEach((message) => {\n            if (message._getType() === \"system\") {\n                const content = message?.content;\n                const contentString = typeof content === \"string\"\n                    ? content\n                    : contentComplexArrayToText(content);\n                ret = `${ret}\\n${contentString}`;\n            }\n        });\n        return ret;\n    }\n    function formatGeminiTool(tool) {\n        if (Object.hasOwn(tool, \"functionDeclarations\")) {\n            const funcs = tool?.functionDeclarations ?? [];\n            return funcs.map((func) => {\n                const inputSchema = func.parameters;\n                return {\n                    // type: \"tool\",  // This may only be valid for models 20241022+\n                    name: func.name,\n                    description: func.description,\n                    input_schema: inputSchema,\n                };\n            });\n        }\n        else {\n            console.warn(`Unable to format GeminiTool: ${JSON.stringify(tool, null, 1)}`);\n            return [];\n        }\n    }\n    function formatTool(tool) {\n        if (Object.hasOwn(tool, \"name\")) {\n            return [tool];\n        }\n        else {\n            return formatGeminiTool(tool);\n        }\n    }\n    function formatTools(parameters) {\n        const tools = parameters?.tools ?? [];\n        const ret = [];\n        tools.forEach((tool) => {\n            const anthropicTools = formatTool(tool);\n            anthropicTools.forEach((anthropicTool) => {\n                if (anthropicTool) {\n                    ret.push(anthropicTool);\n                }\n            });\n        });\n        return ret;\n    }\n    function formatToolChoice(parameters) {\n        const choice = parameters?.tool_choice;\n        if (!choice) {\n            return undefined;\n        }\n        else if (typeof choice === \"object\") {\n            return choice;\n        }\n        else {\n            switch (choice) {\n                case \"any\":\n                case \"auto\":\n                    return {\n                        type: choice,\n                    };\n                case \"none\":\n                    return undefined;\n                default:\n                    return {\n                        type: \"tool\",\n                        name: choice,\n                    };\n            }\n        }\n    }\n    async function formatData(input, parameters) {\n        const typedInput = input;\n        const anthropicVersion = formatAnthropicVersion();\n        const messages = formatMessages(typedInput);\n        const settings = formatSettings(parameters);\n        const system = formatSystem(typedInput);\n        const tools = formatTools(parameters);\n        const toolChoice = formatToolChoice(parameters);\n        const ret = {\n            anthropic_version: anthropicVersion,\n            messages,\n            ...settings,\n        };\n        if (tools && tools.length && parameters?.tool_choice !== \"none\") {\n            ret.tools = tools;\n        }\n        if (toolChoice) {\n            ret.tool_choice = toolChoice;\n        }\n        if (system?.length) {\n            ret.system = system;\n        }\n        return ret;\n    }\n    return {\n        responseToString,\n        responseToChatGeneration,\n        chunkToString,\n        responseToBaseMessage,\n        responseToChatResult,\n        formatData,\n    };\n}\nexports.getAnthropicAPI = getAnthropicAPI;\nfunction validateClaudeParams(_params) {\n    // FIXME - validate the parameters\n}\nexports.validateClaudeParams = validateClaudeParams;\nfunction isModelClaude(modelName) {\n    return modelName.toLowerCase().startsWith(\"claude\");\n}\nexports.isModelClaude = isModelClaude;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvYW50aHJvcGljLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyw0QkFBNEIsR0FBRyx1QkFBdUI7QUFDOUUsa0JBQWtCLG1CQUFPLENBQUMsaUZBQXlCO0FBQ25ELG1CQUFtQixtQkFBTyxDQUFDLG1GQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxXQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLElBQUksRUFBRSxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsc0JBQXNCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxzQkFBc0I7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UscUJBQXFCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFVBQVU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxLQUFLO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsNkJBQTZCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLElBQUksSUFBSSxpQkFBaUI7QUFDbEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsSUFBSSxJQUFJLGNBQWM7QUFDL0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHlEQUF5RCw4QkFBOEI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vZGlzdC91dGlscy9hbnRocm9waWMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc01vZGVsQ2xhdWRlID0gZXhwb3J0cy52YWxpZGF0ZUNsYXVkZVBhcmFtcyA9IGV4cG9ydHMuZ2V0QW50aHJvcGljQVBJID0gdm9pZCAwO1xuY29uc3Qgb3V0cHV0c18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9vdXRwdXRzXCIpO1xuY29uc3QgbWVzc2FnZXNfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvbWVzc2FnZXNcIik7XG5mdW5jdGlvbiBnZXRBbnRocm9waWNBUEkoY29uZmlnKSB7XG4gICAgZnVuY3Rpb24gcGFydFRvU3RyaW5nKHBhcnQpIHtcbiAgICAgICAgcmV0dXJuIFwidGV4dFwiIGluIHBhcnQgPyBwYXJ0LnRleHQgOiBcIlwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtZXNzYWdlVG9TdHJpbmcobWVzc2FnZSkge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gbWVzc2FnZT8uY29udGVudCA/PyBbXTtcbiAgICAgICAgY29uc3QgcmV0ID0gY29udGVudC5yZWR1Y2UoKGFjYywgcGFydCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RyID0gcGFydFRvU3RyaW5nKHBhcnQpO1xuICAgICAgICAgICAgcmV0dXJuIGFjYyArIHN0cjtcbiAgICAgICAgfSwgXCJcIik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3BvbnNlVG9TdHJpbmcocmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIHN3aXRjaCAoZGF0YT8udHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZVRvU3RyaW5nKGRhdGEpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgVW5rbm93biB0eXBlOiAke2RhdGE/LnR5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIHRoZSBBSU1lc3NhZ2VDaHVuay5cbiAgICAgKiBJZiB0aGUgZmllbGRzIGFyZSBqdXN0IGEgc3RyaW5nIC0gdXNlIHRoYXQgYXMgY29udGVudC5cbiAgICAgKiBJZiB0aGUgY29udGVudCBpcyBhbiBhcnJheSBvZiBqdXN0IHRleHQgZmllbGRzLCB0dXJuIHRoZW0gaW50byBhIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gZmllbGRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmV3QUlNZXNzYWdlQ2h1bmsoZmllbGRzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IG1lc3NhZ2VzXzEuQUlNZXNzYWdlQ2h1bmsoZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSB7XG4gICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkcz8uY29udGVudCkpIHtcbiAgICAgICAgICAgIGxldCBzdHIgPSBcIlwiO1xuICAgICAgICAgICAgZmllbGRzLmNvbnRlbnQuZm9yRWFjaCgodmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN0ciAhPT0gdW5kZWZpbmVkICYmIHZhbC50eXBlID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSBgJHtzdHJ9JHt2YWwudGV4dH1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgICAgIHJldC5jb250ZW50ID0gc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgbWVzc2FnZXNfMS5BSU1lc3NhZ2VDaHVuayhyZXQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXh0Q29udGVudFRvTWVzc2FnZUZpZWxkcyh0ZXh0Q29udGVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udGVudDogW3RleHRDb250ZW50XSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9vbFVzZUNvbnRlbnRUb01lc3NhZ2VGaWVsZHModG9vbFVzZUNvbnRlbnQpIHtcbiAgICAgICAgY29uc3QgdG9vbCA9IHtcbiAgICAgICAgICAgIGlkOiB0b29sVXNlQ29udGVudC5pZCxcbiAgICAgICAgICAgIG5hbWU6IHRvb2xVc2VDb250ZW50Lm5hbWUsXG4gICAgICAgICAgICB0eXBlOiBcInRvb2xfY2FsbFwiLFxuICAgICAgICAgICAgYXJnczogdG9vbFVzZUNvbnRlbnQuaW5wdXQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb250ZW50OiBbXSxcbiAgICAgICAgICAgIHRvb2xfY2FsbHM6IFt0b29sXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYW50aHJvcGljQ29udGVudFRvTWVzc2FnZUZpZWxkcyhhbnRocm9waWNDb250ZW50KSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBhbnRocm9waWNDb250ZW50Py50eXBlO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHRDb250ZW50VG9NZXNzYWdlRmllbGRzKGFudGhyb3BpY0NvbnRlbnQpO1xuICAgICAgICAgICAgY2FzZSBcInRvb2xfdXNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xVc2VDb250ZW50VG9NZXNzYWdlRmllbGRzKGFudGhyb3BpY0NvbnRlbnQpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnRlbnRUb01lc3NhZ2UoYW50aHJvcGljQ29udGVudCkge1xuICAgICAgICBjb25zdCBjb21wbGV4Q29udGVudCA9IFtdO1xuICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBbXTtcbiAgICAgICAgYW50aHJvcGljQ29udGVudC5mb3JFYWNoKChhYykgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZUZpZWxkcyA9IGFudGhyb3BpY0NvbnRlbnRUb01lc3NhZ2VGaWVsZHMoYWMpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2VGaWVsZHM/LmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBjb21wbGV4Q29udGVudC5wdXNoKC4uLm1lc3NhZ2VGaWVsZHMuY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZUZpZWxkcz8udG9vbF9jYWxscykge1xuICAgICAgICAgICAgICAgIHRvb2xDYWxscy5wdXNoKC4uLm1lc3NhZ2VGaWVsZHMudG9vbF9jYWxscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXQgPSB7XG4gICAgICAgICAgICBjb250ZW50OiBjb21wbGV4Q29udGVudCxcbiAgICAgICAgICAgIHRvb2xfY2FsbHM6IHRvb2xDYWxscyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ld0FJTWVzc2FnZUNodW5rKHJldCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lc3NhZ2VUb0dlbmVyYXRpb25JbmZvKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgdXNhZ2UgPSBtZXNzYWdlPy51c2FnZTtcbiAgICAgICAgY29uc3QgdXNhZ2VNZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIGlucHV0X3Rva2VuczogdXNhZ2U/LmlucHV0X3Rva2VucyA/PyAwLFxuICAgICAgICAgICAgb3V0cHV0X3Rva2VuczogdXNhZ2U/Lm91dHB1dF90b2tlbnMgPz8gMCxcbiAgICAgICAgICAgIHRvdGFsX3Rva2VuczogKHVzYWdlPy5pbnB1dF90b2tlbnMgPz8gMCkgKyAodXNhZ2U/Lm91dHB1dF90b2tlbnMgPz8gMCksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2FnZV9tZXRhZGF0YTogdXNhZ2VNZXRhZGF0YSxcbiAgICAgICAgICAgIGZpbmlzaF9yZWFzb246IG1lc3NhZ2Uuc3RvcF9yZWFzb24sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lc3NhZ2VUb0NoYXRHZW5lcmF0aW9uKHJlc3BvbnNlTWVzc2FnZSkge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gcmVzcG9uc2VNZXNzYWdlPy5jb250ZW50ID8/IFtdO1xuICAgICAgICBjb25zdCB0ZXh0ID0gbWVzc2FnZVRvU3RyaW5nKHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjb250ZW50VG9NZXNzYWdlKGNvbnRlbnQpO1xuICAgICAgICBjb25zdCBnZW5lcmF0aW9uSW5mbyA9IG1lc3NhZ2VUb0dlbmVyYXRpb25JbmZvKHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBuZXcgb3V0cHV0c18xLkNoYXRHZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICBnZW5lcmF0aW9uSW5mbyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lc3NhZ2VTdGFydFRvQ2hhdEdlbmVyYXRpb24oZXZlbnQpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VNZXNzYWdlID0gZXZlbnQubWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VUb0NoYXRHZW5lcmF0aW9uKHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lc3NhZ2VEZWx0YVRvQ2hhdEdlbmVyYXRpb24oZXZlbnQpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VNZXNzYWdlID0gZXZlbnQuZGVsdGE7XG4gICAgICAgIHJldHVybiBtZXNzYWdlVG9DaGF0R2VuZXJhdGlvbihyZXNwb25zZU1lc3NhZ2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb250ZW50QmxvY2tTdGFydFRleHRUb0NoYXRHZW5lcmF0aW9uKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBldmVudC5jb250ZW50X2Jsb2NrO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY29udGVudFRvTWVzc2FnZShbY29udGVudF0pO1xuICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRleHQgPSBcInRleHRcIiBpbiBjb250ZW50ID8gY29udGVudC50ZXh0IDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG5ldyBvdXRwdXRzXzEuQ2hhdEdlbmVyYXRpb25DaHVuayh7XG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnRlbnRCbG9ja1N0YXJ0VG9vbFVzZVRvQ2hhdEdlbmVyYXRpb24oZXZlbnQpIHtcbiAgICAgICAgY29uc3QgY29udGVudEJsb2NrID0gZXZlbnQuY29udGVudF9ibG9jaztcbiAgICAgICAgY29uc3QgdGV4dCA9IFwiXCI7XG4gICAgICAgIGNvbnN0IHRvb2xDaHVuayA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwidG9vbF9jYWxsX2NodW5rXCIsXG4gICAgICAgICAgICBpbmRleDogZXZlbnQuaW5kZXgsXG4gICAgICAgICAgICBuYW1lOiBjb250ZW50QmxvY2submFtZSxcbiAgICAgICAgICAgIGlkOiBjb250ZW50QmxvY2suaWQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgY29udGVudEJsb2NrLmlucHV0ID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjb250ZW50QmxvY2suaW5wdXQpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRvb2xDaHVuay5hcmdzID0gSlNPTi5zdHJpbmdpZnkoY29udGVudEJsb2NrLmlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b29sQ2h1bmtzID0gW3Rvb2xDaHVua107XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGV2ZW50LmluZGV4LFxuICAgICAgICAgICAgICAgIC4uLmNvbnRlbnRCbG9jayxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VGaWVsZHMgPSB7XG4gICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgdG9vbF9jYWxsX2NodW5rczogdG9vbENodW5rcyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG5ld0FJTWVzc2FnZUNodW5rKG1lc3NhZ2VGaWVsZHMpO1xuICAgICAgICByZXR1cm4gbmV3IG91dHB1dHNfMS5DaGF0R2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udGVudEJsb2NrU3RhcnRUb0NoYXRHZW5lcmF0aW9uKGV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQuY29udGVudF9ibG9jay50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50QmxvY2tTdGFydFRleHRUb0NoYXRHZW5lcmF0aW9uKGV2ZW50KTtcbiAgICAgICAgICAgIGNhc2UgXCJ0b29sX3VzZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50QmxvY2tTdGFydFRvb2xVc2VUb0NoYXRHZW5lcmF0aW9uKGV2ZW50KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmV4cGVjdGVkIHN0YXJ0IGNvbnRlbnRfYmxvY2sgdHlwZTogJHtKU09OLnN0cmluZ2lmeShldmVudCl9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29udGVudEJsb2NrRGVsdGFUZXh0VG9DaGF0R2VuZXJhdGlvbihldmVudCkge1xuICAgICAgICBjb25zdCBkZWx0YSA9IGV2ZW50LmRlbHRhO1xuICAgICAgICBjb25zdCB0ZXh0ID0gZGVsdGE/LnRleHQ7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXdBSU1lc3NhZ2VDaHVuayh0ZXh0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBvdXRwdXRzXzEuQ2hhdEdlbmVyYXRpb25DaHVuayh7XG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnRlbnRCbG9ja0RlbHRhSW5wdXRKc29uRGVsdGFUb0NoYXRHZW5lcmF0aW9uKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gZXZlbnQuZGVsdGE7XG4gICAgICAgIGNvbnN0IHRleHQgPSBcIlwiO1xuICAgICAgICBjb25zdCB0b29sQ2h1bmtzID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4OiBldmVudC5pbmRleCxcbiAgICAgICAgICAgICAgICBhcmdzOiBkZWx0YS5wYXJ0aWFsX2pzb24sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4OiBldmVudC5pbmRleCxcbiAgICAgICAgICAgICAgICAuLi5kZWx0YSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VGaWVsZHMgPSB7XG4gICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgdG9vbF9jYWxsX2NodW5rczogdG9vbENodW5rcyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG5ld0FJTWVzc2FnZUNodW5rKG1lc3NhZ2VGaWVsZHMpO1xuICAgICAgICByZXR1cm4gbmV3IG91dHB1dHNfMS5DaGF0R2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udGVudEJsb2NrRGVsdGFUb0NoYXRHZW5lcmF0aW9uKGV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQuZGVsdGEudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInRleHRfZGVsdGFcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudEJsb2NrRGVsdGFUZXh0VG9DaGF0R2VuZXJhdGlvbihldmVudCk7XG4gICAgICAgICAgICBjYXNlIFwiaW5wdXRfanNvbl9kZWx0YVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50QmxvY2tEZWx0YUlucHV0SnNvbkRlbHRhVG9DaGF0R2VuZXJhdGlvbihldmVudCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5leHBlY3RlZCBkZWx0YSBjb250ZW50X2Jsb2NrIHR5cGU6ICR7SlNPTi5zdHJpbmdpZnkoZXZlbnQpfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3BvbnNlVG9DaGF0R2VuZXJhdGlvbihyZXNwb25zZSkge1xuICAgICAgICBjb25zdCBkYXRhID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VUb0NoYXRHZW5lcmF0aW9uKGRhdGEpO1xuICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2Vfc3RhcnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZVN0YXJ0VG9DaGF0R2VuZXJhdGlvbihkYXRhKTtcbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlX2RlbHRhXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VEZWx0YVRvQ2hhdEdlbmVyYXRpb24oZGF0YSk7XG4gICAgICAgICAgICBjYXNlIFwiY29udGVudF9ibG9ja19zdGFydFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50QmxvY2tTdGFydFRvQ2hhdEdlbmVyYXRpb24oZGF0YSk7XG4gICAgICAgICAgICBjYXNlIFwiY29udGVudF9ibG9ja19kZWx0YVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50QmxvY2tEZWx0YVRvQ2hhdEdlbmVyYXRpb24oZGF0YSk7XG4gICAgICAgICAgICBjYXNlIFwicGluZ1wiOlxuICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2Vfc3RvcFwiOlxuICAgICAgICAgICAgY2FzZSBcImNvbnRlbnRfYmxvY2tfc3RvcFwiOlxuICAgICAgICAgICAgICAgIC8vIFRoZXNlIGFyZSBpZ25vcmFibGVcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3Igd2hpbGUgc3RyZWFtaW5nIHJlc3VsdHM6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9YCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IGtub3cgd2hhdCB0eXBlIHRoaXMgaXMsIGJ1dCBBbnRocm9waWMgbWF5IGhhdmUgYWRkZWRcbiAgICAgICAgICAgICAgICAvLyBuZXcgb25lcyB3aXRob3V0IHRlbGxpbmcgdXMuIERvbid0IGVycm9yLCBidXQgZG9uJ3QgdXNlIHRoZW0uXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5rbm93biBkYXRhIGZvciByZXNwb25zZVRvQ2hhdEdlbmVyYXRpb25cIiwgZGF0YSk7XG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHJlc3BvbnNlIHR5cGU6ICR7ZGF0YS50eXBlfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNodW5rVG9TdHJpbmcoY2h1bmspIHtcbiAgICAgICAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2h1bmsuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGNodW5rLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2h1bmsuY29udGVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNodW5rLmNvbnRlbnRbMF0udHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjaHVuay5jb250ZW50WzBdLnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgY2h1bms6ICR7Y2h1bmt9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzcG9uc2VUb0Jhc2VNZXNzYWdlKHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gZGF0YT8uY29udGVudCA/PyBbXTtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnRUb01lc3NhZ2UoY29udGVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3BvbnNlVG9DaGF0UmVzdWx0KHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICBjb25zdCBnZW5lcmF0aW9ucyA9IFtdO1xuICAgICAgICBjb25zdCBnZW4gPSByZXNwb25zZVRvQ2hhdEdlbmVyYXRpb24ocmVzcG9uc2UpO1xuICAgICAgICBpZiAoZ2VuKSB7XG4gICAgICAgICAgICBnZW5lcmF0aW9ucy5wdXNoKGdlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGxtT3V0cHV0ID0gbWVzc2FnZVRvR2VuZXJhdGlvbkluZm8obWVzc2FnZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZW5lcmF0aW9ucyxcbiAgICAgICAgICAgIGxsbU91dHB1dCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9ybWF0QW50aHJvcGljVmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZz8udmVyc2lvbiA/PyBcInZlcnRleC0yMDIzLTEwLTE2XCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRleHRDb250ZW50VG9BbnRocm9waWNDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGV4dHJhY3RNaW1lVHlwZShzdHIpIHtcbiAgICAgICAgaWYgKHN0ci5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWVkaWFfdHlwZTogc3RyLnNwbGl0KFwiOlwiKVsxXS5zcGxpdChcIjtcIilbMF0sXG4gICAgICAgICAgICAgICAgZGF0YTogc3RyLnNwbGl0KFwiLFwiKVsxXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGltYWdlQ29udGVudFRvQW50aHJvcGljQ29udGVudChjb250ZW50KSB7XG4gICAgICAgIGNvbnN0IGRhdGFVcmwgPSBjb250ZW50LmltYWdlX3VybDtcbiAgICAgICAgY29uc3QgdXJsID0gdHlwZW9mIGRhdGFVcmwgPT09IFwic3RyaW5nXCIgPyBkYXRhVXJsIDogZGF0YVVybD8udXJsO1xuICAgICAgICBjb25zdCB1cmxJbmZvID0gZXh0cmFjdE1pbWVUeXBlKHVybCk7XG4gICAgICAgIGlmICghdXJsSW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJpbWFnZVwiLFxuICAgICAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJiYXNlNjRcIixcbiAgICAgICAgICAgICAgICAuLi51cmxJbmZvLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udGVudENvbXBsZXhUb0FudGhyb3BpY0NvbnRlbnQoY29udGVudCkge1xuICAgICAgICBjb25zdCB0eXBlID0gY29udGVudD8udHlwZTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0Q29udGVudFRvQW50aHJvcGljQ29udGVudChjb250ZW50KTtcbiAgICAgICAgICAgIGNhc2UgXCJpbWFnZV91cmxcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1hZ2VDb250ZW50VG9BbnRocm9waWNDb250ZW50KGNvbnRlbnQpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFVuZXhwZWN0ZWQgY29udGVudCB0eXBlOiAke3R5cGV9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb250ZW50VG9BbnRocm9waWNDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gW107XG4gICAgICAgIGNvbnN0IGNhID0gdHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIgPyBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogY29udGVudCB9XSA6IGNvbnRlbnQ7XG4gICAgICAgIGNhLmZvckVhY2goKGNvbXBsZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFjID0gY29udGVudENvbXBsZXhUb0FudGhyb3BpY0NvbnRlbnQoY29tcGxleCk7XG4gICAgICAgICAgICBpZiAoYWMpIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChhYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBiYXNlUm9sZVRvQW50aHJvcGljTWVzc2FnZShiYXNlLCByb2xlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBjb250ZW50VG9BbnRocm9waWNDb250ZW50KGJhc2UuY29udGVudCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb2xlLFxuICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9vbE1lc3NhZ2VUb0FudGhyb3BpY01lc3NhZ2UoYmFzZSkge1xuICAgICAgICBjb25zdCByb2xlID0gXCJ1c2VyXCI7XG4gICAgICAgIGNvbnN0IHRvb2xVc2VJZCA9IGJhc2UudG9vbF9jYWxsX2lkO1xuICAgICAgICBjb25zdCB0b29sQ29udGVudCA9IGNvbnRlbnRUb0FudGhyb3BpY0NvbnRlbnQoYmFzZS5jb250ZW50KTtcbiAgICAgICAgY29uc3QgY29udGVudCA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2xfcmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgdG9vbF91c2VfaWQ6IHRvb2xVc2VJZCxcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0b29sQ29udGVudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb2xlLFxuICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFzZVRvQW50aHJvcGljTWVzc2FnZShiYXNlKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBiYXNlLl9nZXRUeXBlKCk7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImh1bWFuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VSb2xlVG9BbnRocm9waWNNZXNzYWdlKGJhc2UsIFwidXNlclwiKTtcbiAgICAgICAgICAgIGNhc2UgXCJhaVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlUm9sZVRvQW50aHJvcGljTWVzc2FnZShiYXNlLCBcImFzc2lzdGFudFwiKTtcbiAgICAgICAgICAgIGNhc2UgXCJ0b29sXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xNZXNzYWdlVG9BbnRocm9waWNNZXNzYWdlKGJhc2UpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2VzKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFtdO1xuICAgICAgICBpbnB1dC5mb3JFYWNoKChiYXNlTWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYW50aHJvcGljTWVzc2FnZSA9IGJhc2VUb0FudGhyb3BpY01lc3NhZ2UoYmFzZU1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKGFudGhyb3BpY01lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChhbnRocm9waWNNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcm1hdFNldHRpbmdzKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3QgcmV0ID0ge1xuICAgICAgICAgICAgc3RyZWFtOiBwYXJhbWV0ZXJzPy5zdHJlYW1pbmcgPz8gZmFsc2UsXG4gICAgICAgICAgICBtYXhfdG9rZW5zOiBwYXJhbWV0ZXJzPy5tYXhPdXRwdXRUb2tlbnMgPz8gODE5MixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMudG9wUCkge1xuICAgICAgICAgICAgcmV0LnRvcF9wID0gcGFyYW1ldGVycy50b3BQO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbWV0ZXJzLnRvcEspIHtcbiAgICAgICAgICAgIHJldC50b3BfayA9IHBhcmFtZXRlcnMudG9wSztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1ldGVycy50ZW1wZXJhdHVyZSkge1xuICAgICAgICAgICAgcmV0LnRlbXBlcmF0dXJlID0gcGFyYW1ldGVycy50ZW1wZXJhdHVyZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1ldGVycy5zdG9wU2VxdWVuY2VzKSB7XG4gICAgICAgICAgICByZXQuc3RvcF9zZXF1ZW5jZXMgPSBwYXJhbWV0ZXJzLnN0b3BTZXF1ZW5jZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udGVudENvbXBsZXhBcnJheVRvVGV4dChjb250ZW50QXJyYXkpIHtcbiAgICAgICAgbGV0IHJldCA9IFwiXCI7XG4gICAgICAgIGNvbnRlbnRBcnJheS5mb3JFYWNoKChjb250ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IGNvbnRlbnQ/LnR5cGU7XG4gICAgICAgICAgICBpZiAoY29udGVudFR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dENvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICAgICAgICAgIHJldCA9IGAke3JldH1cXG4ke3RleHRDb250ZW50LnRleHR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcm1hdFN5c3RlbShpbnB1dCkge1xuICAgICAgICBsZXQgcmV0ID0gXCJcIjtcbiAgICAgICAgaW5wdXQuZm9yRWFjaCgobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuX2dldFR5cGUoKSA9PT0gXCJzeXN0ZW1cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBtZXNzYWdlPy5jb250ZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRTdHJpbmcgPSB0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICA/IGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgOiBjb250ZW50Q29tcGxleEFycmF5VG9UZXh0KGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHJldCA9IGAke3JldH1cXG4ke2NvbnRlbnRTdHJpbmd9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcm1hdEdlbWluaVRvb2wodG9vbCkge1xuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bih0b29sLCBcImZ1bmN0aW9uRGVjbGFyYXRpb25zXCIpKSB7XG4gICAgICAgICAgICBjb25zdCBmdW5jcyA9IHRvb2w/LmZ1bmN0aW9uRGVjbGFyYXRpb25zID8/IFtdO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmNzLm1hcCgoZnVuYykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0U2NoZW1hID0gZnVuYy5wYXJhbWV0ZXJzO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHR5cGU6IFwidG9vbFwiLCAgLy8gVGhpcyBtYXkgb25seSBiZSB2YWxpZCBmb3IgbW9kZWxzIDIwMjQxMDIyK1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBmdW5jLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dF9zY2hlbWE6IGlucHV0U2NoZW1hLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5hYmxlIHRvIGZvcm1hdCBHZW1pbmlUb29sOiAke0pTT04uc3RyaW5naWZ5KHRvb2wsIG51bGwsIDEpfWApO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcm1hdFRvb2wodG9vbCkge1xuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bih0b29sLCBcIm5hbWVcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBbdG9vbF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0R2VtaW5pVG9vbCh0b29sKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JtYXRUb29scyhwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGNvbnN0IHRvb2xzID0gcGFyYW1ldGVycz8udG9vbHMgPz8gW107XG4gICAgICAgIGNvbnN0IHJldCA9IFtdO1xuICAgICAgICB0b29scy5mb3JFYWNoKCh0b29sKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhbnRocm9waWNUb29scyA9IGZvcm1hdFRvb2wodG9vbCk7XG4gICAgICAgICAgICBhbnRocm9waWNUb29scy5mb3JFYWNoKChhbnRocm9waWNUb29sKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFudGhyb3BpY1Rvb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goYW50aHJvcGljVG9vbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JtYXRUb29sQ2hvaWNlKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3QgY2hvaWNlID0gcGFyYW1ldGVycz8udG9vbF9jaG9pY2U7XG4gICAgICAgIGlmICghY2hvaWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaG9pY2UgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjaG9pY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNob2ljZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJhbnlcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiYXV0b1wiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogY2hvaWNlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhc2UgXCJub25lXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogY2hvaWNlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGZvcm1hdERhdGEoaW5wdXQsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3QgdHlwZWRJbnB1dCA9IGlucHV0O1xuICAgICAgICBjb25zdCBhbnRocm9waWNWZXJzaW9uID0gZm9ybWF0QW50aHJvcGljVmVyc2lvbigpO1xuICAgICAgICBjb25zdCBtZXNzYWdlcyA9IGZvcm1hdE1lc3NhZ2VzKHR5cGVkSW5wdXQpO1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGZvcm1hdFNldHRpbmdzKHBhcmFtZXRlcnMpO1xuICAgICAgICBjb25zdCBzeXN0ZW0gPSBmb3JtYXRTeXN0ZW0odHlwZWRJbnB1dCk7XG4gICAgICAgIGNvbnN0IHRvb2xzID0gZm9ybWF0VG9vbHMocGFyYW1ldGVycyk7XG4gICAgICAgIGNvbnN0IHRvb2xDaG9pY2UgPSBmb3JtYXRUb29sQ2hvaWNlKHBhcmFtZXRlcnMpO1xuICAgICAgICBjb25zdCByZXQgPSB7XG4gICAgICAgICAgICBhbnRocm9waWNfdmVyc2lvbjogYW50aHJvcGljVmVyc2lvbixcbiAgICAgICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICAgICAgLi4uc2V0dGluZ3MsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0b29scyAmJiB0b29scy5sZW5ndGggJiYgcGFyYW1ldGVycz8udG9vbF9jaG9pY2UgIT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICByZXQudG9vbHMgPSB0b29scztcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9vbENob2ljZSkge1xuICAgICAgICAgICAgcmV0LnRvb2xfY2hvaWNlID0gdG9vbENob2ljZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3lzdGVtPy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldC5zeXN0ZW0gPSBzeXN0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzcG9uc2VUb1N0cmluZyxcbiAgICAgICAgcmVzcG9uc2VUb0NoYXRHZW5lcmF0aW9uLFxuICAgICAgICBjaHVua1RvU3RyaW5nLFxuICAgICAgICByZXNwb25zZVRvQmFzZU1lc3NhZ2UsXG4gICAgICAgIHJlc3BvbnNlVG9DaGF0UmVzdWx0LFxuICAgICAgICBmb3JtYXREYXRhLFxuICAgIH07XG59XG5leHBvcnRzLmdldEFudGhyb3BpY0FQSSA9IGdldEFudGhyb3BpY0FQSTtcbmZ1bmN0aW9uIHZhbGlkYXRlQ2xhdWRlUGFyYW1zKF9wYXJhbXMpIHtcbiAgICAvLyBGSVhNRSAtIHZhbGlkYXRlIHRoZSBwYXJhbWV0ZXJzXG59XG5leHBvcnRzLnZhbGlkYXRlQ2xhdWRlUGFyYW1zID0gdmFsaWRhdGVDbGF1ZGVQYXJhbXM7XG5mdW5jdGlvbiBpc01vZGVsQ2xhdWRlKG1vZGVsTmFtZSkge1xuICAgIHJldHVybiBtb2RlbE5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwiY2xhdWRlXCIpO1xufVxuZXhwb3J0cy5pc01vZGVsQ2xhdWRlID0gaXNNb2RlbENsYXVkZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/utils/anthropic.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/utils/common.cjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/utils/common.cjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.copyAndValidateModelParamsInto = exports.validateModelParams = exports.modelToPublisher = exports.modelToFamily = exports.copyAIModelParamsInto = exports.convertToGeminiTools = exports.copyAIModelParams = void 0;\nconst base_1 = __webpack_require__(/*! @langchain/core/language_models/base */ \"(rsc)/./node_modules/@langchain/core/language_models/base.cjs\");\nconst function_calling_1 = __webpack_require__(/*! @langchain/core/utils/function_calling */ \"(rsc)/./node_modules/@langchain/core/utils/function_calling.cjs\");\nconst gemini_js_1 = __webpack_require__(/*! ./gemini.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/gemini.cjs\");\nconst types_js_1 = __webpack_require__(/*! ../types.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/types.cjs\");\nconst zod_to_gemini_parameters_js_1 = __webpack_require__(/*! ./zod_to_gemini_parameters.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/zod_to_gemini_parameters.cjs\");\nconst anthropic_js_1 = __webpack_require__(/*! ./anthropic.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/anthropic.cjs\");\nfunction copyAIModelParams(params, options) {\n    return copyAIModelParamsInto(params, options, {});\n}\nexports.copyAIModelParams = copyAIModelParams;\nfunction processToolChoice(toolChoice, allowedFunctionNames) {\n    if (!toolChoice) {\n        if (allowedFunctionNames) {\n            // Allowed func names is passed, return 'any' so it forces the model to use a tool.\n            return {\n                tool_choice: \"any\",\n                allowed_function_names: allowedFunctionNames,\n            };\n        }\n        return undefined;\n    }\n    if (toolChoice === \"any\" || toolChoice === \"auto\" || toolChoice === \"none\") {\n        return {\n            tool_choice: toolChoice,\n            allowed_function_names: allowedFunctionNames,\n        };\n    }\n    if (typeof toolChoice === \"string\") {\n        // String representing the function name.\n        // Return any to force the model to predict the specified function call.\n        return {\n            tool_choice: \"any\",\n            allowed_function_names: [...(allowedFunctionNames ?? []), toolChoice],\n        };\n    }\n    throw new Error(\"Object inputs for tool_choice not supported.\");\n}\nfunction isGeminiTool(tool) {\n    for (const toolAttribute of types_js_1.GeminiToolAttributes) {\n        if (toolAttribute in tool) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction isGeminiNonFunctionTool(tool) {\n    return isGeminiTool(tool) && !(\"functionDeclaration\" in tool);\n}\nfunction convertToGeminiTools(tools) {\n    const geminiTools = [];\n    let functionDeclarationsIndex = -1;\n    tools.forEach((tool) => {\n        if (isGeminiNonFunctionTool(tool)) {\n            geminiTools.push(tool);\n        }\n        else {\n            if (functionDeclarationsIndex === -1) {\n                geminiTools.push({\n                    functionDeclarations: [],\n                });\n                functionDeclarationsIndex = geminiTools.length - 1;\n            }\n            if (\"functionDeclarations\" in tool &&\n                Array.isArray(tool.functionDeclarations)) {\n                const funcs = tool.functionDeclarations;\n                geminiTools[functionDeclarationsIndex].functionDeclarations.push(...funcs);\n            }\n            else if ((0, function_calling_1.isLangChainTool)(tool)) {\n                const jsonSchema = (0, zod_to_gemini_parameters_js_1.zodToGeminiParameters)(tool.schema);\n                geminiTools[functionDeclarationsIndex].functionDeclarations.push({\n                    name: tool.name,\n                    description: tool.description ?? `A function available to call.`,\n                    parameters: jsonSchema,\n                });\n            }\n            else if ((0, base_1.isOpenAITool)(tool)) {\n                geminiTools[functionDeclarationsIndex].functionDeclarations.push({\n                    name: tool.function.name,\n                    description: tool.function.description ?? `A function available to call.`,\n                    parameters: (0, zod_to_gemini_parameters_js_1.jsonSchemaToGeminiParameters)(tool.function.parameters),\n                });\n            }\n            else {\n                throw new Error(`Received invalid tool: ${JSON.stringify(tool)}`);\n            }\n        }\n    });\n    return geminiTools;\n}\nexports.convertToGeminiTools = convertToGeminiTools;\nfunction copyAIModelParamsInto(params, options, target) {\n    const ret = target || {};\n    const model = options?.model ?? params?.model ?? target.model;\n    ret.modelName =\n        model ?? options?.modelName ?? params?.modelName ?? target.modelName;\n    ret.model = model;\n    ret.temperature =\n        options?.temperature ?? params?.temperature ?? target.temperature;\n    ret.maxOutputTokens =\n        options?.maxOutputTokens ??\n            params?.maxOutputTokens ??\n            target.maxOutputTokens;\n    ret.topP = options?.topP ?? params?.topP ?? target.topP;\n    ret.topK = options?.topK ?? params?.topK ?? target.topK;\n    ret.presencePenalty =\n        options?.presencePenalty ??\n            params?.presencePenalty ??\n            target.presencePenalty;\n    ret.frequencyPenalty =\n        options?.frequencyPenalty ??\n            params?.frequencyPenalty ??\n            target.frequencyPenalty;\n    ret.stopSequences =\n        options?.stopSequences ?? params?.stopSequences ?? target.stopSequences;\n    ret.safetySettings =\n        options?.safetySettings ?? params?.safetySettings ?? target.safetySettings;\n    ret.logprobs = options?.logprobs ?? params?.logprobs ?? target.logprobs;\n    ret.topLogprobs =\n        options?.topLogprobs ?? params?.topLogprobs ?? target.topLogprobs;\n    ret.convertSystemMessageToHumanContent =\n        options?.convertSystemMessageToHumanContent ??\n            params?.convertSystemMessageToHumanContent ??\n            target?.convertSystemMessageToHumanContent;\n    ret.responseMimeType =\n        options?.responseMimeType ??\n            params?.responseMimeType ??\n            target?.responseMimeType;\n    ret.streaming = options?.streaming ?? params?.streaming ?? target?.streaming;\n    const toolChoice = processToolChoice(options?.tool_choice, options?.allowed_function_names);\n    if (toolChoice) {\n        ret.tool_choice = toolChoice.tool_choice;\n        ret.allowed_function_names = toolChoice.allowed_function_names;\n    }\n    const tools = options?.tools;\n    if (tools) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ret.tools = convertToGeminiTools(tools);\n    }\n    return ret;\n}\nexports.copyAIModelParamsInto = copyAIModelParamsInto;\nfunction modelToFamily(modelName) {\n    if (!modelName) {\n        return null;\n    }\n    else if ((0, gemini_js_1.isModelGemini)(modelName)) {\n        return \"gemini\";\n    }\n    else if ((0, anthropic_js_1.isModelClaude)(modelName)) {\n        return \"claude\";\n    }\n    else {\n        return null;\n    }\n}\nexports.modelToFamily = modelToFamily;\nfunction modelToPublisher(modelName) {\n    const family = modelToFamily(modelName);\n    switch (family) {\n        case \"gemini\":\n        case \"palm\":\n            return \"google\";\n        case \"claude\":\n            return \"anthropic\";\n        default:\n            return \"unknown\";\n    }\n}\nexports.modelToPublisher = modelToPublisher;\nfunction validateModelParams(params) {\n    const testParams = params ?? {};\n    const model = testParams.model ?? testParams.modelName;\n    switch (modelToFamily(model)) {\n        case \"gemini\":\n            return (0, gemini_js_1.validateGeminiParams)(testParams);\n        case \"claude\":\n            return (0, anthropic_js_1.validateClaudeParams)(testParams);\n        default:\n            throw new Error(`Unable to verify model params: ${JSON.stringify(params)}`);\n    }\n}\nexports.validateModelParams = validateModelParams;\nfunction copyAndValidateModelParamsInto(params, target) {\n    copyAIModelParamsInto(params, undefined, target);\n    validateModelParams(target);\n    return target;\n}\nexports.copyAndValidateModelParamsInto = copyAndValidateModelParamsInto;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvY29tbW9uLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQ0FBc0MsR0FBRywyQkFBMkIsR0FBRyx3QkFBd0IsR0FBRyxxQkFBcUIsR0FBRyw2QkFBNkIsR0FBRyw0QkFBNEIsR0FBRyx5QkFBeUI7QUFDbE4sZUFBZSxtQkFBTyxDQUFDLDJHQUFzQztBQUM3RCwyQkFBMkIsbUJBQU8sQ0FBQywrR0FBd0M7QUFDM0Usb0JBQW9CLG1CQUFPLENBQUMseUZBQWM7QUFDMUMsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQWM7QUFDekMsc0NBQXNDLG1CQUFPLENBQUMsNkhBQWdDO0FBQzlFLHVCQUF1QixtQkFBTyxDQUFDLCtGQUFpQjtBQUNoRDtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDBEQUEwRCxxQkFBcUI7QUFDL0U7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHVCQUF1QjtBQUNyRjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vZGlzdC91dGlscy9jb21tb24uY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb3B5QW5kVmFsaWRhdGVNb2RlbFBhcmFtc0ludG8gPSBleHBvcnRzLnZhbGlkYXRlTW9kZWxQYXJhbXMgPSBleHBvcnRzLm1vZGVsVG9QdWJsaXNoZXIgPSBleHBvcnRzLm1vZGVsVG9GYW1pbHkgPSBleHBvcnRzLmNvcHlBSU1vZGVsUGFyYW1zSW50byA9IGV4cG9ydHMuY29udmVydFRvR2VtaW5pVG9vbHMgPSBleHBvcnRzLmNvcHlBSU1vZGVsUGFyYW1zID0gdm9pZCAwO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9sYW5ndWFnZV9tb2RlbHMvYmFzZVwiKTtcbmNvbnN0IGZ1bmN0aW9uX2NhbGxpbmdfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvdXRpbHMvZnVuY3Rpb25fY2FsbGluZ1wiKTtcbmNvbnN0IGdlbWluaV9qc18xID0gcmVxdWlyZShcIi4vZ2VtaW5pLmNqc1wiKTtcbmNvbnN0IHR5cGVzX2pzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXMuY2pzXCIpO1xuY29uc3Qgem9kX3RvX2dlbWluaV9wYXJhbWV0ZXJzX2pzXzEgPSByZXF1aXJlKFwiLi96b2RfdG9fZ2VtaW5pX3BhcmFtZXRlcnMuY2pzXCIpO1xuY29uc3QgYW50aHJvcGljX2pzXzEgPSByZXF1aXJlKFwiLi9hbnRocm9waWMuY2pzXCIpO1xuZnVuY3Rpb24gY29weUFJTW9kZWxQYXJhbXMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGNvcHlBSU1vZGVsUGFyYW1zSW50byhwYXJhbXMsIG9wdGlvbnMsIHt9KTtcbn1cbmV4cG9ydHMuY29weUFJTW9kZWxQYXJhbXMgPSBjb3B5QUlNb2RlbFBhcmFtcztcbmZ1bmN0aW9uIHByb2Nlc3NUb29sQ2hvaWNlKHRvb2xDaG9pY2UsIGFsbG93ZWRGdW5jdGlvbk5hbWVzKSB7XG4gICAgaWYgKCF0b29sQ2hvaWNlKSB7XG4gICAgICAgIGlmIChhbGxvd2VkRnVuY3Rpb25OYW1lcykge1xuICAgICAgICAgICAgLy8gQWxsb3dlZCBmdW5jIG5hbWVzIGlzIHBhc3NlZCwgcmV0dXJuICdhbnknIHNvIGl0IGZvcmNlcyB0aGUgbW9kZWwgdG8gdXNlIGEgdG9vbC5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9vbF9jaG9pY2U6IFwiYW55XCIsXG4gICAgICAgICAgICAgICAgYWxsb3dlZF9mdW5jdGlvbl9uYW1lczogYWxsb3dlZEZ1bmN0aW9uTmFtZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0b29sQ2hvaWNlID09PSBcImFueVwiIHx8IHRvb2xDaG9pY2UgPT09IFwiYXV0b1wiIHx8IHRvb2xDaG9pY2UgPT09IFwibm9uZVwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b29sX2Nob2ljZTogdG9vbENob2ljZSxcbiAgICAgICAgICAgIGFsbG93ZWRfZnVuY3Rpb25fbmFtZXM6IGFsbG93ZWRGdW5jdGlvbk5hbWVzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRvb2xDaG9pY2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgLy8gU3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZnVuY3Rpb24gbmFtZS5cbiAgICAgICAgLy8gUmV0dXJuIGFueSB0byBmb3JjZSB0aGUgbW9kZWwgdG8gcHJlZGljdCB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uIGNhbGwuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b29sX2Nob2ljZTogXCJhbnlcIixcbiAgICAgICAgICAgIGFsbG93ZWRfZnVuY3Rpb25fbmFtZXM6IFsuLi4oYWxsb3dlZEZ1bmN0aW9uTmFtZXMgPz8gW10pLCB0b29sQ2hvaWNlXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0IGlucHV0cyBmb3IgdG9vbF9jaG9pY2Ugbm90IHN1cHBvcnRlZC5cIik7XG59XG5mdW5jdGlvbiBpc0dlbWluaVRvb2wodG9vbCkge1xuICAgIGZvciAoY29uc3QgdG9vbEF0dHJpYnV0ZSBvZiB0eXBlc19qc18xLkdlbWluaVRvb2xBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmICh0b29sQXR0cmlidXRlIGluIHRvb2wpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzR2VtaW5pTm9uRnVuY3Rpb25Ub29sKHRvb2wpIHtcbiAgICByZXR1cm4gaXNHZW1pbmlUb29sKHRvb2wpICYmICEoXCJmdW5jdGlvbkRlY2xhcmF0aW9uXCIgaW4gdG9vbCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9HZW1pbmlUb29scyh0b29scykge1xuICAgIGNvbnN0IGdlbWluaVRvb2xzID0gW107XG4gICAgbGV0IGZ1bmN0aW9uRGVjbGFyYXRpb25zSW5kZXggPSAtMTtcbiAgICB0b29scy5mb3JFYWNoKCh0b29sKSA9PiB7XG4gICAgICAgIGlmIChpc0dlbWluaU5vbkZ1bmN0aW9uVG9vbCh0b29sKSkge1xuICAgICAgICAgICAgZ2VtaW5pVG9vbHMucHVzaCh0b29sKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmdW5jdGlvbkRlY2xhcmF0aW9uc0luZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGdlbWluaVRvb2xzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uczogW10sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbnNJbmRleCA9IGdlbWluaVRvb2xzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJmdW5jdGlvbkRlY2xhcmF0aW9uc1wiIGluIHRvb2wgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KHRvb2wuZnVuY3Rpb25EZWNsYXJhdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnVuY3MgPSB0b29sLmZ1bmN0aW9uRGVjbGFyYXRpb25zO1xuICAgICAgICAgICAgICAgIGdlbWluaVRvb2xzW2Z1bmN0aW9uRGVjbGFyYXRpb25zSW5kZXhdLmZ1bmN0aW9uRGVjbGFyYXRpb25zLnB1c2goLi4uZnVuY3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKDAsIGZ1bmN0aW9uX2NhbGxpbmdfMS5pc0xhbmdDaGFpblRvb2wpKHRvb2wpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QganNvblNjaGVtYSA9ICgwLCB6b2RfdG9fZ2VtaW5pX3BhcmFtZXRlcnNfanNfMS56b2RUb0dlbWluaVBhcmFtZXRlcnMpKHRvb2wuc2NoZW1hKTtcbiAgICAgICAgICAgICAgICBnZW1pbmlUb29sc1tmdW5jdGlvbkRlY2xhcmF0aW9uc0luZGV4XS5mdW5jdGlvbkRlY2xhcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdG9vbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogdG9vbC5kZXNjcmlwdGlvbiA/PyBgQSBmdW5jdGlvbiBhdmFpbGFibGUgdG8gY2FsbC5gLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBqc29uU2NoZW1hLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKDAsIGJhc2VfMS5pc09wZW5BSVRvb2wpKHRvb2wpKSB7XG4gICAgICAgICAgICAgICAgZ2VtaW5pVG9vbHNbZnVuY3Rpb25EZWNsYXJhdGlvbnNJbmRleF0uZnVuY3Rpb25EZWNsYXJhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRvb2wuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHRvb2wuZnVuY3Rpb24uZGVzY3JpcHRpb24gPz8gYEEgZnVuY3Rpb24gYXZhaWxhYmxlIHRvIGNhbGwuYCxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyczogKDAsIHpvZF90b19nZW1pbmlfcGFyYW1ldGVyc19qc18xLmpzb25TY2hlbWFUb0dlbWluaVBhcmFtZXRlcnMpKHRvb2wuZnVuY3Rpb24ucGFyYW1ldGVycyksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlY2VpdmVkIGludmFsaWQgdG9vbDogJHtKU09OLnN0cmluZ2lmeSh0b29sKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBnZW1pbmlUb29scztcbn1cbmV4cG9ydHMuY29udmVydFRvR2VtaW5pVG9vbHMgPSBjb252ZXJ0VG9HZW1pbmlUb29scztcbmZ1bmN0aW9uIGNvcHlBSU1vZGVsUGFyYW1zSW50byhwYXJhbXMsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgIGNvbnN0IHJldCA9IHRhcmdldCB8fCB7fTtcbiAgICBjb25zdCBtb2RlbCA9IG9wdGlvbnM/Lm1vZGVsID8/IHBhcmFtcz8ubW9kZWwgPz8gdGFyZ2V0Lm1vZGVsO1xuICAgIHJldC5tb2RlbE5hbWUgPVxuICAgICAgICBtb2RlbCA/PyBvcHRpb25zPy5tb2RlbE5hbWUgPz8gcGFyYW1zPy5tb2RlbE5hbWUgPz8gdGFyZ2V0Lm1vZGVsTmFtZTtcbiAgICByZXQubW9kZWwgPSBtb2RlbDtcbiAgICByZXQudGVtcGVyYXR1cmUgPVxuICAgICAgICBvcHRpb25zPy50ZW1wZXJhdHVyZSA/PyBwYXJhbXM/LnRlbXBlcmF0dXJlID8/IHRhcmdldC50ZW1wZXJhdHVyZTtcbiAgICByZXQubWF4T3V0cHV0VG9rZW5zID1cbiAgICAgICAgb3B0aW9ucz8ubWF4T3V0cHV0VG9rZW5zID8/XG4gICAgICAgICAgICBwYXJhbXM/Lm1heE91dHB1dFRva2VucyA/P1xuICAgICAgICAgICAgdGFyZ2V0Lm1heE91dHB1dFRva2VucztcbiAgICByZXQudG9wUCA9IG9wdGlvbnM/LnRvcFAgPz8gcGFyYW1zPy50b3BQID8/IHRhcmdldC50b3BQO1xuICAgIHJldC50b3BLID0gb3B0aW9ucz8udG9wSyA/PyBwYXJhbXM/LnRvcEsgPz8gdGFyZ2V0LnRvcEs7XG4gICAgcmV0LnByZXNlbmNlUGVuYWx0eSA9XG4gICAgICAgIG9wdGlvbnM/LnByZXNlbmNlUGVuYWx0eSA/P1xuICAgICAgICAgICAgcGFyYW1zPy5wcmVzZW5jZVBlbmFsdHkgPz9cbiAgICAgICAgICAgIHRhcmdldC5wcmVzZW5jZVBlbmFsdHk7XG4gICAgcmV0LmZyZXF1ZW5jeVBlbmFsdHkgPVxuICAgICAgICBvcHRpb25zPy5mcmVxdWVuY3lQZW5hbHR5ID8/XG4gICAgICAgICAgICBwYXJhbXM/LmZyZXF1ZW5jeVBlbmFsdHkgPz9cbiAgICAgICAgICAgIHRhcmdldC5mcmVxdWVuY3lQZW5hbHR5O1xuICAgIHJldC5zdG9wU2VxdWVuY2VzID1cbiAgICAgICAgb3B0aW9ucz8uc3RvcFNlcXVlbmNlcyA/PyBwYXJhbXM/LnN0b3BTZXF1ZW5jZXMgPz8gdGFyZ2V0LnN0b3BTZXF1ZW5jZXM7XG4gICAgcmV0LnNhZmV0eVNldHRpbmdzID1cbiAgICAgICAgb3B0aW9ucz8uc2FmZXR5U2V0dGluZ3MgPz8gcGFyYW1zPy5zYWZldHlTZXR0aW5ncyA/PyB0YXJnZXQuc2FmZXR5U2V0dGluZ3M7XG4gICAgcmV0LmxvZ3Byb2JzID0gb3B0aW9ucz8ubG9ncHJvYnMgPz8gcGFyYW1zPy5sb2dwcm9icyA/PyB0YXJnZXQubG9ncHJvYnM7XG4gICAgcmV0LnRvcExvZ3Byb2JzID1cbiAgICAgICAgb3B0aW9ucz8udG9wTG9ncHJvYnMgPz8gcGFyYW1zPy50b3BMb2dwcm9icyA/PyB0YXJnZXQudG9wTG9ncHJvYnM7XG4gICAgcmV0LmNvbnZlcnRTeXN0ZW1NZXNzYWdlVG9IdW1hbkNvbnRlbnQgPVxuICAgICAgICBvcHRpb25zPy5jb252ZXJ0U3lzdGVtTWVzc2FnZVRvSHVtYW5Db250ZW50ID8/XG4gICAgICAgICAgICBwYXJhbXM/LmNvbnZlcnRTeXN0ZW1NZXNzYWdlVG9IdW1hbkNvbnRlbnQgPz9cbiAgICAgICAgICAgIHRhcmdldD8uY29udmVydFN5c3RlbU1lc3NhZ2VUb0h1bWFuQ29udGVudDtcbiAgICByZXQucmVzcG9uc2VNaW1lVHlwZSA9XG4gICAgICAgIG9wdGlvbnM/LnJlc3BvbnNlTWltZVR5cGUgPz9cbiAgICAgICAgICAgIHBhcmFtcz8ucmVzcG9uc2VNaW1lVHlwZSA/P1xuICAgICAgICAgICAgdGFyZ2V0Py5yZXNwb25zZU1pbWVUeXBlO1xuICAgIHJldC5zdHJlYW1pbmcgPSBvcHRpb25zPy5zdHJlYW1pbmcgPz8gcGFyYW1zPy5zdHJlYW1pbmcgPz8gdGFyZ2V0Py5zdHJlYW1pbmc7XG4gICAgY29uc3QgdG9vbENob2ljZSA9IHByb2Nlc3NUb29sQ2hvaWNlKG9wdGlvbnM/LnRvb2xfY2hvaWNlLCBvcHRpb25zPy5hbGxvd2VkX2Z1bmN0aW9uX25hbWVzKTtcbiAgICBpZiAodG9vbENob2ljZSkge1xuICAgICAgICByZXQudG9vbF9jaG9pY2UgPSB0b29sQ2hvaWNlLnRvb2xfY2hvaWNlO1xuICAgICAgICByZXQuYWxsb3dlZF9mdW5jdGlvbl9uYW1lcyA9IHRvb2xDaG9pY2UuYWxsb3dlZF9mdW5jdGlvbl9uYW1lcztcbiAgICB9XG4gICAgY29uc3QgdG9vbHMgPSBvcHRpb25zPy50b29scztcbiAgICBpZiAodG9vbHMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0LnRvb2xzID0gY29udmVydFRvR2VtaW5pVG9vbHModG9vbHMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuZXhwb3J0cy5jb3B5QUlNb2RlbFBhcmFtc0ludG8gPSBjb3B5QUlNb2RlbFBhcmFtc0ludG87XG5mdW5jdGlvbiBtb2RlbFRvRmFtaWx5KG1vZGVsTmFtZSkge1xuICAgIGlmICghbW9kZWxOYW1lKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgZ2VtaW5pX2pzXzEuaXNNb2RlbEdlbWluaSkobW9kZWxOYW1lKSkge1xuICAgICAgICByZXR1cm4gXCJnZW1pbmlcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIGFudGhyb3BpY19qc18xLmlzTW9kZWxDbGF1ZGUpKG1vZGVsTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiY2xhdWRlXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLm1vZGVsVG9GYW1pbHkgPSBtb2RlbFRvRmFtaWx5O1xuZnVuY3Rpb24gbW9kZWxUb1B1Ymxpc2hlcihtb2RlbE5hbWUpIHtcbiAgICBjb25zdCBmYW1pbHkgPSBtb2RlbFRvRmFtaWx5KG1vZGVsTmFtZSk7XG4gICAgc3dpdGNoIChmYW1pbHkpIHtcbiAgICAgICAgY2FzZSBcImdlbWluaVwiOlxuICAgICAgICBjYXNlIFwicGFsbVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZ29vZ2xlXCI7XG4gICAgICAgIGNhc2UgXCJjbGF1ZGVcIjpcbiAgICAgICAgICAgIHJldHVybiBcImFudGhyb3BpY1wiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwidW5rbm93blwiO1xuICAgIH1cbn1cbmV4cG9ydHMubW9kZWxUb1B1Ymxpc2hlciA9IG1vZGVsVG9QdWJsaXNoZXI7XG5mdW5jdGlvbiB2YWxpZGF0ZU1vZGVsUGFyYW1zKHBhcmFtcykge1xuICAgIGNvbnN0IHRlc3RQYXJhbXMgPSBwYXJhbXMgPz8ge307XG4gICAgY29uc3QgbW9kZWwgPSB0ZXN0UGFyYW1zLm1vZGVsID8/IHRlc3RQYXJhbXMubW9kZWxOYW1lO1xuICAgIHN3aXRjaCAobW9kZWxUb0ZhbWlseShtb2RlbCkpIHtcbiAgICAgICAgY2FzZSBcImdlbWluaVwiOlxuICAgICAgICAgICAgcmV0dXJuICgwLCBnZW1pbmlfanNfMS52YWxpZGF0ZUdlbWluaVBhcmFtcykodGVzdFBhcmFtcyk7XG4gICAgICAgIGNhc2UgXCJjbGF1ZGVcIjpcbiAgICAgICAgICAgIHJldHVybiAoMCwgYW50aHJvcGljX2pzXzEudmFsaWRhdGVDbGF1ZGVQYXJhbXMpKHRlc3RQYXJhbXMpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gdmVyaWZ5IG1vZGVsIHBhcmFtczogJHtKU09OLnN0cmluZ2lmeShwYXJhbXMpfWApO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVNb2RlbFBhcmFtcyA9IHZhbGlkYXRlTW9kZWxQYXJhbXM7XG5mdW5jdGlvbiBjb3B5QW5kVmFsaWRhdGVNb2RlbFBhcmFtc0ludG8ocGFyYW1zLCB0YXJnZXQpIHtcbiAgICBjb3B5QUlNb2RlbFBhcmFtc0ludG8ocGFyYW1zLCB1bmRlZmluZWQsIHRhcmdldCk7XG4gICAgdmFsaWRhdGVNb2RlbFBhcmFtcyh0YXJnZXQpO1xuICAgIHJldHVybiB0YXJnZXQ7XG59XG5leHBvcnRzLmNvcHlBbmRWYWxpZGF0ZU1vZGVsUGFyYW1zSW50byA9IGNvcHlBbmRWYWxpZGF0ZU1vZGVsUGFyYW1zSW50bztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/utils/common.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/utils/failed_handler.cjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/utils/failed_handler.cjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ensureParams = exports.failedAttemptHandler = void 0;\nconst STATUS_NO_RETRY = [\n    400,\n    401,\n    402,\n    403,\n    404,\n    405,\n    406,\n    407,\n    408,\n    409, // Conflict\n];\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction failedAttemptHandler(error) {\n    const status = error?.response?.status ?? 0;\n    if (status === 0) {\n        // What is this?\n        console.error(\"failedAttemptHandler\", error);\n        throw error;\n    }\n    // What errors shouldn't be retried?\n    if (STATUS_NO_RETRY.includes(+status)) {\n        throw error;\n    }\n}\nexports.failedAttemptHandler = failedAttemptHandler;\nfunction ensureParams(params) {\n    const base = params ?? {};\n    return {\n        onFailedAttempt: failedAttemptHandler,\n        ...base,\n    };\n}\nexports.ensureParams = ensureParams;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvZmFpbGVkX2hhbmRsZXIuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9kaXN0L3V0aWxzL2ZhaWxlZF9oYW5kbGVyLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5zdXJlUGFyYW1zID0gZXhwb3J0cy5mYWlsZWRBdHRlbXB0SGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IFNUQVRVU19OT19SRVRSWSA9IFtcbiAgICA0MDAsXG4gICAgNDAxLFxuICAgIDQwMixcbiAgICA0MDMsXG4gICAgNDA0LFxuICAgIDQwNSxcbiAgICA0MDYsXG4gICAgNDA3LFxuICAgIDQwOCxcbiAgICA0MDksIC8vIENvbmZsaWN0XG5dO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGZhaWxlZEF0dGVtcHRIYW5kbGVyKGVycm9yKSB7XG4gICAgY29uc3Qgc3RhdHVzID0gZXJyb3I/LnJlc3BvbnNlPy5zdGF0dXMgPz8gMDtcbiAgICBpZiAoc3RhdHVzID09PSAwKSB7XG4gICAgICAgIC8vIFdoYXQgaXMgdGhpcz9cbiAgICAgICAgY29uc29sZS5lcnJvcihcImZhaWxlZEF0dGVtcHRIYW5kbGVyXCIsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIC8vIFdoYXQgZXJyb3JzIHNob3VsZG4ndCBiZSByZXRyaWVkP1xuICAgIGlmIChTVEFUVVNfTk9fUkVUUlkuaW5jbHVkZXMoK3N0YXR1cykpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5mYWlsZWRBdHRlbXB0SGFuZGxlciA9IGZhaWxlZEF0dGVtcHRIYW5kbGVyO1xuZnVuY3Rpb24gZW5zdXJlUGFyYW1zKHBhcmFtcykge1xuICAgIGNvbnN0IGJhc2UgPSBwYXJhbXMgPz8ge307XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb25GYWlsZWRBdHRlbXB0OiBmYWlsZWRBdHRlbXB0SGFuZGxlcixcbiAgICAgICAgLi4uYmFzZSxcbiAgICB9O1xufVxuZXhwb3J0cy5lbnN1cmVQYXJhbXMgPSBlbnN1cmVQYXJhbXM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/utils/failed_handler.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/utils/gemini.cjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/utils/gemini.cjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isModelGemini = exports.validateGeminiParams = exports.getGeminiAPI = exports.MessageGeminiSafetyHandler = exports.DefaultGeminiSafetyHandler = void 0;\nconst uuid_1 = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/index.js\");\nconst messages_1 = __webpack_require__(/*! @langchain/core/messages */ \"(rsc)/./node_modules/@langchain/core/messages.cjs\");\nconst outputs_1 = __webpack_require__(/*! @langchain/core/outputs */ \"(rsc)/./node_modules/@langchain/core/outputs.cjs\");\nconst function_calling_1 = __webpack_require__(/*! @langchain/core/utils/function_calling */ \"(rsc)/./node_modules/@langchain/core/utils/function_calling.cjs\");\nconst safety_js_1 = __webpack_require__(/*! ./safety.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/safety.cjs\");\nconst types_js_1 = __webpack_require__(/*! ../types.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/types.cjs\");\nconst zod_to_gemini_parameters_js_1 = __webpack_require__(/*! ./zod_to_gemini_parameters.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/zod_to_gemini_parameters.cjs\");\nclass DefaultGeminiSafetyHandler {\n    constructor(settings) {\n        Object.defineProperty(this, \"errorFinish\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"SAFETY\", \"RECITATION\", \"OTHER\"]\n        });\n        this.errorFinish = settings?.errorFinish ?? this.errorFinish;\n    }\n    handleDataPromptFeedback(response, data) {\n        // Check to see if our prompt was blocked in the first place\n        const promptFeedback = data?.promptFeedback;\n        const blockReason = promptFeedback?.blockReason;\n        if (blockReason) {\n            throw new safety_js_1.GoogleAISafetyError(response, `Prompt blocked: ${blockReason}`);\n        }\n        return data;\n    }\n    handleDataFinishReason(response, data) {\n        const firstCandidate = data?.candidates?.[0];\n        const finishReason = firstCandidate?.finishReason;\n        if (this.errorFinish.includes(finishReason)) {\n            throw new safety_js_1.GoogleAISafetyError(response, `Finish reason: ${finishReason}`);\n        }\n        return data;\n    }\n    handleData(response, data) {\n        let ret = data;\n        ret = this.handleDataPromptFeedback(response, ret);\n        ret = this.handleDataFinishReason(response, ret);\n        return ret;\n    }\n    handle(response) {\n        let newdata;\n        if (\"nextChunk\" in response.data) {\n            // TODO: This is a stream. How to handle?\n            newdata = response.data;\n        }\n        else if (Array.isArray(response.data)) {\n            // If it is an array, try to handle every item in the array\n            try {\n                newdata = response.data.map((item) => this.handleData(response, item));\n            }\n            catch (xx) {\n                // eslint-disable-next-line no-instanceof/no-instanceof\n                if (xx instanceof safety_js_1.GoogleAISafetyError) {\n                    throw new safety_js_1.GoogleAISafetyError(response, xx.message);\n                }\n                else {\n                    throw xx;\n                }\n            }\n        }\n        else {\n            const data = response.data;\n            newdata = this.handleData(response, data);\n        }\n        return {\n            ...response,\n            data: newdata,\n        };\n    }\n}\nexports.DefaultGeminiSafetyHandler = DefaultGeminiSafetyHandler;\nclass MessageGeminiSafetyHandler extends DefaultGeminiSafetyHandler {\n    constructor(settings) {\n        super(settings);\n        Object.defineProperty(this, \"msg\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"\"\n        });\n        Object.defineProperty(this, \"forceNewMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        this.msg = settings?.msg ?? this.msg;\n        this.forceNewMessage = settings?.forceNewMessage ?? this.forceNewMessage;\n    }\n    setMessage(data) {\n        const ret = data;\n        if (this.forceNewMessage ||\n            !data?.candidates?.[0]?.content?.parts?.length) {\n            ret.candidates = data.candidates ?? [];\n            ret.candidates[0] = data.candidates[0] ?? {};\n            ret.candidates[0].content = data.candidates[0].content ?? {};\n            ret.candidates[0].content = {\n                role: \"model\",\n                parts: [{ text: this.msg }],\n            };\n        }\n        return ret;\n    }\n    handleData(response, data) {\n        try {\n            return super.handleData(response, data);\n        }\n        catch (xx) {\n            return this.setMessage(data);\n        }\n    }\n}\nexports.MessageGeminiSafetyHandler = MessageGeminiSafetyHandler;\nconst extractMimeType = (str) => {\n    if (str.startsWith(\"data:\")) {\n        return {\n            mimeType: str.split(\":\")[1].split(\";\")[0],\n            data: str.split(\",\")[1],\n        };\n    }\n    return null;\n};\nfunction getGeminiAPI(config) {\n    function messageContentText(content) {\n        if (content?.text && content?.text.length > 0) {\n            return {\n                text: content.text,\n            };\n        }\n        else {\n            return null;\n        }\n    }\n    function messageContentImageUrl(content) {\n        const url = typeof content.image_url === \"string\"\n            ? content.image_url\n            : content.image_url.url;\n        if (!url) {\n            throw new Error(\"Missing Image URL\");\n        }\n        const mimeTypeAndData = extractMimeType(url);\n        if (mimeTypeAndData) {\n            return {\n                inlineData: mimeTypeAndData,\n            };\n        }\n        else {\n            // FIXME - need some way to get mime type\n            return {\n                fileData: {\n                    mimeType: \"image/png\",\n                    fileUri: url,\n                },\n            };\n        }\n    }\n    async function blobToFileData(blob) {\n        return {\n            fileData: {\n                fileUri: blob.path,\n                mimeType: blob.mimetype,\n            },\n        };\n    }\n    async function fileUriContentToBlob(uri) {\n        return config?.mediaManager?.getMediaBlob(uri);\n    }\n    async function messageContentMedia(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    content) {\n        if (\"mimeType\" in content && \"data\" in content) {\n            return {\n                inlineData: {\n                    mimeType: content.mimeType,\n                    data: content.data,\n                },\n            };\n        }\n        else if (\"mimeType\" in content && \"fileUri\" in content) {\n            return {\n                fileData: {\n                    mimeType: content.mimeType,\n                    fileUri: content.fileUri,\n                },\n            };\n        }\n        else {\n            const uri = content.fileUri;\n            const blob = await fileUriContentToBlob(uri);\n            if (blob) {\n                return await blobToFileData(blob);\n            }\n        }\n        throw new Error(`Invalid media content: ${JSON.stringify(content, null, 1)}`);\n    }\n    async function messageContentComplexToPart(content) {\n        switch (content.type) {\n            case \"text\":\n                if (\"text\" in content) {\n                    return messageContentText(content);\n                }\n                break;\n            case \"image_url\":\n                if (\"image_url\" in content) {\n                    // Type guard for MessageContentImageUrl\n                    return messageContentImageUrl(content);\n                }\n                break;\n            case \"media\":\n                return await messageContentMedia(content);\n            default:\n                throw new Error(`Unsupported type \"${content.type}\" received while converting message to message parts: ${content}`);\n        }\n        throw new Error(`Cannot coerce \"${content.type}\" message part into a string.`);\n    }\n    async function messageContentComplexToParts(content) {\n        const contents = content.map(messageContentComplexToPart);\n        return Promise.all(contents);\n    }\n    async function messageContentToParts(content) {\n        // Convert a string to a text type MessageContent if needed\n        const messageContent = typeof content === \"string\"\n            ? [\n                {\n                    type: \"text\",\n                    text: content,\n                },\n            ]\n            : content;\n        // Get all of the parts, even those that don't correctly resolve\n        const allParts = await messageContentComplexToParts(messageContent);\n        // Remove any invalid parts\n        const parts = allParts.reduce((acc, val) => {\n            if (val) {\n                return [...acc, val];\n            }\n            else {\n                return acc;\n            }\n        }, []);\n        return parts;\n    }\n    function messageToolCallsToParts(toolCalls) {\n        if (!toolCalls || toolCalls.length === 0) {\n            return [];\n        }\n        return toolCalls.map((tool) => {\n            let args = {};\n            if (tool?.function?.arguments) {\n                const argStr = tool.function.arguments;\n                args = JSON.parse(argStr);\n            }\n            return {\n                functionCall: {\n                    name: tool.function.name,\n                    args,\n                },\n            };\n        });\n    }\n    function messageKwargsToParts(kwargs) {\n        const ret = [];\n        if (kwargs?.tool_calls) {\n            ret.push(...messageToolCallsToParts(kwargs.tool_calls));\n        }\n        return ret;\n    }\n    async function roleMessageToContent(role, message) {\n        const contentParts = await messageContentToParts(message.content);\n        let toolParts;\n        if ((0, messages_1.isAIMessage)(message) && !!message.tool_calls?.length) {\n            toolParts = message.tool_calls.map((toolCall) => ({\n                functionCall: {\n                    name: toolCall.name,\n                    args: toolCall.args,\n                },\n            }));\n        }\n        else {\n            toolParts = messageKwargsToParts(message.additional_kwargs);\n        }\n        const parts = [...contentParts, ...toolParts];\n        return [\n            {\n                role,\n                parts,\n            },\n        ];\n    }\n    async function systemMessageToContent(message) {\n        return config?.useSystemInstruction\n            ? roleMessageToContent(\"system\", message)\n            : [\n                ...(await roleMessageToContent(\"user\", message)),\n                ...(await roleMessageToContent(\"model\", new messages_1.AIMessage(\"Ok\"))),\n            ];\n    }\n    function toolMessageToContent(message, prevMessage) {\n        const contentStr = typeof message.content === \"string\"\n            ? message.content\n            : message.content.reduce((acc, content) => {\n                if (content.type === \"text\") {\n                    return acc + content.text;\n                }\n                else {\n                    return acc;\n                }\n            }, \"\");\n        // Hacky :(\n        const responseName = ((0, messages_1.isAIMessage)(prevMessage) && !!prevMessage.tool_calls?.length\n            ? prevMessage.tool_calls[0].name\n            : prevMessage.name) ?? message.tool_call_id;\n        try {\n            const content = JSON.parse(contentStr);\n            return [\n                {\n                    role: \"function\",\n                    parts: [\n                        {\n                            functionResponse: {\n                                name: responseName,\n                                response: { content },\n                            },\n                        },\n                    ],\n                },\n            ];\n        }\n        catch (_) {\n            return [\n                {\n                    role: \"function\",\n                    parts: [\n                        {\n                            functionResponse: {\n                                name: responseName,\n                                response: { content: contentStr },\n                            },\n                        },\n                    ],\n                },\n            ];\n        }\n    }\n    async function baseMessageToContent(message, prevMessage) {\n        const type = message._getType();\n        switch (type) {\n            case \"system\":\n                return systemMessageToContent(message);\n            case \"human\":\n                return roleMessageToContent(\"user\", message);\n            case \"ai\":\n                return roleMessageToContent(\"model\", message);\n            case \"tool\":\n                if (!prevMessage) {\n                    throw new Error(\"Tool messages cannot be the first message passed to the model.\");\n                }\n                return toolMessageToContent(message, prevMessage);\n            default:\n                console.log(`Unsupported message type: ${type}`);\n                return [];\n        }\n    }\n    function textPartToMessageContent(part) {\n        return {\n            type: \"text\",\n            text: part.text,\n        };\n    }\n    function inlineDataPartToMessageContent(part) {\n        return {\n            type: \"image_url\",\n            image_url: `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`,\n        };\n    }\n    function fileDataPartToMessageContent(part) {\n        return {\n            type: \"image_url\",\n            image_url: part.fileData.fileUri,\n        };\n    }\n    function partsToMessageContent(parts) {\n        return parts\n            .map((part) => {\n            if (part === undefined || part === null) {\n                return null;\n            }\n            else if (\"text\" in part) {\n                return textPartToMessageContent(part);\n            }\n            else if (\"inlineData\" in part) {\n                return inlineDataPartToMessageContent(part);\n            }\n            else if (\"fileData\" in part) {\n                return fileDataPartToMessageContent(part);\n            }\n            else {\n                return null;\n            }\n        })\n            .reduce((acc, content) => {\n            if (content) {\n                acc.push(content);\n            }\n            return acc;\n        }, []);\n    }\n    function toolRawToTool(raw) {\n        return {\n            id: raw.id,\n            type: raw.type,\n            function: {\n                name: raw.function.name,\n                arguments: JSON.stringify(raw.function.arguments),\n            },\n        };\n    }\n    function functionCallPartToToolRaw(part) {\n        return {\n            id: (0, uuid_1.v4)().replace(/-/g, \"\"),\n            type: \"function\",\n            function: {\n                name: part.functionCall.name,\n                arguments: part.functionCall.args ?? {},\n            },\n        };\n    }\n    function partsToToolsRaw(parts) {\n        return parts\n            .map((part) => {\n            if (part === undefined || part === null) {\n                return null;\n            }\n            else if (\"functionCall\" in part) {\n                return functionCallPartToToolRaw(part);\n            }\n            else {\n                return null;\n            }\n        })\n            .reduce((acc, content) => {\n            if (content) {\n                acc.push(content);\n            }\n            return acc;\n        }, []);\n    }\n    function toolsRawToTools(raws) {\n        return raws.map((raw) => toolRawToTool(raw));\n    }\n    function responseToGenerateContentResponseData(response) {\n        if (\"nextChunk\" in response.data) {\n            throw new Error(\"Cannot convert Stream to GenerateContentResponseData\");\n        }\n        else if (Array.isArray(response.data)) {\n            // Collapse the array of response data as if it was a single one\n            return response.data.reduce((acc, val) => {\n                // Add all the parts\n                // FIXME: Handle other candidates?\n                const valParts = val?.candidates?.[0]?.content?.parts ?? [];\n                acc.candidates[0].content.parts.push(...valParts);\n                // FIXME: Merge promptFeedback and safety settings\n                acc.promptFeedback = val.promptFeedback;\n                return acc;\n            });\n        }\n        else {\n            return response.data;\n        }\n    }\n    function responseToParts(response) {\n        const responseData = responseToGenerateContentResponseData(response);\n        const parts = responseData?.candidates?.[0]?.content?.parts ?? [];\n        return parts;\n    }\n    function partToText(part) {\n        return \"text\" in part ? part.text : \"\";\n    }\n    function responseToString(response) {\n        const parts = responseToParts(response);\n        const ret = parts.reduce((acc, part) => {\n            const val = partToText(part);\n            return acc + val;\n        }, \"\");\n        return ret;\n    }\n    function safeResponseTo(response, responseTo) {\n        const safetyHandler = config?.safetyHandler ?? new DefaultGeminiSafetyHandler();\n        try {\n            const safeResponse = safetyHandler.handle(response);\n            return responseTo(safeResponse);\n        }\n        catch (xx) {\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (xx instanceof safety_js_1.GoogleAISafetyError) {\n                const ret = responseTo(xx.response);\n                xx.reply = ret;\n            }\n            throw xx;\n        }\n    }\n    function safeResponseToString(response) {\n        return safeResponseTo(response, responseToString);\n    }\n    function logprobResultToLogprob(result) {\n        const token = result?.token;\n        const logprob = result?.logProbability;\n        const encoder = new TextEncoder();\n        const bytes = Array.from(encoder.encode(token));\n        return {\n            token,\n            logprob,\n            bytes,\n        };\n    }\n    function candidateToLogprobs(candidate) {\n        const logprobs = candidate?.logprobsResult;\n        const chosenTokens = logprobs?.chosenCandidates ?? [];\n        const topTokens = logprobs?.topCandidates ?? [];\n        const content = [];\n        for (let co = 0; co < chosenTokens.length; co += 1) {\n            const chosen = chosenTokens[co];\n            const top = topTokens[co]?.candidates ?? [];\n            const logprob = logprobResultToLogprob(chosen);\n            logprob.top_logprobs = top.map((l) => logprobResultToLogprob(l));\n            content.push(logprob);\n        }\n        return {\n            content,\n        };\n    }\n    function responseToGenerationInfo(response) {\n        if (!Array.isArray(response.data)) {\n            return {};\n        }\n        const data = response.data[0];\n        return {\n            usage_metadata: {\n                prompt_token_count: data.usageMetadata?.promptTokenCount,\n                candidates_token_count: data.usageMetadata?.candidatesTokenCount,\n                total_token_count: data.usageMetadata?.totalTokenCount,\n            },\n            safety_ratings: data.candidates[0]?.safetyRatings?.map((rating) => ({\n                category: rating.category,\n                probability: rating.probability,\n                probability_score: rating.probabilityScore,\n                severity: rating.severity,\n                severity_score: rating.severityScore,\n            })),\n            citation_metadata: data.candidates[0]?.citationMetadata,\n            grounding_metadata: data.candidates[0]?.groundingMetadata,\n            finish_reason: data.candidates[0]?.finishReason,\n            avgLogprobs: data.candidates[0]?.avgLogprobs,\n            logprobs: candidateToLogprobs(data.candidates[0]),\n        };\n    }\n    function responseToChatGeneration(response) {\n        return new outputs_1.ChatGenerationChunk({\n            text: responseToString(response),\n            message: partToMessageChunk(responseToParts(response)[0]),\n            generationInfo: responseToGenerationInfo(response),\n        });\n    }\n    function safeResponseToChatGeneration(response) {\n        return safeResponseTo(response, responseToChatGeneration);\n    }\n    function chunkToString(chunk) {\n        if (chunk === null) {\n            return \"\";\n        }\n        else if (typeof chunk.content === \"string\") {\n            return chunk.content;\n        }\n        else if (chunk.content.length === 0) {\n            return \"\";\n        }\n        else if (chunk.content[0].type === \"text\") {\n            return chunk.content[0].text;\n        }\n        else {\n            throw new Error(`Unexpected chunk: ${chunk}`);\n        }\n    }\n    function partToMessageChunk(part) {\n        const fields = partsToBaseMessageChunkFields([part]);\n        if (typeof fields.content === \"string\") {\n            return new messages_1.AIMessageChunk(fields);\n        }\n        else if (fields.content.every((item) => item.type === \"text\")) {\n            const newContent = fields.content\n                .map((item) => (\"text\" in item ? item.text : \"\"))\n                .join(\"\");\n            return new messages_1.AIMessageChunk({\n                ...fields,\n                content: newContent,\n            });\n        }\n        return new messages_1.AIMessageChunk(fields);\n    }\n    function partToChatGeneration(part) {\n        const message = partToMessageChunk(part);\n        const text = partToText(part);\n        return new outputs_1.ChatGenerationChunk({\n            text,\n            message,\n        });\n    }\n    function groundingSupportByPart(groundingSupports) {\n        const ret = [];\n        if (!groundingSupports || groundingSupports.length === 0) {\n            return [];\n        }\n        groundingSupports?.forEach((groundingSupport) => {\n            const segment = groundingSupport?.segment;\n            const partIndex = segment?.partIndex ?? 0;\n            if (ret[partIndex]) {\n                ret[partIndex].push(groundingSupport);\n            }\n            else {\n                ret[partIndex] = [groundingSupport];\n            }\n        });\n        return ret;\n    }\n    function responseToGroundedChatGenerations(response) {\n        const parts = responseToParts(response);\n        if (parts.length === 0) {\n            return [];\n        }\n        // Citation and grounding information connected to each part / ChatGeneration\n        // to make sure they are available in downstream filters.\n        const candidate = response?.data\n            ?.candidates?.[0];\n        const groundingMetadata = candidate?.groundingMetadata;\n        const citationMetadata = candidate?.citationMetadata;\n        const groundingParts = groundingSupportByPart(groundingMetadata?.groundingSupports);\n        const ret = parts.map((part, index) => {\n            const gen = partToChatGeneration(part);\n            if (!gen.generationInfo) {\n                gen.generationInfo = {};\n            }\n            if (groundingMetadata) {\n                gen.generationInfo.groundingMetadata = groundingMetadata;\n                const groundingPart = groundingParts[index];\n                if (groundingPart) {\n                    gen.generationInfo.groundingSupport = groundingPart;\n                }\n            }\n            if (citationMetadata) {\n                gen.generationInfo.citationMetadata = citationMetadata;\n            }\n            return gen;\n        });\n        return ret;\n    }\n    function responseToChatGenerations(response) {\n        let ret = responseToGroundedChatGenerations(response);\n        if (ret.length === 0) {\n            return [];\n        }\n        if (ret.every((item) => typeof item.message.content === \"string\")) {\n            const combinedContent = ret.map((item) => item.message.content).join(\"\");\n            const combinedText = ret.map((item) => item.text).join(\"\");\n            const toolCallChunks = ret[ret.length - 1]?.message.additional_kwargs?.tool_calls?.map((toolCall, i) => ({\n                name: toolCall.function.name,\n                args: toolCall.function.arguments,\n                id: toolCall.id,\n                index: i,\n                type: \"tool_call_chunk\",\n            }));\n            let usageMetadata;\n            if (\"usageMetadata\" in response.data) {\n                usageMetadata = {\n                    input_tokens: response.data.usageMetadata.promptTokenCount,\n                    output_tokens: response.data.usageMetadata\n                        .candidatesTokenCount,\n                    total_tokens: response.data.usageMetadata.totalTokenCount,\n                };\n            }\n            ret = [\n                new outputs_1.ChatGenerationChunk({\n                    message: new messages_1.AIMessageChunk({\n                        content: combinedContent,\n                        additional_kwargs: ret[ret.length - 1]?.message.additional_kwargs,\n                        tool_call_chunks: toolCallChunks,\n                        usage_metadata: usageMetadata,\n                    }),\n                    text: combinedText,\n                    generationInfo: ret[ret.length - 1].generationInfo,\n                }),\n            ];\n        }\n        // Add logprobs information to the message\n        const candidate = response?.data\n            ?.candidates?.[0];\n        const avgLogprobs = candidate?.avgLogprobs;\n        const logprobs = candidateToLogprobs(candidate);\n        if (logprobs) {\n            ret[0].message.response_metadata = {\n                ...ret[0].message.response_metadata,\n                logprobs,\n                avgLogprobs,\n            };\n        }\n        return ret;\n    }\n    function responseToBaseMessageFields(response) {\n        const parts = responseToParts(response);\n        return partsToBaseMessageChunkFields(parts);\n    }\n    function partsToBaseMessageChunkFields(parts) {\n        const fields = {\n            content: partsToMessageContent(parts),\n            tool_call_chunks: [],\n            tool_calls: [],\n            invalid_tool_calls: [],\n        };\n        const rawTools = partsToToolsRaw(parts);\n        if (rawTools.length > 0) {\n            const tools = toolsRawToTools(rawTools);\n            for (const tool of tools) {\n                fields.tool_call_chunks?.push({\n                    name: tool.function.name,\n                    args: tool.function.arguments,\n                    id: tool.id,\n                    type: \"tool_call_chunk\",\n                });\n                try {\n                    fields.tool_calls?.push({\n                        name: tool.function.name,\n                        args: JSON.parse(tool.function.arguments),\n                        id: tool.id,\n                    });\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                }\n                catch (e) {\n                    fields.invalid_tool_calls?.push({\n                        name: tool.function.name,\n                        args: tool.function.arguments,\n                        id: tool.id,\n                        error: e.message,\n                        type: \"invalid_tool_call\",\n                    });\n                }\n            }\n            fields.additional_kwargs = {\n                tool_calls: tools,\n            };\n        }\n        return fields;\n    }\n    function responseToBaseMessage(response) {\n        const fields = responseToBaseMessageFields(response);\n        return new messages_1.AIMessage(fields);\n    }\n    function safeResponseToBaseMessage(response) {\n        return safeResponseTo(response, responseToBaseMessage);\n    }\n    function responseToChatResult(response) {\n        const generations = responseToChatGenerations(response);\n        return {\n            generations,\n            llmOutput: responseToGenerationInfo(response),\n        };\n    }\n    function safeResponseToChatResult(response) {\n        return safeResponseTo(response, responseToChatResult);\n    }\n    function inputType(input) {\n        if (typeof input === \"string\") {\n            return \"MessageContent\";\n        }\n        else {\n            const firstItem = input[0];\n            if (Object.hasOwn(firstItem, \"content\")) {\n                return \"BaseMessageArray\";\n            }\n            else {\n                return \"MessageContent\";\n            }\n        }\n    }\n    async function formatMessageContents(input, _parameters) {\n        const parts = await messageContentToParts(input);\n        const contents = [\n            {\n                role: \"user\",\n                parts,\n            },\n        ];\n        return contents;\n    }\n    async function formatBaseMessageContents(input, _parameters) {\n        const inputPromises = input.map((msg, i) => baseMessageToContent(msg, input[i - 1]));\n        const inputs = await Promise.all(inputPromises);\n        return inputs.reduce((acc, cur) => {\n            // Filter out the system content\n            if (cur.every((content) => content.role === \"system\")) {\n                return acc;\n            }\n            // Combine adjacent function messages\n            if (cur[0]?.role === \"function\" &&\n                acc.length > 0 &&\n                acc[acc.length - 1].role === \"function\") {\n                acc[acc.length - 1].parts = [\n                    ...acc[acc.length - 1].parts,\n                    ...cur[0].parts,\n                ];\n            }\n            else {\n                acc.push(...cur);\n            }\n            return acc;\n        }, []);\n    }\n    async function formatContents(input, parameters) {\n        const it = inputType(input);\n        switch (it) {\n            case \"MessageContent\":\n                return formatMessageContents(input, parameters);\n            case \"BaseMessageArray\":\n                return formatBaseMessageContents(input, parameters);\n            default:\n                throw new Error(`Unknown input type \"${it}\": ${input}`);\n        }\n    }\n    function formatGenerationConfig(parameters) {\n        const ret = {\n            temperature: parameters.temperature,\n            topK: parameters.topK,\n            topP: parameters.topP,\n            presencePenalty: parameters.presencePenalty,\n            frequencyPenalty: parameters.frequencyPenalty,\n            maxOutputTokens: parameters.maxOutputTokens,\n            stopSequences: parameters.stopSequences,\n            responseMimeType: parameters.responseMimeType,\n        };\n        // Add the logprobs if explicitly set\n        if (typeof parameters.logprobs !== \"undefined\") {\n            ret.responseLogprobs = parameters.logprobs;\n            if (parameters.logprobs &&\n                typeof parameters.topLogprobs !== \"undefined\") {\n                ret.logprobs = parameters.topLogprobs;\n            }\n        }\n        return ret;\n    }\n    function formatSafetySettings(parameters) {\n        return parameters.safetySettings ?? [];\n    }\n    async function formatBaseMessageSystemInstruction(input) {\n        let ret = {};\n        for (let index = 0; index < input.length; index += 1) {\n            const message = input[index];\n            if (message._getType() === \"system\") {\n                // For system types, we only want it if it is the first message,\n                // if it appears anywhere else, it should be an error.\n                if (index === 0) {\n                    // eslint-disable-next-line prefer-destructuring\n                    ret = (await baseMessageToContent(message, undefined))[0];\n                }\n                else {\n                    throw new Error(\"System messages are only permitted as the first passed message.\");\n                }\n            }\n        }\n        return ret;\n    }\n    async function formatSystemInstruction(input) {\n        if (!config?.useSystemInstruction) {\n            return {};\n        }\n        const it = inputType(input);\n        switch (it) {\n            case \"BaseMessageArray\":\n                return formatBaseMessageSystemInstruction(input);\n            default:\n                return {};\n        }\n    }\n    function structuredToolToFunctionDeclaration(tool) {\n        const jsonSchema = (0, zod_to_gemini_parameters_js_1.zodToGeminiParameters)(tool.schema);\n        return {\n            name: tool.name,\n            description: tool.description ?? `A function available to call.`,\n            parameters: jsonSchema,\n        };\n    }\n    function searchToolName(tool) {\n        for (const name of types_js_1.GeminiSearchToolAttributes) {\n            if (name in tool) {\n                return name;\n            }\n        }\n        return undefined;\n    }\n    function cleanGeminiTool(tool) {\n        const orig = searchToolName(tool);\n        const adj = config?.googleSearchToolAdjustment;\n        if (orig && adj && adj !== orig) {\n            return {\n                [adj]: {},\n            };\n        }\n        else {\n            return tool;\n        }\n    }\n    function formatTools(parameters) {\n        const tools = parameters?.tools;\n        if (!tools || tools.length === 0) {\n            return [];\n        }\n        // Group all LangChain tools into a single functionDeclarations array.\n        // Gemini Tools may be normalized to different tool names\n        const langChainTools = [];\n        const otherTools = [];\n        tools.forEach((tool) => {\n            if ((0, function_calling_1.isLangChainTool)(tool)) {\n                langChainTools.push(tool);\n            }\n            else {\n                otherTools.push(cleanGeminiTool(tool));\n            }\n        });\n        const result = [...otherTools];\n        if (langChainTools.length > 0) {\n            result.push({\n                functionDeclarations: langChainTools.map(structuredToolToFunctionDeclaration),\n            });\n        }\n        return result;\n    }\n    function formatToolConfig(parameters) {\n        if (!parameters.tool_choice || typeof parameters.tool_choice !== \"string\") {\n            return undefined;\n        }\n        if ([\"auto\", \"any\", \"none\"].includes(parameters.tool_choice)) {\n            return {\n                functionCallingConfig: {\n                    mode: parameters.tool_choice,\n                    allowedFunctionNames: parameters.allowed_function_names,\n                },\n            };\n        }\n        // force tool choice to be a single function name in case of structured output\n        return {\n            functionCallingConfig: {\n                mode: \"any\",\n                allowedFunctionNames: [parameters.tool_choice],\n            },\n        };\n    }\n    async function formatData(input, parameters) {\n        const typedInput = input;\n        const contents = await formatContents(typedInput, parameters);\n        const generationConfig = formatGenerationConfig(parameters);\n        const tools = formatTools(parameters);\n        const toolConfig = formatToolConfig(parameters);\n        const safetySettings = formatSafetySettings(parameters);\n        const systemInstruction = await formatSystemInstruction(typedInput);\n        const ret = {\n            contents,\n            generationConfig,\n        };\n        if (tools && tools.length) {\n            ret.tools = tools;\n        }\n        if (toolConfig) {\n            ret.toolConfig = toolConfig;\n        }\n        if (safetySettings && safetySettings.length) {\n            ret.safetySettings = safetySettings;\n        }\n        if (systemInstruction?.role &&\n            systemInstruction?.parts &&\n            systemInstruction?.parts?.length) {\n            ret.systemInstruction = systemInstruction;\n        }\n        return ret;\n    }\n    return {\n        messageContentToParts,\n        baseMessageToContent,\n        responseToString: safeResponseToString,\n        responseToChatGeneration: safeResponseToChatGeneration,\n        chunkToString,\n        responseToBaseMessage: safeResponseToBaseMessage,\n        responseToChatResult: safeResponseToChatResult,\n        formatData,\n    };\n}\nexports.getGeminiAPI = getGeminiAPI;\nfunction validateGeminiParams(params) {\n    if (params.maxOutputTokens && params.maxOutputTokens < 0) {\n        throw new Error(\"`maxOutputTokens` must be a positive integer\");\n    }\n    if (params.temperature &&\n        (params.temperature < 0 || params.temperature > 2)) {\n        throw new Error(\"`temperature` must be in the range of [0.0,2.0]\");\n    }\n    if (params.topP && (params.topP < 0 || params.topP > 1)) {\n        throw new Error(\"`topP` must be in the range of [0.0,1.0]\");\n    }\n    if (params.topK && params.topK < 0) {\n        throw new Error(\"`topK` must be a positive integer\");\n    }\n}\nexports.validateGeminiParams = validateGeminiParams;\nfunction isModelGemini(modelName) {\n    return modelName.toLowerCase().startsWith(\"gemini\");\n}\nexports.isModelGemini = isModelGemini;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvZ2VtaW5pLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyw0QkFBNEIsR0FBRyxvQkFBb0IsR0FBRyxrQ0FBa0MsR0FBRyxrQ0FBa0M7QUFDckosZUFBZSxtQkFBTyxDQUFDLG9HQUFNO0FBQzdCLG1CQUFtQixtQkFBTyxDQUFDLG1GQUEwQjtBQUNyRCxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBeUI7QUFDbkQsMkJBQTJCLG1CQUFPLENBQUMsK0dBQXdDO0FBQzNFLG9CQUFvQixtQkFBTyxDQUFDLHlGQUFjO0FBQzFDLG1CQUFtQixtQkFBTyxDQUFDLGtGQUFjO0FBQ3pDLHNDQUFzQyxtQkFBTyxDQUFDLDZIQUFnQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixZQUFZO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLGFBQWE7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsaUNBQWlDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsYUFBYSx3REFBd0QsUUFBUTtBQUNsSTtBQUNBLDBDQUEwQyxhQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxxQkFBcUI7QUFDakUsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsS0FBSztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMEJBQTBCLFNBQVMscUJBQXFCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwQkFBMEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsR0FBRyxLQUFLLE1BQU07QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvZ2VtaW5pLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNNb2RlbEdlbWluaSA9IGV4cG9ydHMudmFsaWRhdGVHZW1pbmlQYXJhbXMgPSBleHBvcnRzLmdldEdlbWluaUFQSSA9IGV4cG9ydHMuTWVzc2FnZUdlbWluaVNhZmV0eUhhbmRsZXIgPSBleHBvcnRzLkRlZmF1bHRHZW1pbmlTYWZldHlIYW5kbGVyID0gdm9pZCAwO1xuY29uc3QgdXVpZF8xID0gcmVxdWlyZShcInV1aWRcIik7XG5jb25zdCBtZXNzYWdlc18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9tZXNzYWdlc1wiKTtcbmNvbnN0IG91dHB1dHNfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvb3V0cHV0c1wiKTtcbmNvbnN0IGZ1bmN0aW9uX2NhbGxpbmdfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvdXRpbHMvZnVuY3Rpb25fY2FsbGluZ1wiKTtcbmNvbnN0IHNhZmV0eV9qc18xID0gcmVxdWlyZShcIi4vc2FmZXR5LmNqc1wiKTtcbmNvbnN0IHR5cGVzX2pzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXMuY2pzXCIpO1xuY29uc3Qgem9kX3RvX2dlbWluaV9wYXJhbWV0ZXJzX2pzXzEgPSByZXF1aXJlKFwiLi96b2RfdG9fZ2VtaW5pX3BhcmFtZXRlcnMuY2pzXCIpO1xuY2xhc3MgRGVmYXVsdEdlbWluaVNhZmV0eUhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVycm9yRmluaXNoXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJTQUZFVFlcIiwgXCJSRUNJVEFUSU9OXCIsIFwiT1RIRVJcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXJyb3JGaW5pc2ggPSBzZXR0aW5ncz8uZXJyb3JGaW5pc2ggPz8gdGhpcy5lcnJvckZpbmlzaDtcbiAgICB9XG4gICAgaGFuZGxlRGF0YVByb21wdEZlZWRiYWNrKHJlc3BvbnNlLCBkYXRhKSB7XG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiBvdXIgcHJvbXB0IHdhcyBibG9ja2VkIGluIHRoZSBmaXJzdCBwbGFjZVxuICAgICAgICBjb25zdCBwcm9tcHRGZWVkYmFjayA9IGRhdGE/LnByb21wdEZlZWRiYWNrO1xuICAgICAgICBjb25zdCBibG9ja1JlYXNvbiA9IHByb21wdEZlZWRiYWNrPy5ibG9ja1JlYXNvbjtcbiAgICAgICAgaWYgKGJsb2NrUmVhc29uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgc2FmZXR5X2pzXzEuR29vZ2xlQUlTYWZldHlFcnJvcihyZXNwb25zZSwgYFByb21wdCBibG9ja2VkOiAke2Jsb2NrUmVhc29ufWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBoYW5kbGVEYXRhRmluaXNoUmVhc29uKHJlc3BvbnNlLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Q2FuZGlkYXRlID0gZGF0YT8uY2FuZGlkYXRlcz8uWzBdO1xuICAgICAgICBjb25zdCBmaW5pc2hSZWFzb24gPSBmaXJzdENhbmRpZGF0ZT8uZmluaXNoUmVhc29uO1xuICAgICAgICBpZiAodGhpcy5lcnJvckZpbmlzaC5pbmNsdWRlcyhmaW5pc2hSZWFzb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgc2FmZXR5X2pzXzEuR29vZ2xlQUlTYWZldHlFcnJvcihyZXNwb25zZSwgYEZpbmlzaCByZWFzb246ICR7ZmluaXNoUmVhc29ufWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBoYW5kbGVEYXRhKHJlc3BvbnNlLCBkYXRhKSB7XG4gICAgICAgIGxldCByZXQgPSBkYXRhO1xuICAgICAgICByZXQgPSB0aGlzLmhhbmRsZURhdGFQcm9tcHRGZWVkYmFjayhyZXNwb25zZSwgcmV0KTtcbiAgICAgICAgcmV0ID0gdGhpcy5oYW5kbGVEYXRhRmluaXNoUmVhc29uKHJlc3BvbnNlLCByZXQpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBoYW5kbGUocmVzcG9uc2UpIHtcbiAgICAgICAgbGV0IG5ld2RhdGE7XG4gICAgICAgIGlmIChcIm5leHRDaHVua1wiIGluIHJlc3BvbnNlLmRhdGEpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgaXMgYSBzdHJlYW0uIEhvdyB0byBoYW5kbGU/XG4gICAgICAgICAgICBuZXdkYXRhID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlc3BvbnNlLmRhdGEpKSB7XG4gICAgICAgICAgICAvLyBJZiBpdCBpcyBhbiBhcnJheSwgdHJ5IHRvIGhhbmRsZSBldmVyeSBpdGVtIGluIHRoZSBhcnJheVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBuZXdkYXRhID0gcmVzcG9uc2UuZGF0YS5tYXAoKGl0ZW0pID0+IHRoaXMuaGFuZGxlRGF0YShyZXNwb25zZSwgaXRlbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKHh4KSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAgICAgICAgIGlmICh4eCBpbnN0YW5jZW9mIHNhZmV0eV9qc18xLkdvb2dsZUFJU2FmZXR5RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHNhZmV0eV9qc18xLkdvb2dsZUFJU2FmZXR5RXJyb3IocmVzcG9uc2UsIHh4Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgeHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgICBuZXdkYXRhID0gdGhpcy5oYW5kbGVEYXRhKHJlc3BvbnNlLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICAgICAgICBkYXRhOiBuZXdkYXRhLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuRGVmYXVsdEdlbWluaVNhZmV0eUhhbmRsZXIgPSBEZWZhdWx0R2VtaW5pU2FmZXR5SGFuZGxlcjtcbmNsYXNzIE1lc3NhZ2VHZW1pbmlTYWZldHlIYW5kbGVyIGV4dGVuZHMgRGVmYXVsdEdlbWluaVNhZmV0eUhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibXNnXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcIlwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmb3JjZU5ld01lc3NhZ2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1zZyA9IHNldHRpbmdzPy5tc2cgPz8gdGhpcy5tc2c7XG4gICAgICAgIHRoaXMuZm9yY2VOZXdNZXNzYWdlID0gc2V0dGluZ3M/LmZvcmNlTmV3TWVzc2FnZSA/PyB0aGlzLmZvcmNlTmV3TWVzc2FnZTtcbiAgICB9XG4gICAgc2V0TWVzc2FnZShkYXRhKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGRhdGE7XG4gICAgICAgIGlmICh0aGlzLmZvcmNlTmV3TWVzc2FnZSB8fFxuICAgICAgICAgICAgIWRhdGE/LmNhbmRpZGF0ZXM/LlswXT8uY29udGVudD8ucGFydHM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0LmNhbmRpZGF0ZXMgPSBkYXRhLmNhbmRpZGF0ZXMgPz8gW107XG4gICAgICAgICAgICByZXQuY2FuZGlkYXRlc1swXSA9IGRhdGEuY2FuZGlkYXRlc1swXSA/PyB7fTtcbiAgICAgICAgICAgIHJldC5jYW5kaWRhdGVzWzBdLmNvbnRlbnQgPSBkYXRhLmNhbmRpZGF0ZXNbMF0uY29udGVudCA/PyB7fTtcbiAgICAgICAgICAgIHJldC5jYW5kaWRhdGVzWzBdLmNvbnRlbnQgPSB7XG4gICAgICAgICAgICAgICAgcm9sZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgICAgIHBhcnRzOiBbeyB0ZXh0OiB0aGlzLm1zZyB9XSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgaGFuZGxlRGF0YShyZXNwb25zZSwgZGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmhhbmRsZURhdGEocmVzcG9uc2UsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoICh4eCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TWVzc2FnZShkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTWVzc2FnZUdlbWluaVNhZmV0eUhhbmRsZXIgPSBNZXNzYWdlR2VtaW5pU2FmZXR5SGFuZGxlcjtcbmNvbnN0IGV4dHJhY3RNaW1lVHlwZSA9IChzdHIpID0+IHtcbiAgICBpZiAoc3RyLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWltZVR5cGU6IHN0ci5zcGxpdChcIjpcIilbMV0uc3BsaXQoXCI7XCIpWzBdLFxuICAgICAgICAgICAgZGF0YTogc3RyLnNwbGl0KFwiLFwiKVsxXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuZnVuY3Rpb24gZ2V0R2VtaW5pQVBJKGNvbmZpZykge1xuICAgIGZ1bmN0aW9uIG1lc3NhZ2VDb250ZW50VGV4dChjb250ZW50KSB7XG4gICAgICAgIGlmIChjb250ZW50Py50ZXh0ICYmIGNvbnRlbnQ/LnRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBjb250ZW50LnRleHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbWVzc2FnZUNvbnRlbnRJbWFnZVVybChjb250ZW50KSB7XG4gICAgICAgIGNvbnN0IHVybCA9IHR5cGVvZiBjb250ZW50LmltYWdlX3VybCA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgPyBjb250ZW50LmltYWdlX3VybFxuICAgICAgICAgICAgOiBjb250ZW50LmltYWdlX3VybC51cmw7XG4gICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIEltYWdlIFVSTFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaW1lVHlwZUFuZERhdGEgPSBleHRyYWN0TWltZVR5cGUodXJsKTtcbiAgICAgICAgaWYgKG1pbWVUeXBlQW5kRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbmxpbmVEYXRhOiBtaW1lVHlwZUFuZERhdGEsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRklYTUUgLSBuZWVkIHNvbWUgd2F5IHRvIGdldCBtaW1lIHR5cGVcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZmlsZURhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IFwiaW1hZ2UvcG5nXCIsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVVcmk6IHVybCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBibG9iVG9GaWxlRGF0YShibG9iKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWxlRGF0YToge1xuICAgICAgICAgICAgICAgIGZpbGVVcmk6IGJsb2IucGF0aCxcbiAgICAgICAgICAgICAgICBtaW1lVHlwZTogYmxvYi5taW1ldHlwZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGZpbGVVcmlDb250ZW50VG9CbG9iKHVyaSkge1xuICAgICAgICByZXR1cm4gY29uZmlnPy5tZWRpYU1hbmFnZXI/LmdldE1lZGlhQmxvYih1cmkpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBtZXNzYWdlQ29udGVudE1lZGlhKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY29udGVudCkge1xuICAgICAgICBpZiAoXCJtaW1lVHlwZVwiIGluIGNvbnRlbnQgJiYgXCJkYXRhXCIgaW4gY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbmxpbmVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBjb250ZW50Lm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjb250ZW50LmRhdGEsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXCJtaW1lVHlwZVwiIGluIGNvbnRlbnQgJiYgXCJmaWxlVXJpXCIgaW4gY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmaWxlRGF0YToge1xuICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogY29udGVudC5taW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZVVyaTogY29udGVudC5maWxlVXJpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdXJpID0gY29udGVudC5maWxlVXJpO1xuICAgICAgICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IGZpbGVVcmlDb250ZW50VG9CbG9iKHVyaSk7XG4gICAgICAgICAgICBpZiAoYmxvYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBibG9iVG9GaWxlRGF0YShibG9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWVkaWEgY29udGVudDogJHtKU09OLnN0cmluZ2lmeShjb250ZW50LCBudWxsLCAxKX1gKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gbWVzc2FnZUNvbnRlbnRDb21wbGV4VG9QYXJ0KGNvbnRlbnQpIHtcbiAgICAgICAgc3dpdGNoIChjb250ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgICAgICAgaWYgKFwidGV4dFwiIGluIGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VDb250ZW50VGV4dChjb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaW1hZ2VfdXJsXCI6XG4gICAgICAgICAgICAgICAgaWYgKFwiaW1hZ2VfdXJsXCIgaW4gY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUeXBlIGd1YXJkIGZvciBNZXNzYWdlQ29udGVudEltYWdlVXJsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlQ29udGVudEltYWdlVXJsKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtZWRpYVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBtZXNzYWdlQ29udGVudE1lZGlhKGNvbnRlbnQpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHR5cGUgXCIke2NvbnRlbnQudHlwZX1cIiByZWNlaXZlZCB3aGlsZSBjb252ZXJ0aW5nIG1lc3NhZ2UgdG8gbWVzc2FnZSBwYXJ0czogJHtjb250ZW50fWApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvZXJjZSBcIiR7Y29udGVudC50eXBlfVwiIG1lc3NhZ2UgcGFydCBpbnRvIGEgc3RyaW5nLmApO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBtZXNzYWdlQ29udGVudENvbXBsZXhUb1BhcnRzKGNvbnRlbnQpIHtcbiAgICAgICAgY29uc3QgY29udGVudHMgPSBjb250ZW50Lm1hcChtZXNzYWdlQ29udGVudENvbXBsZXhUb1BhcnQpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoY29udGVudHMpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBtZXNzYWdlQ29udGVudFRvUGFydHMoY29udGVudCkge1xuICAgICAgICAvLyBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgdGV4dCB0eXBlIE1lc3NhZ2VDb250ZW50IGlmIG5lZWRlZFxuICAgICAgICBjb25zdCBtZXNzYWdlQ29udGVudCA9IHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjb250ZW50LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgICAgICA6IGNvbnRlbnQ7XG4gICAgICAgIC8vIEdldCBhbGwgb2YgdGhlIHBhcnRzLCBldmVuIHRob3NlIHRoYXQgZG9uJ3QgY29ycmVjdGx5IHJlc29sdmVcbiAgICAgICAgY29uc3QgYWxsUGFydHMgPSBhd2FpdCBtZXNzYWdlQ29udGVudENvbXBsZXhUb1BhcnRzKG1lc3NhZ2VDb250ZW50KTtcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBpbnZhbGlkIHBhcnRzXG4gICAgICAgIGNvbnN0IHBhcnRzID0gYWxsUGFydHMucmVkdWNlKChhY2MsIHZhbCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbLi4uYWNjLCB2YWxdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW10pO1xuICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lc3NhZ2VUb29sQ2FsbHNUb1BhcnRzKHRvb2xDYWxscykge1xuICAgICAgICBpZiAoIXRvb2xDYWxscyB8fCB0b29sQ2FsbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvb2xDYWxscy5tYXAoKHRvb2wpID0+IHtcbiAgICAgICAgICAgIGxldCBhcmdzID0ge307XG4gICAgICAgICAgICBpZiAodG9vbD8uZnVuY3Rpb24/LmFyZ3VtZW50cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ1N0ciA9IHRvb2wuZnVuY3Rpb24uYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBKU09OLnBhcnNlKGFyZ1N0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbDoge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0b29sLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtZXNzYWdlS3dhcmdzVG9QYXJ0cyhrd2FyZ3MpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gW107XG4gICAgICAgIGlmIChrd2FyZ3M/LnRvb2xfY2FsbHMpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKC4uLm1lc3NhZ2VUb29sQ2FsbHNUb1BhcnRzKGt3YXJncy50b29sX2NhbGxzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gcm9sZU1lc3NhZ2VUb0NvbnRlbnQocm9sZSwgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBjb250ZW50UGFydHMgPSBhd2FpdCBtZXNzYWdlQ29udGVudFRvUGFydHMobWVzc2FnZS5jb250ZW50KTtcbiAgICAgICAgbGV0IHRvb2xQYXJ0cztcbiAgICAgICAgaWYgKCgwLCBtZXNzYWdlc18xLmlzQUlNZXNzYWdlKShtZXNzYWdlKSAmJiAhIW1lc3NhZ2UudG9vbF9jYWxscz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0b29sUGFydHMgPSBtZXNzYWdlLnRvb2xfY2FsbHMubWFwKCh0b29sQ2FsbCkgPT4gKHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkNhbGw6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdG9vbENhbGwubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogdG9vbENhbGwuYXJncyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9vbFBhcnRzID0gbWVzc2FnZUt3YXJnc1RvUGFydHMobWVzc2FnZS5hZGRpdGlvbmFsX2t3YXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFydHMgPSBbLi4uY29udGVudFBhcnRzLCAuLi50b29sUGFydHNdO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJvbGUsXG4gICAgICAgICAgICAgICAgcGFydHMsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBzeXN0ZW1NZXNzYWdlVG9Db250ZW50KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZz8udXNlU3lzdGVtSW5zdHJ1Y3Rpb25cbiAgICAgICAgICAgID8gcm9sZU1lc3NhZ2VUb0NvbnRlbnQoXCJzeXN0ZW1cIiwgbWVzc2FnZSlcbiAgICAgICAgICAgIDogW1xuICAgICAgICAgICAgICAgIC4uLihhd2FpdCByb2xlTWVzc2FnZVRvQ29udGVudChcInVzZXJcIiwgbWVzc2FnZSkpLFxuICAgICAgICAgICAgICAgIC4uLihhd2FpdCByb2xlTWVzc2FnZVRvQ29udGVudChcIm1vZGVsXCIsIG5ldyBtZXNzYWdlc18xLkFJTWVzc2FnZShcIk9rXCIpKSksXG4gICAgICAgICAgICBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b29sTWVzc2FnZVRvQ29udGVudChtZXNzYWdlLCBwcmV2TWVzc2FnZSkge1xuICAgICAgICBjb25zdCBjb250ZW50U3RyID0gdHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgPyBtZXNzYWdlLmNvbnRlbnRcbiAgICAgICAgICAgIDogbWVzc2FnZS5jb250ZW50LnJlZHVjZSgoYWNjLCBjb250ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYyArIGNvbnRlbnQudGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgXCJcIik7XG4gICAgICAgIC8vIEhhY2t5IDooXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlTmFtZSA9ICgoMCwgbWVzc2FnZXNfMS5pc0FJTWVzc2FnZSkocHJldk1lc3NhZ2UpICYmICEhcHJldk1lc3NhZ2UudG9vbF9jYWxscz8ubGVuZ3RoXG4gICAgICAgICAgICA/IHByZXZNZXNzYWdlLnRvb2xfY2FsbHNbMF0ubmFtZVxuICAgICAgICAgICAgOiBwcmV2TWVzc2FnZS5uYW1lKSA/PyBtZXNzYWdlLnRvb2xfY2FsbF9pZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBKU09OLnBhcnNlKGNvbnRlbnRTdHIpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgcGFydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHJlc3BvbnNlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHsgY29udGVudCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcmVzcG9uc2VOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogeyBjb250ZW50OiBjb250ZW50U3RyIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gYmFzZU1lc3NhZ2VUb0NvbnRlbnQobWVzc2FnZSwgcHJldk1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UuX2dldFR5cGUoKTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwic3lzdGVtXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5c3RlbU1lc3NhZ2VUb0NvbnRlbnQobWVzc2FnZSk7XG4gICAgICAgICAgICBjYXNlIFwiaHVtYW5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9sZU1lc3NhZ2VUb0NvbnRlbnQoXCJ1c2VyXCIsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgY2FzZSBcImFpXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvbGVNZXNzYWdlVG9Db250ZW50KFwibW9kZWxcIiwgbWVzc2FnZSk7XG4gICAgICAgICAgICBjYXNlIFwidG9vbFwiOlxuICAgICAgICAgICAgICAgIGlmICghcHJldk1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG9vbCBtZXNzYWdlcyBjYW5ub3QgYmUgdGhlIGZpcnN0IG1lc3NhZ2UgcGFzc2VkIHRvIHRoZSBtb2RlbC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0b29sTWVzc2FnZVRvQ29udGVudChtZXNzYWdlLCBwcmV2TWVzc2FnZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBVbnN1cHBvcnRlZCBtZXNzYWdlIHR5cGU6ICR7dHlwZX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdGV4dFBhcnRUb01lc3NhZ2VDb250ZW50KHBhcnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbmxpbmVEYXRhUGFydFRvTWVzc2FnZUNvbnRlbnQocGFydCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJpbWFnZV91cmxcIixcbiAgICAgICAgICAgIGltYWdlX3VybDogYGRhdGE6JHtwYXJ0LmlubGluZURhdGEubWltZVR5cGV9O2Jhc2U2NCwke3BhcnQuaW5saW5lRGF0YS5kYXRhfWAsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbGVEYXRhUGFydFRvTWVzc2FnZUNvbnRlbnQocGFydCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJpbWFnZV91cmxcIixcbiAgICAgICAgICAgIGltYWdlX3VybDogcGFydC5maWxlRGF0YS5maWxlVXJpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJ0c1RvTWVzc2FnZUNvbnRlbnQocGFydHMpIHtcbiAgICAgICAgcmV0dXJuIHBhcnRzXG4gICAgICAgICAgICAubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICBpZiAocGFydCA9PT0gdW5kZWZpbmVkIHx8IHBhcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFwidGV4dFwiIGluIHBhcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dFBhcnRUb01lc3NhZ2VDb250ZW50KHBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoXCJpbmxpbmVEYXRhXCIgaW4gcGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmxpbmVEYXRhUGFydFRvTWVzc2FnZUNvbnRlbnQocGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChcImZpbGVEYXRhXCIgaW4gcGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlRGF0YVBhcnRUb01lc3NhZ2VDb250ZW50KHBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAucmVkdWNlKChhY2MsIGNvbnRlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgYWNjLnB1c2goY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvb2xSYXdUb1Rvb2wocmF3KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogcmF3LmlkLFxuICAgICAgICAgICAgdHlwZTogcmF3LnR5cGUsXG4gICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHJhdy5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5zdHJpbmdpZnkocmF3LmZ1bmN0aW9uLmFyZ3VtZW50cyksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkNhbGxQYXJ0VG9Ub29sUmF3KHBhcnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiAoMCwgdXVpZF8xLnY0KSgpLnJlcGxhY2UoLy0vZywgXCJcIiksXG4gICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcnQuZnVuY3Rpb25DYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzOiBwYXJ0LmZ1bmN0aW9uQ2FsbC5hcmdzID8/IHt9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFydHNUb1Rvb2xzUmF3KHBhcnRzKSB7XG4gICAgICAgIHJldHVybiBwYXJ0c1xuICAgICAgICAgICAgLm1hcCgocGFydCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcnQgPT09IHVuZGVmaW5lZCB8fCBwYXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChcImZ1bmN0aW9uQ2FsbFwiIGluIHBhcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25DYWxsUGFydFRvVG9vbFJhdyhwYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLnJlZHVjZSgoYWNjLCBjb250ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgICAgICAgIGFjYy5wdXNoKGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b29sc1Jhd1RvVG9vbHMocmF3cykge1xuICAgICAgICByZXR1cm4gcmF3cy5tYXAoKHJhdykgPT4gdG9vbFJhd1RvVG9vbChyYXcpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzcG9uc2VUb0dlbmVyYXRlQ29udGVudFJlc3BvbnNlRGF0YShyZXNwb25zZSkge1xuICAgICAgICBpZiAoXCJuZXh0Q2h1bmtcIiBpbiByZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29udmVydCBTdHJlYW0gdG8gR2VuZXJhdGVDb250ZW50UmVzcG9uc2VEYXRhXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UuZGF0YSkpIHtcbiAgICAgICAgICAgIC8vIENvbGxhcHNlIHRoZSBhcnJheSBvZiByZXNwb25zZSBkYXRhIGFzIGlmIGl0IHdhcyBhIHNpbmdsZSBvbmVcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLnJlZHVjZSgoYWNjLCB2YWwpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYWxsIHRoZSBwYXJ0c1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBIYW5kbGUgb3RoZXIgY2FuZGlkYXRlcz9cbiAgICAgICAgICAgICAgICBjb25zdCB2YWxQYXJ0cyA9IHZhbD8uY2FuZGlkYXRlcz8uWzBdPy5jb250ZW50Py5wYXJ0cyA/PyBbXTtcbiAgICAgICAgICAgICAgICBhY2MuY2FuZGlkYXRlc1swXS5jb250ZW50LnBhcnRzLnB1c2goLi4udmFsUGFydHMpO1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBNZXJnZSBwcm9tcHRGZWVkYmFjayBhbmQgc2FmZXR5IHNldHRpbmdzXG4gICAgICAgICAgICAgICAgYWNjLnByb21wdEZlZWRiYWNrID0gdmFsLnByb21wdEZlZWRiYWNrO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3BvbnNlVG9QYXJ0cyhyZXNwb25zZSkge1xuICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSByZXNwb25zZVRvR2VuZXJhdGVDb250ZW50UmVzcG9uc2VEYXRhKHJlc3BvbnNlKTtcbiAgICAgICAgY29uc3QgcGFydHMgPSByZXNwb25zZURhdGE/LmNhbmRpZGF0ZXM/LlswXT8uY29udGVudD8ucGFydHMgPz8gW107XG4gICAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFydFRvVGV4dChwYXJ0KSB7XG4gICAgICAgIHJldHVybiBcInRleHRcIiBpbiBwYXJ0ID8gcGFydC50ZXh0IDogXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzcG9uc2VUb1N0cmluZyhyZXNwb25zZSkge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IHJlc3BvbnNlVG9QYXJ0cyhyZXNwb25zZSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHBhcnRzLnJlZHVjZSgoYWNjLCBwYXJ0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBwYXJ0VG9UZXh0KHBhcnQpO1xuICAgICAgICAgICAgcmV0dXJuIGFjYyArIHZhbDtcbiAgICAgICAgfSwgXCJcIik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNhZmVSZXNwb25zZVRvKHJlc3BvbnNlLCByZXNwb25zZVRvKSB7XG4gICAgICAgIGNvbnN0IHNhZmV0eUhhbmRsZXIgPSBjb25maWc/LnNhZmV0eUhhbmRsZXIgPz8gbmV3IERlZmF1bHRHZW1pbmlTYWZldHlIYW5kbGVyKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzYWZlUmVzcG9uc2UgPSBzYWZldHlIYW5kbGVyLmhhbmRsZShyZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VUbyhzYWZlUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoICh4eCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAgICAgaWYgKHh4IGluc3RhbmNlb2Ygc2FmZXR5X2pzXzEuR29vZ2xlQUlTYWZldHlFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IHJlc3BvbnNlVG8oeHgucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHh4LnJlcGx5ID0gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgeHg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2FmZVJlc3BvbnNlVG9TdHJpbmcocmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHNhZmVSZXNwb25zZVRvKHJlc3BvbnNlLCByZXNwb25zZVRvU3RyaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbG9ncHJvYlJlc3VsdFRvTG9ncHJvYihyZXN1bHQpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSByZXN1bHQ/LnRva2VuO1xuICAgICAgICBjb25zdCBsb2dwcm9iID0gcmVzdWx0Py5sb2dQcm9iYWJpbGl0eTtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICBjb25zdCBieXRlcyA9IEFycmF5LmZyb20oZW5jb2Rlci5lbmNvZGUodG9rZW4pKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgbG9ncHJvYixcbiAgICAgICAgICAgIGJ5dGVzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5kaWRhdGVUb0xvZ3Byb2JzKGNhbmRpZGF0ZSkge1xuICAgICAgICBjb25zdCBsb2dwcm9icyA9IGNhbmRpZGF0ZT8ubG9ncHJvYnNSZXN1bHQ7XG4gICAgICAgIGNvbnN0IGNob3NlblRva2VucyA9IGxvZ3Byb2JzPy5jaG9zZW5DYW5kaWRhdGVzID8/IFtdO1xuICAgICAgICBjb25zdCB0b3BUb2tlbnMgPSBsb2dwcm9icz8udG9wQ2FuZGlkYXRlcyA/PyBbXTtcbiAgICAgICAgY29uc3QgY29udGVudCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBjbyA9IDA7IGNvIDwgY2hvc2VuVG9rZW5zLmxlbmd0aDsgY28gKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgY2hvc2VuID0gY2hvc2VuVG9rZW5zW2NvXTtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IHRvcFRva2Vuc1tjb10/LmNhbmRpZGF0ZXMgPz8gW107XG4gICAgICAgICAgICBjb25zdCBsb2dwcm9iID0gbG9ncHJvYlJlc3VsdFRvTG9ncHJvYihjaG9zZW4pO1xuICAgICAgICAgICAgbG9ncHJvYi50b3BfbG9ncHJvYnMgPSB0b3AubWFwKChsKSA9PiBsb2dwcm9iUmVzdWx0VG9Mb2dwcm9iKGwpKTtcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaChsb2dwcm9iKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzcG9uc2VUb0dlbmVyYXRpb25JbmZvKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXNwb25zZS5kYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSByZXNwb25zZS5kYXRhWzBdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNhZ2VfbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICBwcm9tcHRfdG9rZW5fY291bnQ6IGRhdGEudXNhZ2VNZXRhZGF0YT8ucHJvbXB0VG9rZW5Db3VudCxcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzX3Rva2VuX2NvdW50OiBkYXRhLnVzYWdlTWV0YWRhdGE/LmNhbmRpZGF0ZXNUb2tlbkNvdW50LFxuICAgICAgICAgICAgICAgIHRvdGFsX3Rva2VuX2NvdW50OiBkYXRhLnVzYWdlTWV0YWRhdGE/LnRvdGFsVG9rZW5Db3VudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzYWZldHlfcmF0aW5nczogZGF0YS5jYW5kaWRhdGVzWzBdPy5zYWZldHlSYXRpbmdzPy5tYXAoKHJhdGluZykgPT4gKHtcbiAgICAgICAgICAgICAgICBjYXRlZ29yeTogcmF0aW5nLmNhdGVnb3J5LFxuICAgICAgICAgICAgICAgIHByb2JhYmlsaXR5OiByYXRpbmcucHJvYmFiaWxpdHksXG4gICAgICAgICAgICAgICAgcHJvYmFiaWxpdHlfc2NvcmU6IHJhdGluZy5wcm9iYWJpbGl0eVNjb3JlLFxuICAgICAgICAgICAgICAgIHNldmVyaXR5OiByYXRpbmcuc2V2ZXJpdHksXG4gICAgICAgICAgICAgICAgc2V2ZXJpdHlfc2NvcmU6IHJhdGluZy5zZXZlcml0eVNjb3JlLFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgY2l0YXRpb25fbWV0YWRhdGE6IGRhdGEuY2FuZGlkYXRlc1swXT8uY2l0YXRpb25NZXRhZGF0YSxcbiAgICAgICAgICAgIGdyb3VuZGluZ19tZXRhZGF0YTogZGF0YS5jYW5kaWRhdGVzWzBdPy5ncm91bmRpbmdNZXRhZGF0YSxcbiAgICAgICAgICAgIGZpbmlzaF9yZWFzb246IGRhdGEuY2FuZGlkYXRlc1swXT8uZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgYXZnTG9ncHJvYnM6IGRhdGEuY2FuZGlkYXRlc1swXT8uYXZnTG9ncHJvYnMsXG4gICAgICAgICAgICBsb2dwcm9iczogY2FuZGlkYXRlVG9Mb2dwcm9icyhkYXRhLmNhbmRpZGF0ZXNbMF0pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNwb25zZVRvQ2hhdEdlbmVyYXRpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBvdXRwdXRzXzEuQ2hhdEdlbmVyYXRpb25DaHVuayh7XG4gICAgICAgICAgICB0ZXh0OiByZXNwb25zZVRvU3RyaW5nKHJlc3BvbnNlKSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHBhcnRUb01lc3NhZ2VDaHVuayhyZXNwb25zZVRvUGFydHMocmVzcG9uc2UpWzBdKSxcbiAgICAgICAgICAgIGdlbmVyYXRpb25JbmZvOiByZXNwb25zZVRvR2VuZXJhdGlvbkluZm8ocmVzcG9uc2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2FmZVJlc3BvbnNlVG9DaGF0R2VuZXJhdGlvbihyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gc2FmZVJlc3BvbnNlVG8ocmVzcG9uc2UsIHJlc3BvbnNlVG9DaGF0R2VuZXJhdGlvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNodW5rVG9TdHJpbmcoY2h1bmspIHtcbiAgICAgICAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2h1bmsuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGNodW5rLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2h1bmsuY29udGVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNodW5rLmNvbnRlbnRbMF0udHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjaHVuay5jb250ZW50WzBdLnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgY2h1bms6ICR7Y2h1bmt9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcGFydFRvTWVzc2FnZUNodW5rKHBhcnQpIHtcbiAgICAgICAgY29uc3QgZmllbGRzID0gcGFydHNUb0Jhc2VNZXNzYWdlQ2h1bmtGaWVsZHMoW3BhcnRdKTtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBtZXNzYWdlc18xLkFJTWVzc2FnZUNodW5rKGZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmllbGRzLmNvbnRlbnQuZXZlcnkoKGl0ZW0pID0+IGl0ZW0udHlwZSA9PT0gXCJ0ZXh0XCIpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdDb250ZW50ID0gZmllbGRzLmNvbnRlbnRcbiAgICAgICAgICAgICAgICAubWFwKChpdGVtKSA9PiAoXCJ0ZXh0XCIgaW4gaXRlbSA/IGl0ZW0udGV4dCA6IFwiXCIpKVxuICAgICAgICAgICAgICAgIC5qb2luKFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBtZXNzYWdlc18xLkFJTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgICAgICAgY29udGVudDogbmV3Q29udGVudCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgbWVzc2FnZXNfMS5BSU1lc3NhZ2VDaHVuayhmaWVsZHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJ0VG9DaGF0R2VuZXJhdGlvbihwYXJ0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBwYXJ0VG9NZXNzYWdlQ2h1bmsocGFydCk7XG4gICAgICAgIGNvbnN0IHRleHQgPSBwYXJ0VG9UZXh0KHBhcnQpO1xuICAgICAgICByZXR1cm4gbmV3IG91dHB1dHNfMS5DaGF0R2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ3JvdW5kaW5nU3VwcG9ydEJ5UGFydChncm91bmRpbmdTdXBwb3J0cykge1xuICAgICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgICAgaWYgKCFncm91bmRpbmdTdXBwb3J0cyB8fCBncm91bmRpbmdTdXBwb3J0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBncm91bmRpbmdTdXBwb3J0cz8uZm9yRWFjaCgoZ3JvdW5kaW5nU3VwcG9ydCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudCA9IGdyb3VuZGluZ1N1cHBvcnQ/LnNlZ21lbnQ7XG4gICAgICAgICAgICBjb25zdCBwYXJ0SW5kZXggPSBzZWdtZW50Py5wYXJ0SW5kZXggPz8gMDtcbiAgICAgICAgICAgIGlmIChyZXRbcGFydEluZGV4XSkge1xuICAgICAgICAgICAgICAgIHJldFtwYXJ0SW5kZXhdLnB1c2goZ3JvdW5kaW5nU3VwcG9ydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXRbcGFydEluZGV4XSA9IFtncm91bmRpbmdTdXBwb3J0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3BvbnNlVG9Hcm91bmRlZENoYXRHZW5lcmF0aW9ucyhyZXNwb25zZSkge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IHJlc3BvbnNlVG9QYXJ0cyhyZXNwb25zZSk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaXRhdGlvbiBhbmQgZ3JvdW5kaW5nIGluZm9ybWF0aW9uIGNvbm5lY3RlZCB0byBlYWNoIHBhcnQgLyBDaGF0R2VuZXJhdGlvblxuICAgICAgICAvLyB0byBtYWtlIHN1cmUgdGhleSBhcmUgYXZhaWxhYmxlIGluIGRvd25zdHJlYW0gZmlsdGVycy5cbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gcmVzcG9uc2U/LmRhdGFcbiAgICAgICAgICAgID8uY2FuZGlkYXRlcz8uWzBdO1xuICAgICAgICBjb25zdCBncm91bmRpbmdNZXRhZGF0YSA9IGNhbmRpZGF0ZT8uZ3JvdW5kaW5nTWV0YWRhdGE7XG4gICAgICAgIGNvbnN0IGNpdGF0aW9uTWV0YWRhdGEgPSBjYW5kaWRhdGU/LmNpdGF0aW9uTWV0YWRhdGE7XG4gICAgICAgIGNvbnN0IGdyb3VuZGluZ1BhcnRzID0gZ3JvdW5kaW5nU3VwcG9ydEJ5UGFydChncm91bmRpbmdNZXRhZGF0YT8uZ3JvdW5kaW5nU3VwcG9ydHMpO1xuICAgICAgICBjb25zdCByZXQgPSBwYXJ0cy5tYXAoKHBhcnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBnZW4gPSBwYXJ0VG9DaGF0R2VuZXJhdGlvbihwYXJ0KTtcbiAgICAgICAgICAgIGlmICghZ2VuLmdlbmVyYXRpb25JbmZvKSB7XG4gICAgICAgICAgICAgICAgZ2VuLmdlbmVyYXRpb25JbmZvID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdW5kaW5nTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICBnZW4uZ2VuZXJhdGlvbkluZm8uZ3JvdW5kaW5nTWV0YWRhdGEgPSBncm91bmRpbmdNZXRhZGF0YTtcbiAgICAgICAgICAgICAgICBjb25zdCBncm91bmRpbmdQYXJ0ID0gZ3JvdW5kaW5nUGFydHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChncm91bmRpbmdQYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5nZW5lcmF0aW9uSW5mby5ncm91bmRpbmdTdXBwb3J0ID0gZ3JvdW5kaW5nUGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2l0YXRpb25NZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIGdlbi5nZW5lcmF0aW9uSW5mby5jaXRhdGlvbk1ldGFkYXRhID0gY2l0YXRpb25NZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZW47XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNwb25zZVRvQ2hhdEdlbmVyYXRpb25zKHJlc3BvbnNlKSB7XG4gICAgICAgIGxldCByZXQgPSByZXNwb25zZVRvR3JvdW5kZWRDaGF0R2VuZXJhdGlvbnMocmVzcG9uc2UpO1xuICAgICAgICBpZiAocmV0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXQuZXZlcnkoKGl0ZW0pID0+IHR5cGVvZiBpdGVtLm1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkQ29udGVudCA9IHJldC5tYXAoKGl0ZW0pID0+IGl0ZW0ubWVzc2FnZS5jb250ZW50KS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgY29uc3QgY29tYmluZWRUZXh0ID0gcmV0Lm1hcCgoaXRlbSkgPT4gaXRlbS50ZXh0KS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgY29uc3QgdG9vbENhbGxDaHVua3MgPSByZXRbcmV0Lmxlbmd0aCAtIDFdPy5tZXNzYWdlLmFkZGl0aW9uYWxfa3dhcmdzPy50b29sX2NhbGxzPy5tYXAoKHRvb2xDYWxsLCBpKSA9PiAoe1xuICAgICAgICAgICAgICAgIG5hbWU6IHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgYXJnczogdG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgIGlkOiB0b29sQ2FsbC5pZCxcbiAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2xfY2FsbF9jaHVua1wiLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgbGV0IHVzYWdlTWV0YWRhdGE7XG4gICAgICAgICAgICBpZiAoXCJ1c2FnZU1ldGFkYXRhXCIgaW4gcmVzcG9uc2UuZGF0YSkge1xuICAgICAgICAgICAgICAgIHVzYWdlTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0X3Rva2VuczogcmVzcG9uc2UuZGF0YS51c2FnZU1ldGFkYXRhLnByb21wdFRva2VuQ291bnQsXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dF90b2tlbnM6IHJlc3BvbnNlLmRhdGEudXNhZ2VNZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhbmRpZGF0ZXNUb2tlbkNvdW50LFxuICAgICAgICAgICAgICAgICAgICB0b3RhbF90b2tlbnM6IHJlc3BvbnNlLmRhdGEudXNhZ2VNZXRhZGF0YS50b3RhbFRva2VuQ291bnQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldCA9IFtcbiAgICAgICAgICAgICAgICBuZXcgb3V0cHV0c18xLkNoYXRHZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBuZXcgbWVzc2FnZXNfMS5BSU1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBjb21iaW5lZENvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsX2t3YXJnczogcmV0W3JldC5sZW5ndGggLSAxXT8ubWVzc2FnZS5hZGRpdGlvbmFsX2t3YXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xfY2FsbF9jaHVua3M6IHRvb2xDYWxsQ2h1bmtzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNhZ2VfbWV0YWRhdGE6IHVzYWdlTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjb21iaW5lZFRleHQsXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb25JbmZvOiByZXRbcmV0Lmxlbmd0aCAtIDFdLmdlbmVyYXRpb25JbmZvLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgbG9ncHJvYnMgaW5mb3JtYXRpb24gdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gcmVzcG9uc2U/LmRhdGFcbiAgICAgICAgICAgID8uY2FuZGlkYXRlcz8uWzBdO1xuICAgICAgICBjb25zdCBhdmdMb2dwcm9icyA9IGNhbmRpZGF0ZT8uYXZnTG9ncHJvYnM7XG4gICAgICAgIGNvbnN0IGxvZ3Byb2JzID0gY2FuZGlkYXRlVG9Mb2dwcm9icyhjYW5kaWRhdGUpO1xuICAgICAgICBpZiAobG9ncHJvYnMpIHtcbiAgICAgICAgICAgIHJldFswXS5tZXNzYWdlLnJlc3BvbnNlX21ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgIC4uLnJldFswXS5tZXNzYWdlLnJlc3BvbnNlX21ldGFkYXRhLFxuICAgICAgICAgICAgICAgIGxvZ3Byb2JzLFxuICAgICAgICAgICAgICAgIGF2Z0xvZ3Byb2JzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNwb25zZVRvQmFzZU1lc3NhZ2VGaWVsZHMocmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSByZXNwb25zZVRvUGFydHMocmVzcG9uc2UpO1xuICAgICAgICByZXR1cm4gcGFydHNUb0Jhc2VNZXNzYWdlQ2h1bmtGaWVsZHMocGFydHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJ0c1RvQmFzZU1lc3NhZ2VDaHVua0ZpZWxkcyhwYXJ0cykge1xuICAgICAgICBjb25zdCBmaWVsZHMgPSB7XG4gICAgICAgICAgICBjb250ZW50OiBwYXJ0c1RvTWVzc2FnZUNvbnRlbnQocGFydHMpLFxuICAgICAgICAgICAgdG9vbF9jYWxsX2NodW5rczogW10sXG4gICAgICAgICAgICB0b29sX2NhbGxzOiBbXSxcbiAgICAgICAgICAgIGludmFsaWRfdG9vbF9jYWxsczogW10sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJhd1Rvb2xzID0gcGFydHNUb1Rvb2xzUmF3KHBhcnRzKTtcbiAgICAgICAgaWYgKHJhd1Rvb2xzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xzID0gdG9vbHNSYXdUb1Rvb2xzKHJhd1Rvb2xzKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbCBvZiB0b29scykge1xuICAgICAgICAgICAgICAgIGZpZWxkcy50b29sX2NhbGxfY2h1bmtzPy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdG9vbC5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiB0b29sLmZ1bmN0aW9uLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRvb2wuaWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbF9jYWxsX2NodW5rXCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzLnRvb2xfY2FsbHM/LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdG9vbC5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogSlNPTi5wYXJzZSh0b29sLmZ1bmN0aW9uLmFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdG9vbC5pZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkcy5pbnZhbGlkX3Rvb2xfY2FsbHM/LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdG9vbC5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogdG9vbC5mdW5jdGlvbi5hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdG9vbC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImludmFsaWRfdG9vbF9jYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpZWxkcy5hZGRpdGlvbmFsX2t3YXJncyA9IHtcbiAgICAgICAgICAgICAgICB0b29sX2NhbGxzOiB0b29scyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkcztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzcG9uc2VUb0Jhc2VNZXNzYWdlKHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHJlc3BvbnNlVG9CYXNlTWVzc2FnZUZpZWxkcyhyZXNwb25zZSk7XG4gICAgICAgIHJldHVybiBuZXcgbWVzc2FnZXNfMS5BSU1lc3NhZ2UoZmllbGRzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2FmZVJlc3BvbnNlVG9CYXNlTWVzc2FnZShyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gc2FmZVJlc3BvbnNlVG8ocmVzcG9uc2UsIHJlc3BvbnNlVG9CYXNlTWVzc2FnZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3BvbnNlVG9DaGF0UmVzdWx0KHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRpb25zID0gcmVzcG9uc2VUb0NoYXRHZW5lcmF0aW9ucyhyZXNwb25zZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZW5lcmF0aW9ucyxcbiAgICAgICAgICAgIGxsbU91dHB1dDogcmVzcG9uc2VUb0dlbmVyYXRpb25JbmZvKHJlc3BvbnNlKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2FmZVJlc3BvbnNlVG9DaGF0UmVzdWx0KHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBzYWZlUmVzcG9uc2VUbyhyZXNwb25zZSwgcmVzcG9uc2VUb0NoYXRSZXN1bHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnB1dFR5cGUoaW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIFwiTWVzc2FnZUNvbnRlbnRcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0SXRlbSA9IGlucHV0WzBdO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oZmlyc3RJdGVtLCBcImNvbnRlbnRcIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJCYXNlTWVzc2FnZUFycmF5XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJNZXNzYWdlQ29udGVudFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2VDb250ZW50cyhpbnB1dCwgX3BhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBhd2FpdCBtZXNzYWdlQ29udGVudFRvUGFydHMoaW5wdXQpO1xuICAgICAgICBjb25zdCBjb250ZW50cyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgICAgICBwYXJ0cyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBjb250ZW50cztcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZm9ybWF0QmFzZU1lc3NhZ2VDb250ZW50cyhpbnB1dCwgX3BhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3QgaW5wdXRQcm9taXNlcyA9IGlucHV0Lm1hcCgobXNnLCBpKSA9PiBiYXNlTWVzc2FnZVRvQ29udGVudChtc2csIGlucHV0W2kgLSAxXSkpO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBhd2FpdCBQcm9taXNlLmFsbChpbnB1dFByb21pc2VzKTtcbiAgICAgICAgcmV0dXJuIGlucHV0cy5yZWR1Y2UoKGFjYywgY3VyKSA9PiB7XG4gICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IHRoZSBzeXN0ZW0gY29udGVudFxuICAgICAgICAgICAgaWYgKGN1ci5ldmVyeSgoY29udGVudCkgPT4gY29udGVudC5yb2xlID09PSBcInN5c3RlbVwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb21iaW5lIGFkamFjZW50IGZ1bmN0aW9uIG1lc3NhZ2VzXG4gICAgICAgICAgICBpZiAoY3VyWzBdPy5yb2xlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICAgICBhY2MubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgIGFjY1thY2MubGVuZ3RoIC0gMV0ucm9sZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgYWNjW2FjYy5sZW5ndGggLSAxXS5wYXJ0cyA9IFtcbiAgICAgICAgICAgICAgICAgICAgLi4uYWNjW2FjYy5sZW5ndGggLSAxXS5wYXJ0cyxcbiAgICAgICAgICAgICAgICAgICAgLi4uY3VyWzBdLnBhcnRzLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY2MucHVzaCguLi5jdXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBmb3JtYXRDb250ZW50cyhpbnB1dCwgcGFyYW1ldGVycykge1xuICAgICAgICBjb25zdCBpdCA9IGlucHV0VHlwZShpbnB1dCk7XG4gICAgICAgIHN3aXRjaCAoaXQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJNZXNzYWdlQ29udGVudFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRNZXNzYWdlQ29udGVudHMoaW5wdXQsIHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgY2FzZSBcIkJhc2VNZXNzYWdlQXJyYXlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0QmFzZU1lc3NhZ2VDb250ZW50cyhpbnB1dCwgcGFyYW1ldGVycyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBpbnB1dCB0eXBlIFwiJHtpdH1cIjogJHtpbnB1dH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JtYXRHZW5lcmF0aW9uQ29uZmlnKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3QgcmV0ID0ge1xuICAgICAgICAgICAgdGVtcGVyYXR1cmU6IHBhcmFtZXRlcnMudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICB0b3BLOiBwYXJhbWV0ZXJzLnRvcEssXG4gICAgICAgICAgICB0b3BQOiBwYXJhbWV0ZXJzLnRvcFAsXG4gICAgICAgICAgICBwcmVzZW5jZVBlbmFsdHk6IHBhcmFtZXRlcnMucHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICAgICAgZnJlcXVlbmN5UGVuYWx0eTogcGFyYW1ldGVycy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgbWF4T3V0cHV0VG9rZW5zOiBwYXJhbWV0ZXJzLm1heE91dHB1dFRva2VucyxcbiAgICAgICAgICAgIHN0b3BTZXF1ZW5jZXM6IHBhcmFtZXRlcnMuc3RvcFNlcXVlbmNlcyxcbiAgICAgICAgICAgIHJlc3BvbnNlTWltZVR5cGU6IHBhcmFtZXRlcnMucmVzcG9uc2VNaW1lVHlwZSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQWRkIHRoZSBsb2dwcm9icyBpZiBleHBsaWNpdGx5IHNldFxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtZXRlcnMubG9ncHJvYnMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldC5yZXNwb25zZUxvZ3Byb2JzID0gcGFyYW1ldGVycy5sb2dwcm9icztcbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzLmxvZ3Byb2JzICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHBhcmFtZXRlcnMudG9wTG9ncHJvYnMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXQubG9ncHJvYnMgPSBwYXJhbWV0ZXJzLnRvcExvZ3Byb2JzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcm1hdFNhZmV0eVNldHRpbmdzKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnMuc2FmZXR5U2V0dGluZ3MgPz8gW107XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGZvcm1hdEJhc2VNZXNzYWdlU3lzdGVtSW5zdHJ1Y3Rpb24oaW5wdXQpIHtcbiAgICAgICAgbGV0IHJldCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgaW5wdXQubGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gaW5wdXRbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuX2dldFR5cGUoKSA9PT0gXCJzeXN0ZW1cIikge1xuICAgICAgICAgICAgICAgIC8vIEZvciBzeXN0ZW0gdHlwZXMsIHdlIG9ubHkgd2FudCBpdCBpZiBpdCBpcyB0aGUgZmlyc3QgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAvLyBpZiBpdCBhcHBlYXJzIGFueXdoZXJlIGVsc2UsIGl0IHNob3VsZCBiZSBhbiBlcnJvci5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IChhd2FpdCBiYXNlTWVzc2FnZVRvQ29udGVudChtZXNzYWdlLCB1bmRlZmluZWQpKVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN5c3RlbSBtZXNzYWdlcyBhcmUgb25seSBwZXJtaXR0ZWQgYXMgdGhlIGZpcnN0IHBhc3NlZCBtZXNzYWdlLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZm9ybWF0U3lzdGVtSW5zdHJ1Y3Rpb24oaW5wdXQpIHtcbiAgICAgICAgaWYgKCFjb25maWc/LnVzZVN5c3RlbUluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXQgPSBpbnB1dFR5cGUoaW5wdXQpO1xuICAgICAgICBzd2l0Y2ggKGl0KSB7XG4gICAgICAgICAgICBjYXNlIFwiQmFzZU1lc3NhZ2VBcnJheVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRCYXNlTWVzc2FnZVN5c3RlbUluc3RydWN0aW9uKGlucHV0KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0cnVjdHVyZWRUb29sVG9GdW5jdGlvbkRlY2xhcmF0aW9uKHRvb2wpIHtcbiAgICAgICAgY29uc3QganNvblNjaGVtYSA9ICgwLCB6b2RfdG9fZ2VtaW5pX3BhcmFtZXRlcnNfanNfMS56b2RUb0dlbWluaVBhcmFtZXRlcnMpKHRvb2wuc2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IHRvb2wubmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0b29sLmRlc2NyaXB0aW9uID8/IGBBIGZ1bmN0aW9uIGF2YWlsYWJsZSB0byBjYWxsLmAsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBqc29uU2NoZW1hLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZWFyY2hUb29sTmFtZSh0b29sKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiB0eXBlc19qc18xLkdlbWluaVNlYXJjaFRvb2xBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBpZiAobmFtZSBpbiB0b29sKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYW5HZW1pbmlUb29sKHRvb2wpIHtcbiAgICAgICAgY29uc3Qgb3JpZyA9IHNlYXJjaFRvb2xOYW1lKHRvb2wpO1xuICAgICAgICBjb25zdCBhZGogPSBjb25maWc/Lmdvb2dsZVNlYXJjaFRvb2xBZGp1c3RtZW50O1xuICAgICAgICBpZiAob3JpZyAmJiBhZGogJiYgYWRqICE9PSBvcmlnKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIFthZGpdOiB7fSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdG9vbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JtYXRUb29scyhwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGNvbnN0IHRvb2xzID0gcGFyYW1ldGVycz8udG9vbHM7XG4gICAgICAgIGlmICghdG9vbHMgfHwgdG9vbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gR3JvdXAgYWxsIExhbmdDaGFpbiB0b29scyBpbnRvIGEgc2luZ2xlIGZ1bmN0aW9uRGVjbGFyYXRpb25zIGFycmF5LlxuICAgICAgICAvLyBHZW1pbmkgVG9vbHMgbWF5IGJlIG5vcm1hbGl6ZWQgdG8gZGlmZmVyZW50IHRvb2wgbmFtZXNcbiAgICAgICAgY29uc3QgbGFuZ0NoYWluVG9vbHMgPSBbXTtcbiAgICAgICAgY29uc3Qgb3RoZXJUb29scyA9IFtdO1xuICAgICAgICB0b29scy5mb3JFYWNoKCh0b29sKSA9PiB7XG4gICAgICAgICAgICBpZiAoKDAsIGZ1bmN0aW9uX2NhbGxpbmdfMS5pc0xhbmdDaGFpblRvb2wpKHRvb2wpKSB7XG4gICAgICAgICAgICAgICAgbGFuZ0NoYWluVG9vbHMucHVzaCh0b29sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG90aGVyVG9vbHMucHVzaChjbGVhbkdlbWluaVRvb2wodG9vbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gWy4uLm90aGVyVG9vbHNdO1xuICAgICAgICBpZiAobGFuZ0NoYWluVG9vbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb25zOiBsYW5nQ2hhaW5Ub29scy5tYXAoc3RydWN0dXJlZFRvb2xUb0Z1bmN0aW9uRGVjbGFyYXRpb24pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9ybWF0VG9vbENvbmZpZyhwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGlmICghcGFyYW1ldGVycy50b29sX2Nob2ljZSB8fCB0eXBlb2YgcGFyYW1ldGVycy50b29sX2Nob2ljZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoW1wiYXV0b1wiLCBcImFueVwiLCBcIm5vbmVcIl0uaW5jbHVkZXMocGFyYW1ldGVycy50b29sX2Nob2ljZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25DYWxsaW5nQ29uZmlnOiB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IHBhcmFtZXRlcnMudG9vbF9jaG9pY2UsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93ZWRGdW5jdGlvbk5hbWVzOiBwYXJhbWV0ZXJzLmFsbG93ZWRfZnVuY3Rpb25fbmFtZXMsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gZm9yY2UgdG9vbCBjaG9pY2UgdG8gYmUgYSBzaW5nbGUgZnVuY3Rpb24gbmFtZSBpbiBjYXNlIG9mIHN0cnVjdHVyZWQgb3V0cHV0XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmdW5jdGlvbkNhbGxpbmdDb25maWc6IHtcbiAgICAgICAgICAgICAgICBtb2RlOiBcImFueVwiLFxuICAgICAgICAgICAgICAgIGFsbG93ZWRGdW5jdGlvbk5hbWVzOiBbcGFyYW1ldGVycy50b29sX2Nob2ljZV0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBmb3JtYXREYXRhKGlucHV0LCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGNvbnN0IHR5cGVkSW5wdXQgPSBpbnB1dDtcbiAgICAgICAgY29uc3QgY29udGVudHMgPSBhd2FpdCBmb3JtYXRDb250ZW50cyh0eXBlZElucHV0LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGlvbkNvbmZpZyA9IGZvcm1hdEdlbmVyYXRpb25Db25maWcocGFyYW1ldGVycyk7XG4gICAgICAgIGNvbnN0IHRvb2xzID0gZm9ybWF0VG9vbHMocGFyYW1ldGVycyk7XG4gICAgICAgIGNvbnN0IHRvb2xDb25maWcgPSBmb3JtYXRUb29sQ29uZmlnKHBhcmFtZXRlcnMpO1xuICAgICAgICBjb25zdCBzYWZldHlTZXR0aW5ncyA9IGZvcm1hdFNhZmV0eVNldHRpbmdzKHBhcmFtZXRlcnMpO1xuICAgICAgICBjb25zdCBzeXN0ZW1JbnN0cnVjdGlvbiA9IGF3YWl0IGZvcm1hdFN5c3RlbUluc3RydWN0aW9uKHR5cGVkSW5wdXQpO1xuICAgICAgICBjb25zdCByZXQgPSB7XG4gICAgICAgICAgICBjb250ZW50cyxcbiAgICAgICAgICAgIGdlbmVyYXRpb25Db25maWcsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0b29scyAmJiB0b29scy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldC50b29scyA9IHRvb2xzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b29sQ29uZmlnKSB7XG4gICAgICAgICAgICByZXQudG9vbENvbmZpZyA9IHRvb2xDb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNhZmV0eVNldHRpbmdzICYmIHNhZmV0eVNldHRpbmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0LnNhZmV0eVNldHRpbmdzID0gc2FmZXR5U2V0dGluZ3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN5c3RlbUluc3RydWN0aW9uPy5yb2xlICYmXG4gICAgICAgICAgICBzeXN0ZW1JbnN0cnVjdGlvbj8ucGFydHMgJiZcbiAgICAgICAgICAgIHN5c3RlbUluc3RydWN0aW9uPy5wYXJ0cz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXQuc3lzdGVtSW5zdHJ1Y3Rpb24gPSBzeXN0ZW1JbnN0cnVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBtZXNzYWdlQ29udGVudFRvUGFydHMsXG4gICAgICAgIGJhc2VNZXNzYWdlVG9Db250ZW50LFxuICAgICAgICByZXNwb25zZVRvU3RyaW5nOiBzYWZlUmVzcG9uc2VUb1N0cmluZyxcbiAgICAgICAgcmVzcG9uc2VUb0NoYXRHZW5lcmF0aW9uOiBzYWZlUmVzcG9uc2VUb0NoYXRHZW5lcmF0aW9uLFxuICAgICAgICBjaHVua1RvU3RyaW5nLFxuICAgICAgICByZXNwb25zZVRvQmFzZU1lc3NhZ2U6IHNhZmVSZXNwb25zZVRvQmFzZU1lc3NhZ2UsXG4gICAgICAgIHJlc3BvbnNlVG9DaGF0UmVzdWx0OiBzYWZlUmVzcG9uc2VUb0NoYXRSZXN1bHQsXG4gICAgICAgIGZvcm1hdERhdGEsXG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0R2VtaW5pQVBJID0gZ2V0R2VtaW5pQVBJO1xuZnVuY3Rpb24gdmFsaWRhdGVHZW1pbmlQYXJhbXMocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcy5tYXhPdXRwdXRUb2tlbnMgJiYgcGFyYW1zLm1heE91dHB1dFRva2VucyA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYG1heE91dHB1dFRva2Vuc2AgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJcIik7XG4gICAgfVxuICAgIGlmIChwYXJhbXMudGVtcGVyYXR1cmUgJiZcbiAgICAgICAgKHBhcmFtcy50ZW1wZXJhdHVyZSA8IDAgfHwgcGFyYW1zLnRlbXBlcmF0dXJlID4gMikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYHRlbXBlcmF0dXJlYCBtdXN0IGJlIGluIHRoZSByYW5nZSBvZiBbMC4wLDIuMF1cIik7XG4gICAgfVxuICAgIGlmIChwYXJhbXMudG9wUCAmJiAocGFyYW1zLnRvcFAgPCAwIHx8IHBhcmFtcy50b3BQID4gMSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYHRvcFBgIG11c3QgYmUgaW4gdGhlIHJhbmdlIG9mIFswLjAsMS4wXVwiKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy50b3BLICYmIHBhcmFtcy50b3BLIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgdG9wS2AgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJcIik7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUdlbWluaVBhcmFtcyA9IHZhbGlkYXRlR2VtaW5pUGFyYW1zO1xuZnVuY3Rpb24gaXNNb2RlbEdlbWluaShtb2RlbE5hbWUpIHtcbiAgICByZXR1cm4gbW9kZWxOYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcImdlbWluaVwiKTtcbn1cbmV4cG9ydHMuaXNNb2RlbEdlbWluaSA9IGlzTW9kZWxHZW1pbmk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/utils/gemini.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/utils/index.cjs":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/utils/index.cjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./common.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/common.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./failed_handler.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/failed_handler.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./gemini.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/gemini.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./zod_to_gemini_parameters.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/zod_to_gemini_parameters.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./palm.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/palm.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./safety.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/safety.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./stream.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/stream.cjs\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyx5RkFBYztBQUNuQyxhQUFhLG1CQUFPLENBQUMseUdBQXNCO0FBQzNDLGFBQWEsbUJBQU8sQ0FBQyx5RkFBYztBQUNuQyxhQUFhLG1CQUFPLENBQUMsNkhBQWdDO0FBQ3JELGFBQWEsbUJBQU8sQ0FBQyxxRkFBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMseUZBQWM7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLHlGQUFjIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29tbW9uLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZmFpbGVkX2hhbmRsZXIuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9nZW1pbmkuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi96b2RfdG9fZ2VtaW5pX3BhcmFtZXRlcnMuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wYWxtLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2FmZXR5LmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3RyZWFtLmNqc1wiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/utils/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/utils/palm.cjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/utils/palm.cjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvcGFsbS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vZGlzdC91dGlscy9wYWxtLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/utils/palm.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/utils/safety.cjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/utils/safety.cjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GoogleAISafetyError = void 0;\nclass GoogleAISafetyError extends Error {\n    constructor(response, message) {\n        super(message);\n        Object.defineProperty(this, \"response\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"reply\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"\"\n        });\n        this.response = response;\n    }\n}\nexports.GoogleAISafetyError = GoogleAISafetyError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvc2FmZXR5LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvc2FmZXR5LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR29vZ2xlQUlTYWZldHlFcnJvciA9IHZvaWQgMDtcbmNsYXNzIEdvb2dsZUFJU2FmZXR5RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc3BvbnNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlcGx5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcIlwiXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgfVxufVxuZXhwb3J0cy5Hb29nbGVBSVNhZmV0eUVycm9yID0gR29vZ2xlQUlTYWZldHlFcnJvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/utils/safety.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/utils/stream.cjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/utils/stream.cjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ReadableSseJsonStream = exports.SseJsonStream = exports.ReadableSseStream = exports.SseStream = exports.ReadableJsonStream = exports.ReadableAbstractStream = exports.ComplexJsonStream = exports.JsonStream = exports.simpleValue = exports.complexValue = void 0;\nfunction complexValue(value) {\n    if (value === null || typeof value === \"undefined\") {\n        // I dunno what to put here. An error, probably\n        return undefined;\n    }\n    else if (typeof value === \"object\") {\n        if (Array.isArray(value)) {\n            return {\n                list_val: value.map((avalue) => complexValue(avalue)),\n            };\n        }\n        else {\n            const ret = {};\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const v = value;\n            Object.keys(v).forEach((key) => {\n                ret[key] = complexValue(v[key]);\n            });\n            return { struct_val: ret };\n        }\n    }\n    else if (typeof value === \"number\") {\n        if (Number.isInteger(value)) {\n            return { int_val: value };\n        }\n        else {\n            return { float_val: value };\n        }\n    }\n    else {\n        return {\n            string_val: [value],\n        };\n    }\n}\nexports.complexValue = complexValue;\nfunction simpleValue(val) {\n    if (val && typeof val === \"object\" && !Array.isArray(val)) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (val.hasOwnProperty(\"stringVal\")) {\n            return val.stringVal[0];\n            // eslint-disable-next-line no-prototype-builtins\n        }\n        else if (val.hasOwnProperty(\"boolVal\")) {\n            return val.boolVal[0];\n            // eslint-disable-next-line no-prototype-builtins\n        }\n        else if (val.hasOwnProperty(\"listVal\")) {\n            const { listVal } = val;\n            return listVal.map((aval) => simpleValue(aval));\n            // eslint-disable-next-line no-prototype-builtins\n        }\n        else if (val.hasOwnProperty(\"structVal\")) {\n            const ret = {};\n            const struct = val.structVal;\n            Object.keys(struct).forEach((key) => {\n                ret[key] = simpleValue(struct[key]);\n            });\n            return ret;\n        }\n        else {\n            const ret = {};\n            const struct = val;\n            Object.keys(struct).forEach((key) => {\n                ret[key] = simpleValue(struct[key]);\n            });\n            return ret;\n        }\n    }\n    else if (Array.isArray(val)) {\n        return val.map((aval) => simpleValue(aval));\n    }\n    else {\n        return val;\n    }\n}\nexports.simpleValue = simpleValue;\nclass JsonStream {\n    constructor() {\n        Object.defineProperty(this, \"_buffer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"\"\n        });\n        Object.defineProperty(this, \"_bufferOpen\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"_firstRun\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        // Set up a potential Promise that the handler can resolve.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"_chunkResolution\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // If there is no Promise (it is null), the handler must add it to the queue\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"_chunkPending\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        // A queue that will collect chunks while there is no Promise\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"_chunkQueue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n    }\n    /**\n     * Add data to the buffer. This may cause chunks to be generated, if available.\n     * @param data\n     */\n    appendBuffer(data) {\n        this._buffer += data;\n        // Our first time, skip to the opening of the array\n        if (this._firstRun) {\n            this._skipTo(\"[\");\n            this._firstRun = false;\n        }\n        this._parseBuffer();\n    }\n    /**\n     * Indicate there is no more data that will be added to the text buffer.\n     * This should be called when all the data has been read and added to indicate\n     * that we should process everything remaining in the buffer.\n     */\n    closeBuffer() {\n        this._bufferOpen = false;\n        this._parseBuffer();\n    }\n    /**\n     * Skip characters in the buffer till we get to the start of an object.\n     * Then attempt to read a full object.\n     * If we do read a full object, turn it into a chunk and send it to the chunk handler.\n     * Repeat this for as much as we can.\n     */\n    _parseBuffer() {\n        let obj = null;\n        do {\n            this._skipTo(\"{\");\n            obj = this._getFullObject();\n            if (obj !== null) {\n                const chunk = this._simplifyObject(obj);\n                this._handleChunk(chunk);\n            }\n        } while (obj !== null);\n        if (!this._bufferOpen) {\n            // No more data will be added, and we have parsed everything we could,\n            // so everything else is garbage.\n            this._handleChunk(null);\n            this._buffer = \"\";\n        }\n    }\n    /**\n     * If the string is present, move the start of the buffer to the first occurrence\n     * of that string. This is useful for skipping over elements or parts that we're not\n     * really interested in parsing. (ie - the opening characters, comma separators, etc.)\n     * @param start The string to start the buffer with\n     */\n    _skipTo(start) {\n        const index = this._buffer.indexOf(start);\n        if (index > 0) {\n            this._buffer = this._buffer.slice(index);\n        }\n    }\n    /**\n     * Given what is in the buffer, parse a single object out of it.\n     * If a complete object isn't available, return null.\n     * Assumes that we are at the start of an object to parse.\n     */\n    _getFullObject() {\n        let ret = null;\n        // Loop while we don't have something to return AND we have something in the buffer\n        let index = 0;\n        while (ret === null && this._buffer.length > index) {\n            // Advance to the next close bracket after our current index\n            index = this._buffer.indexOf(\"}\", index + 1);\n            // If we don't find one, exit with null\n            if (index === -1) {\n                return null;\n            }\n            // If we have one, try to turn it into an object to return\n            try {\n                const objStr = this._buffer.substring(0, index + 1);\n                ret = JSON.parse(objStr);\n                // We only get here if it parsed it ok\n                // If we did turn it into an object, remove it from the buffer\n                this._buffer = this._buffer.slice(index + 1);\n            }\n            catch (xx) {\n                // It didn't parse it correctly, so we swallow the exception and continue\n            }\n        }\n        return ret;\n    }\n    _simplifyObject(obj) {\n        return obj;\n    }\n    /**\n     * Register that we have another chunk available for consumption.\n     * If we are waiting for a chunk, resolve the promise waiting for it immediately.\n     * If not, then add it to the queue.\n     * @param chunk\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _handleChunk(chunk) {\n        if (this._chunkPending) {\n            this._chunkResolution(chunk);\n            this._chunkPending = null;\n        }\n        else {\n            this._chunkQueue.push(chunk);\n        }\n    }\n    /**\n     * Get the next chunk that is coming from the stream.\n     * This chunk may be null, usually indicating the last chunk in the stream.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async nextChunk() {\n        if (this._chunkQueue.length > 0) {\n            // If there is data in the queue, return the next queue chunk\n            return this._chunkQueue.shift();\n        }\n        else {\n            // Otherwise, set up a promise that handleChunk will cause to be resolved\n            this._chunkPending = new Promise((resolve) => {\n                this._chunkResolution = resolve;\n            });\n            return this._chunkPending;\n        }\n    }\n    /**\n     * Is the stream done?\n     * A stream is only done if all of the following are true:\n     * - There is no more data to be added to the text buffer\n     * - There is no more data in the text buffer\n     * - There are no chunks that are waiting to be consumed\n     */\n    get streamDone() {\n        return (!this._bufferOpen &&\n            this._buffer.length === 0 &&\n            this._chunkQueue.length === 0 &&\n            this._chunkPending === null);\n    }\n}\nexports.JsonStream = JsonStream;\nclass ComplexJsonStream extends JsonStream {\n    _simplifyObject(obj) {\n        return simpleValue(obj);\n    }\n}\nexports.ComplexJsonStream = ComplexJsonStream;\nclass ReadableAbstractStream {\n    constructor(baseStream, body) {\n        Object.defineProperty(this, \"baseStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"decoder\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.baseStream = baseStream;\n        this.decoder = new TextDecoder(\"utf-8\");\n        if (body) {\n            void this.run(body);\n        }\n        else {\n            console.error(\"Unexpected empty body while streaming\");\n        }\n    }\n    appendBuffer(data) {\n        return this.baseStream.appendBuffer(data);\n    }\n    closeBuffer() {\n        return this.baseStream.closeBuffer();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    nextChunk() {\n        return this.baseStream.nextChunk();\n    }\n    get streamDone() {\n        return this.baseStream.streamDone;\n    }\n    async run(body) {\n        const reader = body.getReader();\n        let isDone = false;\n        while (!isDone) {\n            const { value, done } = await reader.read();\n            if (!done) {\n                const svalue = this.decoder.decode(value, { stream: true });\n                this.appendBuffer(svalue);\n            }\n            else {\n                isDone = done;\n                this.closeBuffer();\n            }\n        }\n    }\n}\nexports.ReadableAbstractStream = ReadableAbstractStream;\nclass ReadableJsonStream extends ReadableAbstractStream {\n    constructor(body) {\n        super(new JsonStream(), body);\n    }\n}\nexports.ReadableJsonStream = ReadableJsonStream;\nclass SseStream {\n    constructor() {\n        Object.defineProperty(this, \"_buffer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"\"\n        });\n        Object.defineProperty(this, \"_bufferOpen\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        // Set up a potential Promise that the handler can resolve.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"_chunkResolution\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // If there is no Promise (it is null), the handler must add it to the queue\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"_chunkPending\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        // A queue that will collect chunks while there is no Promise\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"_chunkQueue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n    }\n    appendBuffer(data) {\n        this._buffer += data;\n        this._parseBuffer();\n    }\n    closeBuffer() {\n        this._bufferOpen = false;\n        this._parseBuffer();\n    }\n    /**\n     * Attempt to load an entire event.\n     * For each entire event we load,\n     * send them to be handled.\n     */\n    _parseBuffer() {\n        const events = this._buffer.split(/\\n\\n/);\n        this._buffer = events.pop() ?? \"\";\n        events.forEach((event) => this._handleEvent(event.trim()));\n        if (!this._bufferOpen) {\n            // No more data will be added, and we have parsed\n            // everything. So dump the rest.\n            this._handleEvent(null);\n            this._buffer = \"\";\n        }\n    }\n    /**\n     * Given an event string, get all the fields\n     * in the event. It is assumed there is one field\n     * per line, but that field names can be duplicated,\n     * indicating to append the new value to the previous value\n     * @param event\n     */\n    _parseEvent(event) {\n        if (!event || event.trim() === \"\") {\n            return null;\n        }\n        const ret = {};\n        const lines = event.split(/\\n/);\n        lines.forEach((line) => {\n            const match = line.match(/^([^:]+): \\s*(.+)\\n*$/);\n            if (match && match.length === 3) {\n                const key = match[1];\n                const val = match[2];\n                const cur = ret[key] ?? \"\";\n                ret[key] = `${cur}${val}`;\n            }\n        });\n        return ret;\n    }\n    _handleEvent(event) {\n        const chunk = this._parseEvent(event);\n        if (this._chunkPending) {\n            this._chunkResolution(chunk);\n            this._chunkPending = null;\n        }\n        else {\n            this._chunkQueue.push(chunk);\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async nextChunk() {\n        if (this._chunkQueue.length > 0) {\n            // If there is data in the queue, return the next queue chunk\n            return this._chunkQueue.shift();\n        }\n        else {\n            // Otherwise, set up a promise that handleChunk will cause to be resolved\n            this._chunkPending = new Promise((resolve) => {\n                this._chunkResolution = resolve;\n            });\n            return this._chunkPending;\n        }\n    }\n    get streamDone() {\n        return (!this._bufferOpen &&\n            this._buffer.length === 0 &&\n            this._chunkQueue.length === 0 &&\n            this._chunkPending === null);\n    }\n}\nexports.SseStream = SseStream;\nclass ReadableSseStream extends ReadableAbstractStream {\n    constructor(body) {\n        super(new SseStream(), body);\n    }\n}\nexports.ReadableSseStream = ReadableSseStream;\nclass SseJsonStream extends SseStream {\n    constructor(jsonAttribute) {\n        super();\n        Object.defineProperty(this, \"_jsonAttribute\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"data\"\n        });\n        this._jsonAttribute = jsonAttribute ?? this._jsonAttribute;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async nextChunk() {\n        const eventRecord = (await super.nextChunk());\n        const json = eventRecord?.[this._jsonAttribute];\n        if (!json) {\n            return null;\n        }\n        else {\n            return JSON.parse(json);\n        }\n    }\n}\nexports.SseJsonStream = SseJsonStream;\nclass ReadableSseJsonStream extends ReadableAbstractStream {\n    constructor(body) {\n        super(new SseJsonStream(), body);\n    }\n}\nexports.ReadableSseJsonStream = ReadableSseJsonStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvc3RyZWFtLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyxxQkFBcUIsR0FBRyx5QkFBeUIsR0FBRyxpQkFBaUIsR0FBRywwQkFBMEIsR0FBRyw4QkFBOEIsR0FBRyx5QkFBeUIsR0FBRyxrQkFBa0IsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0I7QUFDalE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBLDREQUE0RCxjQUFjO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixJQUFJLEVBQUUsSUFBSTtBQUN4QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvc3RyZWFtLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVhZGFibGVTc2VKc29uU3RyZWFtID0gZXhwb3J0cy5Tc2VKc29uU3RyZWFtID0gZXhwb3J0cy5SZWFkYWJsZVNzZVN0cmVhbSA9IGV4cG9ydHMuU3NlU3RyZWFtID0gZXhwb3J0cy5SZWFkYWJsZUpzb25TdHJlYW0gPSBleHBvcnRzLlJlYWRhYmxlQWJzdHJhY3RTdHJlYW0gPSBleHBvcnRzLkNvbXBsZXhKc29uU3RyZWFtID0gZXhwb3J0cy5Kc29uU3RyZWFtID0gZXhwb3J0cy5zaW1wbGVWYWx1ZSA9IGV4cG9ydHMuY29tcGxleFZhbHVlID0gdm9pZCAwO1xuZnVuY3Rpb24gY29tcGxleFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBJIGR1bm5vIHdoYXQgdG8gcHV0IGhlcmUuIEFuIGVycm9yLCBwcm9iYWJseVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxpc3RfdmFsOiB2YWx1ZS5tYXAoKGF2YWx1ZSkgPT4gY29tcGxleFZhbHVlKGF2YWx1ZSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHt9O1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGNvbnN0IHYgPSB2YWx1ZTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHYpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldFtrZXldID0gY29tcGxleFZhbHVlKHZba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IHN0cnVjdF92YWw6IHJldCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGludF92YWw6IHZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBmbG9hdF92YWw6IHZhbHVlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdHJpbmdfdmFsOiBbdmFsdWVdLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuY29tcGxleFZhbHVlID0gY29tcGxleFZhbHVlO1xuZnVuY3Rpb24gc2ltcGxlVmFsdWUodmFsKSB7XG4gICAgaWYgKHZhbCAmJiB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICBpZiAodmFsLmhhc093blByb3BlcnR5KFwic3RyaW5nVmFsXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsLnN0cmluZ1ZhbFswXTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwuaGFzT3duUHJvcGVydHkoXCJib29sVmFsXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsLmJvb2xWYWxbMF07XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsLmhhc093blByb3BlcnR5KFwibGlzdFZhbFwiKSkge1xuICAgICAgICAgICAgY29uc3QgeyBsaXN0VmFsIH0gPSB2YWw7XG4gICAgICAgICAgICByZXR1cm4gbGlzdFZhbC5tYXAoKGF2YWwpID0+IHNpbXBsZVZhbHVlKGF2YWwpKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwuaGFzT3duUHJvcGVydHkoXCJzdHJ1Y3RWYWxcIikpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHt9O1xuICAgICAgICAgICAgY29uc3Qgc3RydWN0ID0gdmFsLnN0cnVjdFZhbDtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHN0cnVjdCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0W2tleV0gPSBzaW1wbGVWYWx1ZShzdHJ1Y3Rba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IHZhbDtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHN0cnVjdCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0W2tleV0gPSBzaW1wbGVWYWx1ZShzdHJ1Y3Rba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHJldHVybiB2YWwubWFwKChhdmFsKSA9PiBzaW1wbGVWYWx1ZShhdmFsKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbn1cbmV4cG9ydHMuc2ltcGxlVmFsdWUgPSBzaW1wbGVWYWx1ZTtcbmNsYXNzIEpzb25TdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfYnVmZmVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcIlwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfYnVmZmVyT3BlblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ZpcnN0UnVuXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgdXAgYSBwb3RlbnRpYWwgUHJvbWlzZSB0aGF0IHRoZSBoYW5kbGVyIGNhbiByZXNvbHZlLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfY2h1bmtSZXNvbHV0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIFByb21pc2UgKGl0IGlzIG51bGwpLCB0aGUgaGFuZGxlciBtdXN0IGFkZCBpdCB0byB0aGUgcXVldWVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NodW5rUGVuZGluZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQSBxdWV1ZSB0aGF0IHdpbGwgY29sbGVjdCBjaHVua3Mgd2hpbGUgdGhlcmUgaXMgbm8gUHJvbWlzZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfY2h1bmtRdWV1ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBkYXRhIHRvIHRoZSBidWZmZXIuIFRoaXMgbWF5IGNhdXNlIGNodW5rcyB0byBiZSBnZW5lcmF0ZWQsIGlmIGF2YWlsYWJsZS5cbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIGFwcGVuZEJ1ZmZlcihkYXRhKSB7XG4gICAgICAgIHRoaXMuX2J1ZmZlciArPSBkYXRhO1xuICAgICAgICAvLyBPdXIgZmlyc3QgdGltZSwgc2tpcCB0byB0aGUgb3BlbmluZyBvZiB0aGUgYXJyYXlcbiAgICAgICAgaWYgKHRoaXMuX2ZpcnN0UnVuKSB7XG4gICAgICAgICAgICB0aGlzLl9za2lwVG8oXCJbXCIpO1xuICAgICAgICAgICAgdGhpcy5fZmlyc3RSdW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYXJzZUJ1ZmZlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZSB0aGVyZSBpcyBubyBtb3JlIGRhdGEgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0ZXh0IGJ1ZmZlci5cbiAgICAgKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgd2hlbiBhbGwgdGhlIGRhdGEgaGFzIGJlZW4gcmVhZCBhbmQgYWRkZWQgdG8gaW5kaWNhdGVcbiAgICAgKiB0aGF0IHdlIHNob3VsZCBwcm9jZXNzIGV2ZXJ5dGhpbmcgcmVtYWluaW5nIGluIHRoZSBidWZmZXIuXG4gICAgICovXG4gICAgY2xvc2VCdWZmZXIoKSB7XG4gICAgICAgIHRoaXMuX2J1ZmZlck9wZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcGFyc2VCdWZmZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2tpcCBjaGFyYWN0ZXJzIGluIHRoZSBidWZmZXIgdGlsbCB3ZSBnZXQgdG8gdGhlIHN0YXJ0IG9mIGFuIG9iamVjdC5cbiAgICAgKiBUaGVuIGF0dGVtcHQgdG8gcmVhZCBhIGZ1bGwgb2JqZWN0LlxuICAgICAqIElmIHdlIGRvIHJlYWQgYSBmdWxsIG9iamVjdCwgdHVybiBpdCBpbnRvIGEgY2h1bmsgYW5kIHNlbmQgaXQgdG8gdGhlIGNodW5rIGhhbmRsZXIuXG4gICAgICogUmVwZWF0IHRoaXMgZm9yIGFzIG11Y2ggYXMgd2UgY2FuLlxuICAgICAqL1xuICAgIF9wYXJzZUJ1ZmZlcigpIHtcbiAgICAgICAgbGV0IG9iaiA9IG51bGw7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHRoaXMuX3NraXBUbyhcIntcIik7XG4gICAgICAgICAgICBvYmogPSB0aGlzLl9nZXRGdWxsT2JqZWN0KCk7XG4gICAgICAgICAgICBpZiAob2JqICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9zaW1wbGlmeU9iamVjdChvYmopO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUNodW5rKGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAob2JqICE9PSBudWxsKTtcbiAgICAgICAgaWYgKCF0aGlzLl9idWZmZXJPcGVuKSB7XG4gICAgICAgICAgICAvLyBObyBtb3JlIGRhdGEgd2lsbCBiZSBhZGRlZCwgYW5kIHdlIGhhdmUgcGFyc2VkIGV2ZXJ5dGhpbmcgd2UgY291bGQsXG4gICAgICAgICAgICAvLyBzbyBldmVyeXRoaW5nIGVsc2UgaXMgZ2FyYmFnZS5cbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUNodW5rKG51bGwpO1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgc3RyaW5nIGlzIHByZXNlbnQsIG1vdmUgdGhlIHN0YXJ0IG9mIHRoZSBidWZmZXIgdG8gdGhlIGZpcnN0IG9jY3VycmVuY2VcbiAgICAgKiBvZiB0aGF0IHN0cmluZy4gVGhpcyBpcyB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgZWxlbWVudHMgb3IgcGFydHMgdGhhdCB3ZSdyZSBub3RcbiAgICAgKiByZWFsbHkgaW50ZXJlc3RlZCBpbiBwYXJzaW5nLiAoaWUgLSB0aGUgb3BlbmluZyBjaGFyYWN0ZXJzLCBjb21tYSBzZXBhcmF0b3JzLCBldGMuKVxuICAgICAqIEBwYXJhbSBzdGFydCBUaGUgc3RyaW5nIHRvIHN0YXJ0IHRoZSBidWZmZXIgd2l0aFxuICAgICAqL1xuICAgIF9za2lwVG8oc3RhcnQpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9idWZmZXIuaW5kZXhPZihzdGFydCk7XG4gICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlciA9IHRoaXMuX2J1ZmZlci5zbGljZShpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gd2hhdCBpcyBpbiB0aGUgYnVmZmVyLCBwYXJzZSBhIHNpbmdsZSBvYmplY3Qgb3V0IG9mIGl0LlxuICAgICAqIElmIGEgY29tcGxldGUgb2JqZWN0IGlzbid0IGF2YWlsYWJsZSwgcmV0dXJuIG51bGwuXG4gICAgICogQXNzdW1lcyB0aGF0IHdlIGFyZSBhdCB0aGUgc3RhcnQgb2YgYW4gb2JqZWN0IHRvIHBhcnNlLlxuICAgICAqL1xuICAgIF9nZXRGdWxsT2JqZWN0KCkge1xuICAgICAgICBsZXQgcmV0ID0gbnVsbDtcbiAgICAgICAgLy8gTG9vcCB3aGlsZSB3ZSBkb24ndCBoYXZlIHNvbWV0aGluZyB0byByZXR1cm4gQU5EIHdlIGhhdmUgc29tZXRoaW5nIGluIHRoZSBidWZmZXJcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKHJldCA9PT0gbnVsbCAmJiB0aGlzLl9idWZmZXIubGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2UgYnJhY2tldCBhZnRlciBvdXIgY3VycmVudCBpbmRleFxuICAgICAgICAgICAgaW5kZXggPSB0aGlzLl9idWZmZXIuaW5kZXhPZihcIn1cIiwgaW5kZXggKyAxKTtcbiAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGZpbmQgb25lLCBleGl0IHdpdGggbnVsbFxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBvbmUsIHRyeSB0byB0dXJuIGl0IGludG8gYW4gb2JqZWN0IHRvIHJldHVyblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmpTdHIgPSB0aGlzLl9idWZmZXIuc3Vic3RyaW5nKDAsIGluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgcmV0ID0gSlNPTi5wYXJzZShvYmpTdHIpO1xuICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgZ2V0IGhlcmUgaWYgaXQgcGFyc2VkIGl0IG9rXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZGlkIHR1cm4gaXQgaW50byBhbiBvYmplY3QsIHJlbW92ZSBpdCBmcm9tIHRoZSBidWZmZXJcbiAgICAgICAgICAgICAgICB0aGlzLl9idWZmZXIgPSB0aGlzLl9idWZmZXIuc2xpY2UoaW5kZXggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoICh4eCkge1xuICAgICAgICAgICAgICAgIC8vIEl0IGRpZG4ndCBwYXJzZSBpdCBjb3JyZWN0bHksIHNvIHdlIHN3YWxsb3cgdGhlIGV4Y2VwdGlvbiBhbmQgY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBfc2ltcGxpZnlPYmplY3Qob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIHRoYXQgd2UgaGF2ZSBhbm90aGVyIGNodW5rIGF2YWlsYWJsZSBmb3IgY29uc3VtcHRpb24uXG4gICAgICogSWYgd2UgYXJlIHdhaXRpbmcgZm9yIGEgY2h1bmssIHJlc29sdmUgdGhlIHByb21pc2Ugd2FpdGluZyBmb3IgaXQgaW1tZWRpYXRlbHkuXG4gICAgICogSWYgbm90LCB0aGVuIGFkZCBpdCB0byB0aGUgcXVldWUuXG4gICAgICogQHBhcmFtIGNodW5rXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBfaGFuZGxlQ2h1bmsoY2h1bmspIHtcbiAgICAgICAgaWYgKHRoaXMuX2NodW5rUGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy5fY2h1bmtSZXNvbHV0aW9uKGNodW5rKTtcbiAgICAgICAgICAgIHRoaXMuX2NodW5rUGVuZGluZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jaHVua1F1ZXVlLnB1c2goY2h1bmspO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmV4dCBjaHVuayB0aGF0IGlzIGNvbWluZyBmcm9tIHRoZSBzdHJlYW0uXG4gICAgICogVGhpcyBjaHVuayBtYXkgYmUgbnVsbCwgdXN1YWxseSBpbmRpY2F0aW5nIHRoZSBsYXN0IGNodW5rIGluIHRoZSBzdHJlYW0uXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBhc3luYyBuZXh0Q2h1bmsoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jaHVua1F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGRhdGEgaW4gdGhlIHF1ZXVlLCByZXR1cm4gdGhlIG5leHQgcXVldWUgY2h1bmtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaHVua1F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHNldCB1cCBhIHByb21pc2UgdGhhdCBoYW5kbGVDaHVuayB3aWxsIGNhdXNlIHRvIGJlIHJlc29sdmVkXG4gICAgICAgICAgICB0aGlzLl9jaHVua1BlbmRpbmcgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NodW5rUmVzb2x1dGlvbiA9IHJlc29sdmU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaHVua1BlbmRpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhlIHN0cmVhbSBkb25lP1xuICAgICAqIEEgc3RyZWFtIGlzIG9ubHkgZG9uZSBpZiBhbGwgb2YgdGhlIGZvbGxvd2luZyBhcmUgdHJ1ZTpcbiAgICAgKiAtIFRoZXJlIGlzIG5vIG1vcmUgZGF0YSB0byBiZSBhZGRlZCB0byB0aGUgdGV4dCBidWZmZXJcbiAgICAgKiAtIFRoZXJlIGlzIG5vIG1vcmUgZGF0YSBpbiB0aGUgdGV4dCBidWZmZXJcbiAgICAgKiAtIFRoZXJlIGFyZSBubyBjaHVua3MgdGhhdCBhcmUgd2FpdGluZyB0byBiZSBjb25zdW1lZFxuICAgICAqL1xuICAgIGdldCBzdHJlYW1Eb25lKCkge1xuICAgICAgICByZXR1cm4gKCF0aGlzLl9idWZmZXJPcGVuICYmXG4gICAgICAgICAgICB0aGlzLl9idWZmZXIubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICB0aGlzLl9jaHVua1F1ZXVlLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgdGhpcy5fY2h1bmtQZW5kaW5nID09PSBudWxsKTtcbiAgICB9XG59XG5leHBvcnRzLkpzb25TdHJlYW0gPSBKc29uU3RyZWFtO1xuY2xhc3MgQ29tcGxleEpzb25TdHJlYW0gZXh0ZW5kcyBKc29uU3RyZWFtIHtcbiAgICBfc2ltcGxpZnlPYmplY3Qob2JqKSB7XG4gICAgICAgIHJldHVybiBzaW1wbGVWYWx1ZShvYmopO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29tcGxleEpzb25TdHJlYW0gPSBDb21wbGV4SnNvblN0cmVhbTtcbmNsYXNzIFJlYWRhYmxlQWJzdHJhY3RTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKGJhc2VTdHJlYW0sIGJvZHkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYmFzZVN0cmVhbVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWNvZGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYmFzZVN0cmVhbSA9IGJhc2VTdHJlYW07XG4gICAgICAgIHRoaXMuZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpO1xuICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgICAgdm9pZCB0aGlzLnJ1bihib2R5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmV4cGVjdGVkIGVtcHR5IGJvZHkgd2hpbGUgc3RyZWFtaW5nXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGVuZEJ1ZmZlcihkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VTdHJlYW0uYXBwZW5kQnVmZmVyKGRhdGEpO1xuICAgIH1cbiAgICBjbG9zZUJ1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVN0cmVhbS5jbG9zZUJ1ZmZlcigpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIG5leHRDaHVuaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVN0cmVhbS5uZXh0Q2h1bmsoKTtcbiAgICB9XG4gICAgZ2V0IHN0cmVhbURvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VTdHJlYW0uc3RyZWFtRG9uZTtcbiAgICB9XG4gICAgYXN5bmMgcnVuKGJvZHkpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgICAgbGV0IGlzRG9uZSA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoIWlzRG9uZSkge1xuICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN2YWx1ZSA9IHRoaXMuZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kQnVmZmVyKHN2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc0RvbmUgPSBkb25lO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VCdWZmZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUmVhZGFibGVBYnN0cmFjdFN0cmVhbSA9IFJlYWRhYmxlQWJzdHJhY3RTdHJlYW07XG5jbGFzcyBSZWFkYWJsZUpzb25TdHJlYW0gZXh0ZW5kcyBSZWFkYWJsZUFic3RyYWN0U3RyZWFtIHtcbiAgICBjb25zdHJ1Y3Rvcihib2R5KSB7XG4gICAgICAgIHN1cGVyKG5ldyBKc29uU3RyZWFtKCksIGJvZHkpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVhZGFibGVKc29uU3RyZWFtID0gUmVhZGFibGVKc29uU3RyZWFtO1xuY2xhc3MgU3NlU3RyZWFtIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2J1ZmZlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2J1ZmZlck9wZW5cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNldCB1cCBhIHBvdGVudGlhbCBQcm9taXNlIHRoYXQgdGhlIGhhbmRsZXIgY2FuIHJlc29sdmUuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jaHVua1Jlc29sdXRpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gUHJvbWlzZSAoaXQgaXMgbnVsbCksIHRoZSBoYW5kbGVyIG11c3QgYWRkIGl0IHRvIHRoZSBxdWV1ZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfY2h1bmtQZW5kaW5nXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBIHF1ZXVlIHRoYXQgd2lsbCBjb2xsZWN0IGNodW5rcyB3aGlsZSB0aGVyZSBpcyBubyBQcm9taXNlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jaHVua1F1ZXVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXBwZW5kQnVmZmVyKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fYnVmZmVyICs9IGRhdGE7XG4gICAgICAgIHRoaXMuX3BhcnNlQnVmZmVyKCk7XG4gICAgfVxuICAgIGNsb3NlQnVmZmVyKCkge1xuICAgICAgICB0aGlzLl9idWZmZXJPcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BhcnNlQnVmZmVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgdG8gbG9hZCBhbiBlbnRpcmUgZXZlbnQuXG4gICAgICogRm9yIGVhY2ggZW50aXJlIGV2ZW50IHdlIGxvYWQsXG4gICAgICogc2VuZCB0aGVtIHRvIGJlIGhhbmRsZWQuXG4gICAgICovXG4gICAgX3BhcnNlQnVmZmVyKCkge1xuICAgICAgICBjb25zdCBldmVudHMgPSB0aGlzLl9idWZmZXIuc3BsaXQoL1xcblxcbi8pO1xuICAgICAgICB0aGlzLl9idWZmZXIgPSBldmVudHMucG9wKCkgPz8gXCJcIjtcbiAgICAgICAgZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB0aGlzLl9oYW5kbGVFdmVudChldmVudC50cmltKCkpKTtcbiAgICAgICAgaWYgKCF0aGlzLl9idWZmZXJPcGVuKSB7XG4gICAgICAgICAgICAvLyBObyBtb3JlIGRhdGEgd2lsbCBiZSBhZGRlZCwgYW5kIHdlIGhhdmUgcGFyc2VkXG4gICAgICAgICAgICAvLyBldmVyeXRoaW5nLiBTbyBkdW1wIHRoZSByZXN0LlxuICAgICAgICAgICAgdGhpcy5faGFuZGxlRXZlbnQobnVsbCk7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXIgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGFuIGV2ZW50IHN0cmluZywgZ2V0IGFsbCB0aGUgZmllbGRzXG4gICAgICogaW4gdGhlIGV2ZW50LiBJdCBpcyBhc3N1bWVkIHRoZXJlIGlzIG9uZSBmaWVsZFxuICAgICAqIHBlciBsaW5lLCBidXQgdGhhdCBmaWVsZCBuYW1lcyBjYW4gYmUgZHVwbGljYXRlZCxcbiAgICAgKiBpbmRpY2F0aW5nIHRvIGFwcGVuZCB0aGUgbmV3IHZhbHVlIHRvIHRoZSBwcmV2aW91cyB2YWx1ZVxuICAgICAqIEBwYXJhbSBldmVudFxuICAgICAqL1xuICAgIF9wYXJzZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmICghZXZlbnQgfHwgZXZlbnQudHJpbSgpID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSB7fTtcbiAgICAgICAgY29uc3QgbGluZXMgPSBldmVudC5zcGxpdCgvXFxuLyk7XG4gICAgICAgIGxpbmVzLmZvckVhY2goKGxpbmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gbGluZS5tYXRjaCgvXihbXjpdKyk6IFxccyooLispXFxuKiQvKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBtYXRjaFsyXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXIgPSByZXRba2V5XSA/PyBcIlwiO1xuICAgICAgICAgICAgICAgIHJldFtrZXldID0gYCR7Y3VyfSR7dmFsfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBfaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9wYXJzZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgaWYgKHRoaXMuX2NodW5rUGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy5fY2h1bmtSZXNvbHV0aW9uKGNodW5rKTtcbiAgICAgICAgICAgIHRoaXMuX2NodW5rUGVuZGluZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jaHVua1F1ZXVlLnB1c2goY2h1bmspO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgYXN5bmMgbmV4dENodW5rKCkge1xuICAgICAgICBpZiAodGhpcy5fY2h1bmtRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBkYXRhIGluIHRoZSBxdWV1ZSwgcmV0dXJuIHRoZSBuZXh0IHF1ZXVlIGNodW5rXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2h1bmtRdWV1ZS5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBzZXQgdXAgYSBwcm9taXNlIHRoYXQgaGFuZGxlQ2h1bmsgd2lsbCBjYXVzZSB0byBiZSByZXNvbHZlZFxuICAgICAgICAgICAgdGhpcy5fY2h1bmtQZW5kaW5nID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaHVua1Jlc29sdXRpb24gPSByZXNvbHZlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2h1bmtQZW5kaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzdHJlYW1Eb25lKCkge1xuICAgICAgICByZXR1cm4gKCF0aGlzLl9idWZmZXJPcGVuICYmXG4gICAgICAgICAgICB0aGlzLl9idWZmZXIubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICB0aGlzLl9jaHVua1F1ZXVlLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgdGhpcy5fY2h1bmtQZW5kaW5nID09PSBudWxsKTtcbiAgICB9XG59XG5leHBvcnRzLlNzZVN0cmVhbSA9IFNzZVN0cmVhbTtcbmNsYXNzIFJlYWRhYmxlU3NlU3RyZWFtIGV4dGVuZHMgUmVhZGFibGVBYnN0cmFjdFN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoYm9keSkge1xuICAgICAgICBzdXBlcihuZXcgU3NlU3RyZWFtKCksIGJvZHkpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVhZGFibGVTc2VTdHJlYW0gPSBSZWFkYWJsZVNzZVN0cmVhbTtcbmNsYXNzIFNzZUpzb25TdHJlYW0gZXh0ZW5kcyBTc2VTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKGpzb25BdHRyaWJ1dGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2pzb25BdHRyaWJ1dGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiZGF0YVwiXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9qc29uQXR0cmlidXRlID0ganNvbkF0dHJpYnV0ZSA/PyB0aGlzLl9qc29uQXR0cmlidXRlO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGFzeW5jIG5leHRDaHVuaygpIHtcbiAgICAgICAgY29uc3QgZXZlbnRSZWNvcmQgPSAoYXdhaXQgc3VwZXIubmV4dENodW5rKCkpO1xuICAgICAgICBjb25zdCBqc29uID0gZXZlbnRSZWNvcmQ/Llt0aGlzLl9qc29uQXR0cmlidXRlXTtcbiAgICAgICAgaWYgKCFqc29uKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Tc2VKc29uU3RyZWFtID0gU3NlSnNvblN0cmVhbTtcbmNsYXNzIFJlYWRhYmxlU3NlSnNvblN0cmVhbSBleHRlbmRzIFJlYWRhYmxlQWJzdHJhY3RTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKGJvZHkpIHtcbiAgICAgICAgc3VwZXIobmV3IFNzZUpzb25TdHJlYW0oKSwgYm9keSk7XG4gICAgfVxufVxuZXhwb3J0cy5SZWFkYWJsZVNzZUpzb25TdHJlYW0gPSBSZWFkYWJsZVNzZUpzb25TdHJlYW07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/utils/stream.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/utils/zod_to_gemini_parameters.cjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/utils/zod_to_gemini_parameters.cjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* eslint-disable @typescript-eslint/no-unused-vars */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.jsonSchemaToGeminiParameters = exports.zodToGeminiParameters = exports.removeAdditionalProperties = void 0;\nconst zod_to_json_schema_1 = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/cjs/index.js\");\nfunction removeAdditionalProperties(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nobj) {\n    if (typeof obj === \"object\" && obj !== null) {\n        const newObj = { ...obj };\n        if (\"additionalProperties\" in newObj) {\n            delete newObj.additionalProperties;\n        }\n        for (const key in newObj) {\n            if (key in newObj) {\n                if (Array.isArray(newObj[key])) {\n                    newObj[key] = newObj[key].map(removeAdditionalProperties);\n                }\n                else if (typeof newObj[key] === \"object\" && newObj[key] !== null) {\n                    newObj[key] = removeAdditionalProperties(newObj[key]);\n                }\n            }\n        }\n        return newObj;\n    }\n    return obj;\n}\nexports.removeAdditionalProperties = removeAdditionalProperties;\nfunction zodToGeminiParameters(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nzodObj) {\n    // Gemini doesn't accept either the $schema or additionalProperties\n    // attributes, so we need to explicitly remove them.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const jsonSchema = removeAdditionalProperties((0, zod_to_json_schema_1.zodToJsonSchema)(zodObj));\n    const { $schema, ...rest } = jsonSchema;\n    return rest;\n}\nexports.zodToGeminiParameters = zodToGeminiParameters;\nfunction jsonSchemaToGeminiParameters(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nschema) {\n    // Gemini doesn't accept either the $schema or additionalProperties\n    // attributes, so we need to explicitly remove them.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const jsonSchema = removeAdditionalProperties(schema);\n    const { $schema, ...rest } = jsonSchema;\n    return rest;\n}\nexports.jsonSchemaToGeminiParameters = jsonSchemaToGeminiParameters;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvem9kX3RvX2dlbWluaV9wYXJhbWV0ZXJzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9DQUFvQyxHQUFHLDZCQUE2QixHQUFHLGtDQUFrQztBQUN6Ryw2QkFBNkIsbUJBQU8sQ0FBQyxxRkFBb0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0Esb0NBQW9DIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvem9kX3RvX2dlbWluaV9wYXJhbWV0ZXJzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5qc29uU2NoZW1hVG9HZW1pbmlQYXJhbWV0ZXJzID0gZXhwb3J0cy56b2RUb0dlbWluaVBhcmFtZXRlcnMgPSBleHBvcnRzLnJlbW92ZUFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gdm9pZCAwO1xuY29uc3Qgem9kX3RvX2pzb25fc2NoZW1hXzEgPSByZXF1aXJlKFwiem9kLXRvLWpzb24tc2NoZW1hXCIpO1xuZnVuY3Rpb24gcmVtb3ZlQWRkaXRpb25hbFByb3BlcnRpZXMoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxub2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG5ld09iaiA9IHsgLi4ub2JqIH07XG4gICAgICAgIGlmIChcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIgaW4gbmV3T2JqKSB7XG4gICAgICAgICAgICBkZWxldGUgbmV3T2JqLmFkZGl0aW9uYWxQcm9wZXJ0aWVzO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5ld09iaikge1xuICAgICAgICAgICAgaWYgKGtleSBpbiBuZXdPYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShuZXdPYmpba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBuZXdPYmpba2V5XS5tYXAocmVtb3ZlQWRkaXRpb25hbFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbmV3T2JqW2tleV0gPT09IFwib2JqZWN0XCIgJiYgbmV3T2JqW2tleV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3T2JqW2tleV0gPSByZW1vdmVBZGRpdGlvbmFsUHJvcGVydGllcyhuZXdPYmpba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5leHBvcnRzLnJlbW92ZUFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gcmVtb3ZlQWRkaXRpb25hbFByb3BlcnRpZXM7XG5mdW5jdGlvbiB6b2RUb0dlbWluaVBhcmFtZXRlcnMoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuem9kT2JqKSB7XG4gICAgLy8gR2VtaW5pIGRvZXNuJ3QgYWNjZXB0IGVpdGhlciB0aGUgJHNjaGVtYSBvciBhZGRpdGlvbmFsUHJvcGVydGllc1xuICAgIC8vIGF0dHJpYnV0ZXMsIHNvIHdlIG5lZWQgdG8gZXhwbGljaXRseSByZW1vdmUgdGhlbS5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0IGpzb25TY2hlbWEgPSByZW1vdmVBZGRpdGlvbmFsUHJvcGVydGllcygoMCwgem9kX3RvX2pzb25fc2NoZW1hXzEuem9kVG9Kc29uU2NoZW1hKSh6b2RPYmopKTtcbiAgICBjb25zdCB7ICRzY2hlbWEsIC4uLnJlc3QgfSA9IGpzb25TY2hlbWE7XG4gICAgcmV0dXJuIHJlc3Q7XG59XG5leHBvcnRzLnpvZFRvR2VtaW5pUGFyYW1ldGVycyA9IHpvZFRvR2VtaW5pUGFyYW1ldGVycztcbmZ1bmN0aW9uIGpzb25TY2hlbWFUb0dlbWluaVBhcmFtZXRlcnMoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuc2NoZW1hKSB7XG4gICAgLy8gR2VtaW5pIGRvZXNuJ3QgYWNjZXB0IGVpdGhlciB0aGUgJHNjaGVtYSBvciBhZGRpdGlvbmFsUHJvcGVydGllc1xuICAgIC8vIGF0dHJpYnV0ZXMsIHNvIHdlIG5lZWQgdG8gZXhwbGljaXRseSByZW1vdmUgdGhlbS5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0IGpzb25TY2hlbWEgPSByZW1vdmVBZGRpdGlvbmFsUHJvcGVydGllcyhzY2hlbWEpO1xuICAgIGNvbnN0IHsgJHNjaGVtYSwgLi4ucmVzdCB9ID0ganNvblNjaGVtYTtcbiAgICByZXR1cm4gcmVzdDtcbn1cbmV4cG9ydHMuanNvblNjaGVtYVRvR2VtaW5pUGFyYW1ldGVycyA9IGpzb25TY2hlbWFUb0dlbWluaVBhcmFtZXRlcnM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/utils/zod_to_gemini_parameters.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/experimental/media.cjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@langchain/google-common/experimental/media.cjs ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/experimental/media.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/experimental/media.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2V4cGVyaW1lbnRhbC9tZWRpYS5janMiLCJtYXBwaW5ncyI6IkFBQUEsdUpBQTBEIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2V4cGVyaW1lbnRhbC9tZWRpYS5janMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9kaXN0L2V4cGVyaW1lbnRhbC9tZWRpYS5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/experimental/media.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/index.cjs":
/*!*********************************************************!*\
  !*** ./node_modules/@langchain/google-common/index.cjs ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/index.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBQSw0SEFBNEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2luZGV4LmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/index.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAX: () => (/* reexport safe */ _max_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   NIL: () => (/* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   parse: () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   stringify: () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   v1: () => (/* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   v1ToV6: () => (/* reexport safe */ _v1ToV6_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   v3: () => (/* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   v4: () => (/* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   v5: () => (/* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   v6: () => (/* reexport safe */ _v6_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]),\n/* harmony export */   v6ToV1: () => (/* reexport safe */ _v6ToV1_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]),\n/* harmony export */   v7: () => (/* reexport safe */ _v7_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"]),\n/* harmony export */   validate: () => (/* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"]),\n/* harmony export */   version: () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _max_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./max.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/max.js\");\n/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nil.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/nil.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/parse.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./v1.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v1.js\");\n/* harmony import */ var _v1ToV6_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./v1ToV6.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v1ToV6.js\");\n/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./v3.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v3.js\");\n/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./v4.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./v5.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v5.js\");\n/* harmony import */ var _v6_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./v6.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v6.js\");\n/* harmony import */ var _v6ToV1_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./v6ToV1.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v6ToV1.js\");\n/* harmony import */ var _v7_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./v7.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v7.js\");\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/validate.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./version.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/version.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQztBQUNBO0FBQ0k7QUFDUTtBQUNkO0FBQ1E7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNRO0FBQ1I7QUFDWSIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGRlZmF1bHQgYXMgTUFYIH0gZnJvbSAnLi9tYXguanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBOSUwgfSBmcm9tICcuL25pbC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHBhcnNlIH0gZnJvbSAnLi9wYXJzZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjEgfSBmcm9tICcuL3YxLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjFUb1Y2IH0gZnJvbSAnLi92MVRvVjYuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2MyB9IGZyb20gJy4vdjMuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2NCB9IGZyb20gJy4vdjQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2NSB9IGZyb20gJy4vdjUuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2NiB9IGZyb20gJy4vdjYuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2NlRvVjEgfSBmcm9tICcuL3Y2VG9WMS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY3IH0gZnJvbSAnLi92Ny5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHZhbGlkYXRlIH0gZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24uanMnOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/max.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/max.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('ffffffff-ffff-ffff-ffff-ffffffffffff');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbWF4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxzQ0FBc0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9tYXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgJ2ZmZmZmZmZmLWZmZmYtZmZmZi1mZmZmLWZmZmZmZmZmZmZmZic7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/max.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/md5.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/md5.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n  return node_crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('md5').update(bytes).digest();\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbWQ1LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFNBQVMsNkRBQWlCO0FBQzFCO0FBQ0EsaUVBQWUsR0FBRyIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL21kNS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3J5cHRvIGZyb20gJ25vZGU6Y3J5cHRvJztcbmZ1bmN0aW9uIG1kNShieXRlcykge1xuICBpZiAoQXJyYXkuaXNBcnJheShieXRlcykpIHtcbiAgICBieXRlcyA9IEJ1ZmZlci5mcm9tKGJ5dGVzKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgYnl0ZXMgPSBCdWZmZXIuZnJvbShieXRlcywgJ3V0ZjgnKTtcbiAgfVxuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ21kNScpLnVwZGF0ZShieXRlcykuZGlnZXN0KCk7XG59XG5leHBvcnQgZGVmYXVsdCBtZDU7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/md5.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/native.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/native.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  randomUUID: (node_crypto__WEBPACK_IMPORTED_MODULE_0___default().randomUUID)\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmF0aXZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNqQyxpRUFBZTtBQUNmLGNBQWMsK0RBQWlCO0FBQy9CLENBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9uYXRpdmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdub2RlOmNyeXB0byc7XG5leHBvcnQgZGVmYXVsdCB7XG4gIHJhbmRvbVVVSUQ6IGNyeXB0by5yYW5kb21VVUlEXG59OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/native.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/nil.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/nil.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('00000000-0000-0000-0000-000000000000');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxzQ0FBc0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9uaWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCc7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/nil.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/parse.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/parse.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/validate.js\");\n\nfunction parse(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n  let v;\n  const arr = new Uint8Array(16);\n\n  // Parse ########-....-....-....-............\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff;\n\n  // Parse ........-####-....-....-............\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff;\n\n  // Parse ........-....-####-....-............\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff;\n\n  // Parse ........-....-....-####-............\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff;\n\n  // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcGFyc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUM7QUFDckM7QUFDQSxPQUFPLHdEQUFRO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLEtBQUsiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9wYXJzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5mdW5jdGlvbiBwYXJzZSh1dWlkKSB7XG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG4gIGxldCB2O1xuICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSgxNik7XG5cbiAgLy8gUGFyc2UgIyMjIyMjIyMtLi4uLi0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG4gIGFyclswXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgwLCA4KSwgMTYpKSA+Pj4gMjQ7XG4gIGFyclsxXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzJdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclszXSA9IHYgJiAweGZmO1xuXG4gIC8vIFBhcnNlIC4uLi4uLi4uLSMjIyMtLi4uLi0uLi4uLS4uLi4uLi4uLi4uLlxuICBhcnJbNF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoOSwgMTMpLCAxNikpID4+PiA4O1xuICBhcnJbNV0gPSB2ICYgMHhmZjtcblxuICAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLSMjIyMtLi4uLi0uLi4uLi4uLi4uLi5cbiAgYXJyWzZdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE0LCAxOCksIDE2KSkgPj4+IDg7XG4gIGFycls3XSA9IHYgJiAweGZmO1xuXG4gIC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tLi4uLi0jIyMjLS4uLi4uLi4uLi4uLlxuICBhcnJbOF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTksIDIzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzldID0gdiAmIDB4ZmY7XG5cbiAgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLS4uLi4tIyMjIyMjIyMjIyMjXG4gIC8vIChVc2UgXCIvXCIgdG8gYXZvaWQgMzItYml0IHRydW5jYXRpb24gd2hlbiBiaXQtc2hpZnRpbmcgaGlnaC1vcmRlciBieXRlcylcbiAgYXJyWzEwXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgyNCwgMzYpLCAxNikpIC8gMHgxMDAwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMV0gPSB2IC8gMHgxMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTJdID0gdiA+Pj4gMjQgJiAweGZmO1xuICBhcnJbMTNdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMTRdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclsxNV0gPSB2ICYgMHhmZjtcbiAgcmV0dXJuIGFycjtcbn1cbmV4cG9ydCBkZWZhdWx0IHBhcnNlOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/parse.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/regex.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/regex.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcmVnZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWMsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLFVBQVUsR0FBRyw4RUFBOEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9yZWdleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLThdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMHxmZmZmZmZmZi1mZmZmLWZmZmYtZmZmZi1mZmZmZmZmZmZmZmYpJC9pOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/regex.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/rng.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/rng.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\nlet poolPtr = rnds8Pool.length;\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    node_crypto__WEBPACK_IMPORTED_MODULE_0___default().randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcm5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNqQyx1Q0FBdUM7QUFDdkM7QUFDZTtBQUNmO0FBQ0EsSUFBSSxpRUFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9ybmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdub2RlOmNyeXB0byc7XG5jb25zdCBybmRzOFBvb2wgPSBuZXcgVWludDhBcnJheSgyNTYpOyAvLyAjIG9mIHJhbmRvbSB2YWx1ZXMgdG8gcHJlLWFsbG9jYXRlXG5sZXQgcG9vbFB0ciA9IHJuZHM4UG9vbC5sZW5ndGg7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBybmcoKSB7XG4gIGlmIChwb29sUHRyID4gcm5kczhQb29sLmxlbmd0aCAtIDE2KSB7XG4gICAgY3J5cHRvLnJhbmRvbUZpbGxTeW5jKHJuZHM4UG9vbCk7XG4gICAgcG9vbFB0ciA9IDA7XG4gIH1cbiAgcmV0dXJuIHJuZHM4UG9vbC5zbGljZShwb29sUHRyLCBwb29sUHRyICs9IDE2KTtcbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/rng.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/sha1.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/sha1.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n  return node_crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('sha1').update(bytes).digest();\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc2hhMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxTQUFTLDZEQUFpQjtBQUMxQjtBQUNBLGlFQUFlLElBQUkiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9zaGExLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnbm9kZTpjcnlwdG8nO1xuZnVuY3Rpb24gc2hhMShieXRlcykge1xuICBpZiAoQXJyYXkuaXNBcnJheShieXRlcykpIHtcbiAgICBieXRlcyA9IEJ1ZmZlci5mcm9tKGJ5dGVzKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgYnl0ZXMgPSBCdWZmZXIuZnJvbShieXRlcywgJ3V0ZjgnKTtcbiAgfVxuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoYnl0ZXMpLmRpZ2VzdCgpO1xufVxuZXhwb3J0IGRlZmF1bHQgc2hhMTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/sha1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/stringify.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/stringify.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/validate.js\");\n\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  //\n  // Note to future-self: No, you can't remove the `toLowerCase()` call.\n  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset);\n  // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n  return uuid;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc3RyaW5naWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHdEQUFRO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxTQUFTIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc3RyaW5naWZ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG5jb25zdCBieXRlVG9IZXggPSBbXTtcbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnNsaWNlKDEpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1bnNhZmVTdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XG4gIC8vIE5vdGU6IEJlIGNhcmVmdWwgZWRpdGluZyB0aGlzIGNvZGUhICBJdCdzIGJlZW4gdHVuZWQgZm9yIHBlcmZvcm1hbmNlXG4gIC8vIGFuZCB3b3JrcyBpbiB3YXlzIHlvdSBtYXkgbm90IGV4cGVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzQzNFxuICAvL1xuICAvLyBOb3RlIHRvIGZ1dHVyZS1zZWxmOiBObywgeW91IGNhbid0IHJlbW92ZSB0aGUgYHRvTG93ZXJDYXNlKClgIGNhbGwuXG4gIC8vIFJFRjogaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNjc3I2lzc3VlY29tbWVudC0xNzU3MzUxMzUxXG4gIHJldHVybiAoYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV0pLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XG4gIGNvbnN0IHV1aWQgPSB1bnNhZmVTdHJpbmdpZnkoYXJyLCBvZmZzZXQpO1xuICAvLyBDb25zaXN0ZW5jeSBjaGVjayBmb3IgdmFsaWQgVVVJRC4gIElmIHRoaXMgdGhyb3dzLCBpdCdzIGxpa2VseSBkdWUgdG8gb25lXG4gIC8vIG9mIHRoZSBmb2xsb3dpbmc6XG4gIC8vIC0gT25lIG9yIG1vcmUgaW5wdXQgYXJyYXkgdmFsdWVzIGRvbid0IG1hcCB0byBhIGhleCBvY3RldCAobGVhZGluZyB0b1xuICAvLyBcInVuZGVmaW5lZFwiIGluIHRoZSB1dWlkKVxuICAvLyAtIEludmFsaWQgaW5wdXQgdmFsdWVzIGZvciB0aGUgUkZDIGB2ZXJzaW9uYCBvciBgdmFyaWFudGAgZmllbGRzXG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG4gIHJldHVybiB1dWlkO1xufVxuZXhwb3J0IGRlZmF1bHQgc3RyaW5naWZ5OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/stringify.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v1.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v1.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nlet _nodeId;\nlet _clockseq;\n\n// Previous uuid creation time\nlet _lastMSecs = 0;\nlet _lastNSecs = 0;\n\n// See https://github.com/uuidjs/uuid for API details\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node;\n  let clockseq = options.clockseq;\n\n  // v1 only: Use cached `node` and `clockseq` values\n  if (!options._v6) {\n    if (!node) {\n      node = _nodeId;\n    }\n    if (clockseq == null) {\n      clockseq = _clockseq;\n    }\n  }\n\n  // Handle cases where we need entropy.  We do this lazily to minimize issues\n  // related to insufficient system entropy.  See #189\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n    // Randomize node\n    if (node == null) {\n      node = [seedBytes[0], seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n\n      // v1 only: cache node value for reuse\n      if (!_nodeId && !options._v6) {\n        // per RFC4122 4.5: Set MAC multicast bit (v1 only)\n        node[0] |= 0x01; // Set multicast bit\n\n        _nodeId = node;\n      }\n    }\n\n    // Randomize clockseq\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n      if (_clockseq === undefined && !options._v6) {\n        _clockseq = clockseq;\n      }\n    }\n  }\n\n  // v1 & v6 timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so time is\n  // handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(b);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ3NCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELCtDQUFHOztBQUUzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0EsZ0JBQWdCLDhEQUFlO0FBQy9CO0FBQ0EsaUVBQWUsRUFBRSIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3YxLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuXG4vLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4vL1xuLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbi8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbmxldCBfbm9kZUlkO1xubGV0IF9jbG9ja3NlcTtcblxuLy8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG5sZXQgX2xhc3RNU2VjcyA9IDA7XG5sZXQgX2xhc3ROU2VjcyA9IDA7XG5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQgZm9yIEFQSSBkZXRhaWxzXG5mdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBsZXQgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgY29uc3QgYiA9IGJ1ZiB8fCBuZXcgQXJyYXkoMTYpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGV0IG5vZGUgPSBvcHRpb25zLm5vZGU7XG4gIGxldCBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXE7XG5cbiAgLy8gdjEgb25seTogVXNlIGNhY2hlZCBgbm9kZWAgYW5kIGBjbG9ja3NlcWAgdmFsdWVzXG4gIGlmICghb3B0aW9ucy5fdjYpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIG5vZGUgPSBfbm9kZUlkO1xuICAgIH1cbiAgICBpZiAoY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgICAgY2xvY2tzZXEgPSBfY2xvY2tzZXE7XG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIGNhc2VzIHdoZXJlIHdlIG5lZWQgZW50cm9weS4gIFdlIGRvIHRoaXMgbGF6aWx5IHRvIG1pbmltaXplIGlzc3Vlc1xuICAvLyByZWxhdGVkIHRvIGluc3VmZmljaWVudCBzeXN0ZW0gZW50cm9weS4gIFNlZSAjMTg5XG4gIGlmIChub2RlID09IG51bGwgfHwgY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgIGNvbnN0IHNlZWRCeXRlcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgICAvLyBSYW5kb21pemUgbm9kZVxuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIG5vZGUgPSBbc2VlZEJ5dGVzWzBdLCBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XV07XG5cbiAgICAgIC8vIHYxIG9ubHk6IGNhY2hlIG5vZGUgdmFsdWUgZm9yIHJldXNlXG4gICAgICBpZiAoIV9ub2RlSWQgJiYgIW9wdGlvbnMuX3Y2KSB7XG4gICAgICAgIC8vIHBlciBSRkM0MTIyIDQuNTogU2V0IE1BQyBtdWx0aWNhc3QgYml0ICh2MSBvbmx5KVxuICAgICAgICBub2RlWzBdIHw9IDB4MDE7IC8vIFNldCBtdWx0aWNhc3QgYml0XG5cbiAgICAgICAgX25vZGVJZCA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmFuZG9taXplIGNsb2Nrc2VxXG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgICBpZiAoX2Nsb2Nrc2VxID09PSB1bmRlZmluZWQgJiYgIW9wdGlvbnMuX3Y2KSB7XG4gICAgICAgIF9jbG9ja3NlcSA9IGNsb2Nrc2VxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHYxICYgdjYgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvIHRpbWUgaXNcbiAgLy8gaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuICBsZXQgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1zZWNzIDogRGF0ZS5ub3coKTtcblxuICAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG4gIGxldCBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTtcblxuICAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG4gIGNvbnN0IGR0ID0gbXNlY3MgLSBfbGFzdE1TZWNzICsgKG5zZWNzIC0gX2xhc3ROU2VjcykgLyAxMDAwMDtcblxuICAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG4gIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gIH1cblxuICAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAvLyB0aW1lIGludGVydmFsXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9XG5cbiAgLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1dWlkLnYxKCk6IENhbid0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlY1wiKTtcbiAgfVxuICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7XG5cbiAgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG4gIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwO1xuXG4gIC8vIGB0aW1lX2xvd2BcbiAgY29uc3QgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XG4gIGJbaSsrXSA9IHRsID4+PiAyNCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdGwgJiAweGZmO1xuXG4gIC8vIGB0aW1lX21pZGBcbiAgY29uc3QgdG1oID0gbXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwICYgMHhmZmZmZmZmO1xuICBiW2krK10gPSB0bWggPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bWggJiAweGZmO1xuXG4gIC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMjQgJiAweGYgfCAweDEwOyAvLyBpbmNsdWRlIHZlcnNpb25cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7XG5cbiAgLy8gYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgIChQZXIgNC4yLjIgLSBpbmNsdWRlIHZhcmlhbnQpXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDtcblxuICAvLyBgY2xvY2tfc2VxX2xvd2BcbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmO1xuXG4gIC8vIGBub2RlYFxuICBmb3IgKGxldCBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuICByZXR1cm4gYnVmIHx8IHVuc2FmZVN0cmluZ2lmeShiKTtcbn1cbmV4cG9ydCBkZWZhdWx0IHYxOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v1ToV6.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v1ToV6.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ v1ToV6)\n/* harmony export */ });\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/parse.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n/**\n * Convert a v1 UUID to a v6 UUID\n *\n * @param {string|Uint8Array} uuid - The v1 UUID to convert to v6\n * @returns {string|Uint8Array} The v6 UUID as the same type as the `uuid` arg\n * (string or Uint8Array)\n */\nfunction v1ToV6(uuid) {\n  const v1Bytes = typeof uuid === 'string' ? (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid) : uuid;\n  const v6Bytes = _v1ToV6(v1Bytes);\n  return typeof uuid === 'string' ? (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(v6Bytes) : v6Bytes;\n}\n\n// Do the field transformation needed for v1 -> v6\nfunction _v1ToV6(v1Bytes, randomize = false) {\n  return Uint8Array.of((v1Bytes[6] & 0x0f) << 4 | v1Bytes[7] >> 4 & 0x0f, (v1Bytes[7] & 0x0f) << 4 | (v1Bytes[4] & 0xf0) >> 4, (v1Bytes[4] & 0x0f) << 4 | (v1Bytes[5] & 0xf0) >> 4, (v1Bytes[5] & 0x0f) << 4 | (v1Bytes[0] & 0xf0) >> 4, (v1Bytes[0] & 0x0f) << 4 | (v1Bytes[1] & 0xf0) >> 4, (v1Bytes[1] & 0x0f) << 4 | (v1Bytes[2] & 0xf0) >> 4, 0x60 | v1Bytes[2] & 0x0f, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjFUb1Y2LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQjtBQUNrQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNlO0FBQ2YsNkNBQTZDLHFEQUFLO0FBQ2xEO0FBQ0Esb0NBQW9DLDhEQUFlO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjFUb1Y2LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXJzZSBmcm9tICcuL3BhcnNlLmpzJztcbmltcG9ydCB7IHVuc2FmZVN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcblxuLyoqXG4gKiBDb252ZXJ0IGEgdjEgVVVJRCB0byBhIHY2IFVVSURcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xVaW50OEFycmF5fSB1dWlkIC0gVGhlIHYxIFVVSUQgdG8gY29udmVydCB0byB2NlxuICogQHJldHVybnMge3N0cmluZ3xVaW50OEFycmF5fSBUaGUgdjYgVVVJRCBhcyB0aGUgc2FtZSB0eXBlIGFzIHRoZSBgdXVpZGAgYXJnXG4gKiAoc3RyaW5nIG9yIFVpbnQ4QXJyYXkpXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHYxVG9WNih1dWlkKSB7XG4gIGNvbnN0IHYxQnl0ZXMgPSB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgPyBwYXJzZSh1dWlkKSA6IHV1aWQ7XG4gIGNvbnN0IHY2Qnl0ZXMgPSBfdjFUb1Y2KHYxQnl0ZXMpO1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnID8gdW5zYWZlU3RyaW5naWZ5KHY2Qnl0ZXMpIDogdjZCeXRlcztcbn1cblxuLy8gRG8gdGhlIGZpZWxkIHRyYW5zZm9ybWF0aW9uIG5lZWRlZCBmb3IgdjEgLT4gdjZcbmZ1bmN0aW9uIF92MVRvVjYodjFCeXRlcywgcmFuZG9taXplID0gZmFsc2UpIHtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkub2YoKHYxQnl0ZXNbNl0gJiAweDBmKSA8PCA0IHwgdjFCeXRlc1s3XSA+PiA0ICYgMHgwZiwgKHYxQnl0ZXNbN10gJiAweDBmKSA8PCA0IHwgKHYxQnl0ZXNbNF0gJiAweGYwKSA+PiA0LCAodjFCeXRlc1s0XSAmIDB4MGYpIDw8IDQgfCAodjFCeXRlc1s1XSAmIDB4ZjApID4+IDQsICh2MUJ5dGVzWzVdICYgMHgwZikgPDwgNCB8ICh2MUJ5dGVzWzBdICYgMHhmMCkgPj4gNCwgKHYxQnl0ZXNbMF0gJiAweDBmKSA8PCA0IHwgKHYxQnl0ZXNbMV0gJiAweGYwKSA+PiA0LCAodjFCeXRlc1sxXSAmIDB4MGYpIDw8IDQgfCAodjFCeXRlc1syXSAmIDB4ZjApID4+IDQsIDB4NjAgfCB2MUJ5dGVzWzJdICYgMHgwZiwgdjFCeXRlc1szXSwgdjFCeXRlc1s4XSwgdjFCeXRlc1s5XSwgdjFCeXRlc1sxMF0sIHYxQnl0ZXNbMTFdLCB2MUJ5dGVzWzEyXSwgdjFCeXRlc1sxM10sIHYxQnl0ZXNbMTRdLCB2MUJ5dGVzWzE1XSk7XG59Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v1ToV6.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v3.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v3.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/md5.js\");\n\n\nconst v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ0E7QUFDM0IsV0FBVyxtREFBRyxhQUFhLCtDQUFHO0FBQzlCLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92My5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdjM1IGZyb20gJy4vdjM1LmpzJztcbmltcG9ydCBtZDUgZnJvbSAnLi9tZDUuanMnO1xuY29uc3QgdjMgPSB2MzUoJ3YzJywgMHgzMCwgbWQ1KTtcbmV4cG9ydCBkZWZhdWx0IHYzOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v3.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v35.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v35.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DNS: () => (/* binding */ DNS),\n/* harmony export */   URL: () => (/* binding */ URL),\n/* harmony export */   \"default\": () => (/* binding */ v35)\n/* harmony export */ });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/parse.js\");\n\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n  return bytes;\n}\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nfunction v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var _namespace;\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n    if (typeof namespace === 'string') {\n      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(namespace);\n    }\n    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    }\n\n    // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n    if (buf) {\n      offset = offset || 0;\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n      return buf;\n    }\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(bytes);\n  }\n\n  // Function#name is not settable on some platforms (#270)\n  try {\n    generateUUID.name = name;\n  } catch (err) {}\n\n  // For CommonJS default export support\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjM1LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWlEO0FBQ2xCO0FBQy9CO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1E7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscURBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4REFBZTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92MzUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuaW1wb3J0IHBhcnNlIGZyb20gJy4vcGFyc2UuanMnO1xuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHIpIHtcbiAgc3RyID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpOyAvLyBVVEY4IGVzY2FwZVxuXG4gIGNvbnN0IGJ5dGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgYnl0ZXMucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuZXhwb3J0IGNvbnN0IEROUyA9ICc2YmE3YjgxMC05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0IGNvbnN0IFVSTCA9ICc2YmE3YjgxMS05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdjM1KG5hbWUsIHZlcnNpb24sIGhhc2hmdW5jKSB7XG4gIGZ1bmN0aW9uIGdlbmVyYXRlVVVJRCh2YWx1ZSwgbmFtZXNwYWNlLCBidWYsIG9mZnNldCkge1xuICAgIHZhciBfbmFtZXNwYWNlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWVzcGFjZSA9IHBhcnNlKG5hbWVzcGFjZSk7XG4gICAgfVxuICAgIGlmICgoKF9uYW1lc3BhY2UgPSBuYW1lc3BhY2UpID09PSBudWxsIHx8IF9uYW1lc3BhY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9uYW1lc3BhY2UubGVuZ3RoKSAhPT0gMTYpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignTmFtZXNwYWNlIG11c3QgYmUgYXJyYXktbGlrZSAoMTYgaXRlcmFibGUgaW50ZWdlciB2YWx1ZXMsIDAtMjU1KScpO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgaGFzaCBvZiBuYW1lc3BhY2UgYW5kIHZhbHVlLCBQZXIgNC4zXG4gICAgLy8gRnV0dXJlOiBVc2Ugc3ByZWFkIHN5bnRheCB3aGVuIHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zLCBlLmcuIGBieXRlcyA9XG4gICAgLy8gaGFzaGZ1bmMoWy4uLm5hbWVzcGFjZSwgLi4uIHZhbHVlXSlgXG4gICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTYgKyB2YWx1ZS5sZW5ndGgpO1xuICAgIGJ5dGVzLnNldChuYW1lc3BhY2UpO1xuICAgIGJ5dGVzLnNldCh2YWx1ZSwgbmFtZXNwYWNlLmxlbmd0aCk7XG4gICAgYnl0ZXMgPSBoYXNoZnVuYyhieXRlcyk7XG4gICAgYnl0ZXNbNl0gPSBieXRlc1s2XSAmIDB4MGYgfCB2ZXJzaW9uO1xuICAgIGJ5dGVzWzhdID0gYnl0ZXNbOF0gJiAweDNmIHwgMHg4MDtcbiAgICBpZiAoYnVmKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlc1tpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIHJldHVybiB1bnNhZmVTdHJpbmdpZnkoYnl0ZXMpO1xuICB9XG5cbiAgLy8gRnVuY3Rpb24jbmFtZSBpcyBub3Qgc2V0dGFibGUgb24gc29tZSBwbGF0Zm9ybXMgKCMyNzApXG4gIHRyeSB7XG4gICAgZ2VuZXJhdGVVVUlELm5hbWUgPSBuYW1lO1xuICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgLy8gRm9yIENvbW1vbkpTIGRlZmF1bHQgZXhwb3J0IHN1cHBvcnRcbiAgZ2VuZXJhdGVVVUlELkROUyA9IEROUztcbiAgZ2VuZXJhdGVVVUlELlVSTCA9IFVSTDtcbiAgcmV0dXJuIGdlbmVyYXRlVVVJRDtcbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v35.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v4.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v4.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n  if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n    return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n  }\n  options = options || {};\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    offset = offset || 0;\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n    return buf;\n  }\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpQztBQUNOO0FBQ3NCO0FBQ2pEO0FBQ0EsTUFBTSxrREFBTTtBQUNaLFdBQVcsa0RBQU07QUFDakI7QUFDQTtBQUNBLGlEQUFpRCwrQ0FBRzs7QUFFcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBZTtBQUN4QjtBQUNBLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92NC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbmF0aXZlIGZyb20gJy4vbmF0aXZlLmpzJztcbmltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgaWYgKG5hdGl2ZS5yYW5kb21VVUlEICYmICFidWYgJiYgIW9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmF0aXZlLnJhbmRvbVVVSUQoKTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3Qgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwO1xuXG4gIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICBpZiAoYnVmKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSBybmRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xuICB9XG4gIHJldHVybiB1bnNhZmVTdHJpbmdpZnkocm5kcyk7XG59XG5leHBvcnQgZGVmYXVsdCB2NDsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v4.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v5.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v5.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/sha1.js\");\n\n\nconst v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ0U7QUFDN0IsV0FBVyxtREFBRyxhQUFhLGdEQUFJO0FBQy9CLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92NS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdjM1IGZyb20gJy4vdjM1LmpzJztcbmltcG9ydCBzaGExIGZyb20gJy4vc2hhMS5qcyc7XG5jb25zdCB2NSA9IHYzNSgndjUnLCAweDUwLCBzaGExKTtcbmV4cG9ydCBkZWZhdWx0IHY1OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v5.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v6.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v6.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ v6)\n/* harmony export */ });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v1.js\");\n/* harmony import */ var _v1ToV6_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v1ToV6.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v1ToV6.js\");\n\n\n\n\n/**\n *\n * @param {object} options\n * @param {Uint8Array=} buf\n * @param {number=} offset\n * @returns\n */\nfunction v6(options = {}, buf, offset = 0) {\n  // v6 is v1 with different field layout, so we start with a v1 UUID, albeit\n  // with slightly different behavior around how the clock_seq and node fields\n  // are randomized, which is why we call v1 with _v6: true.\n  let bytes = (0,_v1_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    ...options,\n    _v6: true\n  }, new Uint8Array(16));\n\n  // Reorder the fields to v6 layout.\n  bytes = (0,_v1ToV6_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(bytes);\n\n  // Return as a byte array if requested\n  if (buf) {\n    for (let i = 0; i < 16; i++) {\n      buf[offset + i] = bytes[i];\n    }\n    return buf;\n  }\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(bytes);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpRDtBQUN4QjtBQUNROztBQUVqQztBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsYUFBYTtBQUN4QixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxjQUFjLGtEQUFFO0FBQ2hCO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsVUFBVSxzREFBTTs7QUFFaEI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBZTtBQUN4QiIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3Y2LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVuc2FmZVN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmltcG9ydCB2MSBmcm9tICcuL3YxLmpzJztcbmltcG9ydCB2MVRvVjYgZnJvbSAnLi92MVRvVjYuanMnO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtVaW50OEFycmF5PX0gYnVmXG4gKiBAcGFyYW0ge251bWJlcj19IG9mZnNldFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdjYob3B0aW9ucyA9IHt9LCBidWYsIG9mZnNldCA9IDApIHtcbiAgLy8gdjYgaXMgdjEgd2l0aCBkaWZmZXJlbnQgZmllbGQgbGF5b3V0LCBzbyB3ZSBzdGFydCB3aXRoIGEgdjEgVVVJRCwgYWxiZWl0XG4gIC8vIHdpdGggc2xpZ2h0bHkgZGlmZmVyZW50IGJlaGF2aW9yIGFyb3VuZCBob3cgdGhlIGNsb2NrX3NlcSBhbmQgbm9kZSBmaWVsZHNcbiAgLy8gYXJlIHJhbmRvbWl6ZWQsIHdoaWNoIGlzIHdoeSB3ZSBjYWxsIHYxIHdpdGggX3Y2OiB0cnVlLlxuICBsZXQgYnl0ZXMgPSB2MSh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBfdjY6IHRydWVcbiAgfSwgbmV3IFVpbnQ4QXJyYXkoMTYpKTtcblxuICAvLyBSZW9yZGVyIHRoZSBmaWVsZHMgdG8gdjYgbGF5b3V0LlxuICBieXRlcyA9IHYxVG9WNihieXRlcyk7XG5cbiAgLy8gUmV0dXJuIGFzIGEgYnl0ZSBhcnJheSBpZiByZXF1ZXN0ZWRcbiAgaWYgKGJ1Zikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgYnVmW29mZnNldCArIGldID0gYnl0ZXNbaV07XG4gICAgfVxuICAgIHJldHVybiBidWY7XG4gIH1cbiAgcmV0dXJuIHVuc2FmZVN0cmluZ2lmeShieXRlcyk7XG59Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v6.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v6ToV1.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v6ToV1.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ v6ToV1)\n/* harmony export */ });\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/parse.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n/**\n * Convert a v6 UUID to a v1 UUID\n *\n * @param {string|Uint8Array} uuid - The v6 UUID to convert to v6\n * @returns {string|Uint8Array} The v1 UUID as the same type as the `uuid` arg\n * (string or Uint8Array)\n */\nfunction v6ToV1(uuid) {\n  const v6Bytes = typeof uuid === 'string' ? (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid) : uuid;\n  const v1Bytes = _v6ToV1(v6Bytes);\n  return typeof uuid === 'string' ? (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(v1Bytes) : v1Bytes;\n}\n\n// Do the field transformation needed for v6 -> v1\nfunction _v6ToV1(v6Bytes) {\n  return Uint8Array.of((v6Bytes[3] & 0x0f) << 4 | v6Bytes[4] >> 4 & 0x0f, (v6Bytes[4] & 0x0f) << 4 | (v6Bytes[5] & 0xf0) >> 4, (v6Bytes[5] & 0x0f) << 4 | v6Bytes[6] & 0x0f, v6Bytes[7], (v6Bytes[1] & 0x0f) << 4 | (v6Bytes[2] & 0xf0) >> 4, (v6Bytes[2] & 0x0f) << 4 | (v6Bytes[3] & 0xf0) >> 4, 0x10 | (v6Bytes[0] & 0xf0) >> 4, (v6Bytes[0] & 0x0f) << 4 | (v6Bytes[1] & 0xf0) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjZUb1YxLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQjtBQUNrQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNlO0FBQ2YsNkNBQTZDLHFEQUFLO0FBQ2xEO0FBQ0Esb0NBQW9DLDhEQUFlO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjZUb1YxLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXJzZSBmcm9tICcuL3BhcnNlLmpzJztcbmltcG9ydCB7IHVuc2FmZVN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcblxuLyoqXG4gKiBDb252ZXJ0IGEgdjYgVVVJRCB0byBhIHYxIFVVSURcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xVaW50OEFycmF5fSB1dWlkIC0gVGhlIHY2IFVVSUQgdG8gY29udmVydCB0byB2NlxuICogQHJldHVybnMge3N0cmluZ3xVaW50OEFycmF5fSBUaGUgdjEgVVVJRCBhcyB0aGUgc2FtZSB0eXBlIGFzIHRoZSBgdXVpZGAgYXJnXG4gKiAoc3RyaW5nIG9yIFVpbnQ4QXJyYXkpXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHY2VG9WMSh1dWlkKSB7XG4gIGNvbnN0IHY2Qnl0ZXMgPSB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgPyBwYXJzZSh1dWlkKSA6IHV1aWQ7XG4gIGNvbnN0IHYxQnl0ZXMgPSBfdjZUb1YxKHY2Qnl0ZXMpO1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnID8gdW5zYWZlU3RyaW5naWZ5KHYxQnl0ZXMpIDogdjFCeXRlcztcbn1cblxuLy8gRG8gdGhlIGZpZWxkIHRyYW5zZm9ybWF0aW9uIG5lZWRlZCBmb3IgdjYgLT4gdjFcbmZ1bmN0aW9uIF92NlRvVjEodjZCeXRlcykge1xuICByZXR1cm4gVWludDhBcnJheS5vZigodjZCeXRlc1szXSAmIDB4MGYpIDw8IDQgfCB2NkJ5dGVzWzRdID4+IDQgJiAweDBmLCAodjZCeXRlc1s0XSAmIDB4MGYpIDw8IDQgfCAodjZCeXRlc1s1XSAmIDB4ZjApID4+IDQsICh2NkJ5dGVzWzVdICYgMHgwZikgPDwgNCB8IHY2Qnl0ZXNbNl0gJiAweDBmLCB2NkJ5dGVzWzddLCAodjZCeXRlc1sxXSAmIDB4MGYpIDw8IDQgfCAodjZCeXRlc1syXSAmIDB4ZjApID4+IDQsICh2NkJ5dGVzWzJdICYgMHgwZikgPDwgNCB8ICh2NkJ5dGVzWzNdICYgMHhmMCkgPj4gNCwgMHgxMCB8ICh2NkJ5dGVzWzBdICYgMHhmMCkgPj4gNCwgKHY2Qnl0ZXNbMF0gJiAweDBmKSA8PCA0IHwgKHY2Qnl0ZXNbMV0gJiAweGYwKSA+PiA0LCB2NkJ5dGVzWzhdLCB2NkJ5dGVzWzldLCB2NkJ5dGVzWzEwXSwgdjZCeXRlc1sxMV0sIHY2Qnl0ZXNbMTJdLCB2NkJ5dGVzWzEzXSwgdjZCeXRlc1sxNF0sIHY2Qnl0ZXNbMTVdKTtcbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v6ToV1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v7.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v7.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n/**\n * UUID V7 - Unix Epoch time-based UUID\n *\n * The IETF has published RFC9562, introducing 3 new UUID versions (6,7,8). This\n * implementation of V7 is based on the accepted, though not yet approved,\n * revisions.\n *\n * RFC 9562:https://www.rfc-editor.org/rfc/rfc9562.html Universally Unique\n * IDentifiers (UUIDs)\n\n *\n * Sample V7 value:\n * https://www.rfc-editor.org/rfc/rfc9562.html#name-example-of-a-uuidv7-value\n *\n * Monotonic Bit Layout: RFC rfc9562.6.2 Method 1, Dedicated Counter Bits ref:\n *     https://www.rfc-editor.org/rfc/rfc9562.html#section-6.2-5.1\n *\n *   0                   1                   2                   3 0 1 2 3 4 5 6\n *   7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |                          unix_ts_ms                           |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |          unix_ts_ms           |  ver  |        seq_hi         |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |var|               seq_low               |        rand         |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |                             rand                              |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * seq is a 31 bit serialized counter; comprised of 12 bit seq_hi and 19 bit\n * seq_low, and randomly initialized upon timestamp change. 31 bit counter size\n * was selected as any bitwise operations in node are done as _signed_ 32 bit\n * ints. we exclude the sign bit.\n */\n\nlet _seqLow = null;\nlet _seqHigh = null;\nlet _msecs = 0;\nfunction v7(options, buf, offset) {\n  options = options || {};\n\n  // initialize buffer and pointer\n  let i = buf && offset || 0;\n  const b = buf || new Uint8Array(16);\n\n  // rnds is Uint8Array(16) filled with random bytes\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n  // milliseconds since unix epoch, 1970-01-01 00:00\n  const msecs = options.msecs !== undefined ? options.msecs : Date.now();\n\n  // seq is user provided 31 bit counter\n  let seq = options.seq !== undefined ? options.seq : null;\n\n  // initialize local seq high/low parts\n  let seqHigh = _seqHigh;\n  let seqLow = _seqLow;\n\n  // check if clock has advanced and user has not provided msecs\n  if (msecs > _msecs && options.msecs === undefined) {\n    _msecs = msecs;\n\n    // unless user provided seq, reset seq parts\n    if (seq !== null) {\n      seqHigh = null;\n      seqLow = null;\n    }\n  }\n\n  // if we have a user provided seq\n  if (seq !== null) {\n    // trim provided seq to 31 bits of value, avoiding overflow\n    if (seq > 0x7fffffff) {\n      seq = 0x7fffffff;\n    }\n\n    // split provided seq into high/low parts\n    seqHigh = seq >>> 19 & 0xfff;\n    seqLow = seq & 0x7ffff;\n  }\n\n  // randomly initialize seq\n  if (seqHigh === null || seqLow === null) {\n    seqHigh = rnds[6] & 0x7f;\n    seqHigh = seqHigh << 8 | rnds[7];\n    seqLow = rnds[8] & 0x3f; // pad for var\n    seqLow = seqLow << 8 | rnds[9];\n    seqLow = seqLow << 5 | rnds[10] >>> 3;\n  }\n\n  // increment seq if within msecs window\n  if (msecs + 10000 > _msecs && seq === null) {\n    if (++seqLow > 0x7ffff) {\n      seqLow = 0;\n      if (++seqHigh > 0xfff) {\n        seqHigh = 0;\n\n        // increment internal _msecs. this allows us to continue incrementing\n        // while staying monotonic. Note, once we hit 10k milliseconds beyond system\n        // clock, we will reset breaking monotonicity (after (2^31)*10000 generations)\n        _msecs++;\n      }\n    }\n  } else {\n    // resetting; we have advanced more than\n    // 10k milliseconds beyond system clock\n    _msecs = msecs;\n  }\n  _seqHigh = seqHigh;\n  _seqLow = seqLow;\n\n  // [bytes 0-5] 48 bits of local timestamp\n  b[i++] = _msecs / 0x10000000000 & 0xff;\n  b[i++] = _msecs / 0x100000000 & 0xff;\n  b[i++] = _msecs / 0x1000000 & 0xff;\n  b[i++] = _msecs / 0x10000 & 0xff;\n  b[i++] = _msecs / 0x100 & 0xff;\n  b[i++] = _msecs & 0xff;\n\n  // [byte 6] - set 4 bits of version (7) with first 4 bits seq_hi\n  b[i++] = seqHigh >>> 4 & 0x0f | 0x70;\n\n  // [byte 7] remaining 8 bits of seq_hi\n  b[i++] = seqHigh & 0xff;\n\n  // [byte 8] - variant (2 bits), first 6 bits seq_low\n  b[i++] = seqLow >>> 13 & 0x3f | 0x80;\n\n  // [byte 9] 8 bits seq_low\n  b[i++] = seqLow >>> 5 & 0xff;\n\n  // [byte 10] remaining 5 bits seq_low, 3 bits random\n  b[i++] = seqLow << 3 & 0xff | rnds[10] & 0x07;\n\n  // [bytes 11-15] always random\n  b[i++] = rnds[11];\n  b[i++] = rnds[12];\n  b[i++] = rnds[13];\n  b[i++] = rnds[14];\n  b[i++] = rnds[15];\n  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(b);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v7);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ3NCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQsK0NBQUc7O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4REFBZTtBQUMvQjtBQUNBLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92Ny5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcm5nIGZyb20gJy4vcm5nLmpzJztcbmltcG9ydCB7IHVuc2FmZVN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcblxuLyoqXG4gKiBVVUlEIFY3IC0gVW5peCBFcG9jaCB0aW1lLWJhc2VkIFVVSURcbiAqXG4gKiBUaGUgSUVURiBoYXMgcHVibGlzaGVkIFJGQzk1NjIsIGludHJvZHVjaW5nIDMgbmV3IFVVSUQgdmVyc2lvbnMgKDYsNyw4KS4gVGhpc1xuICogaW1wbGVtZW50YXRpb24gb2YgVjcgaXMgYmFzZWQgb24gdGhlIGFjY2VwdGVkLCB0aG91Z2ggbm90IHlldCBhcHByb3ZlZCxcbiAqIHJldmlzaW9ucy5cbiAqXG4gKiBSRkMgOTU2MjpodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTU2Mi5odG1sIFVuaXZlcnNhbGx5IFVuaXF1ZVxuICogSURlbnRpZmllcnMgKFVVSURzKVxuXG4gKlxuICogU2FtcGxlIFY3IHZhbHVlOlxuICogaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzk1NjIuaHRtbCNuYW1lLWV4YW1wbGUtb2YtYS11dWlkdjctdmFsdWVcbiAqXG4gKiBNb25vdG9uaWMgQml0IExheW91dDogUkZDIHJmYzk1NjIuNi4yIE1ldGhvZCAxLCBEZWRpY2F0ZWQgQ291bnRlciBCaXRzIHJlZjpcbiAqICAgICBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTU2Mi5odG1sI3NlY3Rpb24tNi4yLTUuMVxuICpcbiAqICAgMCAgICAgICAgICAgICAgICAgICAxICAgICAgICAgICAgICAgICAgIDIgICAgICAgICAgICAgICAgICAgMyAwIDEgMiAzIDQgNSA2XG4gKiAgIDcgOCA5IDAgMSAyIDMgNCA1IDYgNyA4IDkgMCAxIDIgMyA0IDUgNiA3IDggOSAwIDFcbiAqICArLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstK1xuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXhfdHNfbXMgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLStcbiAqICB8ICAgICAgICAgIHVuaXhfdHNfbXMgICAgICAgICAgIHwgIHZlciAgfCAgICAgICAgc2VxX2hpICAgICAgICAgfFxuICogICstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rXG4gKiAgfHZhcnwgICAgICAgICAgICAgICBzZXFfbG93ICAgICAgICAgICAgICAgfCAgICAgICAgcmFuZCAgICAgICAgIHxcbiAqICArLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstK1xuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLStcbiAqXG4gKiBzZXEgaXMgYSAzMSBiaXQgc2VyaWFsaXplZCBjb3VudGVyOyBjb21wcmlzZWQgb2YgMTIgYml0IHNlcV9oaSBhbmQgMTkgYml0XG4gKiBzZXFfbG93LCBhbmQgcmFuZG9tbHkgaW5pdGlhbGl6ZWQgdXBvbiB0aW1lc3RhbXAgY2hhbmdlLiAzMSBiaXQgY291bnRlciBzaXplXG4gKiB3YXMgc2VsZWN0ZWQgYXMgYW55IGJpdHdpc2Ugb3BlcmF0aW9ucyBpbiBub2RlIGFyZSBkb25lIGFzIF9zaWduZWRfIDMyIGJpdFxuICogaW50cy4gd2UgZXhjbHVkZSB0aGUgc2lnbiBiaXQuXG4gKi9cblxubGV0IF9zZXFMb3cgPSBudWxsO1xubGV0IF9zZXFIaWdoID0gbnVsbDtcbmxldCBfbXNlY3MgPSAwO1xuZnVuY3Rpb24gdjcob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gaW5pdGlhbGl6ZSBidWZmZXIgYW5kIHBvaW50ZXJcbiAgbGV0IGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gIGNvbnN0IGIgPSBidWYgfHwgbmV3IFVpbnQ4QXJyYXkoMTYpO1xuXG4gIC8vIHJuZHMgaXMgVWludDhBcnJheSgxNikgZmlsbGVkIHdpdGggcmFuZG9tIGJ5dGVzXG4gIGNvbnN0IHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpO1xuXG4gIC8vIG1pbGxpc2Vjb25kcyBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwXG4gIGNvbnN0IG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IERhdGUubm93KCk7XG5cbiAgLy8gc2VxIGlzIHVzZXIgcHJvdmlkZWQgMzEgYml0IGNvdW50ZXJcbiAgbGV0IHNlcSA9IG9wdGlvbnMuc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnNlcSA6IG51bGw7XG5cbiAgLy8gaW5pdGlhbGl6ZSBsb2NhbCBzZXEgaGlnaC9sb3cgcGFydHNcbiAgbGV0IHNlcUhpZ2ggPSBfc2VxSGlnaDtcbiAgbGV0IHNlcUxvdyA9IF9zZXFMb3c7XG5cbiAgLy8gY2hlY2sgaWYgY2xvY2sgaGFzIGFkdmFuY2VkIGFuZCB1c2VyIGhhcyBub3QgcHJvdmlkZWQgbXNlY3NcbiAgaWYgKG1zZWNzID4gX21zZWNzICYmIG9wdGlvbnMubXNlY3MgPT09IHVuZGVmaW5lZCkge1xuICAgIF9tc2VjcyA9IG1zZWNzO1xuXG4gICAgLy8gdW5sZXNzIHVzZXIgcHJvdmlkZWQgc2VxLCByZXNldCBzZXEgcGFydHNcbiAgICBpZiAoc2VxICE9PSBudWxsKSB7XG4gICAgICBzZXFIaWdoID0gbnVsbDtcbiAgICAgIHNlcUxvdyA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgd2UgaGF2ZSBhIHVzZXIgcHJvdmlkZWQgc2VxXG4gIGlmIChzZXEgIT09IG51bGwpIHtcbiAgICAvLyB0cmltIHByb3ZpZGVkIHNlcSB0byAzMSBiaXRzIG9mIHZhbHVlLCBhdm9pZGluZyBvdmVyZmxvd1xuICAgIGlmIChzZXEgPiAweDdmZmZmZmZmKSB7XG4gICAgICBzZXEgPSAweDdmZmZmZmZmO1xuICAgIH1cblxuICAgIC8vIHNwbGl0IHByb3ZpZGVkIHNlcSBpbnRvIGhpZ2gvbG93IHBhcnRzXG4gICAgc2VxSGlnaCA9IHNlcSA+Pj4gMTkgJiAweGZmZjtcbiAgICBzZXFMb3cgPSBzZXEgJiAweDdmZmZmO1xuICB9XG5cbiAgLy8gcmFuZG9tbHkgaW5pdGlhbGl6ZSBzZXFcbiAgaWYgKHNlcUhpZ2ggPT09IG51bGwgfHwgc2VxTG93ID09PSBudWxsKSB7XG4gICAgc2VxSGlnaCA9IHJuZHNbNl0gJiAweDdmO1xuICAgIHNlcUhpZ2ggPSBzZXFIaWdoIDw8IDggfCBybmRzWzddO1xuICAgIHNlcUxvdyA9IHJuZHNbOF0gJiAweDNmOyAvLyBwYWQgZm9yIHZhclxuICAgIHNlcUxvdyA9IHNlcUxvdyA8PCA4IHwgcm5kc1s5XTtcbiAgICBzZXFMb3cgPSBzZXFMb3cgPDwgNSB8IHJuZHNbMTBdID4+PiAzO1xuICB9XG5cbiAgLy8gaW5jcmVtZW50IHNlcSBpZiB3aXRoaW4gbXNlY3Mgd2luZG93XG4gIGlmIChtc2VjcyArIDEwMDAwID4gX21zZWNzICYmIHNlcSA9PT0gbnVsbCkge1xuICAgIGlmICgrK3NlcUxvdyA+IDB4N2ZmZmYpIHtcbiAgICAgIHNlcUxvdyA9IDA7XG4gICAgICBpZiAoKytzZXFIaWdoID4gMHhmZmYpIHtcbiAgICAgICAgc2VxSGlnaCA9IDA7XG5cbiAgICAgICAgLy8gaW5jcmVtZW50IGludGVybmFsIF9tc2Vjcy4gdGhpcyBhbGxvd3MgdXMgdG8gY29udGludWUgaW5jcmVtZW50aW5nXG4gICAgICAgIC8vIHdoaWxlIHN0YXlpbmcgbW9ub3RvbmljLiBOb3RlLCBvbmNlIHdlIGhpdCAxMGsgbWlsbGlzZWNvbmRzIGJleW9uZCBzeXN0ZW1cbiAgICAgICAgLy8gY2xvY2ssIHdlIHdpbGwgcmVzZXQgYnJlYWtpbmcgbW9ub3RvbmljaXR5IChhZnRlciAoMl4zMSkqMTAwMDAgZ2VuZXJhdGlvbnMpXG4gICAgICAgIF9tc2VjcysrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyByZXNldHRpbmc7IHdlIGhhdmUgYWR2YW5jZWQgbW9yZSB0aGFuXG4gICAgLy8gMTBrIG1pbGxpc2Vjb25kcyBiZXlvbmQgc3lzdGVtIGNsb2NrXG4gICAgX21zZWNzID0gbXNlY3M7XG4gIH1cbiAgX3NlcUhpZ2ggPSBzZXFIaWdoO1xuICBfc2VxTG93ID0gc2VxTG93O1xuXG4gIC8vIFtieXRlcyAwLTVdIDQ4IGJpdHMgb2YgbG9jYWwgdGltZXN0YW1wXG4gIGJbaSsrXSA9IF9tc2VjcyAvIDB4MTAwMDAwMDAwMDAgJiAweGZmO1xuICBiW2krK10gPSBfbXNlY3MgLyAweDEwMDAwMDAwMCAmIDB4ZmY7XG4gIGJbaSsrXSA9IF9tc2VjcyAvIDB4MTAwMDAwMCAmIDB4ZmY7XG4gIGJbaSsrXSA9IF9tc2VjcyAvIDB4MTAwMDAgJiAweGZmO1xuICBiW2krK10gPSBfbXNlY3MgLyAweDEwMCAmIDB4ZmY7XG4gIGJbaSsrXSA9IF9tc2VjcyAmIDB4ZmY7XG5cbiAgLy8gW2J5dGUgNl0gLSBzZXQgNCBiaXRzIG9mIHZlcnNpb24gKDcpIHdpdGggZmlyc3QgNCBiaXRzIHNlcV9oaVxuICBiW2krK10gPSBzZXFIaWdoID4+PiA0ICYgMHgwZiB8IDB4NzA7XG5cbiAgLy8gW2J5dGUgN10gcmVtYWluaW5nIDggYml0cyBvZiBzZXFfaGlcbiAgYltpKytdID0gc2VxSGlnaCAmIDB4ZmY7XG5cbiAgLy8gW2J5dGUgOF0gLSB2YXJpYW50ICgyIGJpdHMpLCBmaXJzdCA2IGJpdHMgc2VxX2xvd1xuICBiW2krK10gPSBzZXFMb3cgPj4+IDEzICYgMHgzZiB8IDB4ODA7XG5cbiAgLy8gW2J5dGUgOV0gOCBiaXRzIHNlcV9sb3dcbiAgYltpKytdID0gc2VxTG93ID4+PiA1ICYgMHhmZjtcblxuICAvLyBbYnl0ZSAxMF0gcmVtYWluaW5nIDUgYml0cyBzZXFfbG93LCAzIGJpdHMgcmFuZG9tXG4gIGJbaSsrXSA9IHNlcUxvdyA8PCAzICYgMHhmZiB8IHJuZHNbMTBdICYgMHgwNztcblxuICAvLyBbYnl0ZXMgMTEtMTVdIGFsd2F5cyByYW5kb21cbiAgYltpKytdID0gcm5kc1sxMV07XG4gIGJbaSsrXSA9IHJuZHNbMTJdO1xuICBiW2krK10gPSBybmRzWzEzXTtcbiAgYltpKytdID0gcm5kc1sxNF07XG4gIGJbaSsrXSA9IHJuZHNbMTVdO1xuICByZXR1cm4gYnVmIHx8IHVuc2FmZVN0cmluZ2lmeShiKTtcbn1cbmV4cG9ydCBkZWZhdWx0IHY3OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v7.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/validate.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/validate.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/regex.js\");\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmFsaWRhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0I7QUFDL0I7QUFDQSxxQ0FBcUMsaURBQUs7QUFDMUM7QUFDQSxpRUFBZSxRQUFRIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmFsaWRhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJFR0VYIGZyb20gJy4vcmVnZXguanMnO1xuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIFJFR0VYLnRlc3QodXVpZCk7XG59XG5leHBvcnQgZGVmYXVsdCB2YWxpZGF0ZTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/validate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/version.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/version.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/validate.js\");\n\nfunction version(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n  return parseInt(uuid.slice(14, 15), 16);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (version);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxQztBQUNyQztBQUNBLE9BQU8sd0RBQVE7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLE9BQU8iLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92ZXJzaW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbmZ1bmN0aW9uIHZlcnNpb24odXVpZCkge1xuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbnZhbGlkIFVVSUQnKTtcbiAgfVxuICByZXR1cm4gcGFyc2VJbnQodXVpZC5zbGljZSgxNCwgMTUpLCAxNik7XG59XG5leHBvcnQgZGVmYXVsdCB2ZXJzaW9uOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/version.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-gauth/dist/auth.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/google-gauth/dist/auth.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GAuthClient = exports.NodeSseJsonStream = exports.NodeSseStream = exports.NodeJsonStream = exports.NodeAbstractStream = void 0;\nconst google_common_1 = __webpack_require__(/*! @langchain/google-common */ \"(rsc)/./node_modules/@langchain/google-common/index.cjs\");\nconst google_auth_library_1 = __webpack_require__(/*! google-auth-library */ \"(rsc)/./node_modules/google-auth-library/build/src/index.js\");\nclass NodeAbstractStream {\n    constructor(baseStream, data) {\n        Object.defineProperty(this, \"baseStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.baseStream = baseStream;\n        const decoder = new TextDecoder(\"utf-8\");\n        data.on(\"data\", (data) => {\n            const text = decoder.decode(data, { stream: true });\n            this.appendBuffer(text);\n        });\n        data.on(\"end\", () => {\n            const rest = decoder.decode();\n            this.appendBuffer(rest);\n            this.closeBuffer();\n        });\n    }\n    appendBuffer(data) {\n        return this.baseStream.appendBuffer(data);\n    }\n    closeBuffer() {\n        return this.baseStream.closeBuffer();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    nextChunk() {\n        return this.baseStream.nextChunk();\n    }\n    get streamDone() {\n        return this.baseStream.streamDone;\n    }\n}\nexports.NodeAbstractStream = NodeAbstractStream;\nclass NodeJsonStream extends NodeAbstractStream {\n    constructor(data) {\n        super(new google_common_1.JsonStream(), data);\n    }\n}\nexports.NodeJsonStream = NodeJsonStream;\nclass NodeSseStream extends NodeAbstractStream {\n    constructor(data) {\n        super(new google_common_1.SseStream(), data);\n    }\n}\nexports.NodeSseStream = NodeSseStream;\nclass NodeSseJsonStream extends NodeAbstractStream {\n    constructor(data) {\n        super(new google_common_1.SseJsonStream(), data);\n    }\n}\nexports.NodeSseJsonStream = NodeSseJsonStream;\nclass GAuthClient {\n    constructor(fields) {\n        Object.defineProperty(this, \"gauth\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const options = (0, google_common_1.ensureAuthOptionScopes)(fields?.authOptions, \"scopes\", fields?.platformType);\n        this.gauth = new google_auth_library_1.GoogleAuth(options);\n    }\n    get clientType() {\n        return \"gauth\";\n    }\n    async getProjectId() {\n        return this.gauth.getProjectId();\n    }\n    async request(opts) {\n        const ret = await this.gauth.request(opts);\n        const [contentType] = ret?.headers?.[\"content-type\"]?.split(/;/) ?? [\"\"];\n        if (opts.responseType !== \"stream\") {\n            return ret;\n        }\n        else if (contentType === \"text/event-stream\") {\n            return {\n                ...ret,\n                data: new NodeSseJsonStream(ret.data),\n            };\n        }\n        else {\n            return {\n                ...ret,\n                data: new NodeJsonStream(ret.data),\n            };\n        }\n    }\n}\nexports.GAuthClient = GAuthClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvZGlzdC9hdXRoLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyx5QkFBeUIsR0FBRyxxQkFBcUIsR0FBRyxzQkFBc0IsR0FBRywwQkFBMEI7QUFDN0gsd0JBQXdCLG1CQUFPLENBQUMseUZBQTBCO0FBQzFELDhCQUE4QixtQkFBTyxDQUFDLHdGQUFxQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYztBQUM5RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvZGlzdC9hdXRoLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR0F1dGhDbGllbnQgPSBleHBvcnRzLk5vZGVTc2VKc29uU3RyZWFtID0gZXhwb3J0cy5Ob2RlU3NlU3RyZWFtID0gZXhwb3J0cy5Ob2RlSnNvblN0cmVhbSA9IGV4cG9ydHMuTm9kZUFic3RyYWN0U3RyZWFtID0gdm9pZCAwO1xuY29uc3QgZ29vZ2xlX2NvbW1vbl8xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vblwiKTtcbmNvbnN0IGdvb2dsZV9hdXRoX2xpYnJhcnlfMSA9IHJlcXVpcmUoXCJnb29nbGUtYXV0aC1saWJyYXJ5XCIpO1xuY2xhc3MgTm9kZUFic3RyYWN0U3RyZWFtIHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlU3RyZWFtLCBkYXRhKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJhc2VTdHJlYW1cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5iYXNlU3RyZWFtID0gYmFzZVN0cmVhbTtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpO1xuICAgICAgICBkYXRhLm9uKFwiZGF0YVwiLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGRlY29kZXIuZGVjb2RlKGRhdGEsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRCdWZmZXIodGV4dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBkYXRhLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3QgPSBkZWNvZGVyLmRlY29kZSgpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRCdWZmZXIocmVzdCk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQnVmZmVyKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhcHBlbmRCdWZmZXIoZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlU3RyZWFtLmFwcGVuZEJ1ZmZlcihkYXRhKTtcbiAgICB9XG4gICAgY2xvc2VCdWZmZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VTdHJlYW0uY2xvc2VCdWZmZXIoKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBuZXh0Q2h1bmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VTdHJlYW0ubmV4dENodW5rKCk7XG4gICAgfVxuICAgIGdldCBzdHJlYW1Eb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlU3RyZWFtLnN0cmVhbURvbmU7XG4gICAgfVxufVxuZXhwb3J0cy5Ob2RlQWJzdHJhY3RTdHJlYW0gPSBOb2RlQWJzdHJhY3RTdHJlYW07XG5jbGFzcyBOb2RlSnNvblN0cmVhbSBleHRlbmRzIE5vZGVBYnN0cmFjdFN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcihuZXcgZ29vZ2xlX2NvbW1vbl8xLkpzb25TdHJlYW0oKSwgZGF0YSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob2RlSnNvblN0cmVhbSA9IE5vZGVKc29uU3RyZWFtO1xuY2xhc3MgTm9kZVNzZVN0cmVhbSBleHRlbmRzIE5vZGVBYnN0cmFjdFN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcihuZXcgZ29vZ2xlX2NvbW1vbl8xLlNzZVN0cmVhbSgpLCBkYXRhKTtcbiAgICB9XG59XG5leHBvcnRzLk5vZGVTc2VTdHJlYW0gPSBOb2RlU3NlU3RyZWFtO1xuY2xhc3MgTm9kZVNzZUpzb25TdHJlYW0gZXh0ZW5kcyBOb2RlQWJzdHJhY3RTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIobmV3IGdvb2dsZV9jb21tb25fMS5Tc2VKc29uU3RyZWFtKCksIGRhdGEpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm9kZVNzZUpzb25TdHJlYW0gPSBOb2RlU3NlSnNvblN0cmVhbTtcbmNsYXNzIEdBdXRoQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2F1dGhcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9ICgwLCBnb29nbGVfY29tbW9uXzEuZW5zdXJlQXV0aE9wdGlvblNjb3BlcykoZmllbGRzPy5hdXRoT3B0aW9ucywgXCJzY29wZXNcIiwgZmllbGRzPy5wbGF0Zm9ybVR5cGUpO1xuICAgICAgICB0aGlzLmdhdXRoID0gbmV3IGdvb2dsZV9hdXRoX2xpYnJhcnlfMS5Hb29nbGVBdXRoKG9wdGlvbnMpO1xuICAgIH1cbiAgICBnZXQgY2xpZW50VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiZ2F1dGhcIjtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UHJvamVjdElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nYXV0aC5nZXRQcm9qZWN0SWQoKTtcbiAgICB9XG4gICAgYXN5bmMgcmVxdWVzdChvcHRzKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGF3YWl0IHRoaXMuZ2F1dGgucmVxdWVzdChvcHRzKTtcbiAgICAgICAgY29uc3QgW2NvbnRlbnRUeXBlXSA9IHJldD8uaGVhZGVycz8uW1wiY29udGVudC10eXBlXCJdPy5zcGxpdCgvOy8pID8/IFtcIlwiXTtcbiAgICAgICAgaWYgKG9wdHMucmVzcG9uc2VUeXBlICE9PSBcInN0cmVhbVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRlbnRUeXBlID09PSBcInRleHQvZXZlbnQtc3RyZWFtXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4ucmV0LFxuICAgICAgICAgICAgICAgIGRhdGE6IG5ldyBOb2RlU3NlSnNvblN0cmVhbShyZXQuZGF0YSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5yZXQsXG4gICAgICAgICAgICAgICAgZGF0YTogbmV3IE5vZGVKc29uU3RyZWFtKHJldC5kYXRhKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkdBdXRoQ2xpZW50ID0gR0F1dGhDbGllbnQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-gauth/dist/auth.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-gauth/dist/chat_models.cjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/google-gauth/dist/chat_models.cjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChatGoogle = void 0;\nconst google_common_1 = __webpack_require__(/*! @langchain/google-common */ \"(rsc)/./node_modules/@langchain/google-common/index.cjs\");\nconst auth_js_1 = __webpack_require__(/*! ./auth.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/auth.cjs\");\n/**\n * Integration with a Google chat model.\n */\nclass ChatGoogle extends google_common_1.ChatGoogleBase {\n    // Used for tracing, replace with the same name as your class\n    static lc_name() {\n        return \"ChatGoogle\";\n    }\n    constructor(fields) {\n        super(fields);\n    }\n    buildAbstractedClient(fields) {\n        return new auth_js_1.GAuthClient(fields);\n    }\n}\nexports.ChatGoogle = ChatGoogle;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvZGlzdC9jaGF0X21vZGVscy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLHdCQUF3QixtQkFBTyxDQUFDLHlGQUEwQjtBQUMxRCxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1nYXV0aC9kaXN0L2NoYXRfbW9kZWxzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hhdEdvb2dsZSA9IHZvaWQgMDtcbmNvbnN0IGdvb2dsZV9jb21tb25fMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2dvb2dsZS1jb21tb25cIik7XG5jb25zdCBhdXRoX2pzXzEgPSByZXF1aXJlKFwiLi9hdXRoLmNqc1wiKTtcbi8qKlxuICogSW50ZWdyYXRpb24gd2l0aCBhIEdvb2dsZSBjaGF0IG1vZGVsLlxuICovXG5jbGFzcyBDaGF0R29vZ2xlIGV4dGVuZHMgZ29vZ2xlX2NvbW1vbl8xLkNoYXRHb29nbGVCYXNlIHtcbiAgICAvLyBVc2VkIGZvciB0cmFjaW5nLCByZXBsYWNlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyB5b3VyIGNsYXNzXG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkNoYXRHb29nbGVcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgfVxuICAgIGJ1aWxkQWJzdHJhY3RlZENsaWVudChmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhdXRoX2pzXzEuR0F1dGhDbGllbnQoZmllbGRzKTtcbiAgICB9XG59XG5leHBvcnRzLkNoYXRHb29nbGUgPSBDaGF0R29vZ2xlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-gauth/dist/chat_models.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-gauth/dist/embeddings.cjs":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/google-gauth/dist/embeddings.cjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GoogleEmbeddings = void 0;\nconst google_common_1 = __webpack_require__(/*! @langchain/google-common */ \"(rsc)/./node_modules/@langchain/google-common/index.cjs\");\nconst auth_js_1 = __webpack_require__(/*! ./auth.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/auth.cjs\");\n/**\n * Integration with an Google embeddings model.\n */\nclass GoogleEmbeddings extends google_common_1.BaseGoogleEmbeddings {\n    // Used for tracing, replace with the same name as your class\n    static lc_name() {\n        return \"GoogleEmbeddings\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    buildAbstractedClient(fields) {\n        return new auth_js_1.GAuthClient(fields);\n    }\n}\nexports.GoogleEmbeddings = GoogleEmbeddings;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvZGlzdC9lbWJlZGRpbmdzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsd0JBQXdCLG1CQUFPLENBQUMseUZBQTBCO0FBQzFELGtCQUFrQixtQkFBTyxDQUFDLDhFQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvZGlzdC9lbWJlZGRpbmdzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR29vZ2xlRW1iZWRkaW5ncyA9IHZvaWQgMDtcbmNvbnN0IGdvb2dsZV9jb21tb25fMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2dvb2dsZS1jb21tb25cIik7XG5jb25zdCBhdXRoX2pzXzEgPSByZXF1aXJlKFwiLi9hdXRoLmNqc1wiKTtcbi8qKlxuICogSW50ZWdyYXRpb24gd2l0aCBhbiBHb29nbGUgZW1iZWRkaW5ncyBtb2RlbC5cbiAqL1xuY2xhc3MgR29vZ2xlRW1iZWRkaW5ncyBleHRlbmRzIGdvb2dsZV9jb21tb25fMS5CYXNlR29vZ2xlRW1iZWRkaW5ncyB7XG4gICAgLy8gVXNlZCBmb3IgdHJhY2luZywgcmVwbGFjZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgeW91ciBjbGFzc1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJHb29nbGVFbWJlZGRpbmdzXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJ1aWxkQWJzdHJhY3RlZENsaWVudChmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhdXRoX2pzXzEuR0F1dGhDbGllbnQoZmllbGRzKTtcbiAgICB9XG59XG5leHBvcnRzLkdvb2dsZUVtYmVkZGluZ3MgPSBHb29nbGVFbWJlZGRpbmdzO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-gauth/dist/embeddings.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-gauth/dist/index.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/google-gauth/dist/index.cjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./chat_models.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/chat_models.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./llms.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/llms.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./embeddings.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/embeddings.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./media.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/media.cjs\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvZGlzdC9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLDRGQUFtQjtBQUN4QyxhQUFhLG1CQUFPLENBQUMsOEVBQVk7QUFDakMsYUFBYSxtQkFBTyxDQUFDLDBGQUFrQjtBQUN2QyxhQUFhLG1CQUFPLENBQUMsZ0ZBQWEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1nYXV0aC9kaXN0L2luZGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NoYXRfbW9kZWxzLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGxtcy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2VtYmVkZGluZ3MuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tZWRpYS5janNcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-gauth/dist/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-gauth/dist/llms.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/google-gauth/dist/llms.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GoogleLLM = void 0;\nconst google_common_1 = __webpack_require__(/*! @langchain/google-common */ \"(rsc)/./node_modules/@langchain/google-common/index.cjs\");\nconst auth_js_1 = __webpack_require__(/*! ./auth.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/auth.cjs\");\n/**\n * Integration with a Google LLM.\n */\nclass GoogleLLM extends google_common_1.GoogleBaseLLM {\n    // Used for tracing, replace with the same name as your class\n    static lc_name() {\n        return \"GoogleLLM\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    buildAbstractedClient(fields) {\n        return new auth_js_1.GAuthClient(fields);\n    }\n}\nexports.GoogleLLM = GoogleLLM;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvZGlzdC9sbG1zLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsd0JBQXdCLG1CQUFPLENBQUMseUZBQTBCO0FBQzFELGtCQUFrQixtQkFBTyxDQUFDLDhFQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvZGlzdC9sbG1zLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR29vZ2xlTExNID0gdm9pZCAwO1xuY29uc3QgZ29vZ2xlX2NvbW1vbl8xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vblwiKTtcbmNvbnN0IGF1dGhfanNfMSA9IHJlcXVpcmUoXCIuL2F1dGguY2pzXCIpO1xuLyoqXG4gKiBJbnRlZ3JhdGlvbiB3aXRoIGEgR29vZ2xlIExMTS5cbiAqL1xuY2xhc3MgR29vZ2xlTExNIGV4dGVuZHMgZ29vZ2xlX2NvbW1vbl8xLkdvb2dsZUJhc2VMTE0ge1xuICAgIC8vIFVzZWQgZm9yIHRyYWNpbmcsIHJlcGxhY2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHlvdXIgY2xhc3NcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiR29vZ2xlTExNXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJ1aWxkQWJzdHJhY3RlZENsaWVudChmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhdXRoX2pzXzEuR0F1dGhDbGllbnQoZmllbGRzKTtcbiAgICB9XG59XG5leHBvcnRzLkdvb2dsZUxMTSA9IEdvb2dsZUxMTTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-gauth/dist/llms.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-gauth/dist/media.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/google-gauth/dist/media.cjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BlobStoreAIStudioFile = exports.BlobStoreGoogleCloudStorage = void 0;\nconst media_1 = __webpack_require__(/*! @langchain/google-common/experimental/media */ \"(rsc)/./node_modules/@langchain/google-common/experimental/media.cjs\");\nconst auth_js_1 = __webpack_require__(/*! ./auth.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/auth.cjs\");\nclass BlobStoreGoogleCloudStorage extends media_1.BlobStoreGoogleCloudStorageBase {\n    buildClient(fields) {\n        return new auth_js_1.GAuthClient(fields);\n    }\n}\nexports.BlobStoreGoogleCloudStorage = BlobStoreGoogleCloudStorage;\nclass BlobStoreAIStudioFile extends media_1.BlobStoreAIStudioFileBase {\n    buildAbstractedClient(fields) {\n        return new auth_js_1.GAuthClient(fields);\n    }\n}\nexports.BlobStoreAIStudioFile = BlobStoreAIStudioFile;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvZGlzdC9tZWRpYS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcsbUNBQW1DO0FBQ25FLGdCQUFnQixtQkFBTyxDQUFDLHlIQUE2QztBQUNyRSxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1nYXV0aC9kaXN0L21lZGlhLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmxvYlN0b3JlQUlTdHVkaW9GaWxlID0gZXhwb3J0cy5CbG9iU3RvcmVHb29nbGVDbG91ZFN0b3JhZ2UgPSB2b2lkIDA7XG5jb25zdCBtZWRpYV8xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9leHBlcmltZW50YWwvbWVkaWFcIik7XG5jb25zdCBhdXRoX2pzXzEgPSByZXF1aXJlKFwiLi9hdXRoLmNqc1wiKTtcbmNsYXNzIEJsb2JTdG9yZUdvb2dsZUNsb3VkU3RvcmFnZSBleHRlbmRzIG1lZGlhXzEuQmxvYlN0b3JlR29vZ2xlQ2xvdWRTdG9yYWdlQmFzZSB7XG4gICAgYnVpbGRDbGllbnQoZmllbGRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgYXV0aF9qc18xLkdBdXRoQ2xpZW50KGZpZWxkcyk7XG4gICAgfVxufVxuZXhwb3J0cy5CbG9iU3RvcmVHb29nbGVDbG91ZFN0b3JhZ2UgPSBCbG9iU3RvcmVHb29nbGVDbG91ZFN0b3JhZ2U7XG5jbGFzcyBCbG9iU3RvcmVBSVN0dWRpb0ZpbGUgZXh0ZW5kcyBtZWRpYV8xLkJsb2JTdG9yZUFJU3R1ZGlvRmlsZUJhc2Uge1xuICAgIGJ1aWxkQWJzdHJhY3RlZENsaWVudChmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhdXRoX2pzXzEuR0F1dGhDbGllbnQoZmllbGRzKTtcbiAgICB9XG59XG5leHBvcnRzLkJsb2JTdG9yZUFJU3R1ZGlvRmlsZSA9IEJsb2JTdG9yZUFJU3R1ZGlvRmlsZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-gauth/dist/media.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-gauth/index.cjs":
/*!********************************************************!*\
  !*** ./node_modules/@langchain/google-gauth/index.cjs ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/index.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFBLDJIQUE0QyIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWdhdXRoL2luZGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9pbmRleC5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-gauth/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-sdk/dist/client.js":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/dist/client.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AssistantsClient: () => (/* binding */ AssistantsClient),\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   CronsClient: () => (/* binding */ CronsClient),\n/* harmony export */   RunsClient: () => (/* binding */ RunsClient),\n/* harmony export */   StoreClient: () => (/* binding */ StoreClient),\n/* harmony export */   ThreadsClient: () => (/* binding */ ThreadsClient),\n/* harmony export */   getApiKey: () => (/* binding */ getApiKey),\n/* harmony export */   getClientConfigHash: () => (/* binding */ getClientConfigHash)\n/* harmony export */ });\n/* harmony import */ var _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/async_caller.js */ \"(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/async_caller.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/env.js */ \"(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/env.js\");\n/* harmony import */ var _utils_signals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/signals.js */ \"(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/signals.js\");\n/* harmony import */ var _utils_sse_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/sse.js */ \"(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/sse.js\");\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/stream.js */ \"(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/stream.js\");\n\n\n\n\n\nfunction* iterateHeaders(headers) {\n    let iter;\n    let shouldClear = false;\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (headers instanceof Headers) {\n        const entries = [];\n        headers.forEach((value, name) => {\n            entries.push([name, value]);\n        });\n        iter = entries;\n    }\n    else if (Array.isArray(headers)) {\n        iter = headers;\n    }\n    else {\n        shouldClear = true;\n        iter = Object.entries(headers ?? {});\n    }\n    for (const item of iter) {\n        const name = item[0];\n        if (typeof name !== \"string\")\n            throw new TypeError(`Expected header name to be a string, got ${typeof name}`);\n        const values = Array.isArray(item[1]) ? item[1] : [item[1]];\n        let didClear = false;\n        for (const value of values) {\n            if (value === undefined)\n                continue;\n            // New object keys should always overwrite older headers\n            // Yield a null to clear the header in the headers object\n            // before adding the new value\n            if (shouldClear && !didClear) {\n                didClear = true;\n                yield [name, null];\n            }\n            yield [name, value];\n        }\n    }\n}\nfunction mergeHeaders(...headerObjects) {\n    const outputHeaders = new Headers();\n    for (const headers of headerObjects) {\n        if (!headers)\n            continue;\n        for (const [name, value] of iterateHeaders(headers)) {\n            if (value === null)\n                outputHeaders.delete(name);\n            else\n                outputHeaders.append(name, value);\n        }\n    }\n    const headerEntries = [];\n    outputHeaders.forEach((value, name) => {\n        headerEntries.push([name, value]);\n    });\n    return Object.fromEntries(headerEntries);\n}\n/**\n * Get the API key from the environment.\n * Precedence:\n *   1. explicit argument\n *   2. LANGGRAPH_API_KEY\n *   3. LANGSMITH_API_KEY\n *   4. LANGCHAIN_API_KEY\n *\n * @param apiKey - Optional API key provided as an argument\n * @returns The API key if found, otherwise undefined\n */\nfunction getApiKey(apiKey) {\n    if (apiKey) {\n        return apiKey;\n    }\n    const prefixes = [\"LANGGRAPH\", \"LANGSMITH\", \"LANGCHAIN\"];\n    for (const prefix of prefixes) {\n        const envKey = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_1__.getEnvironmentVariable)(`${prefix}_API_KEY`);\n        if (envKey) {\n            // Remove surrounding quotes\n            return envKey.trim().replace(/^[\"']|[\"']$/g, \"\");\n        }\n    }\n    return undefined;\n}\nconst REGEX_RUN_METADATA = /(\\/threads\\/(?<thread_id>.+))?\\/runs\\/(?<run_id>.+)/;\nfunction getRunMetadataFromResponse(response) {\n    const contentLocation = response.headers.get(\"Content-Location\");\n    if (!contentLocation)\n        return undefined;\n    const match = REGEX_RUN_METADATA.exec(contentLocation);\n    if (!match?.groups?.run_id)\n        return undefined;\n    return {\n        run_id: match.groups.run_id,\n        thread_id: match.groups.thread_id || undefined,\n    };\n}\nclass BaseClient {\n    constructor(config) {\n        Object.defineProperty(this, \"asyncCaller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeoutMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"defaultHeaders\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onRequest\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const callerOptions = {\n            maxRetries: 4,\n            maxConcurrency: 4,\n            ...config?.callerOptions,\n        };\n        let defaultApiUrl = \"http://localhost:8123\";\n        if (!config?.apiUrl &&\n            typeof globalThis === \"object\" &&\n            globalThis != null) {\n            const fetchSmb = Symbol.for(\"langgraph_api:fetch\");\n            const urlSmb = Symbol.for(\"langgraph_api:url\");\n            const global = globalThis;\n            if (global[fetchSmb])\n                callerOptions.fetch ??= global[fetchSmb];\n            if (global[urlSmb])\n                defaultApiUrl = global[urlSmb];\n        }\n        this.asyncCaller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__.AsyncCaller(callerOptions);\n        this.timeoutMs = config?.timeoutMs;\n        // default limit being capped by Chrome\n        // https://github.com/nodejs/undici/issues/1373\n        // Regex to remove trailing slash, if present\n        this.apiUrl = config?.apiUrl?.replace(/\\/$/, \"\") || defaultApiUrl;\n        this.defaultHeaders = config?.defaultHeaders || {};\n        this.onRequest = config?.onRequest;\n        const apiKey = getApiKey(config?.apiKey);\n        if (apiKey) {\n            this.defaultHeaders[\"x-api-key\"] = apiKey;\n        }\n    }\n    prepareFetchOptions(path, options) {\n        const mutatedOptions = {\n            ...options,\n            headers: mergeHeaders(this.defaultHeaders, options?.headers),\n        };\n        if (mutatedOptions.json) {\n            mutatedOptions.body = JSON.stringify(mutatedOptions.json);\n            mutatedOptions.headers = mergeHeaders(mutatedOptions.headers, {\n                \"content-type\": \"application/json\",\n            });\n            delete mutatedOptions.json;\n        }\n        if (mutatedOptions.withResponse) {\n            delete mutatedOptions.withResponse;\n        }\n        let timeoutSignal = null;\n        if (typeof options?.timeoutMs !== \"undefined\") {\n            if (options.timeoutMs != null) {\n                timeoutSignal = AbortSignal.timeout(options.timeoutMs);\n            }\n        }\n        else if (this.timeoutMs != null) {\n            timeoutSignal = AbortSignal.timeout(this.timeoutMs);\n        }\n        mutatedOptions.signal = (0,_utils_signals_js__WEBPACK_IMPORTED_MODULE_2__.mergeSignals)(timeoutSignal, mutatedOptions.signal);\n        const targetUrl = new URL(`${this.apiUrl}${path}`);\n        if (mutatedOptions.params) {\n            for (const [key, value] of Object.entries(mutatedOptions.params)) {\n                if (value == null)\n                    continue;\n                const strValue = typeof value === \"string\" || typeof value === \"number\"\n                    ? value.toString()\n                    : JSON.stringify(value);\n                targetUrl.searchParams.append(key, strValue);\n            }\n            delete mutatedOptions.params;\n        }\n        return [targetUrl, mutatedOptions];\n    }\n    async fetch(path, options) {\n        const [url, init] = this.prepareFetchOptions(path, options);\n        let finalInit = init;\n        if (this.onRequest) {\n            finalInit = await this.onRequest(url, init);\n        }\n        const response = await this.asyncCaller.fetch(url, finalInit);\n        const body = (() => {\n            if (response.status === 202 || response.status === 204) {\n                return undefined;\n            }\n            return response.json();\n        })();\n        if (options?.withResponse) {\n            return [await body, response];\n        }\n        return body;\n    }\n}\nclass CronsClient extends BaseClient {\n    /**\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this cron job.\n     * @param payload Payload for creating a cron job.\n     * @returns The created background run.\n     */\n    async createForThread(threadId, assistantId, payload) {\n        const json = {\n            schedule: payload?.schedule,\n            input: payload?.input,\n            config: payload?.config,\n            context: payload?.context,\n            metadata: payload?.metadata,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            webhook: payload?.webhook,\n            multitask_strategy: payload?.multitaskStrategy,\n            if_not_exists: payload?.ifNotExists,\n            checkpoint_during: payload?.checkpointDuring,\n            durability: payload?.durability,\n        };\n        return this.fetch(`/threads/${threadId}/runs/crons`, {\n            method: \"POST\",\n            json,\n        });\n    }\n    /**\n     *\n     * @param assistantId Assistant ID to use for this cron job.\n     * @param payload Payload for creating a cron job.\n     * @returns\n     */\n    async create(assistantId, payload) {\n        const json = {\n            schedule: payload?.schedule,\n            input: payload?.input,\n            config: payload?.config,\n            context: payload?.context,\n            metadata: payload?.metadata,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            webhook: payload?.webhook,\n            multitask_strategy: payload?.multitaskStrategy,\n            if_not_exists: payload?.ifNotExists,\n            checkpoint_during: payload?.checkpointDuring,\n            durability: payload?.durability,\n        };\n        return this.fetch(`/runs/crons`, {\n            method: \"POST\",\n            json,\n        });\n    }\n    /**\n     *\n     * @param cronId Cron ID of Cron job to delete.\n     */\n    async delete(cronId) {\n        await this.fetch(`/runs/crons/${cronId}`, {\n            method: \"DELETE\",\n        });\n    }\n    /**\n     *\n     * @param query Query options.\n     * @returns List of crons.\n     */\n    async search(query) {\n        return this.fetch(\"/runs/crons/search\", {\n            method: \"POST\",\n            json: {\n                assistant_id: query?.assistantId ?? undefined,\n                thread_id: query?.threadId ?? undefined,\n                limit: query?.limit ?? 10,\n                offset: query?.offset ?? 0,\n                sort_by: query?.sortBy ?? undefined,\n                sort_order: query?.sortOrder ?? undefined,\n                select: query?.select ?? undefined,\n            },\n        });\n    }\n    /**\n     * Count cron jobs matching filters.\n     *\n     * @param query.assistantId Assistant ID to filter by.\n     * @param query.threadId Thread ID to filter by.\n     * @returns Number of cron jobs matching the criteria.\n     */\n    async count(query) {\n        return this.fetch(`/runs/crons/count`, {\n            method: \"POST\",\n            json: {\n                assistant_id: query?.assistantId ?? undefined,\n                thread_id: query?.threadId ?? undefined,\n            },\n        });\n    }\n}\nclass AssistantsClient extends BaseClient {\n    /**\n     * Get an assistant by ID.\n     *\n     * @param assistantId The ID of the assistant.\n     * @returns Assistant\n     */\n    async get(assistantId) {\n        return this.fetch(`/assistants/${assistantId}`);\n    }\n    /**\n     * Get the JSON representation of the graph assigned to a runnable\n     * @param assistantId The ID of the assistant.\n     * @param options.xray Whether to include subgraphs in the serialized graph representation. If an integer value is provided, only subgraphs with a depth less than or equal to the value will be included.\n     * @returns Serialized graph\n     */\n    async getGraph(assistantId, options) {\n        return this.fetch(`/assistants/${assistantId}/graph`, {\n            params: { xray: options?.xray },\n        });\n    }\n    /**\n     * Get the state and config schema of the graph assigned to a runnable\n     * @param assistantId The ID of the assistant.\n     * @returns Graph schema\n     */\n    async getSchemas(assistantId) {\n        return this.fetch(`/assistants/${assistantId}/schemas`);\n    }\n    /**\n     * Get the schemas of an assistant by ID.\n     *\n     * @param assistantId The ID of the assistant to get the schema of.\n     * @param options Additional options for getting subgraphs, such as namespace or recursion extraction.\n     * @returns The subgraphs of the assistant.\n     */\n    async getSubgraphs(assistantId, options) {\n        if (options?.namespace) {\n            return this.fetch(`/assistants/${assistantId}/subgraphs/${options.namespace}`, { params: { recurse: options?.recurse } });\n        }\n        return this.fetch(`/assistants/${assistantId}/subgraphs`, {\n            params: { recurse: options?.recurse },\n        });\n    }\n    /**\n     * Create a new assistant.\n     * @param payload Payload for creating an assistant.\n     * @returns The created assistant.\n     */\n    async create(payload) {\n        return this.fetch(\"/assistants\", {\n            method: \"POST\",\n            json: {\n                graph_id: payload.graphId,\n                config: payload.config,\n                context: payload.context,\n                metadata: payload.metadata,\n                assistant_id: payload.assistantId,\n                if_exists: payload.ifExists,\n                name: payload.name,\n                description: payload.description,\n            },\n        });\n    }\n    /**\n     * Update an assistant.\n     * @param assistantId ID of the assistant.\n     * @param payload Payload for updating the assistant.\n     * @returns The updated assistant.\n     */\n    async update(assistantId, payload) {\n        return this.fetch(`/assistants/${assistantId}`, {\n            method: \"PATCH\",\n            json: {\n                graph_id: payload.graphId,\n                config: payload.config,\n                context: payload.context,\n                metadata: payload.metadata,\n                name: payload.name,\n                description: payload.description,\n            },\n        });\n    }\n    /**\n     * Delete an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     */\n    async delete(assistantId) {\n        return this.fetch(`/assistants/${assistantId}`, {\n            method: \"DELETE\",\n        });\n    }\n    /**\n     * List assistants.\n     * @param query Query options.\n     * @returns List of assistants.\n     */\n    async search(query) {\n        return this.fetch(\"/assistants/search\", {\n            method: \"POST\",\n            json: {\n                graph_id: query?.graphId ?? undefined,\n                metadata: query?.metadata ?? undefined,\n                limit: query?.limit ?? 10,\n                offset: query?.offset ?? 0,\n                sort_by: query?.sortBy ?? undefined,\n                sort_order: query?.sortOrder ?? undefined,\n                select: query?.select ?? undefined,\n            },\n        });\n    }\n    /**\n     * Count assistants matching filters.\n     *\n     * @param query.metadata Metadata to filter by. Exact match for each key/value.\n     * @param query.graphId Optional graph id to filter by.\n     * @returns Number of assistants matching the criteria.\n     */\n    async count(query) {\n        return this.fetch(`/assistants/count`, {\n            method: \"POST\",\n            json: {\n                metadata: query?.metadata ?? undefined,\n                graph_id: query?.graphId ?? undefined,\n            },\n        });\n    }\n    /**\n     * List all versions of an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     * @returns List of assistant versions.\n     */\n    async getVersions(assistantId, payload) {\n        return this.fetch(`/assistants/${assistantId}/versions`, {\n            method: \"POST\",\n            json: {\n                metadata: payload?.metadata ?? undefined,\n                limit: payload?.limit ?? 10,\n                offset: payload?.offset ?? 0,\n            },\n        });\n    }\n    /**\n     * Change the version of an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     * @param version The version to change to.\n     * @returns The updated assistant.\n     */\n    async setLatest(assistantId, version) {\n        return this.fetch(`/assistants/${assistantId}/latest`, {\n            method: \"POST\",\n            json: { version },\n        });\n    }\n}\nclass ThreadsClient extends BaseClient {\n    /**\n     * Get a thread by ID.\n     *\n     * @param threadId ID of the thread.\n     * @returns The thread.\n     */\n    async get(threadId) {\n        return this.fetch(`/threads/${threadId}`);\n    }\n    /**\n     * Create a new thread.\n     *\n     * @param payload Payload for creating a thread.\n     * @returns The created thread.\n     */\n    async create(payload) {\n        // Normalize ttl to an object if a number is provided\n        const ttlPayload = typeof payload?.ttl === \"number\"\n            ? { ttl: payload.ttl, strategy: \"delete\" }\n            : payload?.ttl;\n        return this.fetch(`/threads`, {\n            method: \"POST\",\n            json: {\n                metadata: {\n                    ...payload?.metadata,\n                    graph_id: payload?.graphId,\n                },\n                thread_id: payload?.threadId,\n                if_exists: payload?.ifExists,\n                supersteps: payload?.supersteps?.map((s) => ({\n                    updates: s.updates.map((u) => ({\n                        values: u.values,\n                        command: u.command,\n                        as_node: u.asNode,\n                    })),\n                })),\n                ttl: ttlPayload,\n            },\n        });\n    }\n    /**\n     * Copy an existing thread\n     * @param threadId ID of the thread to be copied\n     * @returns Newly copied thread\n     */\n    async copy(threadId) {\n        return this.fetch(`/threads/${threadId}/copy`, {\n            method: \"POST\",\n        });\n    }\n    /**\n     * Update a thread.\n     *\n     * @param threadId ID of the thread.\n     * @param payload Payload for updating the thread.\n     * @returns The updated thread.\n     */\n    async update(threadId, payload) {\n        const ttlPayload = typeof payload?.ttl === \"number\"\n            ? { ttl: payload.ttl, strategy: \"delete\" }\n            : payload?.ttl;\n        return this.fetch(`/threads/${threadId}`, {\n            method: \"PATCH\",\n            json: { metadata: payload?.metadata, ttl: ttlPayload },\n        });\n    }\n    /**\n     * Delete a thread.\n     *\n     * @param threadId ID of the thread.\n     */\n    async delete(threadId) {\n        return this.fetch(`/threads/${threadId}`, {\n            method: \"DELETE\",\n        });\n    }\n    /**\n     * List threads\n     *\n     * @param query Query options\n     * @returns List of threads\n     */\n    async search(query) {\n        return this.fetch(\"/threads/search\", {\n            method: \"POST\",\n            json: {\n                metadata: query?.metadata ?? undefined,\n                ids: query?.ids ?? undefined,\n                limit: query?.limit ?? 10,\n                offset: query?.offset ?? 0,\n                status: query?.status,\n                sort_by: query?.sortBy,\n                sort_order: query?.sortOrder,\n                select: query?.select ?? undefined,\n            },\n        });\n    }\n    /**\n     * Count threads matching filters.\n     *\n     * @param query.metadata Thread metadata to filter on.\n     * @param query.values State values to filter on.\n     * @param query.status Thread status to filter on.\n     * @returns Number of threads matching the criteria.\n     */\n    async count(query) {\n        return this.fetch(`/threads/count`, {\n            method: \"POST\",\n            json: {\n                metadata: query?.metadata ?? undefined,\n                values: query?.values ?? undefined,\n                status: query?.status ?? undefined,\n            },\n        });\n    }\n    /**\n     * Get state for a thread.\n     *\n     * @param threadId ID of the thread.\n     * @returns Thread state.\n     */\n    async getState(threadId, checkpoint, options) {\n        if (checkpoint != null) {\n            if (typeof checkpoint !== \"string\") {\n                return this.fetch(`/threads/${threadId}/state/checkpoint`, {\n                    method: \"POST\",\n                    json: { checkpoint, subgraphs: options?.subgraphs },\n                });\n            }\n            // deprecated\n            return this.fetch(`/threads/${threadId}/state/${checkpoint}`, { params: { subgraphs: options?.subgraphs } });\n        }\n        return this.fetch(`/threads/${threadId}/state`, {\n            params: { subgraphs: options?.subgraphs },\n        });\n    }\n    /**\n     * Add state to a thread.\n     *\n     * @param threadId The ID of the thread.\n     * @returns\n     */\n    async updateState(threadId, options) {\n        return this.fetch(`/threads/${threadId}/state`, {\n            method: \"POST\",\n            json: {\n                values: options.values,\n                checkpoint_id: options.checkpointId,\n                checkpoint: options.checkpoint,\n                as_node: options?.asNode,\n            },\n        });\n    }\n    /**\n     * Patch the metadata of a thread.\n     *\n     * @param threadIdOrConfig Thread ID or config to patch the state of.\n     * @param metadata Metadata to patch the state with.\n     */\n    async patchState(threadIdOrConfig, metadata) {\n        let threadId;\n        if (typeof threadIdOrConfig !== \"string\") {\n            if (typeof threadIdOrConfig.configurable?.thread_id !== \"string\") {\n                throw new Error(\"Thread ID is required when updating state with a config.\");\n            }\n            threadId = threadIdOrConfig.configurable.thread_id;\n        }\n        else {\n            threadId = threadIdOrConfig;\n        }\n        return this.fetch(`/threads/${threadId}/state`, {\n            method: \"PATCH\",\n            json: { metadata },\n        });\n    }\n    /**\n     * Get all past states for a thread.\n     *\n     * @param threadId ID of the thread.\n     * @param options Additional options.\n     * @returns List of thread states.\n     */\n    async getHistory(threadId, options) {\n        return this.fetch(`/threads/${threadId}/history`, {\n            method: \"POST\",\n            json: {\n                limit: options?.limit ?? 10,\n                before: options?.before,\n                metadata: options?.metadata,\n                checkpoint: options?.checkpoint,\n            },\n        });\n    }\n    async *joinStream(threadId, options\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        let [url, init] = this.prepareFetchOptions(`/threads/${threadId}/stream`, {\n            method: \"GET\",\n            headers: options?.lastEventId\n                ? { \"Last-Event-ID\": options.lastEventId }\n                : undefined,\n            params: options?.streamMode\n                ? { stream_mode: options.streamMode }\n                : undefined,\n        });\n        if (this.onRequest != null)\n            init = await this.onRequest(url, init);\n        const response = await this.asyncCaller.fetch(url, init);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const stream = (response.body || new ReadableStream({ start: (ctrl) => ctrl.close() }))\n            .pipeThrough((0,_utils_sse_js__WEBPACK_IMPORTED_MODULE_3__.BytesLineDecoder)())\n            .pipeThrough((0,_utils_sse_js__WEBPACK_IMPORTED_MODULE_3__.SSEDecoder)());\n        yield* _utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.IterableReadableStream.fromReadableStream(stream);\n    }\n}\nclass RunsClient extends BaseClient {\n    /**\n     * Create a run and stream the results.\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this run.\n     * @param payload Payload for creating a run.\n     */\n    async *stream(threadId, assistantId, payload) {\n        const json = {\n            input: payload?.input,\n            command: payload?.command,\n            config: payload?.config,\n            context: payload?.context,\n            metadata: payload?.metadata,\n            stream_mode: payload?.streamMode,\n            stream_subgraphs: payload?.streamSubgraphs,\n            stream_resumable: payload?.streamResumable,\n            feedback_keys: payload?.feedbackKeys,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            checkpoint: payload?.checkpoint,\n            checkpoint_id: payload?.checkpointId,\n            webhook: payload?.webhook,\n            multitask_strategy: payload?.multitaskStrategy,\n            on_completion: payload?.onCompletion,\n            on_disconnect: payload?.onDisconnect,\n            after_seconds: payload?.afterSeconds,\n            if_not_exists: payload?.ifNotExists,\n            checkpoint_during: payload?.checkpointDuring,\n            durability: payload?.durability,\n        };\n        const endpoint = threadId == null ? `/runs/stream` : `/threads/${threadId}/runs/stream`;\n        let [url, init] = this.prepareFetchOptions(endpoint, {\n            method: \"POST\",\n            json,\n            timeoutMs: null,\n            signal: payload?.signal,\n        });\n        if (this.onRequest != null)\n            init = await this.onRequest(url, init);\n        const response = await this.asyncCaller.fetch(url, init);\n        const runMetadata = getRunMetadataFromResponse(response);\n        if (runMetadata)\n            payload?.onRunCreated?.(runMetadata);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const stream = (response.body || new ReadableStream({ start: (ctrl) => ctrl.close() }))\n            .pipeThrough((0,_utils_sse_js__WEBPACK_IMPORTED_MODULE_3__.BytesLineDecoder)())\n            .pipeThrough((0,_utils_sse_js__WEBPACK_IMPORTED_MODULE_3__.SSEDecoder)());\n        yield* _utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.IterableReadableStream.fromReadableStream(stream);\n    }\n    /**\n     * Create a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this run.\n     * @param payload Payload for creating a run.\n     * @returns The created run.\n     */\n    async create(threadId, assistantId, payload) {\n        const json = {\n            input: payload?.input,\n            command: payload?.command,\n            config: payload?.config,\n            context: payload?.context,\n            metadata: payload?.metadata,\n            stream_mode: payload?.streamMode,\n            stream_subgraphs: payload?.streamSubgraphs,\n            stream_resumable: payload?.streamResumable,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            webhook: payload?.webhook,\n            checkpoint: payload?.checkpoint,\n            checkpoint_id: payload?.checkpointId,\n            multitask_strategy: payload?.multitaskStrategy,\n            after_seconds: payload?.afterSeconds,\n            if_not_exists: payload?.ifNotExists,\n            checkpoint_during: payload?.checkpointDuring,\n            durability: payload?.durability,\n            langsmith_tracer: payload?._langsmithTracer\n                ? {\n                    project_name: payload?._langsmithTracer?.projectName,\n                    example_id: payload?._langsmithTracer?.exampleId,\n                }\n                : undefined,\n        };\n        const endpoint = threadId === null ? \"/runs\" : `/threads/${threadId}/runs`;\n        const [run, response] = await this.fetch(endpoint, {\n            method: \"POST\",\n            json,\n            signal: payload?.signal,\n            withResponse: true,\n        });\n        const runMetadata = getRunMetadataFromResponse(response);\n        if (runMetadata)\n            payload?.onRunCreated?.(runMetadata);\n        return run;\n    }\n    /**\n     * Create a batch of stateless background runs.\n     *\n     * @param payloads An array of payloads for creating runs.\n     * @returns An array of created runs.\n     */\n    async createBatch(payloads) {\n        const filteredPayloads = payloads\n            .map((payload) => ({ ...payload, assistant_id: payload.assistantId }))\n            .map((payload) => {\n            return Object.fromEntries(Object.entries(payload).filter(([_, v]) => v !== undefined));\n        });\n        return this.fetch(\"/runs/batch\", {\n            method: \"POST\",\n            json: filteredPayloads,\n        });\n    }\n    /**\n     * Create a run and wait for it to complete.\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this run.\n     * @param payload Payload for creating a run.\n     * @returns The last values chunk of the thread.\n     */\n    async wait(threadId, assistantId, payload) {\n        const json = {\n            input: payload?.input,\n            command: payload?.command,\n            config: payload?.config,\n            context: payload?.context,\n            metadata: payload?.metadata,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            checkpoint: payload?.checkpoint,\n            checkpoint_id: payload?.checkpointId,\n            webhook: payload?.webhook,\n            multitask_strategy: payload?.multitaskStrategy,\n            on_completion: payload?.onCompletion,\n            on_disconnect: payload?.onDisconnect,\n            after_seconds: payload?.afterSeconds,\n            if_not_exists: payload?.ifNotExists,\n            checkpoint_during: payload?.checkpointDuring,\n            durability: payload?.durability,\n            langsmith_tracer: payload?._langsmithTracer\n                ? {\n                    project_name: payload?._langsmithTracer?.projectName,\n                    example_id: payload?._langsmithTracer?.exampleId,\n                }\n                : undefined,\n        };\n        const endpoint = threadId == null ? `/runs/wait` : `/threads/${threadId}/runs/wait`;\n        const [run, response] = await this.fetch(endpoint, {\n            method: \"POST\",\n            json,\n            timeoutMs: null,\n            signal: payload?.signal,\n            withResponse: true,\n        });\n        const runMetadata = getRunMetadataFromResponse(response);\n        if (runMetadata)\n            payload?.onRunCreated?.(runMetadata);\n        const raiseError = payload?.raiseError !== undefined ? payload.raiseError : true;\n        if (raiseError &&\n            \"__error__\" in run &&\n            typeof run.__error__ === \"object\" &&\n            run.__error__ &&\n            \"error\" in run.__error__ &&\n            \"message\" in run.__error__) {\n            throw new Error(`${run.__error__?.error}: ${run.__error__?.message}`);\n        }\n        return run;\n    }\n    /**\n     * List all runs for a thread.\n     *\n     * @param threadId The ID of the thread.\n     * @param options Filtering and pagination options.\n     * @returns List of runs.\n     */\n    async list(threadId, options) {\n        return this.fetch(`/threads/${threadId}/runs`, {\n            params: {\n                limit: options?.limit ?? 10,\n                offset: options?.offset ?? 0,\n                status: options?.status ?? undefined,\n                select: options?.select ?? undefined,\n            },\n        });\n    }\n    /**\n     * Get a run by ID.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns The run.\n     */\n    async get(threadId, runId) {\n        return this.fetch(`/threads/${threadId}/runs/${runId}`);\n    }\n    /**\n     * Cancel a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @param wait Whether to block when canceling\n     * @param action Action to take when cancelling the run. Possible values are `interrupt` or `rollback`. Default is `interrupt`.\n     * @returns\n     */\n    async cancel(threadId, runId, wait = false, action = \"interrupt\") {\n        return this.fetch(`/threads/${threadId}/runs/${runId}/cancel`, {\n            method: \"POST\",\n            params: {\n                wait: wait ? \"1\" : \"0\",\n                action,\n            },\n        });\n    }\n    /**\n     * Block until a run is done.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns\n     */\n    async join(threadId, runId, options) {\n        return this.fetch(`/threads/${threadId}/runs/${runId}/join`, {\n            timeoutMs: null,\n            signal: options?.signal,\n        });\n    }\n    /**\n     * Stream output from a run in real-time, until the run is done.\n     *\n     * @param threadId The ID of the thread. Can be set to `null` | `undefined` for stateless runs.\n     * @param runId The ID of the run.\n     * @param options Additional options for controlling the stream behavior:\n     *   - signal: An AbortSignal that can be used to cancel the stream request\n     *   - lastEventId: The ID of the last event received. Can be used to reconnect to a stream without losing events.\n     *   - cancelOnDisconnect: When true, automatically cancels the run if the client disconnects from the stream\n     *   - streamMode: Controls what types of events to receive from the stream (can be a single mode or array of modes)\n     *        Must be a subset of the stream modes passed when creating the run. Background runs default to having the union of all\n     *        stream modes enabled.\n     * @returns An async generator yielding stream parts.\n     */\n    async *joinStream(threadId, runId, options\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        const opts = typeof options === \"object\" &&\n            options != null &&\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            options instanceof AbortSignal\n            ? { signal: options }\n            : options;\n        let [url, init] = this.prepareFetchOptions(threadId != null\n            ? `/threads/${threadId}/runs/${runId}/stream`\n            : `/runs/${runId}/stream`, {\n            method: \"GET\",\n            timeoutMs: null,\n            signal: opts?.signal,\n            headers: opts?.lastEventId\n                ? { \"Last-Event-ID\": opts.lastEventId }\n                : undefined,\n            params: {\n                cancel_on_disconnect: opts?.cancelOnDisconnect ? \"1\" : \"0\",\n                stream_mode: opts?.streamMode,\n            },\n        });\n        if (this.onRequest != null)\n            init = await this.onRequest(url, init);\n        const response = await this.asyncCaller.fetch(url, init);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const stream = (response.body || new ReadableStream({ start: (ctrl) => ctrl.close() }))\n            .pipeThrough((0,_utils_sse_js__WEBPACK_IMPORTED_MODULE_3__.BytesLineDecoder)())\n            .pipeThrough((0,_utils_sse_js__WEBPACK_IMPORTED_MODULE_3__.SSEDecoder)());\n        yield* _utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.IterableReadableStream.fromReadableStream(stream);\n    }\n    /**\n     * Delete a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns\n     */\n    async delete(threadId, runId) {\n        return this.fetch(`/threads/${threadId}/runs/${runId}`, {\n            method: \"DELETE\",\n        });\n    }\n}\nclass StoreClient extends BaseClient {\n    /**\n     * Store or update an item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item within the namespace.\n     * @param value A dictionary containing the item's data.\n     * @param options.index Controls search indexing - null (use defaults), false (disable), or list of field paths to index.\n     * @param options.ttl Optional time-to-live in minutes for the item, or null for no expiration.\n     * @returns Promise<void>\n     *\n     * @example\n     * ```typescript\n     * await client.store.putItem(\n     *   [\"documents\", \"user123\"],\n     *   \"item456\",\n     *   { title: \"My Document\", content: \"Hello World\" },\n     *   { ttl: 60 } // expires in 60 minutes\n     * );\n     * ```\n     */\n    async putItem(namespace, key, value, options) {\n        namespace.forEach((label) => {\n            if (label.includes(\".\")) {\n                throw new Error(`Invalid namespace label '${label}'. Namespace labels cannot contain periods ('.')`);\n            }\n        });\n        const payload = {\n            namespace,\n            key,\n            value,\n            index: options?.index,\n            ttl: options?.ttl,\n        };\n        return this.fetch(\"/store/items\", {\n            method: \"PUT\",\n            json: payload,\n        });\n    }\n    /**\n     * Retrieve a single item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item.\n     * @param options.refreshTtl Whether to refresh the TTL on this read operation. If null, uses the store's default behavior.\n     * @returns Promise<Item>\n     *\n     * @example\n     * ```typescript\n     * const item = await client.store.getItem(\n     *   [\"documents\", \"user123\"],\n     *   \"item456\",\n     *   { refreshTtl: true }\n     * );\n     * console.log(item);\n     * // {\n     * //   namespace: [\"documents\", \"user123\"],\n     * //   key: \"item456\",\n     * //   value: { title: \"My Document\", content: \"Hello World\" },\n     * //   createdAt: \"2024-07-30T12:00:00Z\",\n     * //   updatedAt: \"2024-07-30T12:00:00Z\"\n     * // }\n     * ```\n     */\n    async getItem(namespace, key, options) {\n        namespace.forEach((label) => {\n            if (label.includes(\".\")) {\n                throw new Error(`Invalid namespace label '${label}'. Namespace labels cannot contain periods ('.')`);\n            }\n        });\n        const params = {\n            namespace: namespace.join(\".\"),\n            key,\n        };\n        if (options?.refreshTtl !== undefined) {\n            params.refresh_ttl = options.refreshTtl;\n        }\n        const response = await this.fetch(\"/store/items\", {\n            params,\n        });\n        return response\n            ? {\n                ...response,\n                createdAt: response.created_at,\n                updatedAt: response.updated_at,\n            }\n            : null;\n    }\n    /**\n     * Delete an item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item.\n     * @returns Promise<void>\n     */\n    async deleteItem(namespace, key) {\n        namespace.forEach((label) => {\n            if (label.includes(\".\")) {\n                throw new Error(`Invalid namespace label '${label}'. Namespace labels cannot contain periods ('.')`);\n            }\n        });\n        return this.fetch(\"/store/items\", {\n            method: \"DELETE\",\n            json: { namespace, key },\n        });\n    }\n    /**\n     * Search for items within a namespace prefix.\n     *\n     * @param namespacePrefix List of strings representing the namespace prefix.\n     * @param options.filter Optional dictionary of key-value pairs to filter results.\n     * @param options.limit Maximum number of items to return (default is 10).\n     * @param options.offset Number of items to skip before returning results (default is 0).\n     * @param options.query Optional search query.\n     * @param options.refreshTtl Whether to refresh the TTL on items returned by this search. If null, uses the store's default behavior.\n     * @returns Promise<SearchItemsResponse>\n     *\n     * @example\n     * ```typescript\n     * const results = await client.store.searchItems(\n     *   [\"documents\"],\n     *   {\n     *     filter: { author: \"John Doe\" },\n     *     limit: 5,\n     *     refreshTtl: true\n     *   }\n     * );\n     * console.log(results);\n     * // {\n     * //   items: [\n     * //     {\n     * //       namespace: [\"documents\", \"user123\"],\n     * //       key: \"item789\",\n     * //       value: { title: \"Another Document\", author: \"John Doe\" },\n     * //       createdAt: \"2024-07-30T12:00:00Z\",\n     * //       updatedAt: \"2024-07-30T12:00:00Z\"\n     * //     },\n     * //     // ... additional items ...\n     * //   ]\n     * // }\n     * ```\n     */\n    async searchItems(namespacePrefix, options) {\n        const payload = {\n            namespace_prefix: namespacePrefix,\n            filter: options?.filter,\n            limit: options?.limit ?? 10,\n            offset: options?.offset ?? 0,\n            query: options?.query,\n            refresh_ttl: options?.refreshTtl,\n        };\n        const response = await this.fetch(\"/store/items/search\", {\n            method: \"POST\",\n            json: payload,\n        });\n        return {\n            items: response.items.map((item) => ({\n                ...item,\n                createdAt: item.created_at,\n                updatedAt: item.updated_at,\n            })),\n        };\n    }\n    /**\n     * List namespaces with optional match conditions.\n     *\n     * @param options.prefix Optional list of strings representing the prefix to filter namespaces.\n     * @param options.suffix Optional list of strings representing the suffix to filter namespaces.\n     * @param options.maxDepth Optional integer specifying the maximum depth of namespaces to return.\n     * @param options.limit Maximum number of namespaces to return (default is 100).\n     * @param options.offset Number of namespaces to skip before returning results (default is 0).\n     * @returns Promise<ListNamespaceResponse>\n     */\n    async listNamespaces(options) {\n        const payload = {\n            prefix: options?.prefix,\n            suffix: options?.suffix,\n            max_depth: options?.maxDepth,\n            limit: options?.limit ?? 100,\n            offset: options?.offset ?? 0,\n        };\n        return this.fetch(\"/store/namespaces\", {\n            method: \"POST\",\n            json: payload,\n        });\n    }\n}\nclass UiClient extends BaseClient {\n    static getOrCached(key, fn) {\n        if (UiClient.promiseCache[key] != null) {\n            return UiClient.promiseCache[key];\n        }\n        const promise = fn();\n        UiClient.promiseCache[key] = promise;\n        return promise;\n    }\n    async getComponent(assistantId, agentName) {\n        return UiClient.getOrCached(`${this.apiUrl}-${assistantId}-${agentName}`, async () => {\n            let [url, init] = this.prepareFetchOptions(`/ui/${assistantId}`, {\n                headers: {\n                    Accept: \"text/html\",\n                    \"Content-Type\": \"application/json\",\n                },\n                method: \"POST\",\n                json: { name: agentName },\n            });\n            if (this.onRequest != null)\n                init = await this.onRequest(url, init);\n            const response = await this.asyncCaller.fetch(url, init);\n            return response.text();\n        });\n    }\n}\nObject.defineProperty(UiClient, \"promiseCache\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: {}\n});\nclass Client {\n    constructor(config) {\n        /**\n         * The client for interacting with assistants.\n         */\n        Object.defineProperty(this, \"assistants\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with threads.\n         */\n        Object.defineProperty(this, \"threads\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with runs.\n         */\n        Object.defineProperty(this, \"runs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with cron runs.\n         */\n        Object.defineProperty(this, \"crons\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with the KV store.\n         */\n        Object.defineProperty(this, \"store\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with the UI.\n         * @internal Used by LoadExternalComponent and the API might change in the future.\n         */\n        Object.defineProperty(this, \"~ui\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * @internal Used to obtain a stable key representing the client.\n         */\n        Object.defineProperty(this, \"~configHash\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this[\"~configHash\"] = (() => JSON.stringify({\n            apiUrl: config?.apiUrl,\n            apiKey: config?.apiKey,\n            timeoutMs: config?.timeoutMs,\n            defaultHeaders: config?.defaultHeaders,\n            maxConcurrency: config?.callerOptions?.maxConcurrency,\n            maxRetries: config?.callerOptions?.maxRetries,\n            callbacks: {\n                onFailedResponseHook: config?.callerOptions?.onFailedResponseHook != null,\n                onRequest: config?.onRequest != null,\n                fetch: config?.callerOptions?.fetch != null,\n            },\n        }))();\n        this.assistants = new AssistantsClient(config);\n        this.threads = new ThreadsClient(config);\n        this.runs = new RunsClient(config);\n        this.crons = new CronsClient(config);\n        this.store = new StoreClient(config);\n        this[\"~ui\"] = new UiClient(config);\n    }\n}\n/**\n * @internal Used to obtain a stable key representing the client.\n */\nfunction getClientConfigHash(client) {\n    return client[\"~configHash\"];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc0Q7QUFDRTtBQUNOO0FBQ1k7QUFDSDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLFlBQVk7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUVBQXNCLElBQUksT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLCtEQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLCtEQUFZO0FBQzVDLHFDQUFxQyxZQUFZLEVBQUUsS0FBSztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFlBQVk7QUFDckQsc0JBQXNCLHFCQUFxQjtBQUMzQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZLGFBQWEsa0JBQWtCLEtBQUssVUFBVSw2QkFBNkI7QUFDcEk7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRCxzQkFBc0IsMkJBQTJCO0FBQ2pELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBLG9CQUFvQixTQUFTO0FBQzdCLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0Esb0JBQW9CLDhDQUE4QztBQUNsRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQ7QUFDQSw0QkFBNEIsMkNBQTJDO0FBQ3ZFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsMENBQTBDLFNBQVMsU0FBUyxXQUFXLEtBQUssVUFBVSxpQ0FBaUM7QUFDdkg7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQyxzQkFBc0IsK0JBQStCO0FBQ3JELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBLG9CQUFvQixVQUFVO0FBQzlCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFNBQVM7QUFDeEU7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELCtCQUErQjtBQUM3Rix5QkFBeUIsK0RBQWdCO0FBQ3pDLHlCQUF5Qix5REFBVTtBQUNuQyxlQUFlLG9FQUFzQjtBQUNyQztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLFNBQVM7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwrQkFBK0I7QUFDN0YseUJBQXlCLCtEQUFnQjtBQUN6Qyx5QkFBeUIseURBQVU7QUFDbkMsZUFBZSxvRUFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsU0FBUztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLCtDQUErQztBQUNoRjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsU0FBUztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCLElBQUksdUJBQXVCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUyxRQUFRLE1BQU07QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTLFFBQVEsTUFBTTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVMsUUFBUSxNQUFNO0FBQzdEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLDBCQUEwQixTQUFTLFFBQVEsTUFBTTtBQUNqRCx1QkFBdUIsTUFBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsK0JBQStCO0FBQzdGLHlCQUF5QiwrREFBZ0I7QUFDekMseUJBQXlCLHlEQUFVO0FBQ25DLGVBQWUsb0VBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTLFFBQVEsTUFBTTtBQUM3RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhDQUE4QztBQUN6RCxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELE1BQU07QUFDbEU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhDQUE4QztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELE1BQU07QUFDbEU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxNQUFNO0FBQ2xFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwrQ0FBK0M7QUFDeEU7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsWUFBWSxHQUFHLFlBQVksR0FBRyxVQUFVO0FBQy9FLDhEQUE4RCxZQUFZO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2hhZWxkdXJhbnRlL2FpIGRldi9jZS1odWIvcHJvamVjdHMvdHJhZGVycmEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vbGFuZ2dyYXBoLXNkay9kaXN0L2NsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBc3luY0NhbGxlciB9IGZyb20gXCIuL3V0aWxzL2FzeW5jX2NhbGxlci5qc1wiO1xuaW1wb3J0IHsgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSB9IGZyb20gXCIuL3V0aWxzL2Vudi5qc1wiO1xuaW1wb3J0IHsgbWVyZ2VTaWduYWxzIH0gZnJvbSBcIi4vdXRpbHMvc2lnbmFscy5qc1wiO1xuaW1wb3J0IHsgQnl0ZXNMaW5lRGVjb2RlciwgU1NFRGVjb2RlciB9IGZyb20gXCIuL3V0aWxzL3NzZS5qc1wiO1xuaW1wb3J0IHsgSXRlcmFibGVSZWFkYWJsZVN0cmVhbSB9IGZyb20gXCIuL3V0aWxzL3N0cmVhbS5qc1wiO1xuZnVuY3Rpb24qIGl0ZXJhdGVIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICBsZXQgaXRlcjtcbiAgICBsZXQgc2hvdWxkQ2xlYXIgPSBmYWxzZTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgICAgICAgaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgZW50cmllcy5wdXNoKFtuYW1lLCB2YWx1ZV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaXRlciA9IGVudHJpZXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICAgICAgaXRlciA9IGhlYWRlcnM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzaG91bGRDbGVhciA9IHRydWU7XG4gICAgICAgIGl0ZXIgPSBPYmplY3QuZW50cmllcyhoZWFkZXJzID8/IHt9KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZXIpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGl0ZW1bMF07XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGhlYWRlciBuYW1lIHRvIGJlIGEgc3RyaW5nLCBnb3QgJHt0eXBlb2YgbmFtZX1gKTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gQXJyYXkuaXNBcnJheShpdGVtWzFdKSA/IGl0ZW1bMV0gOiBbaXRlbVsxXV07XG4gICAgICAgIGxldCBkaWRDbGVhciA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAvLyBOZXcgb2JqZWN0IGtleXMgc2hvdWxkIGFsd2F5cyBvdmVyd3JpdGUgb2xkZXIgaGVhZGVyc1xuICAgICAgICAgICAgLy8gWWllbGQgYSBudWxsIHRvIGNsZWFyIHRoZSBoZWFkZXIgaW4gdGhlIGhlYWRlcnMgb2JqZWN0XG4gICAgICAgICAgICAvLyBiZWZvcmUgYWRkaW5nIHRoZSBuZXcgdmFsdWVcbiAgICAgICAgICAgIGlmIChzaG91bGRDbGVhciAmJiAhZGlkQ2xlYXIpIHtcbiAgICAgICAgICAgICAgICBkaWRDbGVhciA9IHRydWU7XG4gICAgICAgICAgICAgICAgeWllbGQgW25hbWUsIG51bGxdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgW25hbWUsIHZhbHVlXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlSGVhZGVycyguLi5oZWFkZXJPYmplY3RzKSB7XG4gICAgY29uc3Qgb3V0cHV0SGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgZm9yIChjb25zdCBoZWFkZXJzIG9mIGhlYWRlck9iamVjdHMpIHtcbiAgICAgICAgaWYgKCFoZWFkZXJzKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBpdGVyYXRlSGVhZGVycyhoZWFkZXJzKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIG91dHB1dEhlYWRlcnMuZGVsZXRlKG5hbWUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG91dHB1dEhlYWRlcnMuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBoZWFkZXJFbnRyaWVzID0gW107XG4gICAgb3V0cHV0SGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgICAgICBoZWFkZXJFbnRyaWVzLnB1c2goW25hbWUsIHZhbHVlXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhoZWFkZXJFbnRyaWVzKTtcbn1cbi8qKlxuICogR2V0IHRoZSBBUEkga2V5IGZyb20gdGhlIGVudmlyb25tZW50LlxuICogUHJlY2VkZW5jZTpcbiAqICAgMS4gZXhwbGljaXQgYXJndW1lbnRcbiAqICAgMi4gTEFOR0dSQVBIX0FQSV9LRVlcbiAqICAgMy4gTEFOR1NNSVRIX0FQSV9LRVlcbiAqICAgNC4gTEFOR0NIQUlOX0FQSV9LRVlcbiAqXG4gKiBAcGFyYW0gYXBpS2V5IC0gT3B0aW9uYWwgQVBJIGtleSBwcm92aWRlZCBhcyBhbiBhcmd1bWVudFxuICogQHJldHVybnMgVGhlIEFQSSBrZXkgaWYgZm91bmQsIG90aGVyd2lzZSB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFwaUtleShhcGlLZXkpIHtcbiAgICBpZiAoYXBpS2V5KSB7XG4gICAgICAgIHJldHVybiBhcGlLZXk7XG4gICAgfVxuICAgIGNvbnN0IHByZWZpeGVzID0gW1wiTEFOR0dSQVBIXCIsIFwiTEFOR1NNSVRIXCIsIFwiTEFOR0NIQUlOXCJdO1xuICAgIGZvciAoY29uc3QgcHJlZml4IG9mIHByZWZpeGVzKSB7XG4gICAgICAgIGNvbnN0IGVudktleSA9IGdldEVudmlyb25tZW50VmFyaWFibGUoYCR7cHJlZml4fV9BUElfS0VZYCk7XG4gICAgICAgIGlmIChlbnZLZXkpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBzdXJyb3VuZGluZyBxdW90ZXNcbiAgICAgICAgICAgIHJldHVybiBlbnZLZXkudHJpbSgpLnJlcGxhY2UoL15bXCInXXxbXCInXSQvZywgXCJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmNvbnN0IFJFR0VYX1JVTl9NRVRBREFUQSA9IC8oXFwvdGhyZWFkc1xcLyg/PHRocmVhZF9pZD4uKykpP1xcL3J1bnNcXC8oPzxydW5faWQ+LispLztcbmZ1bmN0aW9uIGdldFJ1bk1ldGFkYXRhRnJvbVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgY29udGVudExvY2F0aW9uID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJDb250ZW50LUxvY2F0aW9uXCIpO1xuICAgIGlmICghY29udGVudExvY2F0aW9uKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IG1hdGNoID0gUkVHRVhfUlVOX01FVEFEQVRBLmV4ZWMoY29udGVudExvY2F0aW9uKTtcbiAgICBpZiAoIW1hdGNoPy5ncm91cHM/LnJ1bl9pZClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4ge1xuICAgICAgICBydW5faWQ6IG1hdGNoLmdyb3Vwcy5ydW5faWQsXG4gICAgICAgIHRocmVhZF9pZDogbWF0Y2guZ3JvdXBzLnRocmVhZF9pZCB8fCB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmNsYXNzIEJhc2VDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhc3luY0NhbGxlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0aW1lb3V0TXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXBpVXJsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlZmF1bHRIZWFkZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uUmVxdWVzdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjYWxsZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgbWF4UmV0cmllczogNCxcbiAgICAgICAgICAgIG1heENvbmN1cnJlbmN5OiA0LFxuICAgICAgICAgICAgLi4uY29uZmlnPy5jYWxsZXJPcHRpb25zLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgZGVmYXVsdEFwaVVybCA9IFwiaHR0cDovL2xvY2FsaG9zdDo4MTIzXCI7XG4gICAgICAgIGlmICghY29uZmlnPy5hcGlVcmwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBnbG9iYWxUaGlzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGZldGNoU21iID0gU3ltYm9sLmZvcihcImxhbmdncmFwaF9hcGk6ZmV0Y2hcIik7XG4gICAgICAgICAgICBjb25zdCB1cmxTbWIgPSBTeW1ib2wuZm9yKFwibGFuZ2dyYXBoX2FwaTp1cmxcIik7XG4gICAgICAgICAgICBjb25zdCBnbG9iYWwgPSBnbG9iYWxUaGlzO1xuICAgICAgICAgICAgaWYgKGdsb2JhbFtmZXRjaFNtYl0pXG4gICAgICAgICAgICAgICAgY2FsbGVyT3B0aW9ucy5mZXRjaCA/Pz0gZ2xvYmFsW2ZldGNoU21iXTtcbiAgICAgICAgICAgIGlmIChnbG9iYWxbdXJsU21iXSlcbiAgICAgICAgICAgICAgICBkZWZhdWx0QXBpVXJsID0gZ2xvYmFsW3VybFNtYl07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hc3luY0NhbGxlciA9IG5ldyBBc3luY0NhbGxlcihjYWxsZXJPcHRpb25zKTtcbiAgICAgICAgdGhpcy50aW1lb3V0TXMgPSBjb25maWc/LnRpbWVvdXRNcztcbiAgICAgICAgLy8gZGVmYXVsdCBsaW1pdCBiZWluZyBjYXBwZWQgYnkgQ2hyb21lXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xMzczXG4gICAgICAgIC8vIFJlZ2V4IHRvIHJlbW92ZSB0cmFpbGluZyBzbGFzaCwgaWYgcHJlc2VudFxuICAgICAgICB0aGlzLmFwaVVybCA9IGNvbmZpZz8uYXBpVXJsPy5yZXBsYWNlKC9cXC8kLywgXCJcIikgfHwgZGVmYXVsdEFwaVVybDtcbiAgICAgICAgdGhpcy5kZWZhdWx0SGVhZGVycyA9IGNvbmZpZz8uZGVmYXVsdEhlYWRlcnMgfHwge307XG4gICAgICAgIHRoaXMub25SZXF1ZXN0ID0gY29uZmlnPy5vblJlcXVlc3Q7XG4gICAgICAgIGNvbnN0IGFwaUtleSA9IGdldEFwaUtleShjb25maWc/LmFwaUtleSk7XG4gICAgICAgIGlmIChhcGlLZXkpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdEhlYWRlcnNbXCJ4LWFwaS1rZXlcIl0gPSBhcGlLZXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJlcGFyZUZldGNoT3B0aW9ucyhwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG11dGF0ZWRPcHRpb25zID0ge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IG1lcmdlSGVhZGVycyh0aGlzLmRlZmF1bHRIZWFkZXJzLCBvcHRpb25zPy5oZWFkZXJzKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG11dGF0ZWRPcHRpb25zLmpzb24pIHtcbiAgICAgICAgICAgIG11dGF0ZWRPcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShtdXRhdGVkT3B0aW9ucy5qc29uKTtcbiAgICAgICAgICAgIG11dGF0ZWRPcHRpb25zLmhlYWRlcnMgPSBtZXJnZUhlYWRlcnMobXV0YXRlZE9wdGlvbnMuaGVhZGVycywge1xuICAgICAgICAgICAgICAgIFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWxldGUgbXV0YXRlZE9wdGlvbnMuanNvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXV0YXRlZE9wdGlvbnMud2l0aFJlc3BvbnNlKSB7XG4gICAgICAgICAgICBkZWxldGUgbXV0YXRlZE9wdGlvbnMud2l0aFJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0aW1lb3V0U2lnbmFsID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zPy50aW1lb3V0TXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRpbWVvdXRNcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dFNpZ25hbCA9IEFib3J0U2lnbmFsLnRpbWVvdXQob3B0aW9ucy50aW1lb3V0TXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudGltZW91dE1zICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRpbWVvdXRTaWduYWwgPSBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dE1zKTtcbiAgICAgICAgfVxuICAgICAgICBtdXRhdGVkT3B0aW9ucy5zaWduYWwgPSBtZXJnZVNpZ25hbHModGltZW91dFNpZ25hbCwgbXV0YXRlZE9wdGlvbnMuc2lnbmFsKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0VXJsID0gbmV3IFVSTChgJHt0aGlzLmFwaVVybH0ke3BhdGh9YCk7XG4gICAgICAgIGlmIChtdXRhdGVkT3B0aW9ucy5wYXJhbXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG11dGF0ZWRPcHRpb25zLnBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyVmFsdWUgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgICAgICAgID8gdmFsdWUudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHN0clZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBtdXRhdGVkT3B0aW9ucy5wYXJhbXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0YXJnZXRVcmwsIG11dGF0ZWRPcHRpb25zXTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2gocGF0aCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBbdXJsLCBpbml0XSA9IHRoaXMucHJlcGFyZUZldGNoT3B0aW9ucyhwYXRoLCBvcHRpb25zKTtcbiAgICAgICAgbGV0IGZpbmFsSW5pdCA9IGluaXQ7XG4gICAgICAgIGlmICh0aGlzLm9uUmVxdWVzdCkge1xuICAgICAgICAgICAgZmluYWxJbml0ID0gYXdhaXQgdGhpcy5vblJlcXVlc3QodXJsLCBpbml0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXN5bmNDYWxsZXIuZmV0Y2godXJsLCBmaW5hbEluaXQpO1xuICAgICAgICBjb25zdCBib2R5ID0gKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMiB8fCByZXNwb25zZS5zdGF0dXMgPT09IDIwNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9KSgpO1xuICAgICAgICBpZiAob3B0aW9ucz8ud2l0aFJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gW2F3YWl0IGJvZHksIHJlc3BvbnNlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm9keTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ3JvbnNDbGllbnQgZXh0ZW5kcyBCYXNlQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aHJlYWRJZCBUaGUgSUQgb2YgdGhlIHRocmVhZC5cbiAgICAgKiBAcGFyYW0gYXNzaXN0YW50SWQgQXNzaXN0YW50IElEIHRvIHVzZSBmb3IgdGhpcyBjcm9uIGpvYi5cbiAgICAgKiBAcGFyYW0gcGF5bG9hZCBQYXlsb2FkIGZvciBjcmVhdGluZyBhIGNyb24gam9iLlxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGJhY2tncm91bmQgcnVuLlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUZvclRocmVhZCh0aHJlYWRJZCwgYXNzaXN0YW50SWQsIHBheWxvYWQpIHtcbiAgICAgICAgY29uc3QganNvbiA9IHtcbiAgICAgICAgICAgIHNjaGVkdWxlOiBwYXlsb2FkPy5zY2hlZHVsZSxcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkPy5pbnB1dCxcbiAgICAgICAgICAgIGNvbmZpZzogcGF5bG9hZD8uY29uZmlnLFxuICAgICAgICAgICAgY29udGV4dDogcGF5bG9hZD8uY29udGV4dCxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBwYXlsb2FkPy5tZXRhZGF0YSxcbiAgICAgICAgICAgIGFzc2lzdGFudF9pZDogYXNzaXN0YW50SWQsXG4gICAgICAgICAgICBpbnRlcnJ1cHRfYmVmb3JlOiBwYXlsb2FkPy5pbnRlcnJ1cHRCZWZvcmUsXG4gICAgICAgICAgICBpbnRlcnJ1cHRfYWZ0ZXI6IHBheWxvYWQ/LmludGVycnVwdEFmdGVyLFxuICAgICAgICAgICAgd2ViaG9vazogcGF5bG9hZD8ud2ViaG9vayxcbiAgICAgICAgICAgIG11bHRpdGFza19zdHJhdGVneTogcGF5bG9hZD8ubXVsdGl0YXNrU3RyYXRlZ3ksXG4gICAgICAgICAgICBpZl9ub3RfZXhpc3RzOiBwYXlsb2FkPy5pZk5vdEV4aXN0cyxcbiAgICAgICAgICAgIGNoZWNrcG9pbnRfZHVyaW5nOiBwYXlsb2FkPy5jaGVja3BvaW50RHVyaW5nLFxuICAgICAgICAgICAgZHVyYWJpbGl0eTogcGF5bG9hZD8uZHVyYWJpbGl0eSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnMvY3JvbnNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2lzdGFudElkIEFzc2lzdGFudCBJRCB0byB1c2UgZm9yIHRoaXMgY3JvbiBqb2IuXG4gICAgICogQHBhcmFtIHBheWxvYWQgUGF5bG9hZCBmb3IgY3JlYXRpbmcgYSBjcm9uIGpvYi5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZShhc3Npc3RhbnRJZCwgcGF5bG9hZCkge1xuICAgICAgICBjb25zdCBqc29uID0ge1xuICAgICAgICAgICAgc2NoZWR1bGU6IHBheWxvYWQ/LnNjaGVkdWxlLFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQ/LmlucHV0LFxuICAgICAgICAgICAgY29uZmlnOiBwYXlsb2FkPy5jb25maWcsXG4gICAgICAgICAgICBjb250ZXh0OiBwYXlsb2FkPy5jb250ZXh0LFxuICAgICAgICAgICAgbWV0YWRhdGE6IHBheWxvYWQ/Lm1ldGFkYXRhLFxuICAgICAgICAgICAgYXNzaXN0YW50X2lkOiBhc3Npc3RhbnRJZCxcbiAgICAgICAgICAgIGludGVycnVwdF9iZWZvcmU6IHBheWxvYWQ/LmludGVycnVwdEJlZm9yZSxcbiAgICAgICAgICAgIGludGVycnVwdF9hZnRlcjogcGF5bG9hZD8uaW50ZXJydXB0QWZ0ZXIsXG4gICAgICAgICAgICB3ZWJob29rOiBwYXlsb2FkPy53ZWJob29rLFxuICAgICAgICAgICAgbXVsdGl0YXNrX3N0cmF0ZWd5OiBwYXlsb2FkPy5tdWx0aXRhc2tTdHJhdGVneSxcbiAgICAgICAgICAgIGlmX25vdF9leGlzdHM6IHBheWxvYWQ/LmlmTm90RXhpc3RzLFxuICAgICAgICAgICAgY2hlY2twb2ludF9kdXJpbmc6IHBheWxvYWQ/LmNoZWNrcG9pbnREdXJpbmcsXG4gICAgICAgICAgICBkdXJhYmlsaXR5OiBwYXlsb2FkPy5kdXJhYmlsaXR5LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3J1bnMvY3JvbnNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGNyb25JZCBDcm9uIElEIG9mIENyb24gam9iIHRvIGRlbGV0ZS5cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUoY3JvbklkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZmV0Y2goYC9ydW5zL2Nyb25zLyR7Y3JvbklkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHF1ZXJ5IFF1ZXJ5IG9wdGlvbnMuXG4gICAgICogQHJldHVybnMgTGlzdCBvZiBjcm9ucy5cbiAgICAgKi9cbiAgICBhc3luYyBzZWFyY2gocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCIvcnVucy9jcm9ucy9zZWFyY2hcIiwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGpzb246IHtcbiAgICAgICAgICAgICAgICBhc3Npc3RhbnRfaWQ6IHF1ZXJ5Py5hc3Npc3RhbnRJZCA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdGhyZWFkX2lkOiBxdWVyeT8udGhyZWFkSWQgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGxpbWl0OiBxdWVyeT8ubGltaXQgPz8gMTAsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBxdWVyeT8ub2Zmc2V0ID8/IDAsXG4gICAgICAgICAgICAgICAgc29ydF9ieTogcXVlcnk/LnNvcnRCeSA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgc29ydF9vcmRlcjogcXVlcnk/LnNvcnRPcmRlciA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgc2VsZWN0OiBxdWVyeT8uc2VsZWN0ID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3VudCBjcm9uIGpvYnMgbWF0Y2hpbmcgZmlsdGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBxdWVyeS5hc3Npc3RhbnRJZCBBc3Npc3RhbnQgSUQgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSBxdWVyeS50aHJlYWRJZCBUaHJlYWQgSUQgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEByZXR1cm5zIE51bWJlciBvZiBjcm9uIGpvYnMgbWF0Y2hpbmcgdGhlIGNyaXRlcmlhLlxuICAgICAqL1xuICAgIGFzeW5jIGNvdW50KHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvcnVucy9jcm9ucy9jb3VudGAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBqc29uOiB7XG4gICAgICAgICAgICAgICAgYXNzaXN0YW50X2lkOiBxdWVyeT8uYXNzaXN0YW50SWQgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHRocmVhZF9pZDogcXVlcnk/LnRocmVhZElkID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBc3Npc3RhbnRzQ2xpZW50IGV4dGVuZHMgQmFzZUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogR2V0IGFuIGFzc2lzdGFudCBieSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3Npc3RhbnRJZCBUaGUgSUQgb2YgdGhlIGFzc2lzdGFudC5cbiAgICAgKiBAcmV0dXJucyBBc3Npc3RhbnRcbiAgICAgKi9cbiAgICBhc3luYyBnZXQoYXNzaXN0YW50SWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC9hc3Npc3RhbnRzLyR7YXNzaXN0YW50SWR9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ3JhcGggYXNzaWduZWQgdG8gYSBydW5uYWJsZVxuICAgICAqIEBwYXJhbSBhc3Npc3RhbnRJZCBUaGUgSUQgb2YgdGhlIGFzc2lzdGFudC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy54cmF5IFdoZXRoZXIgdG8gaW5jbHVkZSBzdWJncmFwaHMgaW4gdGhlIHNlcmlhbGl6ZWQgZ3JhcGggcmVwcmVzZW50YXRpb24uIElmIGFuIGludGVnZXIgdmFsdWUgaXMgcHJvdmlkZWQsIG9ubHkgc3ViZ3JhcGhzIHdpdGggYSBkZXB0aCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIHdpbGwgYmUgaW5jbHVkZWQuXG4gICAgICogQHJldHVybnMgU2VyaWFsaXplZCBncmFwaFxuICAgICAqL1xuICAgIGFzeW5jIGdldEdyYXBoKGFzc2lzdGFudElkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvYXNzaXN0YW50cy8ke2Fzc2lzdGFudElkfS9ncmFwaGAsIHtcbiAgICAgICAgICAgIHBhcmFtczogeyB4cmF5OiBvcHRpb25zPy54cmF5IH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHN0YXRlIGFuZCBjb25maWcgc2NoZW1hIG9mIHRoZSBncmFwaCBhc3NpZ25lZCB0byBhIHJ1bm5hYmxlXG4gICAgICogQHBhcmFtIGFzc2lzdGFudElkIFRoZSBJRCBvZiB0aGUgYXNzaXN0YW50LlxuICAgICAqIEByZXR1cm5zIEdyYXBoIHNjaGVtYVxuICAgICAqL1xuICAgIGFzeW5jIGdldFNjaGVtYXMoYXNzaXN0YW50SWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC9hc3Npc3RhbnRzLyR7YXNzaXN0YW50SWR9L3NjaGVtYXNgKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzY2hlbWFzIG9mIGFuIGFzc2lzdGFudCBieSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3Npc3RhbnRJZCBUaGUgSUQgb2YgdGhlIGFzc2lzdGFudCB0byBnZXQgdGhlIHNjaGVtYSBvZi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGdldHRpbmcgc3ViZ3JhcGhzLCBzdWNoIGFzIG5hbWVzcGFjZSBvciByZWN1cnNpb24gZXh0cmFjdGlvbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3ViZ3JhcGhzIG9mIHRoZSBhc3Npc3RhbnQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U3ViZ3JhcGhzKGFzc2lzdGFudElkLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zPy5uYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvYXNzaXN0YW50cy8ke2Fzc2lzdGFudElkfS9zdWJncmFwaHMvJHtvcHRpb25zLm5hbWVzcGFjZX1gLCB7IHBhcmFtczogeyByZWN1cnNlOiBvcHRpb25zPy5yZWN1cnNlIH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC9hc3Npc3RhbnRzLyR7YXNzaXN0YW50SWR9L3N1YmdyYXBoc2AsIHtcbiAgICAgICAgICAgIHBhcmFtczogeyByZWN1cnNlOiBvcHRpb25zPy5yZWN1cnNlIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgYXNzaXN0YW50LlxuICAgICAqIEBwYXJhbSBwYXlsb2FkIFBheWxvYWQgZm9yIGNyZWF0aW5nIGFuIGFzc2lzdGFudC5cbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBhc3Npc3RhbnQuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCIvYXNzaXN0YW50c1wiLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbjoge1xuICAgICAgICAgICAgICAgIGdyYXBoX2lkOiBwYXlsb2FkLmdyYXBoSWQsXG4gICAgICAgICAgICAgICAgY29uZmlnOiBwYXlsb2FkLmNvbmZpZyxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBwYXlsb2FkLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHBheWxvYWQubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgYXNzaXN0YW50X2lkOiBwYXlsb2FkLmFzc2lzdGFudElkLFxuICAgICAgICAgICAgICAgIGlmX2V4aXN0czogcGF5bG9hZC5pZkV4aXN0cyxcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXlsb2FkLm5hbWUsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHBheWxvYWQuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGFuIGFzc2lzdGFudC5cbiAgICAgKiBAcGFyYW0gYXNzaXN0YW50SWQgSUQgb2YgdGhlIGFzc2lzdGFudC5cbiAgICAgKiBAcGFyYW0gcGF5bG9hZCBQYXlsb2FkIGZvciB1cGRhdGluZyB0aGUgYXNzaXN0YW50LlxuICAgICAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIGFzc2lzdGFudC5cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGUoYXNzaXN0YW50SWQsIHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC9hc3Npc3RhbnRzLyR7YXNzaXN0YW50SWR9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICBqc29uOiB7XG4gICAgICAgICAgICAgICAgZ3JhcGhfaWQ6IHBheWxvYWQuZ3JhcGhJZCxcbiAgICAgICAgICAgICAgICBjb25maWc6IHBheWxvYWQuY29uZmlnLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHBheWxvYWQuY29udGV4dCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogcGF5bG9hZC5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXlsb2FkLm5hbWUsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHBheWxvYWQuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGFuIGFzc2lzdGFudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3Npc3RhbnRJZCBJRCBvZiB0aGUgYXNzaXN0YW50LlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShhc3Npc3RhbnRJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL2Fzc2lzdGFudHMvJHthc3Npc3RhbnRJZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGFzc2lzdGFudHMuXG4gICAgICogQHBhcmFtIHF1ZXJ5IFF1ZXJ5IG9wdGlvbnMuXG4gICAgICogQHJldHVybnMgTGlzdCBvZiBhc3Npc3RhbnRzLlxuICAgICAqL1xuICAgIGFzeW5jIHNlYXJjaChxdWVyeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcIi9hc3Npc3RhbnRzL3NlYXJjaFwiLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbjoge1xuICAgICAgICAgICAgICAgIGdyYXBoX2lkOiBxdWVyeT8uZ3JhcGhJZCA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHF1ZXJ5Py5tZXRhZGF0YSA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbGltaXQ6IHF1ZXJ5Py5saW1pdCA/PyAxMCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHF1ZXJ5Py5vZmZzZXQgPz8gMCxcbiAgICAgICAgICAgICAgICBzb3J0X2J5OiBxdWVyeT8uc29ydEJ5ID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBzb3J0X29yZGVyOiBxdWVyeT8uc29ydE9yZGVyID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IHF1ZXJ5Py5zZWxlY3QgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvdW50IGFzc2lzdGFudHMgbWF0Y2hpbmcgZmlsdGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBxdWVyeS5tZXRhZGF0YSBNZXRhZGF0YSB0byBmaWx0ZXIgYnkuIEV4YWN0IG1hdGNoIGZvciBlYWNoIGtleS92YWx1ZS5cbiAgICAgKiBAcGFyYW0gcXVlcnkuZ3JhcGhJZCBPcHRpb25hbCBncmFwaCBpZCB0byBmaWx0ZXIgYnkuXG4gICAgICogQHJldHVybnMgTnVtYmVyIG9mIGFzc2lzdGFudHMgbWF0Y2hpbmcgdGhlIGNyaXRlcmlhLlxuICAgICAqL1xuICAgIGFzeW5jIGNvdW50KHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvYXNzaXN0YW50cy9jb3VudGAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBqc29uOiB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHF1ZXJ5Py5tZXRhZGF0YSA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZ3JhcGhfaWQ6IHF1ZXJ5Py5ncmFwaElkID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGFsbCB2ZXJzaW9ucyBvZiBhbiBhc3Npc3RhbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzaXN0YW50SWQgSUQgb2YgdGhlIGFzc2lzdGFudC5cbiAgICAgKiBAcmV0dXJucyBMaXN0IG9mIGFzc2lzdGFudCB2ZXJzaW9ucy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRWZXJzaW9ucyhhc3Npc3RhbnRJZCwgcGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL2Fzc2lzdGFudHMvJHthc3Npc3RhbnRJZH0vdmVyc2lvbnNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbjoge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBwYXlsb2FkPy5tZXRhZGF0YSA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbGltaXQ6IHBheWxvYWQ/LmxpbWl0ID8/IDEwLFxuICAgICAgICAgICAgICAgIG9mZnNldDogcGF5bG9hZD8ub2Zmc2V0ID8/IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSB2ZXJzaW9uIG9mIGFuIGFzc2lzdGFudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3Npc3RhbnRJZCBJRCBvZiB0aGUgYXNzaXN0YW50LlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSB2ZXJzaW9uIHRvIGNoYW5nZSB0by5cbiAgICAgKiBAcmV0dXJucyBUaGUgdXBkYXRlZCBhc3Npc3RhbnQuXG4gICAgICovXG4gICAgYXN5bmMgc2V0TGF0ZXN0KGFzc2lzdGFudElkLCB2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvYXNzaXN0YW50cy8ke2Fzc2lzdGFudElkfS9sYXRlc3RgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbjogeyB2ZXJzaW9uIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBUaHJlYWRzQ2xpZW50IGV4dGVuZHMgQmFzZUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogR2V0IGEgdGhyZWFkIGJ5IElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHRocmVhZElkIElEIG9mIHRoZSB0aHJlYWQuXG4gICAgICogQHJldHVybnMgVGhlIHRocmVhZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXQodGhyZWFkSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC90aHJlYWRzLyR7dGhyZWFkSWR9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyB0aHJlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF5bG9hZCBQYXlsb2FkIGZvciBjcmVhdGluZyBhIHRocmVhZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCB0aHJlYWQuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKHBheWxvYWQpIHtcbiAgICAgICAgLy8gTm9ybWFsaXplIHR0bCB0byBhbiBvYmplY3QgaWYgYSBudW1iZXIgaXMgcHJvdmlkZWRcbiAgICAgICAgY29uc3QgdHRsUGF5bG9hZCA9IHR5cGVvZiBwYXlsb2FkPy50dGwgPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgID8geyB0dGw6IHBheWxvYWQudHRsLCBzdHJhdGVneTogXCJkZWxldGVcIiB9XG4gICAgICAgICAgICA6IHBheWxvYWQ/LnR0bDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC90aHJlYWRzYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGpzb246IHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAuLi5wYXlsb2FkPy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhfaWQ6IHBheWxvYWQ/LmdyYXBoSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aHJlYWRfaWQ6IHBheWxvYWQ/LnRocmVhZElkLFxuICAgICAgICAgICAgICAgIGlmX2V4aXN0czogcGF5bG9hZD8uaWZFeGlzdHMsXG4gICAgICAgICAgICAgICAgc3VwZXJzdGVwczogcGF5bG9hZD8uc3VwZXJzdGVwcz8ubWFwKChzKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVzOiBzLnVwZGF0ZXMubWFwKCh1KSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiB1LnZhbHVlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IHUuY29tbWFuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzX25vZGU6IHUuYXNOb2RlLFxuICAgICAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgICAgIHR0bDogdHRsUGF5bG9hZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3B5IGFuIGV4aXN0aW5nIHRocmVhZFxuICAgICAqIEBwYXJhbSB0aHJlYWRJZCBJRCBvZiB0aGUgdGhyZWFkIHRvIGJlIGNvcGllZFxuICAgICAqIEByZXR1cm5zIE5ld2x5IGNvcGllZCB0aHJlYWRcbiAgICAgKi9cbiAgICBhc3luYyBjb3B5KHRocmVhZElkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvdGhyZWFkcy8ke3RocmVhZElkfS9jb3B5YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhIHRocmVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aHJlYWRJZCBJRCBvZiB0aGUgdGhyZWFkLlxuICAgICAqIEBwYXJhbSBwYXlsb2FkIFBheWxvYWQgZm9yIHVwZGF0aW5nIHRoZSB0aHJlYWQuXG4gICAgICogQHJldHVybnMgVGhlIHVwZGF0ZWQgdGhyZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZSh0aHJlYWRJZCwgcGF5bG9hZCkge1xuICAgICAgICBjb25zdCB0dGxQYXlsb2FkID0gdHlwZW9mIHBheWxvYWQ/LnR0bCA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgPyB7IHR0bDogcGF5bG9hZC50dGwsIHN0cmF0ZWd5OiBcImRlbGV0ZVwiIH1cbiAgICAgICAgICAgIDogcGF5bG9hZD8udHRsO1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHMvJHt0aHJlYWRJZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgIGpzb246IHsgbWV0YWRhdGE6IHBheWxvYWQ/Lm1ldGFkYXRhLCB0dGw6IHR0bFBheWxvYWQgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHRocmVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aHJlYWRJZCBJRCBvZiB0aGUgdGhyZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZSh0aHJlYWRJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHMvJHt0aHJlYWRJZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IHRocmVhZHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBxdWVyeSBRdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybnMgTGlzdCBvZiB0aHJlYWRzXG4gICAgICovXG4gICAgYXN5bmMgc2VhcmNoKHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwiL3RocmVhZHMvc2VhcmNoXCIsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBqc29uOiB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHF1ZXJ5Py5tZXRhZGF0YSA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgaWRzOiBxdWVyeT8uaWRzID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBsaW1pdDogcXVlcnk/LmxpbWl0ID8/IDEwLFxuICAgICAgICAgICAgICAgIG9mZnNldDogcXVlcnk/Lm9mZnNldCA/PyAwLFxuICAgICAgICAgICAgICAgIHN0YXR1czogcXVlcnk/LnN0YXR1cyxcbiAgICAgICAgICAgICAgICBzb3J0X2J5OiBxdWVyeT8uc29ydEJ5LFxuICAgICAgICAgICAgICAgIHNvcnRfb3JkZXI6IHF1ZXJ5Py5zb3J0T3JkZXIsXG4gICAgICAgICAgICAgICAgc2VsZWN0OiBxdWVyeT8uc2VsZWN0ID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3VudCB0aHJlYWRzIG1hdGNoaW5nIGZpbHRlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcXVlcnkubWV0YWRhdGEgVGhyZWFkIG1ldGFkYXRhIHRvIGZpbHRlciBvbi5cbiAgICAgKiBAcGFyYW0gcXVlcnkudmFsdWVzIFN0YXRlIHZhbHVlcyB0byBmaWx0ZXIgb24uXG4gICAgICogQHBhcmFtIHF1ZXJ5LnN0YXR1cyBUaHJlYWQgc3RhdHVzIHRvIGZpbHRlciBvbi5cbiAgICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgdGhyZWFkcyBtYXRjaGluZyB0aGUgY3JpdGVyaWEuXG4gICAgICovXG4gICAgYXN5bmMgY291bnQocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC90aHJlYWRzL2NvdW50YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGpzb246IHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogcXVlcnk/Lm1ldGFkYXRhID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHF1ZXJ5Py52YWx1ZXMgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHN0YXR1czogcXVlcnk/LnN0YXR1cyA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHN0YXRlIGZvciBhIHRocmVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aHJlYWRJZCBJRCBvZiB0aGUgdGhyZWFkLlxuICAgICAqIEByZXR1cm5zIFRocmVhZCBzdGF0ZS5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTdGF0ZSh0aHJlYWRJZCwgY2hlY2twb2ludCwgb3B0aW9ucykge1xuICAgICAgICBpZiAoY2hlY2twb2ludCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoZWNrcG9pbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHMvJHt0aHJlYWRJZH0vc3RhdGUvY2hlY2twb2ludGAsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICAgICAganNvbjogeyBjaGVja3BvaW50LCBzdWJncmFwaHM6IG9wdGlvbnM/LnN1YmdyYXBocyB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGVwcmVjYXRlZFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC90aHJlYWRzLyR7dGhyZWFkSWR9L3N0YXRlLyR7Y2hlY2twb2ludH1gLCB7IHBhcmFtczogeyBzdWJncmFwaHM6IG9wdGlvbnM/LnN1YmdyYXBocyB9IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvdGhyZWFkcy8ke3RocmVhZElkfS9zdGF0ZWAsIHtcbiAgICAgICAgICAgIHBhcmFtczogeyBzdWJncmFwaHM6IG9wdGlvbnM/LnN1YmdyYXBocyB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHN0YXRlIHRvIGEgdGhyZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRocmVhZElkIFRoZSBJRCBvZiB0aGUgdGhyZWFkLlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlU3RhdGUodGhyZWFkSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC90aHJlYWRzLyR7dGhyZWFkSWR9L3N0YXRlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGpzb246IHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IG9wdGlvbnMudmFsdWVzLFxuICAgICAgICAgICAgICAgIGNoZWNrcG9pbnRfaWQ6IG9wdGlvbnMuY2hlY2twb2ludElkLFxuICAgICAgICAgICAgICAgIGNoZWNrcG9pbnQ6IG9wdGlvbnMuY2hlY2twb2ludCxcbiAgICAgICAgICAgICAgICBhc19ub2RlOiBvcHRpb25zPy5hc05vZGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGF0Y2ggdGhlIG1ldGFkYXRhIG9mIGEgdGhyZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRocmVhZElkT3JDb25maWcgVGhyZWFkIElEIG9yIGNvbmZpZyB0byBwYXRjaCB0aGUgc3RhdGUgb2YuXG4gICAgICogQHBhcmFtIG1ldGFkYXRhIE1ldGFkYXRhIHRvIHBhdGNoIHRoZSBzdGF0ZSB3aXRoLlxuICAgICAqL1xuICAgIGFzeW5jIHBhdGNoU3RhdGUodGhyZWFkSWRPckNvbmZpZywgbWV0YWRhdGEpIHtcbiAgICAgICAgbGV0IHRocmVhZElkO1xuICAgICAgICBpZiAodHlwZW9mIHRocmVhZElkT3JDb25maWcgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhyZWFkSWRPckNvbmZpZy5jb25maWd1cmFibGU/LnRocmVhZF9pZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRocmVhZCBJRCBpcyByZXF1aXJlZCB3aGVuIHVwZGF0aW5nIHN0YXRlIHdpdGggYSBjb25maWcuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyZWFkSWQgPSB0aHJlYWRJZE9yQ29uZmlnLmNvbmZpZ3VyYWJsZS50aHJlYWRfaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJlYWRJZCA9IHRocmVhZElkT3JDb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC90aHJlYWRzLyR7dGhyZWFkSWR9L3N0YXRlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICBqc29uOiB7IG1ldGFkYXRhIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHBhc3Qgc3RhdGVzIGZvciBhIHRocmVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aHJlYWRJZCBJRCBvZiB0aGUgdGhyZWFkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJucyBMaXN0IG9mIHRocmVhZCBzdGF0ZXMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0SGlzdG9yeSh0aHJlYWRJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHMvJHt0aHJlYWRJZH0vaGlzdG9yeWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBqc29uOiB7XG4gICAgICAgICAgICAgICAgbGltaXQ6IG9wdGlvbnM/LmxpbWl0ID8/IDEwLFxuICAgICAgICAgICAgICAgIGJlZm9yZTogb3B0aW9ucz8uYmVmb3JlLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBvcHRpb25zPy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBjaGVja3BvaW50OiBvcHRpb25zPy5jaGVja3BvaW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jICpqb2luU3RyZWFtKHRocmVhZElkLCBvcHRpb25zXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICApIHtcbiAgICAgICAgbGV0IFt1cmwsIGluaXRdID0gdGhpcy5wcmVwYXJlRmV0Y2hPcHRpb25zKGAvdGhyZWFkcy8ke3RocmVhZElkfS9zdHJlYW1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiBvcHRpb25zPy5sYXN0RXZlbnRJZFxuICAgICAgICAgICAgICAgID8geyBcIkxhc3QtRXZlbnQtSURcIjogb3B0aW9ucy5sYXN0RXZlbnRJZCB9XG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwYXJhbXM6IG9wdGlvbnM/LnN0cmVhbU1vZGVcbiAgICAgICAgICAgICAgICA/IHsgc3RyZWFtX21vZGU6IG9wdGlvbnMuc3RyZWFtTW9kZSB9XG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5vblJlcXVlc3QgIT0gbnVsbClcbiAgICAgICAgICAgIGluaXQgPSBhd2FpdCB0aGlzLm9uUmVxdWVzdCh1cmwsIGluaXQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXN5bmNDYWxsZXIuZmV0Y2godXJsLCBpbml0KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gKHJlc3BvbnNlLmJvZHkgfHwgbmV3IFJlYWRhYmxlU3RyZWFtKHsgc3RhcnQ6IChjdHJsKSA9PiBjdHJsLmNsb3NlKCkgfSkpXG4gICAgICAgICAgICAucGlwZVRocm91Z2goQnl0ZXNMaW5lRGVjb2RlcigpKVxuICAgICAgICAgICAgLnBpcGVUaHJvdWdoKFNTRURlY29kZXIoKSk7XG4gICAgICAgIHlpZWxkKiBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21SZWFkYWJsZVN0cmVhbShzdHJlYW0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSdW5zQ2xpZW50IGV4dGVuZHMgQmFzZUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgcnVuIGFuZCBzdHJlYW0gdGhlIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGhyZWFkSWQgVGhlIElEIG9mIHRoZSB0aHJlYWQuXG4gICAgICogQHBhcmFtIGFzc2lzdGFudElkIEFzc2lzdGFudCBJRCB0byB1c2UgZm9yIHRoaXMgcnVuLlxuICAgICAqIEBwYXJhbSBwYXlsb2FkIFBheWxvYWQgZm9yIGNyZWF0aW5nIGEgcnVuLlxuICAgICAqL1xuICAgIGFzeW5jICpzdHJlYW0odGhyZWFkSWQsIGFzc2lzdGFudElkLCBwYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IGpzb24gPSB7XG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZD8uaW5wdXQsXG4gICAgICAgICAgICBjb21tYW5kOiBwYXlsb2FkPy5jb21tYW5kLFxuICAgICAgICAgICAgY29uZmlnOiBwYXlsb2FkPy5jb25maWcsXG4gICAgICAgICAgICBjb250ZXh0OiBwYXlsb2FkPy5jb250ZXh0LFxuICAgICAgICAgICAgbWV0YWRhdGE6IHBheWxvYWQ/Lm1ldGFkYXRhLFxuICAgICAgICAgICAgc3RyZWFtX21vZGU6IHBheWxvYWQ/LnN0cmVhbU1vZGUsXG4gICAgICAgICAgICBzdHJlYW1fc3ViZ3JhcGhzOiBwYXlsb2FkPy5zdHJlYW1TdWJncmFwaHMsXG4gICAgICAgICAgICBzdHJlYW1fcmVzdW1hYmxlOiBwYXlsb2FkPy5zdHJlYW1SZXN1bWFibGUsXG4gICAgICAgICAgICBmZWVkYmFja19rZXlzOiBwYXlsb2FkPy5mZWVkYmFja0tleXMsXG4gICAgICAgICAgICBhc3Npc3RhbnRfaWQ6IGFzc2lzdGFudElkLFxuICAgICAgICAgICAgaW50ZXJydXB0X2JlZm9yZTogcGF5bG9hZD8uaW50ZXJydXB0QmVmb3JlLFxuICAgICAgICAgICAgaW50ZXJydXB0X2FmdGVyOiBwYXlsb2FkPy5pbnRlcnJ1cHRBZnRlcixcbiAgICAgICAgICAgIGNoZWNrcG9pbnQ6IHBheWxvYWQ/LmNoZWNrcG9pbnQsXG4gICAgICAgICAgICBjaGVja3BvaW50X2lkOiBwYXlsb2FkPy5jaGVja3BvaW50SWQsXG4gICAgICAgICAgICB3ZWJob29rOiBwYXlsb2FkPy53ZWJob29rLFxuICAgICAgICAgICAgbXVsdGl0YXNrX3N0cmF0ZWd5OiBwYXlsb2FkPy5tdWx0aXRhc2tTdHJhdGVneSxcbiAgICAgICAgICAgIG9uX2NvbXBsZXRpb246IHBheWxvYWQ/Lm9uQ29tcGxldGlvbixcbiAgICAgICAgICAgIG9uX2Rpc2Nvbm5lY3Q6IHBheWxvYWQ/Lm9uRGlzY29ubmVjdCxcbiAgICAgICAgICAgIGFmdGVyX3NlY29uZHM6IHBheWxvYWQ/LmFmdGVyU2Vjb25kcyxcbiAgICAgICAgICAgIGlmX25vdF9leGlzdHM6IHBheWxvYWQ/LmlmTm90RXhpc3RzLFxuICAgICAgICAgICAgY2hlY2twb2ludF9kdXJpbmc6IHBheWxvYWQ/LmNoZWNrcG9pbnREdXJpbmcsXG4gICAgICAgICAgICBkdXJhYmlsaXR5OiBwYXlsb2FkPy5kdXJhYmlsaXR5LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IHRocmVhZElkID09IG51bGwgPyBgL3J1bnMvc3RyZWFtYCA6IGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zL3N0cmVhbWA7XG4gICAgICAgIGxldCBbdXJsLCBpbml0XSA9IHRoaXMucHJlcGFyZUZldGNoT3B0aW9ucyhlbmRwb2ludCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGpzb24sXG4gICAgICAgICAgICB0aW1lb3V0TXM6IG51bGwsXG4gICAgICAgICAgICBzaWduYWw6IHBheWxvYWQ/LnNpZ25hbCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLm9uUmVxdWVzdCAhPSBudWxsKVxuICAgICAgICAgICAgaW5pdCA9IGF3YWl0IHRoaXMub25SZXF1ZXN0KHVybCwgaW5pdCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hc3luY0NhbGxlci5mZXRjaCh1cmwsIGluaXQpO1xuICAgICAgICBjb25zdCBydW5NZXRhZGF0YSA9IGdldFJ1bk1ldGFkYXRhRnJvbVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgaWYgKHJ1bk1ldGFkYXRhKVxuICAgICAgICAgICAgcGF5bG9hZD8ub25SdW5DcmVhdGVkPy4ocnVuTWV0YWRhdGEpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBzdHJlYW0gPSAocmVzcG9uc2UuYm9keSB8fCBuZXcgUmVhZGFibGVTdHJlYW0oeyBzdGFydDogKGN0cmwpID0+IGN0cmwuY2xvc2UoKSB9KSlcbiAgICAgICAgICAgIC5waXBlVGhyb3VnaChCeXRlc0xpbmVEZWNvZGVyKCkpXG4gICAgICAgICAgICAucGlwZVRocm91Z2goU1NFRGVjb2RlcigpKTtcbiAgICAgICAgeWllbGQqIEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0uZnJvbVJlYWRhYmxlU3RyZWFtKHN0cmVhbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHJ1bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aHJlYWRJZCBUaGUgSUQgb2YgdGhlIHRocmVhZC5cbiAgICAgKiBAcGFyYW0gYXNzaXN0YW50SWQgQXNzaXN0YW50IElEIHRvIHVzZSBmb3IgdGhpcyBydW4uXG4gICAgICogQHBhcmFtIHBheWxvYWQgUGF5bG9hZCBmb3IgY3JlYXRpbmcgYSBydW4uXG4gICAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgcnVuLlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZSh0aHJlYWRJZCwgYXNzaXN0YW50SWQsIHBheWxvYWQpIHtcbiAgICAgICAgY29uc3QganNvbiA9IHtcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkPy5pbnB1dCxcbiAgICAgICAgICAgIGNvbW1hbmQ6IHBheWxvYWQ/LmNvbW1hbmQsXG4gICAgICAgICAgICBjb25maWc6IHBheWxvYWQ/LmNvbmZpZyxcbiAgICAgICAgICAgIGNvbnRleHQ6IHBheWxvYWQ/LmNvbnRleHQsXG4gICAgICAgICAgICBtZXRhZGF0YTogcGF5bG9hZD8ubWV0YWRhdGEsXG4gICAgICAgICAgICBzdHJlYW1fbW9kZTogcGF5bG9hZD8uc3RyZWFtTW9kZSxcbiAgICAgICAgICAgIHN0cmVhbV9zdWJncmFwaHM6IHBheWxvYWQ/LnN0cmVhbVN1YmdyYXBocyxcbiAgICAgICAgICAgIHN0cmVhbV9yZXN1bWFibGU6IHBheWxvYWQ/LnN0cmVhbVJlc3VtYWJsZSxcbiAgICAgICAgICAgIGFzc2lzdGFudF9pZDogYXNzaXN0YW50SWQsXG4gICAgICAgICAgICBpbnRlcnJ1cHRfYmVmb3JlOiBwYXlsb2FkPy5pbnRlcnJ1cHRCZWZvcmUsXG4gICAgICAgICAgICBpbnRlcnJ1cHRfYWZ0ZXI6IHBheWxvYWQ/LmludGVycnVwdEFmdGVyLFxuICAgICAgICAgICAgd2ViaG9vazogcGF5bG9hZD8ud2ViaG9vayxcbiAgICAgICAgICAgIGNoZWNrcG9pbnQ6IHBheWxvYWQ/LmNoZWNrcG9pbnQsXG4gICAgICAgICAgICBjaGVja3BvaW50X2lkOiBwYXlsb2FkPy5jaGVja3BvaW50SWQsXG4gICAgICAgICAgICBtdWx0aXRhc2tfc3RyYXRlZ3k6IHBheWxvYWQ/Lm11bHRpdGFza1N0cmF0ZWd5LFxuICAgICAgICAgICAgYWZ0ZXJfc2Vjb25kczogcGF5bG9hZD8uYWZ0ZXJTZWNvbmRzLFxuICAgICAgICAgICAgaWZfbm90X2V4aXN0czogcGF5bG9hZD8uaWZOb3RFeGlzdHMsXG4gICAgICAgICAgICBjaGVja3BvaW50X2R1cmluZzogcGF5bG9hZD8uY2hlY2twb2ludER1cmluZyxcbiAgICAgICAgICAgIGR1cmFiaWxpdHk6IHBheWxvYWQ/LmR1cmFiaWxpdHksXG4gICAgICAgICAgICBsYW5nc21pdGhfdHJhY2VyOiBwYXlsb2FkPy5fbGFuZ3NtaXRoVHJhY2VyXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIHByb2plY3RfbmFtZTogcGF5bG9hZD8uX2xhbmdzbWl0aFRyYWNlcj8ucHJvamVjdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGV4YW1wbGVfaWQ6IHBheWxvYWQ/Ll9sYW5nc21pdGhUcmFjZXI/LmV4YW1wbGVJZCxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVuZHBvaW50ID0gdGhyZWFkSWQgPT09IG51bGwgPyBcIi9ydW5zXCIgOiBgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVuc2A7XG4gICAgICAgIGNvbnN0IFtydW4sIHJlc3BvbnNlXSA9IGF3YWl0IHRoaXMuZmV0Y2goZW5kcG9pbnQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBqc29uLFxuICAgICAgICAgICAgc2lnbmFsOiBwYXlsb2FkPy5zaWduYWwsXG4gICAgICAgICAgICB3aXRoUmVzcG9uc2U6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBydW5NZXRhZGF0YSA9IGdldFJ1bk1ldGFkYXRhRnJvbVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgaWYgKHJ1bk1ldGFkYXRhKVxuICAgICAgICAgICAgcGF5bG9hZD8ub25SdW5DcmVhdGVkPy4ocnVuTWV0YWRhdGEpO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBiYXRjaCBvZiBzdGF0ZWxlc3MgYmFja2dyb3VuZCBydW5zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBheWxvYWRzIEFuIGFycmF5IG9mIHBheWxvYWRzIGZvciBjcmVhdGluZyBydW5zLlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGNyZWF0ZWQgcnVucy5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVCYXRjaChwYXlsb2Fkcykge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZFBheWxvYWRzID0gcGF5bG9hZHNcbiAgICAgICAgICAgIC5tYXAoKHBheWxvYWQpID0+ICh7IC4uLnBheWxvYWQsIGFzc2lzdGFudF9pZDogcGF5bG9hZC5hc3Npc3RhbnRJZCB9KSlcbiAgICAgICAgICAgIC5tYXAoKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMocGF5bG9hZCkuZmlsdGVyKChbXywgdl0pID0+IHYgIT09IHVuZGVmaW5lZCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCIvcnVucy9iYXRjaFwiLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbjogZmlsdGVyZWRQYXlsb2FkcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHJ1biBhbmQgd2FpdCBmb3IgaXQgdG8gY29tcGxldGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGhyZWFkSWQgVGhlIElEIG9mIHRoZSB0aHJlYWQuXG4gICAgICogQHBhcmFtIGFzc2lzdGFudElkIEFzc2lzdGFudCBJRCB0byB1c2UgZm9yIHRoaXMgcnVuLlxuICAgICAqIEBwYXJhbSBwYXlsb2FkIFBheWxvYWQgZm9yIGNyZWF0aW5nIGEgcnVuLlxuICAgICAqIEByZXR1cm5zIFRoZSBsYXN0IHZhbHVlcyBjaHVuayBvZiB0aGUgdGhyZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXQodGhyZWFkSWQsIGFzc2lzdGFudElkLCBwYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IGpzb24gPSB7XG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZD8uaW5wdXQsXG4gICAgICAgICAgICBjb21tYW5kOiBwYXlsb2FkPy5jb21tYW5kLFxuICAgICAgICAgICAgY29uZmlnOiBwYXlsb2FkPy5jb25maWcsXG4gICAgICAgICAgICBjb250ZXh0OiBwYXlsb2FkPy5jb250ZXh0LFxuICAgICAgICAgICAgbWV0YWRhdGE6IHBheWxvYWQ/Lm1ldGFkYXRhLFxuICAgICAgICAgICAgYXNzaXN0YW50X2lkOiBhc3Npc3RhbnRJZCxcbiAgICAgICAgICAgIGludGVycnVwdF9iZWZvcmU6IHBheWxvYWQ/LmludGVycnVwdEJlZm9yZSxcbiAgICAgICAgICAgIGludGVycnVwdF9hZnRlcjogcGF5bG9hZD8uaW50ZXJydXB0QWZ0ZXIsXG4gICAgICAgICAgICBjaGVja3BvaW50OiBwYXlsb2FkPy5jaGVja3BvaW50LFxuICAgICAgICAgICAgY2hlY2twb2ludF9pZDogcGF5bG9hZD8uY2hlY2twb2ludElkLFxuICAgICAgICAgICAgd2ViaG9vazogcGF5bG9hZD8ud2ViaG9vayxcbiAgICAgICAgICAgIG11bHRpdGFza19zdHJhdGVneTogcGF5bG9hZD8ubXVsdGl0YXNrU3RyYXRlZ3ksXG4gICAgICAgICAgICBvbl9jb21wbGV0aW9uOiBwYXlsb2FkPy5vbkNvbXBsZXRpb24sXG4gICAgICAgICAgICBvbl9kaXNjb25uZWN0OiBwYXlsb2FkPy5vbkRpc2Nvbm5lY3QsXG4gICAgICAgICAgICBhZnRlcl9zZWNvbmRzOiBwYXlsb2FkPy5hZnRlclNlY29uZHMsXG4gICAgICAgICAgICBpZl9ub3RfZXhpc3RzOiBwYXlsb2FkPy5pZk5vdEV4aXN0cyxcbiAgICAgICAgICAgIGNoZWNrcG9pbnRfZHVyaW5nOiBwYXlsb2FkPy5jaGVja3BvaW50RHVyaW5nLFxuICAgICAgICAgICAgZHVyYWJpbGl0eTogcGF5bG9hZD8uZHVyYWJpbGl0eSxcbiAgICAgICAgICAgIGxhbmdzbWl0aF90cmFjZXI6IHBheWxvYWQ/Ll9sYW5nc21pdGhUcmFjZXJcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdF9uYW1lOiBwYXlsb2FkPy5fbGFuZ3NtaXRoVHJhY2VyPy5wcm9qZWN0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhbXBsZV9pZDogcGF5bG9hZD8uX2xhbmdzbWl0aFRyYWNlcj8uZXhhbXBsZUlkLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZW5kcG9pbnQgPSB0aHJlYWRJZCA9PSBudWxsID8gYC9ydW5zL3dhaXRgIDogYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnMvd2FpdGA7XG4gICAgICAgIGNvbnN0IFtydW4sIHJlc3BvbnNlXSA9IGF3YWl0IHRoaXMuZmV0Y2goZW5kcG9pbnQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBqc29uLFxuICAgICAgICAgICAgdGltZW91dE1zOiBudWxsLFxuICAgICAgICAgICAgc2lnbmFsOiBwYXlsb2FkPy5zaWduYWwsXG4gICAgICAgICAgICB3aXRoUmVzcG9uc2U6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBydW5NZXRhZGF0YSA9IGdldFJ1bk1ldGFkYXRhRnJvbVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgaWYgKHJ1bk1ldGFkYXRhKVxuICAgICAgICAgICAgcGF5bG9hZD8ub25SdW5DcmVhdGVkPy4ocnVuTWV0YWRhdGEpO1xuICAgICAgICBjb25zdCByYWlzZUVycm9yID0gcGF5bG9hZD8ucmFpc2VFcnJvciAhPT0gdW5kZWZpbmVkID8gcGF5bG9hZC5yYWlzZUVycm9yIDogdHJ1ZTtcbiAgICAgICAgaWYgKHJhaXNlRXJyb3IgJiZcbiAgICAgICAgICAgIFwiX19lcnJvcl9fXCIgaW4gcnVuICYmXG4gICAgICAgICAgICB0eXBlb2YgcnVuLl9fZXJyb3JfXyA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgcnVuLl9fZXJyb3JfXyAmJlxuICAgICAgICAgICAgXCJlcnJvclwiIGluIHJ1bi5fX2Vycm9yX18gJiZcbiAgICAgICAgICAgIFwibWVzc2FnZVwiIGluIHJ1bi5fX2Vycm9yX18pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtydW4uX19lcnJvcl9fPy5lcnJvcn06ICR7cnVuLl9fZXJyb3JfXz8ubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGFsbCBydW5zIGZvciBhIHRocmVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aHJlYWRJZCBUaGUgSUQgb2YgdGhlIHRocmVhZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBGaWx0ZXJpbmcgYW5kIHBhZ2luYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJucyBMaXN0IG9mIHJ1bnMuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdCh0aHJlYWRJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVuc2AsIHtcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIGxpbWl0OiBvcHRpb25zPy5saW1pdCA/PyAxMCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG9wdGlvbnM/Lm9mZnNldCA/PyAwLFxuICAgICAgICAgICAgICAgIHN0YXR1czogb3B0aW9ucz8uc3RhdHVzID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IG9wdGlvbnM/LnNlbGVjdCA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgcnVuIGJ5IElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHRocmVhZElkIFRoZSBJRCBvZiB0aGUgdGhyZWFkLlxuICAgICAqIEBwYXJhbSBydW5JZCBUaGUgSUQgb2YgdGhlIHJ1bi5cbiAgICAgKiBAcmV0dXJucyBUaGUgcnVuLlxuICAgICAqL1xuICAgIGFzeW5jIGdldCh0aHJlYWRJZCwgcnVuSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnMvJHtydW5JZH1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VsIGEgcnVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRocmVhZElkIFRoZSBJRCBvZiB0aGUgdGhyZWFkLlxuICAgICAqIEBwYXJhbSBydW5JZCBUaGUgSUQgb2YgdGhlIHJ1bi5cbiAgICAgKiBAcGFyYW0gd2FpdCBXaGV0aGVyIHRvIGJsb2NrIHdoZW4gY2FuY2VsaW5nXG4gICAgICogQHBhcmFtIGFjdGlvbiBBY3Rpb24gdG8gdGFrZSB3aGVuIGNhbmNlbGxpbmcgdGhlIHJ1bi4gUG9zc2libGUgdmFsdWVzIGFyZSBgaW50ZXJydXB0YCBvciBgcm9sbGJhY2tgLiBEZWZhdWx0IGlzIGBpbnRlcnJ1cHRgLlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgYXN5bmMgY2FuY2VsKHRocmVhZElkLCBydW5JZCwgd2FpdCA9IGZhbHNlLCBhY3Rpb24gPSBcImludGVycnVwdFwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zLyR7cnVuSWR9L2NhbmNlbGAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICB3YWl0OiB3YWl0ID8gXCIxXCIgOiBcIjBcIixcbiAgICAgICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmxvY2sgdW50aWwgYSBydW4gaXMgZG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aHJlYWRJZCBUaGUgSUQgb2YgdGhlIHRocmVhZC5cbiAgICAgKiBAcGFyYW0gcnVuSWQgVGhlIElEIG9mIHRoZSBydW4uXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBhc3luYyBqb2luKHRocmVhZElkLCBydW5JZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVucy8ke3J1bklkfS9qb2luYCwge1xuICAgICAgICAgICAgdGltZW91dE1zOiBudWxsLFxuICAgICAgICAgICAgc2lnbmFsOiBvcHRpb25zPy5zaWduYWwsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJlYW0gb3V0cHV0IGZyb20gYSBydW4gaW4gcmVhbC10aW1lLCB1bnRpbCB0aGUgcnVuIGlzIGRvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGhyZWFkSWQgVGhlIElEIG9mIHRoZSB0aHJlYWQuIENhbiBiZSBzZXQgdG8gYG51bGxgIHwgYHVuZGVmaW5lZGAgZm9yIHN0YXRlbGVzcyBydW5zLlxuICAgICAqIEBwYXJhbSBydW5JZCBUaGUgSUQgb2YgdGhlIHJ1bi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGNvbnRyb2xsaW5nIHRoZSBzdHJlYW0gYmVoYXZpb3I6XG4gICAgICogICAtIHNpZ25hbDogQW4gQWJvcnRTaWduYWwgdGhhdCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlIHN0cmVhbSByZXF1ZXN0XG4gICAgICogICAtIGxhc3RFdmVudElkOiBUaGUgSUQgb2YgdGhlIGxhc3QgZXZlbnQgcmVjZWl2ZWQuIENhbiBiZSB1c2VkIHRvIHJlY29ubmVjdCB0byBhIHN0cmVhbSB3aXRob3V0IGxvc2luZyBldmVudHMuXG4gICAgICogICAtIGNhbmNlbE9uRGlzY29ubmVjdDogV2hlbiB0cnVlLCBhdXRvbWF0aWNhbGx5IGNhbmNlbHMgdGhlIHJ1biBpZiB0aGUgY2xpZW50IGRpc2Nvbm5lY3RzIGZyb20gdGhlIHN0cmVhbVxuICAgICAqICAgLSBzdHJlYW1Nb2RlOiBDb250cm9scyB3aGF0IHR5cGVzIG9mIGV2ZW50cyB0byByZWNlaXZlIGZyb20gdGhlIHN0cmVhbSAoY2FuIGJlIGEgc2luZ2xlIG1vZGUgb3IgYXJyYXkgb2YgbW9kZXMpXG4gICAgICogICAgICAgIE11c3QgYmUgYSBzdWJzZXQgb2YgdGhlIHN0cmVhbSBtb2RlcyBwYXNzZWQgd2hlbiBjcmVhdGluZyB0aGUgcnVuLiBCYWNrZ3JvdW5kIHJ1bnMgZGVmYXVsdCB0byBoYXZpbmcgdGhlIHVuaW9uIG9mIGFsbFxuICAgICAqICAgICAgICBzdHJlYW0gbW9kZXMgZW5hYmxlZC5cbiAgICAgKiBAcmV0dXJucyBBbiBhc3luYyBnZW5lcmF0b3IgeWllbGRpbmcgc3RyZWFtIHBhcnRzLlxuICAgICAqL1xuICAgIGFzeW5jICpqb2luU3RyZWFtKHRocmVhZElkLCBydW5JZCwgb3B0aW9uc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgb3B0aW9ucyAhPSBudWxsICYmXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICBvcHRpb25zIGluc3RhbmNlb2YgQWJvcnRTaWduYWxcbiAgICAgICAgICAgID8geyBzaWduYWw6IG9wdGlvbnMgfVxuICAgICAgICAgICAgOiBvcHRpb25zO1xuICAgICAgICBsZXQgW3VybCwgaW5pdF0gPSB0aGlzLnByZXBhcmVGZXRjaE9wdGlvbnModGhyZWFkSWQgIT0gbnVsbFxuICAgICAgICAgICAgPyBgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVucy8ke3J1bklkfS9zdHJlYW1gXG4gICAgICAgICAgICA6IGAvcnVucy8ke3J1bklkfS9zdHJlYW1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICB0aW1lb3V0TXM6IG51bGwsXG4gICAgICAgICAgICBzaWduYWw6IG9wdHM/LnNpZ25hbCxcbiAgICAgICAgICAgIGhlYWRlcnM6IG9wdHM/Lmxhc3RFdmVudElkXG4gICAgICAgICAgICAgICAgPyB7IFwiTGFzdC1FdmVudC1JRFwiOiBvcHRzLmxhc3RFdmVudElkIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIGNhbmNlbF9vbl9kaXNjb25uZWN0OiBvcHRzPy5jYW5jZWxPbkRpc2Nvbm5lY3QgPyBcIjFcIiA6IFwiMFwiLFxuICAgICAgICAgICAgICAgIHN0cmVhbV9tb2RlOiBvcHRzPy5zdHJlYW1Nb2RlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLm9uUmVxdWVzdCAhPSBudWxsKVxuICAgICAgICAgICAgaW5pdCA9IGF3YWl0IHRoaXMub25SZXF1ZXN0KHVybCwgaW5pdCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hc3luY0NhbGxlci5mZXRjaCh1cmwsIGluaXQpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBzdHJlYW0gPSAocmVzcG9uc2UuYm9keSB8fCBuZXcgUmVhZGFibGVTdHJlYW0oeyBzdGFydDogKGN0cmwpID0+IGN0cmwuY2xvc2UoKSB9KSlcbiAgICAgICAgICAgIC5waXBlVGhyb3VnaChCeXRlc0xpbmVEZWNvZGVyKCkpXG4gICAgICAgICAgICAucGlwZVRocm91Z2goU1NFRGVjb2RlcigpKTtcbiAgICAgICAgeWllbGQqIEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0uZnJvbVJlYWRhYmxlU3RyZWFtKHN0cmVhbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHJ1bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aHJlYWRJZCBUaGUgSUQgb2YgdGhlIHRocmVhZC5cbiAgICAgKiBAcGFyYW0gcnVuSWQgVGhlIElEIG9mIHRoZSBydW4uXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUodGhyZWFkSWQsIHJ1bklkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zLyR7cnVuSWR9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU3RvcmVDbGllbnQgZXh0ZW5kcyBCYXNlQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBTdG9yZSBvciB1cGRhdGUgYW4gaXRlbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lc3BhY2UgQSBsaXN0IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIHRoZSBuYW1lc3BhY2UgcGF0aC5cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGl0ZW0gd2l0aGluIHRoZSBuYW1lc3BhY2UuXG4gICAgICogQHBhcmFtIHZhbHVlIEEgZGljdGlvbmFyeSBjb250YWluaW5nIHRoZSBpdGVtJ3MgZGF0YS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pbmRleCBDb250cm9scyBzZWFyY2ggaW5kZXhpbmcgLSBudWxsICh1c2UgZGVmYXVsdHMpLCBmYWxzZSAoZGlzYWJsZSksIG9yIGxpc3Qgb2YgZmllbGQgcGF0aHMgdG8gaW5kZXguXG4gICAgICogQHBhcmFtIG9wdGlvbnMudHRsIE9wdGlvbmFsIHRpbWUtdG8tbGl2ZSBpbiBtaW51dGVzIGZvciB0aGUgaXRlbSwgb3IgbnVsbCBmb3Igbm8gZXhwaXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlPHZvaWQ+XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBhd2FpdCBjbGllbnQuc3RvcmUucHV0SXRlbShcbiAgICAgKiAgIFtcImRvY3VtZW50c1wiLCBcInVzZXIxMjNcIl0sXG4gICAgICogICBcIml0ZW00NTZcIixcbiAgICAgKiAgIHsgdGl0bGU6IFwiTXkgRG9jdW1lbnRcIiwgY29udGVudDogXCJIZWxsbyBXb3JsZFwiIH0sXG4gICAgICogICB7IHR0bDogNjAgfSAvLyBleHBpcmVzIGluIDYwIG1pbnV0ZXNcbiAgICAgKiApO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHB1dEl0ZW0obmFtZXNwYWNlLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIG5hbWVzcGFjZS5mb3JFYWNoKChsYWJlbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGxhYmVsLmluY2x1ZGVzKFwiLlwiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBuYW1lc3BhY2UgbGFiZWwgJyR7bGFiZWx9Jy4gTmFtZXNwYWNlIGxhYmVscyBjYW5ub3QgY29udGFpbiBwZXJpb2RzICgnLicpYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBpbmRleDogb3B0aW9ucz8uaW5kZXgsXG4gICAgICAgICAgICB0dGw6IG9wdGlvbnM/LnR0bCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCIvc3RvcmUvaXRlbXNcIiwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgICAganNvbjogcGF5bG9hZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGEgc2luZ2xlIGl0ZW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZXNwYWNlIEEgbGlzdCBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyB0aGUgbmFtZXNwYWNlIHBhdGguXG4gICAgICogQHBhcmFtIGtleSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBpdGVtLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlZnJlc2hUdGwgV2hldGhlciB0byByZWZyZXNoIHRoZSBUVEwgb24gdGhpcyByZWFkIG9wZXJhdGlvbi4gSWYgbnVsbCwgdXNlcyB0aGUgc3RvcmUncyBkZWZhdWx0IGJlaGF2aW9yLlxuICAgICAqIEByZXR1cm5zIFByb21pc2U8SXRlbT5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGl0ZW0gPSBhd2FpdCBjbGllbnQuc3RvcmUuZ2V0SXRlbShcbiAgICAgKiAgIFtcImRvY3VtZW50c1wiLCBcInVzZXIxMjNcIl0sXG4gICAgICogICBcIml0ZW00NTZcIixcbiAgICAgKiAgIHsgcmVmcmVzaFR0bDogdHJ1ZSB9XG4gICAgICogKTtcbiAgICAgKiBjb25zb2xlLmxvZyhpdGVtKTtcbiAgICAgKiAvLyB7XG4gICAgICogLy8gICBuYW1lc3BhY2U6IFtcImRvY3VtZW50c1wiLCBcInVzZXIxMjNcIl0sXG4gICAgICogLy8gICBrZXk6IFwiaXRlbTQ1NlwiLFxuICAgICAqIC8vICAgdmFsdWU6IHsgdGl0bGU6IFwiTXkgRG9jdW1lbnRcIiwgY29udGVudDogXCJIZWxsbyBXb3JsZFwiIH0sXG4gICAgICogLy8gICBjcmVhdGVkQXQ6IFwiMjAyNC0wNy0zMFQxMjowMDowMFpcIixcbiAgICAgKiAvLyAgIHVwZGF0ZWRBdDogXCIyMDI0LTA3LTMwVDEyOjAwOjAwWlwiXG4gICAgICogLy8gfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldEl0ZW0obmFtZXNwYWNlLCBrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgbmFtZXNwYWNlLmZvckVhY2goKGxhYmVsKSA9PiB7XG4gICAgICAgICAgICBpZiAobGFiZWwuaW5jbHVkZXMoXCIuXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG5hbWVzcGFjZSBsYWJlbCAnJHtsYWJlbH0nLiBOYW1lc3BhY2UgbGFiZWxzIGNhbm5vdCBjb250YWluIHBlcmlvZHMgKCcuJylgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLmpvaW4oXCIuXCIpLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucz8ucmVmcmVzaFR0bCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMucmVmcmVzaF90dGwgPSBvcHRpb25zLnJlZnJlc2hUdGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoKFwiL3N0b3JlL2l0ZW1zXCIsIHtcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZVxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0OiByZXNwb25zZS5jcmVhdGVkX2F0LFxuICAgICAgICAgICAgICAgIHVwZGF0ZWRBdDogcmVzcG9uc2UudXBkYXRlZF9hdCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGFuIGl0ZW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZXNwYWNlIEEgbGlzdCBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyB0aGUgbmFtZXNwYWNlIHBhdGguXG4gICAgICogQHBhcmFtIGtleSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBpdGVtLlxuICAgICAqIEByZXR1cm5zIFByb21pc2U8dm9pZD5cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVJdGVtKG5hbWVzcGFjZSwga2V5KSB7XG4gICAgICAgIG5hbWVzcGFjZS5mb3JFYWNoKChsYWJlbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGxhYmVsLmluY2x1ZGVzKFwiLlwiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBuYW1lc3BhY2UgbGFiZWwgJyR7bGFiZWx9Jy4gTmFtZXNwYWNlIGxhYmVscyBjYW5ub3QgY29udGFpbiBwZXJpb2RzICgnLicpYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcIi9zdG9yZS9pdGVtc1wiLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBqc29uOiB7IG5hbWVzcGFjZSwga2V5IH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggZm9yIGl0ZW1zIHdpdGhpbiBhIG5hbWVzcGFjZSBwcmVmaXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZXNwYWNlUHJlZml4IExpc3Qgb2Ygc3RyaW5ncyByZXByZXNlbnRpbmcgdGhlIG5hbWVzcGFjZSBwcmVmaXguXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZmlsdGVyIE9wdGlvbmFsIGRpY3Rpb25hcnkgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGZpbHRlciByZXN1bHRzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmxpbWl0IE1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRvIHJldHVybiAoZGVmYXVsdCBpcyAxMCkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMub2Zmc2V0IE51bWJlciBvZiBpdGVtcyB0byBza2lwIGJlZm9yZSByZXR1cm5pbmcgcmVzdWx0cyAoZGVmYXVsdCBpcyAwKS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5xdWVyeSBPcHRpb25hbCBzZWFyY2ggcXVlcnkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVmcmVzaFR0bCBXaGV0aGVyIHRvIHJlZnJlc2ggdGhlIFRUTCBvbiBpdGVtcyByZXR1cm5lZCBieSB0aGlzIHNlYXJjaC4gSWYgbnVsbCwgdXNlcyB0aGUgc3RvcmUncyBkZWZhdWx0IGJlaGF2aW9yLlxuICAgICAqIEByZXR1cm5zIFByb21pc2U8U2VhcmNoSXRlbXNSZXNwb25zZT5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBjbGllbnQuc3RvcmUuc2VhcmNoSXRlbXMoXG4gICAgICogICBbXCJkb2N1bWVudHNcIl0sXG4gICAgICogICB7XG4gICAgICogICAgIGZpbHRlcjogeyBhdXRob3I6IFwiSm9obiBEb2VcIiB9LFxuICAgICAqICAgICBsaW1pdDogNSxcbiAgICAgKiAgICAgcmVmcmVzaFR0bDogdHJ1ZVxuICAgICAqICAgfVxuICAgICAqICk7XG4gICAgICogY29uc29sZS5sb2cocmVzdWx0cyk7XG4gICAgICogLy8ge1xuICAgICAqIC8vICAgaXRlbXM6IFtcbiAgICAgKiAvLyAgICAge1xuICAgICAqIC8vICAgICAgIG5hbWVzcGFjZTogW1wiZG9jdW1lbnRzXCIsIFwidXNlcjEyM1wiXSxcbiAgICAgKiAvLyAgICAgICBrZXk6IFwiaXRlbTc4OVwiLFxuICAgICAqIC8vICAgICAgIHZhbHVlOiB7IHRpdGxlOiBcIkFub3RoZXIgRG9jdW1lbnRcIiwgYXV0aG9yOiBcIkpvaG4gRG9lXCIgfSxcbiAgICAgKiAvLyAgICAgICBjcmVhdGVkQXQ6IFwiMjAyNC0wNy0zMFQxMjowMDowMFpcIixcbiAgICAgKiAvLyAgICAgICB1cGRhdGVkQXQ6IFwiMjAyNC0wNy0zMFQxMjowMDowMFpcIlxuICAgICAqIC8vICAgICB9LFxuICAgICAqIC8vICAgICAvLyAuLi4gYWRkaXRpb25hbCBpdGVtcyAuLi5cbiAgICAgKiAvLyAgIF1cbiAgICAgKiAvLyB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgc2VhcmNoSXRlbXMobmFtZXNwYWNlUHJlZml4LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICBuYW1lc3BhY2VfcHJlZml4OiBuYW1lc3BhY2VQcmVmaXgsXG4gICAgICAgICAgICBmaWx0ZXI6IG9wdGlvbnM/LmZpbHRlcixcbiAgICAgICAgICAgIGxpbWl0OiBvcHRpb25zPy5saW1pdCA/PyAxMCxcbiAgICAgICAgICAgIG9mZnNldDogb3B0aW9ucz8ub2Zmc2V0ID8/IDAsXG4gICAgICAgICAgICBxdWVyeTogb3B0aW9ucz8ucXVlcnksXG4gICAgICAgICAgICByZWZyZXNoX3R0bDogb3B0aW9ucz8ucmVmcmVzaFR0bCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoKFwiL3N0b3JlL2l0ZW1zL3NlYXJjaFwiLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbjogcGF5bG9hZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpdGVtczogcmVzcG9uc2UuaXRlbXMubWFwKChpdGVtKSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLml0ZW0sXG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0OiBpdGVtLmNyZWF0ZWRfYXQsXG4gICAgICAgICAgICAgICAgdXBkYXRlZEF0OiBpdGVtLnVwZGF0ZWRfYXQsXG4gICAgICAgICAgICB9KSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgbmFtZXNwYWNlcyB3aXRoIG9wdGlvbmFsIG1hdGNoIGNvbmRpdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wcmVmaXggT3B0aW9uYWwgbGlzdCBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyB0aGUgcHJlZml4IHRvIGZpbHRlciBuYW1lc3BhY2VzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnN1ZmZpeCBPcHRpb25hbCBsaXN0IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIHRoZSBzdWZmaXggdG8gZmlsdGVyIG5hbWVzcGFjZXMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubWF4RGVwdGggT3B0aW9uYWwgaW50ZWdlciBzcGVjaWZ5aW5nIHRoZSBtYXhpbXVtIGRlcHRoIG9mIG5hbWVzcGFjZXMgdG8gcmV0dXJuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmxpbWl0IE1heGltdW0gbnVtYmVyIG9mIG5hbWVzcGFjZXMgdG8gcmV0dXJuIChkZWZhdWx0IGlzIDEwMCkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMub2Zmc2V0IE51bWJlciBvZiBuYW1lc3BhY2VzIHRvIHNraXAgYmVmb3JlIHJldHVybmluZyByZXN1bHRzIChkZWZhdWx0IGlzIDApLlxuICAgICAqIEByZXR1cm5zIFByb21pc2U8TGlzdE5hbWVzcGFjZVJlc3BvbnNlPlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3ROYW1lc3BhY2VzKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgIHByZWZpeDogb3B0aW9ucz8ucHJlZml4LFxuICAgICAgICAgICAgc3VmZml4OiBvcHRpb25zPy5zdWZmaXgsXG4gICAgICAgICAgICBtYXhfZGVwdGg6IG9wdGlvbnM/Lm1heERlcHRoLFxuICAgICAgICAgICAgbGltaXQ6IG9wdGlvbnM/LmxpbWl0ID8/IDEwMCxcbiAgICAgICAgICAgIG9mZnNldDogb3B0aW9ucz8ub2Zmc2V0ID8/IDAsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwiL3N0b3JlL25hbWVzcGFjZXNcIiwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGpzb246IHBheWxvYWQsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFVpQ2xpZW50IGV4dGVuZHMgQmFzZUNsaWVudCB7XG4gICAgc3RhdGljIGdldE9yQ2FjaGVkKGtleSwgZm4pIHtcbiAgICAgICAgaWYgKFVpQ2xpZW50LnByb21pc2VDYWNoZVtrZXldICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBVaUNsaWVudC5wcm9taXNlQ2FjaGVba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNlID0gZm4oKTtcbiAgICAgICAgVWlDbGllbnQucHJvbWlzZUNhY2hlW2tleV0gPSBwcm9taXNlO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q29tcG9uZW50KGFzc2lzdGFudElkLCBhZ2VudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIFVpQ2xpZW50LmdldE9yQ2FjaGVkKGAke3RoaXMuYXBpVXJsfS0ke2Fzc2lzdGFudElkfS0ke2FnZW50TmFtZX1gLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgW3VybCwgaW5pdF0gPSB0aGlzLnByZXBhcmVGZXRjaE9wdGlvbnMoYC91aS8ke2Fzc2lzdGFudElkfWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIEFjY2VwdDogXCJ0ZXh0L2h0bWxcIixcbiAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGpzb246IHsgbmFtZTogYWdlbnROYW1lIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uUmVxdWVzdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGluaXQgPSBhd2FpdCB0aGlzLm9uUmVxdWVzdCh1cmwsIGluaXQpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFzeW5jQ2FsbGVyLmZldGNoKHVybCwgaW5pdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVWlDbGllbnQsIFwicHJvbWlzZUNhY2hlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZToge31cbn0pO1xuZXhwb3J0IGNsYXNzIENsaWVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2xpZW50IGZvciBpbnRlcmFjdGluZyB3aXRoIGFzc2lzdGFudHMuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhc3Npc3RhbnRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2xpZW50IGZvciBpbnRlcmFjdGluZyB3aXRoIHRocmVhZHMuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0aHJlYWRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2xpZW50IGZvciBpbnRlcmFjdGluZyB3aXRoIHJ1bnMuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2xpZW50IGZvciBpbnRlcmFjdGluZyB3aXRoIGNyb24gcnVucy5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNyb25zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2xpZW50IGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBLViBzdG9yZS5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0b3JlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2xpZW50IGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBVSS5cbiAgICAgICAgICogQGludGVybmFsIFVzZWQgYnkgTG9hZEV4dGVybmFsQ29tcG9uZW50IGFuZCB0aGUgQVBJIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwifnVpXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWwgVXNlZCB0byBvYnRhaW4gYSBzdGFibGUga2V5IHJlcHJlc2VudGluZyB0aGUgY2xpZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwifmNvbmZpZ0hhc2hcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpc1tcIn5jb25maWdIYXNoXCJdID0gKCgpID0+IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGFwaVVybDogY29uZmlnPy5hcGlVcmwsXG4gICAgICAgICAgICBhcGlLZXk6IGNvbmZpZz8uYXBpS2V5LFxuICAgICAgICAgICAgdGltZW91dE1zOiBjb25maWc/LnRpbWVvdXRNcyxcbiAgICAgICAgICAgIGRlZmF1bHRIZWFkZXJzOiBjb25maWc/LmRlZmF1bHRIZWFkZXJzLFxuICAgICAgICAgICAgbWF4Q29uY3VycmVuY3k6IGNvbmZpZz8uY2FsbGVyT3B0aW9ucz8ubWF4Q29uY3VycmVuY3ksXG4gICAgICAgICAgICBtYXhSZXRyaWVzOiBjb25maWc/LmNhbGxlck9wdGlvbnM/Lm1heFJldHJpZXMsXG4gICAgICAgICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICAgICAgICBvbkZhaWxlZFJlc3BvbnNlSG9vazogY29uZmlnPy5jYWxsZXJPcHRpb25zPy5vbkZhaWxlZFJlc3BvbnNlSG9vayAhPSBudWxsLFxuICAgICAgICAgICAgICAgIG9uUmVxdWVzdDogY29uZmlnPy5vblJlcXVlc3QgIT0gbnVsbCxcbiAgICAgICAgICAgICAgICBmZXRjaDogY29uZmlnPy5jYWxsZXJPcHRpb25zPy5mZXRjaCAhPSBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkpKCk7XG4gICAgICAgIHRoaXMuYXNzaXN0YW50cyA9IG5ldyBBc3Npc3RhbnRzQ2xpZW50KGNvbmZpZyk7XG4gICAgICAgIHRoaXMudGhyZWFkcyA9IG5ldyBUaHJlYWRzQ2xpZW50KGNvbmZpZyk7XG4gICAgICAgIHRoaXMucnVucyA9IG5ldyBSdW5zQ2xpZW50KGNvbmZpZyk7XG4gICAgICAgIHRoaXMuY3JvbnMgPSBuZXcgQ3JvbnNDbGllbnQoY29uZmlnKTtcbiAgICAgICAgdGhpcy5zdG9yZSA9IG5ldyBTdG9yZUNsaWVudChjb25maWcpO1xuICAgICAgICB0aGlzW1wifnVpXCJdID0gbmV3IFVpQ2xpZW50KGNvbmZpZyk7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWwgVXNlZCB0byBvYnRhaW4gYSBzdGFibGUga2V5IHJlcHJlc2VudGluZyB0aGUgY2xpZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xpZW50Q29uZmlnSGFzaChjbGllbnQpIHtcbiAgICByZXR1cm4gY2xpZW50W1wifmNvbmZpZ0hhc2hcIl07XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-sdk/dist/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-sdk/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.Client),\n/* harmony export */   getApiKey: () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.getApiKey),\n/* harmony export */   overrideFetchImplementation: () => (/* reexport safe */ _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_1__.overrideFetchImplementation)\n/* harmony export */ });\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client.js */ \"(rsc)/./node_modules/@langchain/langgraph-sdk/dist/client.js\");\n/* harmony import */ var _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./singletons/fetch.js */ \"(rsc)/./node_modules/@langchain/langgraph-sdk/dist/singletons/fetch.js\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBZ0Q7QUFDb0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC1zZGsvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBDbGllbnQsIGdldEFwaUtleSB9IGZyb20gXCIuL2NsaWVudC5qc1wiO1xuZXhwb3J0IHsgb3ZlcnJpZGVGZXRjaEltcGxlbWVudGF0aW9uIH0gZnJvbSBcIi4vc2luZ2xldG9ucy9mZXRjaC5qc1wiO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-sdk/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-sdk/dist/singletons/fetch.js":
/*!************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/dist/singletons/fetch.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _getFetchImplementation: () => (/* binding */ _getFetchImplementation),\n/* harmony export */   overrideFetchImplementation: () => (/* binding */ overrideFetchImplementation)\n/* harmony export */ });\n/* eslint-disable @typescript-eslint/no-explicit-any */\n// Wrap the default fetch call due to issues with illegal invocations\n// in some environments:\n// https://stackoverflow.com/questions/69876859/why-does-bind-fix-failed-to-execute-fetch-on-window-illegal-invocation-err\n// @ts-expect-error Broad typing to support a range of fetch implementations\nconst DEFAULT_FETCH_IMPLEMENTATION = (...args) => fetch(...args);\nconst LANGSMITH_FETCH_IMPLEMENTATION_KEY = Symbol.for(\"lg:fetch_implementation\");\n/**\n * Overrides the fetch implementation used for LangSmith calls.\n * You should use this if you need to use an implementation of fetch\n * other than the default global (e.g. for dealing with proxies).\n * @param fetch The new fetch function to use.\n */\nconst overrideFetchImplementation = (fetch) => {\n    globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] = fetch;\n};\n/**\n * @internal\n */\nconst _getFetchImplementation = () => {\n    return (globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] ??\n        DEFAULT_FETCH_IMPLEMENTATION);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3Qvc2luZ2xldG9ucy9mZXRjaC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC1zZGsvZGlzdC9zaW5nbGV0b25zL2ZldGNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8vIFdyYXAgdGhlIGRlZmF1bHQgZmV0Y2ggY2FsbCBkdWUgdG8gaXNzdWVzIHdpdGggaWxsZWdhbCBpbnZvY2F0aW9uc1xuLy8gaW4gc29tZSBlbnZpcm9ubWVudHM6XG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82OTg3Njg1OS93aHktZG9lcy1iaW5kLWZpeC1mYWlsZWQtdG8tZXhlY3V0ZS1mZXRjaC1vbi13aW5kb3ctaWxsZWdhbC1pbnZvY2F0aW9uLWVyclxuLy8gQHRzLWV4cGVjdC1lcnJvciBCcm9hZCB0eXBpbmcgdG8gc3VwcG9ydCBhIHJhbmdlIG9mIGZldGNoIGltcGxlbWVudGF0aW9uc1xuY29uc3QgREVGQVVMVF9GRVRDSF9JTVBMRU1FTlRBVElPTiA9ICguLi5hcmdzKSA9PiBmZXRjaCguLi5hcmdzKTtcbmNvbnN0IExBTkdTTUlUSF9GRVRDSF9JTVBMRU1FTlRBVElPTl9LRVkgPSBTeW1ib2wuZm9yKFwibGc6ZmV0Y2hfaW1wbGVtZW50YXRpb25cIik7XG4vKipcbiAqIE92ZXJyaWRlcyB0aGUgZmV0Y2ggaW1wbGVtZW50YXRpb24gdXNlZCBmb3IgTGFuZ1NtaXRoIGNhbGxzLlxuICogWW91IHNob3VsZCB1c2UgdGhpcyBpZiB5b3UgbmVlZCB0byB1c2UgYW4gaW1wbGVtZW50YXRpb24gb2YgZmV0Y2hcbiAqIG90aGVyIHRoYW4gdGhlIGRlZmF1bHQgZ2xvYmFsIChlLmcuIGZvciBkZWFsaW5nIHdpdGggcHJveGllcykuXG4gKiBAcGFyYW0gZmV0Y2ggVGhlIG5ldyBmZXRjaCBmdW5jdGlvbiB0byB1c2UuXG4gKi9cbmV4cG9ydCBjb25zdCBvdmVycmlkZUZldGNoSW1wbGVtZW50YXRpb24gPSAoZmV0Y2gpID0+IHtcbiAgICBnbG9iYWxUaGlzW0xBTkdTTUlUSF9GRVRDSF9JTVBMRU1FTlRBVElPTl9LRVldID0gZmV0Y2g7XG59O1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IF9nZXRGZXRjaEltcGxlbWVudGF0aW9uID0gKCkgPT4ge1xuICAgIHJldHVybiAoZ2xvYmFsVGhpc1tMQU5HU01JVEhfRkVUQ0hfSU1QTEVNRU5UQVRJT05fS0VZXSA/P1xuICAgICAgICBERUZBVUxUX0ZFVENIX0lNUExFTUVOVEFUSU9OKTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-sdk/dist/singletons/fetch.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/async_caller.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/dist/utils/async_caller.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncCaller: () => (/* binding */ AsyncCaller)\n/* harmony export */ });\n/* harmony import */ var p_retry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-retry */ \"(rsc)/./node_modules/p-retry/index.js\");\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-queue */ \"(rsc)/./node_modules/p-queue/dist/index.js\");\n/* harmony import */ var _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../singletons/fetch.js */ \"(rsc)/./node_modules/@langchain/langgraph-sdk/dist/singletons/fetch.js\");\n\n\n\nconst STATUS_NO_RETRY = [\n    400, // Bad Request\n    401, // Unauthorized\n    402, // Payment required\n    403, // Forbidden\n    404, // Not Found\n    405, // Method Not Allowed\n    406, // Not Acceptable\n    407, // Proxy Authentication Required\n    408, // Request Timeout\n    409, // Conflict\n    422, // Unprocessable Entity\n];\n/**\n * Do not rely on globalThis.Response, rather just\n * do duck typing\n */\nfunction isResponse(x) {\n    if (x == null || typeof x !== \"object\")\n        return false;\n    return \"status\" in x && \"statusText\" in x && \"text\" in x;\n}\n/**\n * Utility error to properly handle failed requests\n */\nclass HTTPError extends Error {\n    constructor(status, message, response) {\n        super(`HTTP ${status}: ${message}`);\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"text\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"response\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.status = status;\n        this.text = message;\n        this.response = response;\n    }\n    static async fromResponse(response, options) {\n        try {\n            return new HTTPError(response.status, await response.text(), options?.includeResponse ? response : undefined);\n        }\n        catch {\n            return new HTTPError(response.status, response.statusText, options?.includeResponse ? response : undefined);\n        }\n    }\n}\n/**\n * A class that can be used to make async calls with concurrency and retry logic.\n *\n * This is useful for making calls to any kind of \"expensive\" external resource,\n * be it because it's rate-limited, subject to network issues, etc.\n *\n * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n * to `Infinity`. This means that by default, all calls will be made in parallel.\n *\n * Retries are limited by the `maxRetries` parameter, which defaults to 5. This\n * means that by default, each call will be retried up to 5 times, with an\n * exponential backoff between each attempt.\n */\nclass AsyncCaller {\n    constructor(params) {\n        Object.defineProperty(this, \"maxConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxRetries\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onFailedResponseHook\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"customFetch\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxConcurrency = params.maxConcurrency ?? Infinity;\n        this.maxRetries = params.maxRetries ?? 4;\n        if ( true) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new p_queue__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n                concurrency: this.maxConcurrency,\n            });\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new p_queue__WEBPACK_IMPORTED_MODULE_1__({ concurrency: this.maxConcurrency });\n        }\n        this.onFailedResponseHook = params?.onFailedResponseHook;\n        this.customFetch = params.fetch;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call(callable, ...args) {\n        const { onFailedResponseHook } = this;\n        return this.queue.add(() => p_retry__WEBPACK_IMPORTED_MODULE_0__(() => callable(...args).catch(async (error) => {\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (error instanceof Error) {\n                throw error;\n            }\n            else if (isResponse(error)) {\n                throw await HTTPError.fromResponse(error, {\n                    includeResponse: !!onFailedResponseHook,\n                });\n            }\n            else {\n                throw new Error(error);\n            }\n        }), {\n            async onFailedAttempt(error) {\n                if (error.message.startsWith(\"Cancel\") ||\n                    error.message.startsWith(\"TimeoutError\") ||\n                    error.message.startsWith(\"AbortError\")) {\n                    throw error;\n                }\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                if (error?.code === \"ECONNABORTED\") {\n                    throw error;\n                }\n                // eslint-disable-next-line no-instanceof/no-instanceof\n                if (error instanceof HTTPError) {\n                    if (STATUS_NO_RETRY.includes(error.status)) {\n                        throw error;\n                    }\n                    if (onFailedResponseHook && error.response) {\n                        await onFailedResponseHook(error.response);\n                    }\n                }\n            },\n            // If needed we can change some of the defaults here,\n            // but they're quite sensible.\n            retries: this.maxRetries,\n            randomize: true,\n        }), { throwOnTimeout: true });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callWithOptions(options, callable, ...args) {\n        // Note this doesn't cancel the underlying request,\n        // when available prefer to use the signal option of the underlying call\n        if (options.signal) {\n            return Promise.race([\n                this.call(callable, ...args),\n                new Promise((_, reject) => {\n                    options.signal?.addEventListener(\"abort\", () => {\n                        reject(new Error(\"AbortError\"));\n                    });\n                }),\n            ]);\n        }\n        return this.call(callable, ...args);\n    }\n    fetch(...args) {\n        const fetchFn = this.customFetch ?? (0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__._getFetchImplementation)();\n        return this.call(() => fetchFn(...args).then((res) => (res.ok ? res : Promise.reject(res))));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNkI7QUFDRztBQUNpQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTyxJQUFJLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFlBQVksS0FBc0I7QUFDbEM7QUFDQSw2QkFBNkIsK0NBQWlCO0FBQzlDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQ0FBUyxHQUFHLGtDQUFrQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDLG9DQUFvQyxvQ0FBTTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsS0FBSyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw2RUFBdUI7QUFDbkU7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWljaGFlbGR1cmFudGUvYWkgZGV2L2NlLWh1Yi9wcm9qZWN0cy90cmFkZXJyYS9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwUmV0cnkgZnJvbSBcInAtcmV0cnlcIjtcbmltcG9ydCBQUXVldWVNb2QgZnJvbSBcInAtcXVldWVcIjtcbmltcG9ydCB7IF9nZXRGZXRjaEltcGxlbWVudGF0aW9uIH0gZnJvbSBcIi4uL3NpbmdsZXRvbnMvZmV0Y2guanNcIjtcbmNvbnN0IFNUQVRVU19OT19SRVRSWSA9IFtcbiAgICA0MDAsIC8vIEJhZCBSZXF1ZXN0XG4gICAgNDAxLCAvLyBVbmF1dGhvcml6ZWRcbiAgICA0MDIsIC8vIFBheW1lbnQgcmVxdWlyZWRcbiAgICA0MDMsIC8vIEZvcmJpZGRlblxuICAgIDQwNCwgLy8gTm90IEZvdW5kXG4gICAgNDA1LCAvLyBNZXRob2QgTm90IEFsbG93ZWRcbiAgICA0MDYsIC8vIE5vdCBBY2NlcHRhYmxlXG4gICAgNDA3LCAvLyBQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFxuICAgIDQwOCwgLy8gUmVxdWVzdCBUaW1lb3V0XG4gICAgNDA5LCAvLyBDb25mbGljdFxuICAgIDQyMiwgLy8gVW5wcm9jZXNzYWJsZSBFbnRpdHlcbl07XG4vKipcbiAqIERvIG5vdCByZWx5IG9uIGdsb2JhbFRoaXMuUmVzcG9uc2UsIHJhdGhlciBqdXN0XG4gKiBkbyBkdWNrIHR5cGluZ1xuICovXG5mdW5jdGlvbiBpc1Jlc3BvbnNlKHgpIHtcbiAgICBpZiAoeCA9PSBudWxsIHx8IHR5cGVvZiB4ICE9PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIFwic3RhdHVzXCIgaW4geCAmJiBcInN0YXR1c1RleHRcIiBpbiB4ICYmIFwidGV4dFwiIGluIHg7XG59XG4vKipcbiAqIFV0aWxpdHkgZXJyb3IgdG8gcHJvcGVybHkgaGFuZGxlIGZhaWxlZCByZXF1ZXN0c1xuICovXG5jbGFzcyBIVFRQRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Ioc3RhdHVzLCBtZXNzYWdlLCByZXNwb25zZSkge1xuICAgICAgICBzdXBlcihgSFRUUCAke3N0YXR1c306ICR7bWVzc2FnZX1gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdHVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRleHRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzcG9uc2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMudGV4dCA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGZyb21SZXNwb25zZShyZXNwb25zZSwgb3B0aW9ucykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIVFRQRXJyb3IocmVzcG9uc2Uuc3RhdHVzLCBhd2FpdCByZXNwb25zZS50ZXh0KCksIG9wdGlvbnM/LmluY2x1ZGVSZXNwb25zZSA/IHJlc3BvbnNlIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhUVFBFcnJvcihyZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnN0YXR1c1RleHQsIG9wdGlvbnM/LmluY2x1ZGVSZXNwb25zZSA/IHJlc3BvbnNlIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQSBjbGFzcyB0aGF0IGNhbiBiZSB1c2VkIHRvIG1ha2UgYXN5bmMgY2FsbHMgd2l0aCBjb25jdXJyZW5jeSBhbmQgcmV0cnkgbG9naWMuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIG1ha2luZyBjYWxscyB0byBhbnkga2luZCBvZiBcImV4cGVuc2l2ZVwiIGV4dGVybmFsIHJlc291cmNlLFxuICogYmUgaXQgYmVjYXVzZSBpdCdzIHJhdGUtbGltaXRlZCwgc3ViamVjdCB0byBuZXR3b3JrIGlzc3VlcywgZXRjLlxuICpcbiAqIENvbmN1cnJlbnQgY2FsbHMgYXJlIGxpbWl0ZWQgYnkgdGhlIGBtYXhDb25jdXJyZW5jeWAgcGFyYW1ldGVyLCB3aGljaCBkZWZhdWx0c1xuICogdG8gYEluZmluaXR5YC4gVGhpcyBtZWFucyB0aGF0IGJ5IGRlZmF1bHQsIGFsbCBjYWxscyB3aWxsIGJlIG1hZGUgaW4gcGFyYWxsZWwuXG4gKlxuICogUmV0cmllcyBhcmUgbGltaXRlZCBieSB0aGUgYG1heFJldHJpZXNgIHBhcmFtZXRlciwgd2hpY2ggZGVmYXVsdHMgdG8gNS4gVGhpc1xuICogbWVhbnMgdGhhdCBieSBkZWZhdWx0LCBlYWNoIGNhbGwgd2lsbCBiZSByZXRyaWVkIHVwIHRvIDUgdGltZXMsIHdpdGggYW5cbiAqIGV4cG9uZW50aWFsIGJhY2tvZmYgYmV0d2VlbiBlYWNoIGF0dGVtcHQuXG4gKi9cbmV4cG9ydCBjbGFzcyBBc3luY0NhbGxlciB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heENvbmN1cnJlbmN5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heFJldHJpZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicXVldWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib25GYWlsZWRSZXNwb25zZUhvb2tcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY3VzdG9tRmV0Y2hcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXhDb25jdXJyZW5jeSA9IHBhcmFtcy5tYXhDb25jdXJyZW5jeSA/PyBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5tYXhSZXRyaWVzID0gcGFyYW1zLm1heFJldHJpZXMgPz8gNDtcbiAgICAgICAgaWYgKFwiZGVmYXVsdFwiIGluIFBRdWV1ZU1vZCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHRoaXMucXVldWUgPSBuZXcgUFF1ZXVlTW9kLmRlZmF1bHQoe1xuICAgICAgICAgICAgICAgIGNvbmN1cnJlbmN5OiB0aGlzLm1heENvbmN1cnJlbmN5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IG5ldyBQUXVldWVNb2QoeyBjb25jdXJyZW5jeTogdGhpcy5tYXhDb25jdXJyZW5jeSB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uRmFpbGVkUmVzcG9uc2VIb29rID0gcGFyYW1zPy5vbkZhaWxlZFJlc3BvbnNlSG9vaztcbiAgICAgICAgdGhpcy5jdXN0b21GZXRjaCA9IHBhcmFtcy5mZXRjaDtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjYWxsKGNhbGxhYmxlLCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHsgb25GYWlsZWRSZXNwb25zZUhvb2sgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLmFkZCgoKSA9PiBwUmV0cnkoKCkgPT4gY2FsbGFibGUoLi4uYXJncykuY2F0Y2goYXN5bmMgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSZXNwb25zZShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBhd2FpdCBIVFRQRXJyb3IuZnJvbVJlc3BvbnNlKGVycm9yLCB7XG4gICAgICAgICAgICAgICAgICAgIGluY2x1ZGVSZXNwb25zZTogISFvbkZhaWxlZFJlc3BvbnNlSG9vayxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgICBhc3luYyBvbkZhaWxlZEF0dGVtcHQoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiQ2FuY2VsXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIlRpbWVvdXRFcnJvclwiKSB8fFxuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJBYm9ydEVycm9yXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGlmIChlcnJvcj8uY29kZSA9PT0gXCJFQ09OTkFCT1JURURcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEhUVFBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoU1RBVFVTX05PX1JFVFJZLmluY2x1ZGVzKGVycm9yLnN0YXR1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbkZhaWxlZFJlc3BvbnNlSG9vayAmJiBlcnJvci5yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgb25GYWlsZWRSZXNwb25zZUhvb2soZXJyb3IucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIElmIG5lZWRlZCB3ZSBjYW4gY2hhbmdlIHNvbWUgb2YgdGhlIGRlZmF1bHRzIGhlcmUsXG4gICAgICAgICAgICAvLyBidXQgdGhleSdyZSBxdWl0ZSBzZW5zaWJsZS5cbiAgICAgICAgICAgIHJldHJpZXM6IHRoaXMubWF4UmV0cmllcyxcbiAgICAgICAgICAgIHJhbmRvbWl6ZTogdHJ1ZSxcbiAgICAgICAgfSksIHsgdGhyb3dPblRpbWVvdXQ6IHRydWUgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY2FsbFdpdGhPcHRpb25zKG9wdGlvbnMsIGNhbGxhYmxlLCAuLi5hcmdzKSB7XG4gICAgICAgIC8vIE5vdGUgdGhpcyBkb2Vzbid0IGNhbmNlbCB0aGUgdW5kZXJseWluZyByZXF1ZXN0LFxuICAgICAgICAvLyB3aGVuIGF2YWlsYWJsZSBwcmVmZXIgdG8gdXNlIHRoZSBzaWduYWwgb3B0aW9uIG9mIHRoZSB1bmRlcmx5aW5nIGNhbGxcbiAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGwoY2FsbGFibGUsIC4uLmFyZ3MpLFxuICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWw/LmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQWJvcnRFcnJvclwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbChjYWxsYWJsZSwgLi4uYXJncyk7XG4gICAgfVxuICAgIGZldGNoKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgZmV0Y2hGbiA9IHRoaXMuY3VzdG9tRmV0Y2ggPz8gX2dldEZldGNoSW1wbGVtZW50YXRpb24oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbCgoKSA9PiBmZXRjaEZuKC4uLmFyZ3MpLnRoZW4oKHJlcykgPT4gKHJlcy5vayA/IHJlcyA6IFByb21pc2UucmVqZWN0KHJlcykpKSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/async_caller.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/env.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/dist/utils/env.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEnvironmentVariable: () => (/* binding */ getEnvironmentVariable)\n/* harmony export */ });\nfunction getEnvironmentVariable(name) {\n    // Certain setups (Deno, frontend) will throw an error if you try to access environment variables\n    try {\n        return typeof process !== \"undefined\"\n            ? // eslint-disable-next-line no-process-env\n                process.env?.[name]\n            : undefined;\n    }\n    catch (e) {\n        return undefined;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvdXRpbHMvZW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC1zZGsvZGlzdC91dGlscy9lbnYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGdldEVudmlyb25tZW50VmFyaWFibGUobmFtZSkge1xuICAgIC8vIENlcnRhaW4gc2V0dXBzIChEZW5vLCBmcm9udGVuZCkgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB5b3UgdHJ5IHRvIGFjY2VzcyBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnY/LltuYW1lXVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/env.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/signals.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/dist/utils/signals.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mergeSignals: () => (/* binding */ mergeSignals)\n/* harmony export */ });\nfunction mergeSignals(...signals) {\n    const nonZeroSignals = signals.filter((signal) => signal != null);\n    if (nonZeroSignals.length === 0)\n        return undefined;\n    if (nonZeroSignals.length === 1)\n        return nonZeroSignals[0];\n    const controller = new AbortController();\n    for (const signal of signals) {\n        if (signal?.aborted) {\n            controller.abort(signal.reason);\n            return controller.signal;\n        }\n        signal?.addEventListener(\"abort\", () => controller.abort(signal.reason), {\n            once: true,\n        });\n    }\n    return controller.signal;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvdXRpbHMvc2lnbmFscy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC1zZGsvZGlzdC91dGlscy9zaWduYWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBtZXJnZVNpZ25hbHMoLi4uc2lnbmFscykge1xuICAgIGNvbnN0IG5vblplcm9TaWduYWxzID0gc2lnbmFscy5maWx0ZXIoKHNpZ25hbCkgPT4gc2lnbmFsICE9IG51bGwpO1xuICAgIGlmIChub25aZXJvU2lnbmFscy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKG5vblplcm9TaWduYWxzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIG5vblplcm9TaWduYWxzWzBdO1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgZm9yIChjb25zdCBzaWduYWwgb2Ygc2lnbmFscykge1xuICAgICAgICBpZiAoc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KHNpZ25hbC5yZWFzb24pO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuc2lnbmFsO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25hbD8uYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IGNvbnRyb2xsZXIuYWJvcnQoc2lnbmFsLnJlYXNvbiksIHtcbiAgICAgICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY29udHJvbGxlci5zaWduYWw7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/signals.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/sse.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/dist/utils/sse.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BytesLineDecoder: () => (/* binding */ BytesLineDecoder),\n/* harmony export */   SSEDecoder: () => (/* binding */ SSEDecoder)\n/* harmony export */ });\nconst CR = \"\\r\".charCodeAt(0);\nconst LF = \"\\n\".charCodeAt(0);\nconst NULL = \"\\0\".charCodeAt(0);\nconst COLON = \":\".charCodeAt(0);\nconst SPACE = \" \".charCodeAt(0);\nconst TRAILING_NEWLINE = [CR, LF];\nfunction BytesLineDecoder() {\n    let buffer = [];\n    let trailingCr = false;\n    return new TransformStream({\n        start() {\n            buffer = [];\n            trailingCr = false;\n        },\n        transform(chunk, controller) {\n            // See https://docs.python.org/3/glossary.html#term-universal-newlines\n            let text = chunk;\n            // Handle trailing CR from previous chunk\n            if (trailingCr) {\n                text = joinArrays([[CR], text]);\n                trailingCr = false;\n            }\n            // Check for trailing CR in current chunk\n            if (text.length > 0 && text.at(-1) === CR) {\n                trailingCr = true;\n                text = text.subarray(0, -1);\n            }\n            if (!text.length)\n                return;\n            const trailingNewline = TRAILING_NEWLINE.includes(text.at(-1));\n            const lastIdx = text.length - 1;\n            const { lines } = text.reduce((acc, cur, idx) => {\n                if (acc.from > idx)\n                    return acc;\n                if (cur === CR || cur === LF) {\n                    acc.lines.push(text.subarray(acc.from, idx));\n                    if (cur === CR && text[idx + 1] === LF) {\n                        acc.from = idx + 2;\n                    }\n                    else {\n                        acc.from = idx + 1;\n                    }\n                }\n                if (idx === lastIdx && acc.from <= lastIdx) {\n                    acc.lines.push(text.subarray(acc.from));\n                }\n                return acc;\n            }, { lines: [], from: 0 });\n            if (lines.length === 1 && !trailingNewline) {\n                buffer.push(lines[0]);\n                return;\n            }\n            if (buffer.length) {\n                // Include existing buffer in first line\n                buffer.push(lines[0]);\n                lines[0] = joinArrays(buffer);\n                buffer = [];\n            }\n            if (!trailingNewline) {\n                // If the last segment is not newline terminated,\n                // buffer it for the next chunk\n                if (lines.length)\n                    buffer = [lines.pop()];\n            }\n            // Enqueue complete lines\n            for (const line of lines) {\n                controller.enqueue(line);\n            }\n        },\n        flush(controller) {\n            if (buffer.length) {\n                controller.enqueue(joinArrays(buffer));\n            }\n        },\n    });\n}\nfunction SSEDecoder() {\n    let event = \"\";\n    let data = [];\n    let lastEventId = \"\";\n    let retry = null;\n    const decoder = new TextDecoder();\n    return new TransformStream({\n        transform(chunk, controller) {\n            // Handle empty line case\n            if (!chunk.length) {\n                if (!event && !data.length && !lastEventId && retry == null)\n                    return;\n                const sse = {\n                    id: lastEventId || undefined,\n                    event,\n                    data: data.length ? decodeArraysToJson(decoder, data) : null,\n                };\n                // NOTE: as per the SSE spec, do not reset lastEventId\n                event = \"\";\n                data = [];\n                retry = null;\n                controller.enqueue(sse);\n                return;\n            }\n            // Ignore comments\n            if (chunk[0] === COLON)\n                return;\n            const sepIdx = chunk.indexOf(COLON);\n            if (sepIdx === -1)\n                return;\n            const fieldName = decoder.decode(chunk.subarray(0, sepIdx));\n            let value = chunk.subarray(sepIdx + 1);\n            if (value[0] === SPACE)\n                value = value.subarray(1);\n            if (fieldName === \"event\") {\n                event = decoder.decode(value);\n            }\n            else if (fieldName === \"data\") {\n                data.push(value);\n            }\n            else if (fieldName === \"id\") {\n                if (value.indexOf(NULL) === -1)\n                    lastEventId = decoder.decode(value);\n            }\n            else if (fieldName === \"retry\") {\n                const retryNum = Number.parseInt(decoder.decode(value), 10);\n                if (!Number.isNaN(retryNum))\n                    retry = retryNum;\n            }\n        },\n        flush(controller) {\n            if (event) {\n                controller.enqueue({\n                    id: lastEventId || undefined,\n                    event,\n                    data: data.length ? decodeArraysToJson(decoder, data) : null,\n                });\n            }\n        },\n    });\n}\nfunction joinArrays(data) {\n    const totalLength = data.reduce((acc, curr) => acc + curr.length, 0);\n    const merged = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const c of data) {\n        merged.set(c, offset);\n        offset += c.length;\n    }\n    return merged;\n}\nfunction decodeArraysToJson(decoder, data) {\n    return JSON.parse(decoder.decode(joinArrays(data)));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvdXRpbHMvc3NlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSSxvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC1zZGsvZGlzdC91dGlscy9zc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQ1IgPSBcIlxcclwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBMRiA9IFwiXFxuXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IE5VTEwgPSBcIlxcMFwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBDT0xPTiA9IFwiOlwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBTUEFDRSA9IFwiIFwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBUUkFJTElOR19ORVdMSU5FID0gW0NSLCBMRl07XG5leHBvcnQgZnVuY3Rpb24gQnl0ZXNMaW5lRGVjb2RlcigpIHtcbiAgICBsZXQgYnVmZmVyID0gW107XG4gICAgbGV0IHRyYWlsaW5nQ3IgPSBmYWxzZTtcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgIHN0YXJ0KCkge1xuICAgICAgICAgICAgYnVmZmVyID0gW107XG4gICAgICAgICAgICB0cmFpbGluZ0NyID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZG9jcy5weXRob24ub3JnLzMvZ2xvc3NhcnkuaHRtbCN0ZXJtLXVuaXZlcnNhbC1uZXdsaW5lc1xuICAgICAgICAgICAgbGV0IHRleHQgPSBjaHVuaztcbiAgICAgICAgICAgIC8vIEhhbmRsZSB0cmFpbGluZyBDUiBmcm9tIHByZXZpb3VzIGNodW5rXG4gICAgICAgICAgICBpZiAodHJhaWxpbmdDcikge1xuICAgICAgICAgICAgICAgIHRleHQgPSBqb2luQXJyYXlzKFtbQ1JdLCB0ZXh0XSk7XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdDciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHRyYWlsaW5nIENSIGluIGN1cnJlbnQgY2h1bmtcbiAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDAgJiYgdGV4dC5hdCgtMSkgPT09IENSKSB7XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdDciA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3ViYXJyYXkoMCwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCB0cmFpbGluZ05ld2xpbmUgPSBUUkFJTElOR19ORVdMSU5FLmluY2x1ZGVzKHRleHQuYXQoLTEpKTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RJZHggPSB0ZXh0Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBjb25zdCB7IGxpbmVzIH0gPSB0ZXh0LnJlZHVjZSgoYWNjLCBjdXIsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhY2MuZnJvbSA+IGlkeClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgICBpZiAoY3VyID09PSBDUiB8fCBjdXIgPT09IExGKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjYy5saW5lcy5wdXNoKHRleHQuc3ViYXJyYXkoYWNjLmZyb20sIGlkeCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyID09PSBDUiAmJiB0ZXh0W2lkeCArIDFdID09PSBMRikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjLmZyb20gPSBpZHggKyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjLmZyb20gPSBpZHggKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpZHggPT09IGxhc3RJZHggJiYgYWNjLmZyb20gPD0gbGFzdElkeCkge1xuICAgICAgICAgICAgICAgICAgICBhY2MubGluZXMucHVzaCh0ZXh0LnN1YmFycmF5KGFjYy5mcm9tKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCB7IGxpbmVzOiBbXSwgZnJvbTogMCB9KTtcbiAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDEgJiYgIXRyYWlsaW5nTmV3bGluZSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGxpbmVzWzBdKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIEluY2x1ZGUgZXhpc3RpbmcgYnVmZmVyIGluIGZpcnN0IGxpbmVcbiAgICAgICAgICAgICAgICBidWZmZXIucHVzaChsaW5lc1swXSk7XG4gICAgICAgICAgICAgICAgbGluZXNbMF0gPSBqb2luQXJyYXlzKGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRyYWlsaW5nTmV3bGluZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBsYXN0IHNlZ21lbnQgaXMgbm90IG5ld2xpbmUgdGVybWluYXRlZCxcbiAgICAgICAgICAgICAgICAvLyBidWZmZXIgaXQgZm9yIHRoZSBuZXh0IGNodW5rXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gW2xpbmVzLnBvcCgpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVucXVldWUgY29tcGxldGUgbGluZXNcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoam9pbkFycmF5cyhidWZmZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBTU0VEZWNvZGVyKCkge1xuICAgIGxldCBldmVudCA9IFwiXCI7XG4gICAgbGV0IGRhdGEgPSBbXTtcbiAgICBsZXQgbGFzdEV2ZW50SWQgPSBcIlwiO1xuICAgIGxldCByZXRyeSA9IG51bGw7XG4gICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgZW1wdHkgbGluZSBjYXNlXG4gICAgICAgICAgICBpZiAoIWNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICghZXZlbnQgJiYgIWRhdGEubGVuZ3RoICYmICFsYXN0RXZlbnRJZCAmJiByZXRyeSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY29uc3Qgc3NlID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogbGFzdEV2ZW50SWQgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YS5sZW5ndGggPyBkZWNvZGVBcnJheXNUb0pzb24oZGVjb2RlciwgZGF0YSkgOiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gTk9URTogYXMgcGVyIHRoZSBTU0Ugc3BlYywgZG8gbm90IHJlc2V0IGxhc3RFdmVudElkXG4gICAgICAgICAgICAgICAgZXZlbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICByZXRyeSA9IG51bGw7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHNzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWdub3JlIGNvbW1lbnRzXG4gICAgICAgICAgICBpZiAoY2h1bmtbMF0gPT09IENPTE9OKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHNlcElkeCA9IGNodW5rLmluZGV4T2YoQ09MT04pO1xuICAgICAgICAgICAgaWYgKHNlcElkeCA9PT0gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgZmllbGROYW1lID0gZGVjb2Rlci5kZWNvZGUoY2h1bmsuc3ViYXJyYXkoMCwgc2VwSWR4KSk7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBjaHVuay5zdWJhcnJheShzZXBJZHggKyAxKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZVswXSA9PT0gU1BBQ0UpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgPT09IFwiZXZlbnRcIikge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gZGVjb2Rlci5kZWNvZGUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgICAgIGRhdGEucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZE5hbWUgPT09IFwiaWRcIikge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5pbmRleE9mKE5VTEwpID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgbGFzdEV2ZW50SWQgPSBkZWNvZGVyLmRlY29kZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZE5hbWUgPT09IFwicmV0cnlcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldHJ5TnVtID0gTnVtYmVyLnBhcnNlSW50KGRlY29kZXIuZGVjb2RlKHZhbHVlKSwgMTApO1xuICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHJldHJ5TnVtKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0cnkgPSByZXRyeU51bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGxhc3RFdmVudElkIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEubGVuZ3RoID8gZGVjb2RlQXJyYXlzVG9Kc29uKGRlY29kZXIsIGRhdGEpIDogbnVsbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGpvaW5BcnJheXMoZGF0YSkge1xuICAgIGNvbnN0IHRvdGFsTGVuZ3RoID0gZGF0YS5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjICsgY3Vyci5sZW5ndGgsIDApO1xuICAgIGNvbnN0IG1lcmdlZCA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGNvbnN0IGMgb2YgZGF0YSkge1xuICAgICAgICBtZXJnZWQuc2V0KGMsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBjLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmZ1bmN0aW9uIGRlY29kZUFycmF5c1RvSnNvbihkZWNvZGVyLCBkYXRhKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2Rlci5kZWNvZGUoam9pbkFycmF5cyhkYXRhKSkpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/sse.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/stream.js":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/dist/utils/stream.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IterableReadableStream: () => (/* binding */ IterableReadableStream)\n/* harmony export */ });\n/*\n * Support async iterator syntax for ReadableStreams in all environments.\n * Source: https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nclass IterableReadableStream extends ReadableStream {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"reader\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    ensureReader() {\n        if (!this.reader) {\n            this.reader = this.getReader();\n        }\n    }\n    async next() {\n        this.ensureReader();\n        try {\n            const result = await this.reader.read();\n            if (result.done) {\n                this.reader.releaseLock(); // release lock when stream becomes closed\n                return {\n                    done: true,\n                    value: undefined,\n                };\n            }\n            else {\n                return {\n                    done: false,\n                    value: result.value,\n                };\n            }\n        }\n        catch (e) {\n            this.reader.releaseLock(); // release lock when stream becomes errored\n            throw e;\n        }\n    }\n    async return() {\n        this.ensureReader();\n        // If wrapped in a Node stream, cancel is already called.\n        if (this.locked) {\n            const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n            this.reader.releaseLock(); // release lock first\n            await cancelPromise; // now await it\n        }\n        return { done: true, value: undefined };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async throw(e) {\n        this.ensureReader();\n        if (this.locked) {\n            const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n            this.reader.releaseLock(); // release lock first\n            await cancelPromise; // now await it\n        }\n        throw e;\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore Not present in Node 18 types, required in latest Node 22\n    async [Symbol.asyncDispose]() {\n        await this.return();\n    }\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n    static fromReadableStream(stream) {\n        // From https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams#reading_the_stream\n        const reader = stream.getReader();\n        return new IterableReadableStream({\n            start(controller) {\n                return pump();\n                function pump() {\n                    return reader.read().then(({ done, value }) => {\n                        // When no more data needs to be consumed, close the stream\n                        if (done) {\n                            controller.close();\n                            return;\n                        }\n                        // Enqueue the next data chunk into our target stream\n                        controller.enqueue(value);\n                        return pump();\n                    });\n                }\n            },\n            cancel() {\n                reader.releaseLock();\n            },\n        });\n    }\n    static fromAsyncGenerator(generator) {\n        return new IterableReadableStream({\n            async pull(controller) {\n                const { value, done } = await generator.next();\n                // When no more data needs to be consumed, close the stream\n                if (done) {\n                    controller.close();\n                }\n                // Fix: `else if (value)` will hang the streaming when nullish value (e.g. empty string) is pulled\n                controller.enqueue(value);\n            },\n            async cancel(reason) {\n                await generator.return(reason);\n            },\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvdXRpbHMvc3RyZWFtLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RCx1Q0FBdUM7QUFDdkMsaUNBQWlDO0FBQ2pDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsdUNBQXVDO0FBQ3ZDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWNoYWVsZHVyYW50ZS9haSBkZXYvY2UtaHViL3Byb2plY3RzL3RyYWRlcnJhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC1zZGsvZGlzdC91dGlscy9zdHJlYW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIFN1cHBvcnQgYXN5bmMgaXRlcmF0b3Igc3ludGF4IGZvciBSZWFkYWJsZVN0cmVhbXMgaW4gYWxsIGVudmlyb25tZW50cy5cbiAqIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL01hdHRpYXNCdWVsZW5zL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3B1bGwvMTIyI2lzc3VlY29tbWVudC0xNjI3MzU0NDkwXG4gKi9cbmV4cG9ydCBjbGFzcyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtIGV4dGVuZHMgUmVhZGFibGVTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWFkZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW5zdXJlUmVhZGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMucmVhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRlciA9IHRoaXMuZ2V0UmVhZGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbmV4dCgpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVSZWFkZXIoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZGVyLnJlbGVhc2VMb2NrKCk7IC8vIHJlbGVhc2UgbG9jayB3aGVuIHN0cmVhbSBiZWNvbWVzIGNsb3NlZFxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnJlbGVhc2VMb2NrKCk7IC8vIHJlbGVhc2UgbG9jayB3aGVuIHN0cmVhbSBiZWNvbWVzIGVycm9yZWRcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmV0dXJuKCkge1xuICAgICAgICB0aGlzLmVuc3VyZVJlYWRlcigpO1xuICAgICAgICAvLyBJZiB3cmFwcGVkIGluIGEgTm9kZSBzdHJlYW0sIGNhbmNlbCBpcyBhbHJlYWR5IGNhbGxlZC5cbiAgICAgICAgaWYgKHRoaXMubG9ja2VkKSB7XG4gICAgICAgICAgICBjb25zdCBjYW5jZWxQcm9taXNlID0gdGhpcy5yZWFkZXIuY2FuY2VsKCk7IC8vIGNhbmNlbCBmaXJzdCwgYnV0IGRvbid0IGF3YWl0IHlldFxuICAgICAgICAgICAgdGhpcy5yZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIGZpcnN0XG4gICAgICAgICAgICBhd2FpdCBjYW5jZWxQcm9taXNlOyAvLyBub3cgYXdhaXQgaXRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgYXN5bmMgdGhyb3coZSkge1xuICAgICAgICB0aGlzLmVuc3VyZVJlYWRlcigpO1xuICAgICAgICBpZiAodGhpcy5sb2NrZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbFByb21pc2UgPSB0aGlzLnJlYWRlci5jYW5jZWwoKTsgLy8gY2FuY2VsIGZpcnN0LCBidXQgZG9uJ3QgYXdhaXQgeWV0XG4gICAgICAgICAgICB0aGlzLnJlYWRlci5yZWxlYXNlTG9jaygpOyAvLyByZWxlYXNlIGxvY2sgZmlyc3RcbiAgICAgICAgICAgIGF3YWl0IGNhbmNlbFByb21pc2U7IC8vIG5vdyBhd2FpdCBpdFxuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAvLyBAdHMtaWdub3JlIE5vdCBwcmVzZW50IGluIE5vZGUgMTggdHlwZXMsIHJlcXVpcmVkIGluIGxhdGVzdCBOb2RlIDIyXG4gICAgYXN5bmMgW1N5bWJvbC5hc3luY0Rpc3Bvc2VdKCkge1xuICAgICAgICBhd2FpdCB0aGlzLnJldHVybigpO1xuICAgIH1cbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RhdGljIGZyb21SZWFkYWJsZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgLy8gRnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3RyZWFtc19BUEkvVXNpbmdfcmVhZGFibGVfc3RyZWFtcyNyZWFkaW5nX3RoZV9zdHJlYW1cbiAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgICByZXR1cm4gbmV3IEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwdW1wKCk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcHVtcCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkKCkudGhlbigoeyBkb25lLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIG5vIG1vcmUgZGF0YSBuZWVkcyB0byBiZSBjb25zdW1lZCwgY2xvc2UgdGhlIHN0cmVhbVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5xdWV1ZSB0aGUgbmV4dCBkYXRhIGNodW5rIGludG8gb3VyIHRhcmdldCBzdHJlYW1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHVtcCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FuY2VsKCkge1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQXN5bmNHZW5lcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgSXRlcmFibGVSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBnZW5lcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gbm8gbW9yZSBkYXRhIG5lZWRzIHRvIGJlIGNvbnN1bWVkLCBjbG9zZSB0aGUgc3RyZWFtXG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGaXg6IGBlbHNlIGlmICh2YWx1ZSlgIHdpbGwgaGFuZyB0aGUgc3RyZWFtaW5nIHdoZW4gbnVsbGlzaCB2YWx1ZSAoZS5nLiBlbXB0eSBzdHJpbmcpIGlzIHB1bGxlZFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN5bmMgY2FuY2VsKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IGdlbmVyYXRvci5yZXR1cm4ocmVhc29uKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-sdk/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Client: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Client),
/* harmony export */   getApiKey: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.getApiKey),
/* harmony export */   overrideFetchImplementation: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.overrideFetchImplementation)
/* harmony export */ });
/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ "(rsc)/./node_modules/@langchain/langgraph-sdk/dist/index.js");


/***/ })

};
;