{
  "source_code": "# daily_para_backside_lite_scan.py\n# Daily-only \"A+ para, backside\" scan — lite mold.\n# Trigger: D-1 (or D-2) fits; trade day (D0) must gap & open > D-1 high.\n# D-1 must take out D-2 high and close above D-2 close.\n# Adds absolute D-1 volume floor: d1_volume_min.\n\nimport pandas as pd, numpy as np, requests\nfrom datetime import datetime\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\n\n# ───────── config ─────────\nsession  = requests.Session()\nAPI_KEY  = \"Fm7brz4s23eSocDErnL68cE7wspz2K1I\"\nBASE_URL = \"https://api.polygon.io\"\nMAX_WORKERS = 6\n\nPRINT_FROM = \"2025-01-01\"  # set None to keep all\nPRINT_TO   = None\n\n# ───────── knobs ─────────\nP = {\n    # hard liquidity / price\n    \"price_min\"        : 8.0,\n    \"adv20_min_usd\"    : 30_000_000,\n\n    # backside context (absolute window)\n    \"abs_lookback_days\": 1000,\n    \"abs_exclude_days\" : 10,\n    \"pos_abs_max\"      : 0.75,\n\n    # pattern thresholds\n    \"gap_up_min\"       : 0.005,   # 0.5% gap minimum\n    \"vol_mult_min\"     : 1.5,     # 1.5x average volume\n    \"atr_mult\"         : 2.0,     # 2x ATR for stops\n    \"rsi_range\"        : (30, 70),\n\n    # filters\n    \"d1_volume_min\"    : 500_000,\n    \"sector_blacklist\" : [\"Utilities\", \"REITs\"],\n}\n\ndef fetch_daily(symbol, days_back=1200):\n    \"\"\"Fetch daily price data for a symbol\"\"\"\n    try:\n        url = f\"{BASE_URL}/v2/aggs/ticker/{symbol}/range/1/day/{datetime.now().date() - pd.Timedelta(days=days_back)}/{datetime.now().date()}\"\n        params = {\"apikey\": API_KEY, \"adjust\": \"raw\"}\n        r = session.get(url, params=params, timeout=10)\n        r.raise_for_status()\n        data = r.json().get('results', [])\n        if not data:\n            return None\n        df = pd.DataFrame(data)\n        df['date'] = pd.to_datetime(df['t'], unit='ms')\n        df.set_index('date', inplace=True)\n        return df[['o', 'h', 'l', 'c', 'v']]\n    except Exception as e:\n        print(f\"Error fetching {symbol}: {e}\")\n        return None\n\ndef calculate_indicators(df):\n    \"\"\"Calculate technical indicators\"\"\"\n    df['sma_20'] = df['c'].rolling(20).mean()\n    df['sma_50'] = df['c'].rolling(50).mean()\n    df['atr'] = df['h'].rolling(14).apply(lambda x: (x.max() - x.min()))\n    df['volume_avg'] = df['v'].rolling(20).mean()\n    df['adv20'] = df['v'].rolling(20).mean() * df['c']\n    return df\n\ndef check_backside_setup(df, i):\n    \"\"\"Check for backside setup at index i\"\"\"\n    if i < 3:\n        return False, {}\n    \n    d0 = df.iloc[i]     # current day\n    d1 = df.iloc[i-1]   # previous day\n    d2 = df.iloc[i-2]   # two days ago\n    \n    # Basic filters\n    if d0['c'] < P['price_min']:\n        return False, {}\n    \n    # D-1 volume floor\n    if d1['v'] < P['d1_volume_min']:\n        return False, {}\n    \n    # Pattern conditions\n    gap_up = (d0['o'] - d1['c']) / d1['c'] > P['gap_up_min']\n    above_d1_high = d0['o'] > d1['h']\n    \n    # D-1 must take out D-2 high\n    d1_takes_d2_high = d1['h'] > d2['h']\n    # D-1 must close above D-2 close\n    d1_closes_above_d2 = d1['c'] > d2['c']\n    \n    # Volume confirmation\n    vol_confirm = d1['v'] > d1['volume_avg'] * P['vol_mult_min']\n    \n    setup_ok = (gap_up and above_d1_high and \n                d1_takes_d2_high and d1_closes_above_d2 and \n                vol_confirm)\n    \n    return setup_ok, {\n        'gap_up_pct': ((d0['o'] - d1['c']) / d1['c']) * 100,\n        'd1_volume_ratio': d1['v'] / d1['volume_avg'],\n        'atr': d0['atr'],\n        'rsi': getattr(d0, 'rsi', 50)\n    }\n\ndef scan_symbol(symbol):\n    \"\"\"Scan a single symbol for backside setups\"\"\"\n    df = fetch_daily(symbol)\n    if df is None or len(df) < 50:\n        return []\n    \n    df = calculate_indicators(df)\n    signals = []\n    \n    for i in range(len(df)-1, 0, -1):  # Check recent days\n        setup, details = check_backside_setup(df, i)\n        if setup:\n            date_str = df.index[i].strftime('%Y-%m-%d')\n            if PRINT_FROM and date_str < PRINT_FROM:\n                continue\n            if PRINT_TO and date_str > PRINT_TO:\n                continue\n            \n            signals.append({\n                'symbol': symbol,\n                'date': date_str,\n                'price': float(df.iloc[i]['c']),\n                'volume': int(df.iloc[i]['v']),\n                **details\n            })\n    \n    return signals\n\ndef get_all_symbols():\n    \"\"\"Get list of symbols to scan\"\"\"\n    # This would typically fetch from a database or API\n    # For now, return a sample list\n    return ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'NVDA', 'META', 'NFLX']\n\ndef main():\n    symbols = get_all_symbols()\n    all_signals = []\n    \n    print(f\"Scanning {len(symbols)} symbols for backside setups...\")\n    \n    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:\n        future_to_symbol = {executor.submit(scan_symbol, symbol): symbol for symbol in symbols}\n        \n        for future in as_completed(future_to_symbol):\n            symbol = future_to_symbol[future]\n            try:\n                signals = future.result()\n                all_signals.extend(signals)\n                if signals:\n                    print(f\"{symbol}: {len(signals)} signals\")\n            except Exception as e:\n                print(f\"Error scanning {symbol}: {e}\")\n    \n    if all_signals:\n        print(f\"\\nTotal signals found: {len(all_signals)}\")\n        for signal in all_signals[:10]:  # Show first 10\n            print(f\"{signal['symbol']} {signal['date']}: ${signal['price']:.2f} \"\n                  f\"Gap: {signal['gap_up_pct']:.2f}% Vol: {signal['d1_volume_ratio']:.1f}x\")\n    else:\n        print(\"No backside setups found.\")\n\nif __name__ == \"__main__\":\n    main()",
  "format_type": "scan_optimization",
  "preserve_logic": true,
  "add_documentation": true,
  "optimize_performance": true
}