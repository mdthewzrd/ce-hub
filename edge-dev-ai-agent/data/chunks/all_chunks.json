[
  {
    "content": "# EdgeDev Codebase Research Report",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::EdgeDev Codebase Research Report",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Codebase Research Report"
    ],
    "metadata": {
      "level": 1,
      "heading": "EdgeDev Codebase Research Report"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "## Presumed \"Gold Standard\" Specification for Scanners, Backtests, and Code Structure\n\n**Research Date**: 2026-01-29\n**Research Scope**: Comprehensive analysis of EdgeDev codebase patterns\n**Status**: RESEARCH COMPLETE - Ready for Review\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::EdgeDev Codebase Research Report::Presumed \"Gold Standard\" Specification for Scanners, Backtests, and Code Structure",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Codebase Research Report",
      "Presumed \"Gold Standard\" Specification for Scanners, Backtests, and Code Structure"
    ],
    "metadata": {
      "level": 2,
      "heading": "Presumed \"Gold Standard\" Specification for Scanners, Backtests, and Code Structure"
    },
    "tags": [
      "scanner",
      "backtest",
      "pattern",
      "code"
    ]
  },
  {
    "content": "## Executive Summary\n\nThis research document synthesizes patterns from **133+ scanner files**, **6+ backtest engines**, and **hundreds of supporting files** to extract the \"presumed gold standard\" for production-ready trading code in the EdgeDev ecosystem.\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::EdgeDev Codebase Research Report::Executive Summary",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Codebase Research Report",
      "Executive Summary"
    ],
    "metadata": {
      "level": 2,
      "heading": "Executive Summary"
    },
    "tags": [
      "scanner",
      "backtest",
      "strategy",
      "pattern",
      "code",
      "position"
    ]
  },
  {
    "content": "### Key Findings\n\n1. **Two Distinct Scanner Architectures Exist**:\n   - **V31 Class-Based** (Modern, scalable, 360x faster)\n   - **Standalone Script-Based** (Simple, direct execution pattern)\n\n2. **Backside B Pattern Dominates** (75+ variants)\n   - The most battle-tested pattern in the codebase\n   - Multiple working implementations available\n   - Clear parameter structure and detection logic\n\n3. **Backtesting Has Two Approaches**:\n   - Simple P&L simulation (fast, for validation)\n   - Enhanced intraday simulation (slow, accurate)\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::EdgeDev Codebase Research Report::Executive Summary::Key Findings",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Codebase Research Report",
      "Executive Summary",
      "Key Findings"
    ],
    "metadata": {
      "level": 3,
      "heading": "Key Findings"
    },
    "tags": [
      "scanner",
      "backtest",
      "strategy",
      "pattern",
      "v31",
      "code",
      "execution"
    ]
  },
  {
    "content": "## Table of Contents\n\n1. [Scanner Architecture Patterns](#scanner-architecture-patterns)\n2. [Backtest Specifications](#backtest-specifications)\n3. [Code Structure Standards](#code-structure-standards)\n4. [Data Structure Requirements](#data-structure-requirements)\n5. [Parameter System Design](#parameter-system-design)\n6. [API Integration Patterns](#api-integration-patterns)\n7. [Workflow Best Practices](#workflow-best-practices)\n8. [Validation Checklists](#validation-checklists)\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::EdgeDev Codebase Research Report::Table of Contents",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Codebase Research Report",
      "Table of Contents"
    ],
    "metadata": {
      "level": 2,
      "heading": "Table of Contents"
    },
    "tags": [
      "scanner",
      "backtest",
      "pattern",
      "code"
    ]
  },
  {
    "content": "## 1. Scanner Architecture Patterns\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::EdgeDev Codebase Research Report::1. Scanner Architecture Patterns",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Codebase Research Report",
      "1. Scanner Architecture Patterns"
    ],
    "metadata": {
      "level": 2,
      "heading": "1. Scanner Architecture Patterns"
    },
    "tags": [
      "scanner",
      "pattern"
    ]
  },
  {
    "content": "### Pattern A: V31 Class-Based Architecture (Recommended for Production)\n\n**File References**:\n- `/projects/edge-dev-main/V31_GOLD_STANDARD_SPECIFICATION.md` (Complete specification)\n- `/projects/edge-dev-main/V31_QUICK_REFERENCE.md` (Quick reference card)\n- `/projects/edge-dev-main/optimized_backside_b_scanner.py` (Working example)\n\n**Core Structure**:",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::EdgeDev Codebase Research Report::1. Scanner Architecture Patterns::Pattern A: V31 Class-Based Architecture (Recommended for Production)::chunk0",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "example",
    "heading_path": [
      "EdgeDev Codebase Research Report",
      "1. Scanner Architecture Patterns",
      "Pattern A: V31 Class-Based Architecture (Recommended for Production)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Pattern A: V31 Class-Based Architecture (Recommended for Production)"
    },
    "tags": [
      "scanner",
      "strategy",
      "indicator",
      "pattern",
      "v31",
      "code",
      "optimization",
      "execution"
    ]
  },
  {
    "content": "(Complete specification)\n- `/projects/edge-dev-main/V31_QUICK_REFERENCE.md` (Quick reference card)\n- `/projects/edge-dev-main/optimized_backside_b_scanner.py` (Working example)\n\n**Core Structure**:\n\n\n\n[...previous chunk overlap...]\n\n```python\nimport pandas as pd\nimport numpy as np\nimport requests\nfrom datetime import datetime, timedelta\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nimport pandas_market_calendars as mcal\nfrom typing import List, Dict, Optional\n\nclass BacksideBScanner:\n    \"\"\"\n    Single-pattern scanner using v31 5-stage architecture\n\n    Stages:\n    1. fetch_grouped_data() - Fetch all tickers for all dates\n    2a. compute_simple_features() - prev_close, adv20, price_range\n    2b. apply_smart_filters() - Validate D0, preserve historical\n    3a. compute_full_features() - EMA, ATR, slopes, etc.\n    3b. detect_patterns() - Pattern detection logic\n    \"\"\"\n\n    def __init__(self, api_key: str, d0_start: str, d0_end: str):\n        \"\"\"Initialize scanner with date range and historical buffer\"\"\"\n\n        # Store user's original D0 range separately\n        self.d0_start_user = d0_start\n        self.d0_end_user = d0_end\n\n        # Calculate historical data range\n        lookback_buffer = self.params['abs_lookback_days'] + 50\n        scan_start_dt = pd.to_datetime(self.d0_start_user) - pd.Timedelta(days=lookback_buffer)\n        self.scan_start = scan_start_dt.strftime('%Y-%m-%d')\n        self.d0_end = self.d0_end_user\n\n        # API Configuration\n        self.api_key = api_key\n        self.base_url = \"https://api.polygon.io\"\n        self.session = requests.Session()\n\n        # Workers\n        self.stage1_workers = 5\n        self.stage3_workers = 10\n\n        # Parameters (flat structure)\n        self.params = {\n            \"price_min\": 8.0,\n            \"adv20_min_usd\": 30_000_000,\n            \"abs_lookback_days\": 1000,\n            \"abs_exclude_days\": 10,\n            # ... pattern-specific params\n        }\n\n    def run_scan(self):\n        \"\"\"Main execution method - 5-stage pipeline\"\"\"\n        # Stage 1\n        stage1_data = self.fetch_grouped_data()\n\n        # Stage 2a\n        stage2a_data = self.compute_simple_features(stage1_data)\n\n        # Stage 2b\n        stage2b_data = self.apply_smart_filters(stage2a_data)\n\n        # Stage 3a\n        stage3a_data = self.compute_full_features(stage2b_data)\n\n        # Stage 3b\n        stage3_results = self.detect_patterns(stage3a_data)\n\n        return stage3_results\n```",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::EdgeDev Codebase Research Report::1. Scanner Architecture Patterns::Pattern A: V31 Class-Based Architecture (Recommended for Production)::chunk1",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Codebase Research Report",
      "1. Scanner Architecture Patterns",
      "Pattern A: V31 Class-Based Architecture (Recommended for Production)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Pattern A: V31 Class-Based Architecture (Recommended for Production)"
    },
    "tags": [
      "scanner",
      "strategy",
      "indicator",
      "pattern",
      "v31",
      "code",
      "optimization",
      "execution"
    ]
  },
  {
    "content": "# Stage 3a\n        stage3a_data = self.compute_full_features(stage2b_data)\n\n        # Stage 3b\n        stage3_results = self.detect_patterns(stage3a_data)\n\n        return stage3_results\n```\n\n\n\n[...previous chunk overlap...]\n\n**Required Methods**:\n\n| Method | Purpose | Critical Requirements |\n|--------|---------|----------------------|\n| `__init__(api_key, d0_start, d0_end)` | Initialize | MUST calculate historical buffer |\n| `run_scan()` | Main execution | Calls all 5 stages in order |\n| `fetch_grouped_data()` | Stage 1 | Use mcal, parallel fetching |\n| `compute_simple_features()` | Stage 2a | Per-ticker operations |\n| `apply_smart_filters()` | Stage 2b | Separate historical/D0 |\n| `compute_full_features()` | Stage 3a | All technical indicators |\n| `detect_patterns()` | Stage 3b | Pattern-specific logic |\n\n---",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::EdgeDev Codebase Research Report::1. Scanner Architecture Patterns::Pattern A: V31 Class-Based Architecture (Recommended for Production)::chunk2",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Codebase Research Report",
      "1. Scanner Architecture Patterns",
      "Pattern A: V31 Class-Based Architecture (Recommended for Production)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Pattern A: V31 Class-Based Architecture (Recommended for Production)"
    },
    "tags": [
      "scanner",
      "strategy",
      "indicator",
      "pattern",
      "v31",
      "code",
      "optimization",
      "execution"
    ]
  },
  {
    "content": "### Pattern B: Standalone Script Architecture (Simple)\n\n**File References**:\n- `/projects/edge-dev-main/backend/SIMPLE_TEST_SCANNER.py`\n- `/projects/edge-dev-main/backend/proven_backside_scanner.py`\n\n**Core Structure**:\n\n```python\nimport pandas as pd\nimport numpy as np\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::EdgeDev Codebase Research Report::1. Scanner Architecture Patterns::Pattern B: Standalone Script Architecture (Simple)",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Codebase Research Report",
      "1. Scanner Architecture Patterns",
      "Pattern B: Standalone Script Architecture (Simple)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Pattern B: Standalone Script Architecture (Simple)"
    },
    "tags": [
      "scanner",
      "pattern",
      "code"
    ]
  },
  {
    "content": "# Required: SYMBOLS list for the scanner\nSYMBOLS = [\n    'AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'META', 'NVDA', 'NFLX',\n    'AMD', 'INTC', 'CRM', 'ORCL', 'ADBE', 'PYPL', 'SHOP', 'SQ'\n]\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Required: SYMBOLS list for the scanner",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Required: SYMBOLS list for the scanner"
    ],
    "metadata": {
      "level": 1,
      "heading": "Required: SYMBOLS list for the scanner"
    },
    "tags": [
      "scanner"
    ]
  },
  {
    "content": "# Required: scan_symbol function\ndef scan_symbol(symbol, start_date, end_date):\n    \"\"\"\n    Scanner function - must match this signature\n    \"\"\"\n    try:\n        # Detection logic here\n\n        if signal_detected:\n            result = {\n                'symbol': symbol,\n                'date': end_date,\n                'gap_percent': gap_percent,\n                'volume_ratio': volume_ratio,\n                # ... other fields\n            }\n            return [result]\n\n        return []\n\n    except Exception as e:\n        print(f\"Error scanning {symbol}: {str(e)}\")\n        return []\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Required: scan_symbol function",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Required: scan_symbol function"
    ],
    "metadata": {
      "level": 1,
      "heading": "Required: scan_symbol function"
    },
    "tags": [
      "scanner",
      "indicator",
      "code"
    ]
  },
  {
    "content": "# Optional: Scanner configuration\nSCANNER_CONFIG = {\n    'name': 'Simple Scanner',\n    'description': 'Simple standalone scanner',\n    'timeframe': 'Daily'\n}\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Optional: Scanner configuration",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Optional: Scanner configuration"
    ],
    "metadata": {
      "level": 1,
      "heading": "Optional: Scanner configuration"
    },
    "tags": [
      "scanner"
    ]
  },
  {
    "content": "# Entry point\nif __name__ == \"__main__\":\n    print(\"Scanner - Verification Mode\")\n    # Test logic here\n```\n\n**Key Requirements**:\n- `SYMBOLS` list at module level\n- `scan_symbol(symbol, start_date, end_date)` function\n- Returns list of dict results\n- Optional `SCANNER_CONFIG` dict\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Entry point",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Entry point"
    ],
    "metadata": {
      "level": 1,
      "heading": "Entry point"
    },
    "tags": [
      "scanner",
      "code"
    ]
  },
  {
    "content": "### Critical Architecture Principles (From V31 Spec)\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Entry point::Critical Architecture Principles (From V31 Spec)",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Entry point",
      "Critical Architecture Principles (From V31 Spec)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Critical Architecture Principles (From V31 Spec)"
    },
    "tags": [
      "v31"
    ]
  },
  {
    "content": "#### Principle 1: Market Calendar Integration\n\n```python\nimport pandas_market_calendars as mcal\n\ndef get_trading_dates(self, start_date: str, end_date: str) -> List[str]:\n    \"\"\"Get all valid trading days between start and end date\"\"\"\n    nyse = mcal.get_calendar('NYSE')\n    trading_days = nyse.valid_days(\n        start_date=pd.to_datetime(start_date),\n        end_date=pd.to_datetime(end_date)\n    )\n    return [date.strftime('%Y-%m-%d') for date in trading_days]\n```\n\n**WHY**: Accounts for holidays, early closes, skip weekends correctly\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Entry point::Critical Architecture Principles (From V31 Spec)::Principle 1: Market Calendar Integration",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Entry point",
      "Critical Architecture Principles (From V31 Spec)",
      "Principle 1: Market Calendar Integration"
    ],
    "metadata": {
      "level": 4,
      "heading": "Principle 1: Market Calendar Integration"
    },
    "tags": [
      "strategy",
      "code"
    ]
  },
  {
    "content": "#### Principle 2: Historical Buffer Calculation\n\n```python\ndef __init__(self, api_key: str, d0_start: str, d0_end: str):\n    self.d0_start_user = d0_start\n    self.d0_end_user = d0_end\n\n    # Calculate historical buffer\n    lookback_buffer = self.params['abs_lookback_days'] + 50\n    scan_start_dt = pd.to_datetime(self.d0_start_user) - pd.Timedelta(days=lookback_buffer)\n    self.scan_start = scan_start_dt.strftime('%Y-%m-%d')\n    self.d0_end = self.d0_end_user\n```\n\n**WHY**: ABS window needs 1000+ days of history to calculate position\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Entry point::Critical Architecture Principles (From V31 Spec)::Principle 1: Market Calendar Integration::Principle 2: Historical Buffer Calculation",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Entry point",
      "Critical Architecture Principles (From V31 Spec)",
      "Principle 1: Market Calendar Integration",
      "Principle 2: Historical Buffer Calculation"
    ],
    "metadata": {
      "level": 4,
      "heading": "Principle 2: Historical Buffer Calculation"
    },
    "tags": [
      "scanner",
      "code",
      "position"
    ]
  },
  {
    "content": "#### Principle 3: Per-Ticker Operations\n\n```python",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Entry point::Critical Architecture Principles (From V31 Spec)::Principle 1: Market Calendar Integration::Principle 3: Per-Ticker Operations",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Entry point",
      "Critical Architecture Principles (From V31 Spec)",
      "Principle 1: Market Calendar Integration",
      "Principle 3: Per-Ticker Operations"
    ],
    "metadata": {
      "level": 4,
      "heading": "Principle 3: Per-Ticker Operations"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# \u2705 CORRECT: adv20 computed per ticker\ndf['adv20_usd'] = (df['close'] * df['volume']).groupby(df['ticker']).transform(\n    lambda x: x.rolling(window=20, min_periods=20).mean()\n)\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::\u2705 CORRECT: adv20 computed per ticker",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "\u2705 CORRECT: adv20 computed per ticker"
    ],
    "metadata": {
      "level": 1,
      "heading": "\u2705 CORRECT: adv20 computed per ticker"
    },
    "tags": []
  },
  {
    "content": "# \u274c WRONG: adv20 computed across entire dataframe\ndf['adv20_usd'] = (df['close'] * df['volume']).rolling(20).mean()\n```\n\n**WHY**: Each ticker has different price/volume scales\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::\u274c WRONG: adv20 computed across entire dataframe",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "\u274c WRONG: adv20 computed across entire dataframe"
    ],
    "metadata": {
      "level": 1,
      "heading": "\u274c WRONG: adv20 computed across entire dataframe"
    },
    "tags": [
      "pyramiding"
    ]
  },
  {
    "content": "#### Principle 4: Historical/D0 Separation\n\n```python\ndef apply_smart_filters(self, df: pd.DataFrame):\n    \"\"\"CRITICAL: Separate historical from D0 output range\"\"\"\n\n    # Separate historical from output range\n    df_historical = df[~df['date'].between(self.d0_start_user, self.d0_end_user)].copy()\n    df_output_range = df[df['date'].between(self.d0_start_user, self.d0_end_user)].copy()\n\n    # Apply filters ONLY to D0 dates\n    df_output_filtered = df_output_range[\n        (df_output_range['prev_close'] >= self.params['price_min']) &\n        (df_output_range['adv20_usd'] >= self.params['adv20_min_usd']) &\n        (df_output_range['price_range'] >= 0.50) &\n        (df_output_range['volume'] >= 1_000_000)\n    ].copy()\n\n    # COMBINE historical + filtered D0\n    df_combined = pd.concat([df_historical, df_output_filtered], ignore_index=True)\n\n    return df_combined\n```\n\n**WHY**: Historical data needed for ABS window calculations, only D0 dates need validation\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::\u274c WRONG: adv20 computed across entire dataframe::Principle 4: Historical/D0 Separation",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "\u274c WRONG: adv20 computed across entire dataframe",
      "Principle 4: Historical/D0 Separation"
    ],
    "metadata": {
      "level": 4,
      "heading": "Principle 4: Historical/D0 Separation"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "#### Principle 5: Parallel Processing\n\n```python",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::\u274c WRONG: adv20 computed across entire dataframe::Principle 4: Historical/D0 Separation::Principle 5: Parallel Processing",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "\u274c WRONG: adv20 computed across entire dataframe",
      "Principle 4: Historical/D0 Separation",
      "Principle 5: Parallel Processing"
    ],
    "metadata": {
      "level": 4,
      "heading": "Principle 5: Parallel Processing"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# Stage 1: Parallel date fetching\nwith ThreadPoolExecutor(max_workers=self.stage1_workers) as executor:\n    future_to_date = {\n        executor.submit(self._fetch_grouped_day, date_str): date_str\n        for date_str in trading_dates\n    }\n\n    for future in as_completed(future_to_date):\n        data = future.result()\n        all_data.append(data)\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Stage 1: Parallel date fetching",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Stage 1: Parallel date fetching"
    ],
    "metadata": {
      "level": 1,
      "heading": "Stage 1: Parallel date fetching"
    },
    "tags": [
      "strategy",
      "v31"
    ]
  },
  {
    "content": "# Stage 3: Parallel ticker processing (pre-sliced)\nticker_data_list = [\n    (ticker, ticker_df.copy(), d0_start_dt, d0_end_dt)\n    for ticker, ticker_df in df.groupby('ticker')\n]\n\nwith ThreadPoolExecutor(max_workers=self.stage3_workers) as executor:\n    future_to_ticker = {\n        executor.submit(self._process_ticker_optimized_pre_sliced, ticker_data): ticker_data[0]\n        for ticker_data in ticker_data_list\n    }\n```\n\n**WHY**: 360x speedup (6-8 minutes \u2192 10-30 seconds)\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Stage 3: Parallel ticker processing (pre-sliced)",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Stage 3: Parallel ticker processing (pre-sliced)"
    ],
    "metadata": {
      "level": 1,
      "heading": "Stage 3: Parallel ticker processing (pre-sliced)"
    },
    "tags": [
      "v31",
      "optimization"
    ]
  },
  {
    "content": "#### Principle 6: Two-Pass Feature Computation\n\n```python",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Stage 3: Parallel ticker processing (pre-sliced)::Principle 6: Two-Pass Feature Computation",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Stage 3: Parallel ticker processing (pre-sliced)",
      "Principle 6: Two-Pass Feature Computation"
    ],
    "metadata": {
      "level": 4,
      "heading": "Principle 6: Two-Pass Feature Computation"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# Stage 2a: Simple features (cheap to compute)\ndef compute_simple_features(self, df: pd.DataFrame):\n    df['prev_close'] = df.groupby('ticker')['close'].shift(1)\n    df['adv20_usd'] = (df['close'] * df['volume']).groupby(df['ticker']).transform(\n        lambda x: x.rolling(window=20, min_periods=20).mean()\n    )\n    df['price_range'] = df['high'] - df['low']\n    return df\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Stage 2a: Simple features (cheap to compute)",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Stage 2a: Simple features (cheap to compute)"
    ],
    "metadata": {
      "level": 1,
      "heading": "Stage 2a: Simple features (cheap to compute)"
    },
    "tags": [
      "v31"
    ]
  },
  {
    "content": "# Stage 3a: Full features (expensive, only compute on filtered data)\ndef compute_full_features(self, df: pd.DataFrame):\n    for ticker, group in df.groupby('ticker'):\n        group['ema_9'] = group['close'].ewm(span=9, adjust=False).mean()\n        group['atr'] = compute_atr(group)\n        # ... more features\n```\n\n**WHY**: Don't compute expensive features on data that will be filtered\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Stage 3a: Full features (expensive, only compute on filtered data)",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Stage 3a: Full features (expensive, only compute on filtered data)"
    ],
    "metadata": {
      "level": 1,
      "heading": "Stage 3a: Full features (expensive, only compute on filtered data)"
    },
    "tags": [
      "v31"
    ]
  },
  {
    "content": "## 2. Backtest Specifications\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Stage 3a: Full features (expensive, only compute on filtered data)::2. Backtest Specifications",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Stage 3a: Full features (expensive, only compute on filtered data)",
      "2. Backtest Specifications"
    ],
    "metadata": {
      "level": 2,
      "heading": "2. Backtest Specifications"
    },
    "tags": [
      "backtest"
    ]
  },
  {
    "content": "### Backtest Type A: Simple P&L Simulation\n\n**File Reference**: `/projects/edge-dev-main/src/utils/backtest_script.py`\n\n**Core Structure**:\n\n```python\nimport pandas as pd\nimport numpy as np\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Stage 3a: Full features (expensive, only compute on filtered data)::2. Backtest Specifications::Backtest Type A: Simple P&L Simulation",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Stage 3a: Full features (expensive, only compute on filtered data)",
      "2. Backtest Specifications",
      "Backtest Type A: Simple P&L Simulation"
    ],
    "metadata": {
      "level": 3,
      "heading": "Backtest Type A: Simple P&L Simulation"
    },
    "tags": [
      "backtest",
      "code"
    ]
  },
  {
    "content": "# Key configuration variables\nd_risk = 1000  # Risk per trade in dollars\np_risk = 0.01  # Risk percentage (1%)\nstart_capital = 100000\n\ndef comp_pnl(df_daily_pnl, start_capital):\n    \"\"\"Calculate compound P&L\"\"\"\n    sim_pnl_comp = start_capital\n    for i, row in df_daily_pnl.iterrows():\n        if i == 0:\n            prev_sim_pnl_comp = start_capital\n        else:\n            prev_sim_pnl_comp = df_daily_pnl.loc[i-1, 'sim_pnl_comp']\n        df_daily_pnl.loc[i, 'sim_pnl_comp'] = (\n            df_daily_pnl.loc[i, 'pnl'] * ((prev_sim_pnl_comp * p_risk) / d_risk) +\n            prev_sim_pnl_comp\n        )\n    return df_daily_pnl\n\ndef stats_by_trade(df):\n    \"\"\"Calculate trade statistics\"\"\"\n    if len(df) == 0:\n        return {}\n\n    win_trades = df[df['pnl'] > 0]\n    loss_trades = df[df['pnl'] < 0]\n\n    win_rate = len(win_trades) / len(df) if len(df) > 0 else 0\n    avg_win = win_trades['R_pnl'].mean() if len(win_trades) > 0 else 0\n    avg_loss = loss_trades['R_pnl'].mean() if len(loss_trades) > 0 else 0\n\n    if abs(avg_loss) > 0:\n        avg_wl_ratio = abs(avg_win) / abs(avg_loss)\n    else:\n        avg_wl_ratio = float('inf')\n\n    total_profit = df['cum_R_pnl'].iloc[-1] if len(df) > 0 else 0\n    ev = (win_rate * avg_win) + ((1 - win_rate) * avg_loss)\n    kelly = win_rate - ((1 - win_rate) / avg_wl_ratio) if avg_wl_ratio > 0 else 0",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Key configuration variables::chunk0",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Key configuration variables"
    ],
    "metadata": {
      "level": 1,
      "heading": "Key configuration variables"
    },
    "tags": [
      "indicator",
      "risk"
    ]
  },
  {
    "content": "_profit = df['cum_R_pnl'].iloc[-1] if len(df) > 0 else 0\n    ev = (win_rate * avg_win) + ((1 - win_rate) * avg_loss)\n    kelly = win_rate - ((1 - win_rate) / avg_wl_ratio) if avg_wl_ratio > 0 else 0\n\n\n\n[...previous chunk overlap...]\n\n    return {\n        'total_trades': len(df),\n        'winners': len(win_trades),\n        'losers': len(loss_trades),\n        'win_rate': win_rate,\n        'avg_win': avg_win,\n        'avg_loss': avg_loss,\n        'avg_wl_ratio': avg_wl_ratio,\n        'total_profit_r': total_profit,\n        'expected_value': ev,\n        'kelly': kelly\n    }\n```\n\n**Required Metrics**:\n- `total_trades`: Total number of trades\n- `winners`: Winning trades count\n- `losers`: Losing trades count\n- `win_rate`: Percentage of winning trades\n- `avg_win`: Average win amount (R-multiple)\n- `avg_loss`: Average loss amount (R-multiple)\n- `avg_wl_ratio`: Win/loss ratio\n- `total_profit_r`: Total profit in R-multiples\n- `expected_value`: Expected value per trade\n- `kelly`: Kelly criterion\n\n---",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Key configuration variables::chunk1",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Key configuration variables"
    ],
    "metadata": {
      "level": 1,
      "heading": "Key configuration variables"
    },
    "tags": [
      "indicator",
      "risk"
    ]
  },
  {
    "content": "### Backtest Type B: Enhanced Intraday Simulation\n\n**File Reference**: `/projects/edge-dev-main/src/utils/enhanced_backtest_engine.py`\n\n**Core Structure**:\n\n```python\nclass EnhancedBacktestEngine:\n    def __init__(self, config: Dict = None):\n        self.config = config or {}\n\n        # Risk management\n        self.d_risk = self.config.get('risk_per_trade_dollars', 1000)\n        self.p_risk = self.config.get('risk_percentage', 0.01)\n        self.start_capital = self.config.get('start_capital', 100000)\n\n        # Exit strategies\n        self.exit_strategies = {\n            'lc_momentum': {\n                'profit_target_atr': 2.0,\n                'stop_loss_atr': 0.8,\n                'trailing_stop_atr': 0.5,\n                'time_exit_minutes': 240,\n                'volume_exit_threshold': 0.3\n            },\n            'parabolic': {\n                'profit_target_atr': 3.0,\n                'stop_loss_atr': 1.0,\n                'trailing_stop_atr': 0.8,\n                'time_exit_minutes': 180,\n                'momentum_exit_threshold': 0.5\n            }\n        }\n\n    def run_enhanced_backtest(self, scan_results: List[Dict]) -> Dict:\n        \"\"\"Run enhanced backtest with real intraday data\"\"\"\n        all_trades = []\n\n        for scan_result in scan_results:\n            trade_result = self.simulate_trade_with_intraday_data(scan_result)\n            if trade_result:\n                all_trades.append(trade_result)\n\n        performance_metrics = self.calculate_enhanced_metrics(all_trades)\n\n        return {\n            'success': True,\n            'trades': all_trades,\n            'summary': performance_metrics\n        }\n```\n\n**Enhanced Features**:\n- Real intraday data fetching\n- Multiple exit strategies\n- Trailing stops\n- Volume-based exits\n- Time-based exits\n- Comprehensive performance analytics\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Key configuration variables::Backtest Type B: Enhanced Intraday Simulation",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Key configuration variables",
      "Backtest Type B: Enhanced Intraday Simulation"
    ],
    "metadata": {
      "level": 3,
      "heading": "Backtest Type B: Enhanced Intraday Simulation"
    },
    "tags": [
      "scanner",
      "backtest",
      "indicator",
      "code",
      "risk"
    ]
  },
  {
    "content": "## 3. Code Structure Standards\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Key configuration variables::3. Code Structure Standards",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Key configuration variables",
      "3. Code Structure Standards"
    ],
    "metadata": {
      "level": 2,
      "heading": "3. Code Structure Standards"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "### Required Imports\n\n```python\nimport pandas as pd\nimport numpy as np\nimport requests\nfrom datetime import datetime, timedelta\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nimport pandas_market_calendars as mcal\nfrom typing import List, Dict, Optional, Any\n```\n\n**File Reference**: All production scanners use these imports\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Key configuration variables::3. Code Structure Standards::Required Imports",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Key configuration variables",
      "3. Code Structure Standards",
      "Required Imports"
    ],
    "metadata": {
      "level": 3,
      "heading": "Required Imports"
    },
    "tags": [
      "scanner",
      "code"
    ]
  },
  {
    "content": "### Column Naming Convention\n\n| Stage | Columns | Format |\n|-------|---------|--------|\n| Stage 1 Output | `ticker`, `date`, `open`, `high`, `low`, `close`, `volume` | lowercase |\n| Stage 2a/2b | Add: `prev_close`, `adv20_usd`, `price_range` | lowercase |\n| Stage 3a | Add: `ema_9`, `atr`, `vol_avg`, etc. | lowercase |\n| Detection Loop | Access via: `r1['Close']`, `r0['atr']` | Capitalized |\n\n**WHY**: Stage 1-3 use lowercase for DataFrame operations, detection loop uses capitalized Series access\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Key configuration variables::3. Code Structure Standards::Column Naming Convention",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Key configuration variables",
      "3. Code Structure Standards",
      "Column Naming Convention"
    ],
    "metadata": {
      "level": 3,
      "heading": "Column Naming Convention"
    },
    "tags": [
      "v31"
    ]
  },
  {
    "content": "### Date Handling Standards\n\n```python",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Key configuration variables::3. Code Structure Standards::Date Handling Standards",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Key configuration variables",
      "3. Code Structure Standards",
      "Date Handling Standards"
    ],
    "metadata": {
      "level": 3,
      "heading": "Date Handling Standards"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# Stage 1-3: Store as datetime\ndf['date'] = pd.to_datetime(df['date'])\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Stage 1-3: Store as datetime",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Stage 1-3: Store as datetime"
    ],
    "metadata": {
      "level": 1,
      "heading": "Stage 1-3: Store as datetime"
    },
    "tags": [
      "v31"
    ]
  },
  {
    "content": "# Detection loop: Access as Timestamp\nd0 = ticker_df.iloc[i]['date']\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Detection loop: Access as Timestamp",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Detection loop: Access as Timestamp"
    ],
    "metadata": {
      "level": 1,
      "heading": "Detection loop: Access as Timestamp"
    },
    "tags": []
  },
  {
    "content": "# Comparison\nd0_start_dt = pd.to_datetime(self.d0_start_user)\nd0_end_dt = pd.to_datetime(self.d0_end_user)\n\nif d0 < d0_start_dt or d0 > d0_end_dt:\n    continue\n```\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Comparison",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Comparison"
    ],
    "metadata": {
      "level": 1,
      "heading": "Comparison"
    },
    "tags": []
  },
  {
    "content": "### Error Handling Patterns\n\n```python",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Comparison::Error Handling Patterns",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Comparison",
      "Error Handling Patterns"
    ],
    "metadata": {
      "level": 3,
      "heading": "Error Handling Patterns"
    },
    "tags": [
      "pattern",
      "code"
    ]
  },
  {
    "content": "# Graceful handling of missing data\ntry:\n    m = add_daily_metrics(ticker_data_indexed)\nexcept:\n    continue\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Graceful handling of missing data",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Graceful handling of missing data"
    ],
    "metadata": {
      "level": 1,
      "heading": "Graceful handling of missing data"
    },
    "tags": [
      "indicator"
    ]
  },
  {
    "content": "# Early data validation\nif len(ticker_df) < 100:\n    return []\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Early data validation",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Early data validation"
    ],
    "metadata": {
      "level": 1,
      "heading": "Early data validation"
    },
    "tags": []
  },
  {
    "content": "# NaN checks\nif not (pd.notna(pos_abs_prev) and pos_abs_prev <= self.params['pos_abs_max']):\n    continue\n```\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::NaN checks",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "NaN checks"
    ],
    "metadata": {
      "level": 1,
      "heading": "NaN checks"
    },
    "tags": []
  },
  {
    "content": "## 4. Data Structure Requirements\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::NaN checks::4. Data Structure Requirements",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "NaN checks",
      "4. Data Structure Requirements"
    ],
    "metadata": {
      "level": 2,
      "heading": "4. Data Structure Requirements"
    },
    "tags": []
  },
  {
    "content": "### Input Data Structure (from API)\n\n```python",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::NaN checks::4. Data Structure Requirements::Input Data Structure (from API)",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "NaN checks",
      "4. Data Structure Requirements",
      "Input Data Structure (from API)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Input Data Structure (from API)"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# Polygon grouped endpoint returns:\n{\n    \"results\": [\n        {\n            \"T\": \"AAPL\",  # Ticker\n            \"t\": 1609459200000,  # Timestamp (ms)\n            \"o\": 150.25,  # Open\n            \"h\": 152.00,  # High\n            \"l\": 149.50,  # Low\n            \"c\": 151.75,  # Close\n            \"v\": 50000000  # Volume\n        }\n    ]\n}\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Polygon grouped endpoint returns:",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Polygon grouped endpoint returns:"
    ],
    "metadata": {
      "level": 1,
      "heading": "Polygon grouped endpoint returns:"
    },
    "tags": []
  },
  {
    "content": "# Convert to DataFrame:\ndf = pd.DataFrame(data['results'])\ndf = df.rename(columns={\n    'T': 'ticker',\n    'v': 'volume',\n    'o': 'open',\n    'c': 'close',\n    'h': 'high',\n    'l': 'low',\n    't': 'timestamp',\n})\ndf['date'] = pd.to_datetime(df['timestamp'], unit='ms').dt.strftime('%Y-%m-%d')\ndf = df[['ticker', 'date', 'open', 'high', 'low', 'close', 'volume']]\n```\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Convert to DataFrame:",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Convert to DataFrame:"
    ],
    "metadata": {
      "level": 1,
      "heading": "Convert to DataFrame:"
    },
    "tags": []
  },
  {
    "content": "### Output Data Structure (Scan Results)\n\n```python",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Convert to DataFrame:::Output Data Structure (Scan Results)",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Convert to DataFrame:",
      "Output Data Structure (Scan Results)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Output Data Structure (Scan Results)"
    },
    "tags": [
      "scanner",
      "code"
    ]
  },
  {
    "content": "# Single pattern scanner returns:\n[\n    {\n        \"Ticker\": \"AAPL\",\n        \"Date\": \"2024-01-15\",\n        \"Gap/ATR\": 1.25,\n        \"D1_Body/ATR\": 0.75,\n        \"PosAbs_1000d\": 0.45,\n        \"D1Vol(shares)\": 50000000,\n        \"D1Vol/Avg\": 1.8,\n        \"Trigger\": \"D1_or_D2\",\n        # ... pattern-specific fields\n    }\n]\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Single pattern scanner returns:",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Single pattern scanner returns:"
    ],
    "metadata": {
      "level": 1,
      "heading": "Single pattern scanner returns:"
    },
    "tags": [
      "scanner",
      "pattern"
    ]
  },
  {
    "content": "# Multi-pattern scanner returns:\n[\n    {\n        \"Ticker\": \"AAPL\",\n        \"Date\": \"2024-01-15\",\n        \"Scanner_Label\": \"D2_PM_Setup\",  # Pattern identifier\n        # ... pattern-specific fields\n    }\n]\n```\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Multi-pattern scanner returns:",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Multi-pattern scanner returns:"
    ],
    "metadata": {
      "level": 1,
      "heading": "Multi-pattern scanner returns:"
    },
    "tags": [
      "scanner",
      "pattern"
    ]
  },
  {
    "content": "## 5. Parameter System Design\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Multi-pattern scanner returns:::5. Parameter System Design",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Multi-pattern scanner returns:",
      "5. Parameter System Design"
    ],
    "metadata": {
      "level": 2,
      "heading": "5. Parameter System Design"
    },
    "tags": []
  },
  {
    "content": "### Parameter Structure Pattern\n\n```python\nself.params = {\n    # === Mass Parameters (shared across all patterns) ===\n    \"price_min\": 8.0,\n    \"adv20_min_usd\": 30_000_000,\n\n    # === Backside B Pattern Parameters ===\n    # Backside context\n    \"abs_lookback_days\": 1000,\n    \"abs_exclude_days\": 10,\n    \"pos_abs_max\": 0.75,\n\n    # Trigger mold\n    \"trigger_mode\": \"D1_or_D2\",\n    \"atr_mult\": 0.9,\n    \"vol_mult\": 0.9,\n\n    # D0 gates\n    \"gap_div_atr_min\": 0.75,\n    \"open_over_ema9_min\": 0.9,\n    \"d1_green_atr_min\": 0.30,\n\n    # === SC DMR Pattern Parameters ===\n    # D2_PM_Setup\n    \"d2_pm_setup_gain_min\": 0.2,\n    \"d2_pm_setup_dol_pmh_gap_vs_range_min\": 0.5,\n    \"d2_pm_setup_pct_pmh_gap_min\": 0.5,\n\n    # D2_PMH_Break\n    \"d2_pmh_break_gain_min\": 1.0,\n    \"d2_pmh_break_gap_min\": 0.2,\n\n    # D3/D4\n    \"d3_gain_min\": 0.2,\n    \"d3_gap_min\": 0.2,\n    \"d4_gain_min\": 0.2,\n}\n```\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Multi-pattern scanner returns:::5. Parameter System Design::Parameter Structure Pattern",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Multi-pattern scanner returns:",
      "5. Parameter System Design",
      "Parameter Structure Pattern"
    ],
    "metadata": {
      "level": 3,
      "heading": "Parameter Structure Pattern"
    },
    "tags": [
      "pattern",
      "code"
    ]
  },
  {
    "content": "### Parameter Access Patterns\n\n```python",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Multi-pattern scanner returns:::5. Parameter System Design::Parameter Access Patterns",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Multi-pattern scanner returns:",
      "5. Parameter System Design",
      "Parameter Access Patterns"
    ],
    "metadata": {
      "level": 3,
      "heading": "Parameter Access Patterns"
    },
    "tags": [
      "pattern",
      "code"
    ]
  },
  {
    "content": "# In __init__: Store as dict\nself.params = {\"price_min\": 8.0, ...}\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::In __init__: Store as dict",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "In __init__: Store as dict"
    ],
    "metadata": {
      "level": 1,
      "heading": "In __init__: Store as dict"
    },
    "tags": []
  },
  {
    "content": "# In methods: Access via self.params\nif r1['Close'] >= self.params['price_min']:\n    ...\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::In methods: Access via self.params",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "In methods: Access via self.params"
    ],
    "metadata": {
      "level": 1,
      "heading": "In methods: Access via self.params"
    },
    "tags": []
  },
  {
    "content": "# In detection loop: Use local copy\nP_local = self.params\nif P_local[\"price_min\"]:\n    ...\n```\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::In detection loop: Use local copy",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "In detection loop: Use local copy"
    ],
    "metadata": {
      "level": 1,
      "heading": "In detection loop: Use local copy"
    },
    "tags": []
  },
  {
    "content": "## 6. API Integration Patterns\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::In detection loop: Use local copy::6. API Integration Patterns",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "In detection loop: Use local copy",
      "6. API Integration Patterns"
    ],
    "metadata": {
      "level": 2,
      "heading": "6. API Integration Patterns"
    },
    "tags": [
      "pattern"
    ]
  },
  {
    "content": "### Polygon API Configuration\n\n```python",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::In detection loop: Use local copy::6. API Integration Patterns::Polygon API Configuration",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "In detection loop: Use local copy",
      "6. API Integration Patterns",
      "Polygon API Configuration"
    ],
    "metadata": {
      "level": 3,
      "heading": "Polygon API Configuration"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# Standard configuration\nAPI_KEY = \"Fm7brz4s23eSocDErnL68cE7wspz2K1I\"  # Should be env variable\nBASE_URL = \"https://api.polygon.io\"\nsession = requests.Session()\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Standard configuration",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Standard configuration"
    ],
    "metadata": {
      "level": 1,
      "heading": "Standard configuration"
    },
    "tags": []
  },
  {
    "content": "# Grouped endpoint (V31 preferred)\ndef fetch_grouped_data(self):\n    url = f\"{self.base_url}/v2/aggs/grouped/locale/us/market/stocks/{date_str}\"\n    response = self.session.get(url, params={\n        'apiKey': self.api_key,\n        'adjusted': 'true'\n    })\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Grouped endpoint (V31 preferred)",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Grouped endpoint (V31 preferred)"
    ],
    "metadata": {
      "level": 1,
      "heading": "Grouped endpoint (V31 preferred)"
    },
    "tags": [
      "v31"
    ]
  },
  {
    "content": "# Individual ticker endpoint (legacy)\ndef fetch_daily(tkr: str, start: str, end: str):\n    url = f\"{self.base_url}/v2/aggs/ticker/{tkr}/range/1/day/{start}/{end}\"\n    response = self.session.get(url, params={\n        \"apiKey\": API_KEY,\n        \"adjusted\": \"true\",\n        \"sort\": \"asc\",\n        \"limit\": 50000\n    })\n```\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Individual ticker endpoint (legacy)",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Individual ticker endpoint (legacy)"
    ],
    "metadata": {
      "level": 1,
      "heading": "Individual ticker endpoint (legacy)"
    },
    "tags": []
  },
  {
    "content": "### API Rate Limiting\n\n```python",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Individual ticker endpoint (legacy)::API Rate Limiting",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Individual ticker endpoint (legacy)",
      "API Rate Limiting"
    ],
    "metadata": {
      "level": 3,
      "heading": "API Rate Limiting"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# V31 uses grouped endpoint: 1 call per day (not per ticker)",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::V31 uses grouped endpoint: 1 call per day (not per ticker)",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "V31 uses grouped endpoint: 1 call per day (not per ticker)"
    ],
    "metadata": {
      "level": 1,
      "heading": "V31 uses grouped endpoint: 1 call per day (not per ticker)"
    },
    "tags": [
      "v31"
    ]
  },
  {
    "content": "# Legacy uses individual ticker: N calls per ticker per day\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Legacy uses individual ticker: N calls per ticker per day",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Legacy uses individual ticker: N calls per ticker per day"
    ],
    "metadata": {
      "level": 1,
      "heading": "Legacy uses individual ticker: N calls per ticker per day"
    },
    "tags": []
  },
  {
    "content": "# Standard rate limiting\nimport time\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Standard rate limiting",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Standard rate limiting"
    ],
    "metadata": {
      "level": 1,
      "heading": "Standard rate limiting"
    },
    "tags": []
  },
  {
    "content": "# Between ticker fetches\ntime.sleep(0.1)  # 100ms delay\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Between ticker fetches",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Between ticker fetches"
    ],
    "metadata": {
      "level": 1,
      "heading": "Between ticker fetches"
    },
    "tags": []
  },
  {
    "content": "# Between date fetches (grouped endpoint)",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Between date fetches (grouped endpoint)",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Between date fetches (grouped endpoint)"
    ],
    "metadata": {
      "level": 1,
      "heading": "Between date fetches (grouped endpoint)"
    },
    "tags": []
  },
  {
    "content": "# No delay needed with ThreadPoolExecutor\n```\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::No delay needed with ThreadPoolExecutor",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "No delay needed with ThreadPoolExecutor"
    ],
    "metadata": {
      "level": 1,
      "heading": "No delay needed with ThreadPoolExecutor"
    },
    "tags": []
  },
  {
    "content": "## 7. Workflow Best Practices\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::No delay needed with ThreadPoolExecutor::7. Workflow Best Practices",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "No delay needed with ThreadPoolExecutor",
      "7. Workflow Best Practices"
    ],
    "metadata": {
      "level": 2,
      "heading": "7. Workflow Best Practices"
    },
    "tags": []
  },
  {
    "content": "### Development Workflow\n\n1. **Create Scanner**\n   - Choose architecture (V31 class-based or standalone script)\n   - Implement required methods/functions\n   - Define parameters\n\n2. **Test Locally**\n   - Use small symbol list (5-10 symbols)\n   - Use short date range (1-2 months)\n   - Verify output structure\n\n3. **Validate**\n   - Run full symbol list\n   - Run full date range\n   - Check performance metrics\n\n4. **Deploy**\n   - Add to project\n   - Configure parameters\n   - Monitor execution\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::No delay needed with ThreadPoolExecutor::7. Workflow Best Practices::Development Workflow",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "No delay needed with ThreadPoolExecutor",
      "7. Workflow Best Practices",
      "Development Workflow"
    ],
    "metadata": {
      "level": 3,
      "heading": "Development Workflow"
    },
    "tags": [
      "scanner",
      "strategy",
      "indicator",
      "v31",
      "code",
      "execution"
    ]
  },
  {
    "content": "### Testing Strategy\n\n```python",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::No delay needed with ThreadPoolExecutor::7. Workflow Best Practices::Testing Strategy",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "No delay needed with ThreadPoolExecutor",
      "7. Workflow Best Practices",
      "Testing Strategy"
    ],
    "metadata": {
      "level": 3,
      "heading": "Testing Strategy"
    },
    "tags": [
      "backtest",
      "strategy",
      "code"
    ]
  },
  {
    "content": "# Simple test scanner\nclass TestScanner:\n    def __init__(self):\n        self.params = {\n            'min_price': 5.0,\n            'min_volume': 1000000\n        }\n        self.symbols = ['AAPL', 'MSFT', 'GOOGL']\n\n    def run_scan(self):\n        results = []\n        for symbol in self.symbols:\n            # Simple logic: find every 3rd symbol\n            if hash(symbol) % 3 == 0:\n                results.append({\n                    'symbol': symbol,\n                    'date': '2024-01-15',\n                    'test': True\n                })\n        return results\n```\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Simple test scanner",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Simple test scanner"
    ],
    "metadata": {
      "level": 1,
      "heading": "Simple test scanner"
    },
    "tags": [
      "scanner"
    ]
  },
  {
    "content": "## 8. Validation Checklists\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Simple test scanner::8. Validation Checklists",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Simple test scanner",
      "8. Validation Checklists"
    ],
    "metadata": {
      "level": 2,
      "heading": "8. Validation Checklists"
    },
    "tags": []
  },
  {
    "content": "### Scanner Validation Checklist\n\n**V31 Class-Based Scanner**:\n- [ ] Uses `pandas_market_calendars` for trading days\n- [ ] Calculates historical buffer in `__init__`\n- [ ] Has 5-stage pipeline (fetch, simple_features, smart_filters, full_features, detect_patterns)\n- [ ] Stage 1 uses parallel fetching (ThreadPoolExecutor)\n- [ ] Stage 2b separates historical from D0 dates\n- [ ] Stage 2b combines historical + filtered D0\n- [ ] All operations use per-ticker groupby/transform\n- [ ] Stage 3a computes features per-ticker\n- [ ] Stage 3b uses pre-sliced data for parallel processing\n- [ ] Detection loop filters by D0 range (early exit)\n- [ ] Parameters stored in `self.params` dict\n- [ ] Returns list of signal dicts from detect_patterns\n\n**Standalone Script Scanner**:\n- [ ] Has `SYMBOLS` list at module level\n- [ ] Has `scan_symbol(symbol, start_date, end_date)` function\n- [ ] Returns list of dict results\n- [ ] Has optional `SCANNER_CONFIG` dict\n- [ ] Handles exceptions gracefully\n- [ ] Provides progress feedback\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Simple test scanner::8. Validation Checklists::Scanner Validation Checklist",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Simple test scanner",
      "8. Validation Checklists",
      "Scanner Validation Checklist"
    ],
    "metadata": {
      "level": 3,
      "heading": "Scanner Validation Checklist"
    },
    "tags": [
      "scanner",
      "strategy",
      "indicator",
      "pattern",
      "v31",
      "code"
    ]
  },
  {
    "content": "### Backtest Validation Checklist\n\n- [ ] Calculates all required metrics\n- [ ] Handles edge cases (no trades, all wins, all losses)\n- [ ] Uses proper position sizing\n- [ ] Accounts for slippage (enhanced version)\n- [ ] Uses realistic exit strategies\n- [ ] Provides comprehensive statistics\n- [ ] Handles missing data gracefully\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Simple test scanner::8. Validation Checklists::Backtest Validation Checklist",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Simple test scanner",
      "8. Validation Checklists",
      "Backtest Validation Checklist"
    ],
    "metadata": {
      "level": 3,
      "heading": "Backtest Validation Checklist"
    },
    "tags": [
      "backtest",
      "indicator",
      "risk",
      "position"
    ]
  },
  {
    "content": "### Code Quality Checklist\n\n- [ ] Follows PEP 8 style guide\n- [ ] Has docstrings for all functions/classes\n- [ ] Has type hints (Python 3.6+)\n- [ ] Handles exceptions properly\n- [ ] Logs progress and errors\n- [ ] Has parameter validation\n- [ ] Has data validation\n- [ ] Is testable in isolation\n- [ ] Has no hardcoded values (use parameters)\n- [ ] Has no magic numbers (use named constants)\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Simple test scanner::8. Validation Checklists::Code Quality Checklist",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Simple test scanner",
      "8. Validation Checklists",
      "Code Quality Checklist"
    ],
    "metadata": {
      "level": 3,
      "heading": "Code Quality Checklist"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "## 9. Common Patterns and Anti-Patterns\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Simple test scanner::9. Common Patterns and Anti-Patterns",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Simple test scanner",
      "9. Common Patterns and Anti-Patterns"
    ],
    "metadata": {
      "level": 2,
      "heading": "9. Common Patterns and Anti-Patterns"
    },
    "tags": [
      "pattern"
    ]
  },
  {
    "content": "### Common Anti-Patterns\n\n**\u274c Anti-Pattern 1**: Using weekday() for trading days\n```python",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Simple test scanner::9. Common Patterns and Anti-Patterns::Common Anti-Patterns",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Simple test scanner",
      "9. Common Patterns and Anti-Patterns",
      "Common Anti-Patterns"
    ],
    "metadata": {
      "level": 3,
      "heading": "Common Anti-Patterns"
    },
    "tags": [
      "strategy",
      "pattern",
      "code"
    ]
  },
  {
    "content": "# WRONG\nif current_date.weekday() < 5:  # Monday-Friday\n    # Process data\n```\n\n**\u2705 Correct Pattern**: Use pandas_market_calendars\n```python",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::WRONG",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "WRONG"
    ],
    "metadata": {
      "level": 1,
      "heading": "WRONG"
    },
    "tags": [
      "pattern",
      "code"
    ]
  },
  {
    "content": "# RIGHT\nnyse = mcal.get_calendar('NYSE')\ntrading_dates = nyse.valid_days(start_date, end_date)\n```\n\n---\n\n**\u274c Anti-Pattern 2**: Computing indicators across entire dataframe\n```python",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::RIGHT",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "RIGHT"
    ],
    "metadata": {
      "level": 1,
      "heading": "RIGHT"
    },
    "tags": [
      "strategy",
      "indicator",
      "pattern",
      "code"
    ]
  },
  {
    "content": "# WRONG\ndf['adv20'] = (df['close'] * df['volume']).rolling(20).mean()\n```\n\n**\u2705 Correct Pattern**: Compute per-ticker\n```python",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::WRONG",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "WRONG"
    ],
    "metadata": {
      "level": 1,
      "heading": "WRONG"
    },
    "tags": [
      "pattern",
      "code"
    ]
  },
  {
    "content": "# RIGHT\ndf['adv20'] = (df['close'] * df['volume']).groupby(df['ticker']).transform(\n    lambda x: x.rolling(window=20, min_periods=20).mean()\n)\n```\n\n---\n\n**\u274c Anti-Pattern 3**: Filtering historical data\n```python",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::RIGHT",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "RIGHT"
    ],
    "metadata": {
      "level": 1,
      "heading": "RIGHT"
    },
    "tags": [
      "pattern",
      "code"
    ]
  },
  {
    "content": "# WRONG\ndf_filtered = df[df['date'] >= d0_start]  # Loses historical data\n```\n\n**\u2705 Correct Pattern**: Separate and recombine\n```python",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::WRONG",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "WRONG"
    ],
    "metadata": {
      "level": 1,
      "heading": "WRONG"
    },
    "tags": [
      "pattern",
      "code"
    ]
  },
  {
    "content": "# RIGHT\ndf_historical = df[~df['date'].between(d0_start, d0_end)]\ndf_output = df[df['date'].between(d0_start, d0_end)]\ndf_output_filtered = df_output[condition]\ndf_combined = pd.concat([df_historical, df_output_filtered])\n```\n\n---\n\n**\u274c Anti-Pattern 4**: Sequential processing\n```python",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::RIGHT",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "RIGHT"
    ],
    "metadata": {
      "level": 1,
      "heading": "RIGHT"
    },
    "tags": [
      "pattern",
      "code"
    ]
  },
  {
    "content": "# WRONG\nresults = []\nfor symbol in symbols:\n    data = fetch_daily(symbol)  # Slow sequential\n    results.append(process(data))\n```\n\n**\u2705 Correct Pattern**: Parallel processing\n```python",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::WRONG",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "WRONG"
    ],
    "metadata": {
      "level": 1,
      "heading": "WRONG"
    },
    "tags": [
      "pattern",
      "code"
    ]
  },
  {
    "content": "# RIGHT\nwith ThreadPoolExecutor(max_workers=10) as executor:\n    futures = {executor.submit(fetch_and_process, symbol): symbol for symbol in symbols}\n    for future in as_completed(futures):\n        results.append(future.result())\n```\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::RIGHT",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "RIGHT"
    ],
    "metadata": {
      "level": 1,
      "heading": "RIGHT"
    },
    "tags": []
  },
  {
    "content": "## 10. Recommended Tools and Libraries\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::RIGHT::10. Recommended Tools and Libraries",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "RIGHT",
      "10. Recommended Tools and Libraries"
    ],
    "metadata": {
      "level": 2,
      "heading": "10. Recommended Tools and Libraries"
    },
    "tags": []
  },
  {
    "content": "### Required Libraries\n\n```python",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::RIGHT::10. Recommended Tools and Libraries::Required Libraries",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "RIGHT",
      "10. Recommended Tools and Libraries",
      "Required Libraries"
    ],
    "metadata": {
      "level": 3,
      "heading": "Required Libraries"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# Data manipulation\nimport pandas as pd\nimport numpy as np\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Data manipulation",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Data manipulation"
    ],
    "metadata": {
      "level": 1,
      "heading": "Data manipulation"
    },
    "tags": []
  },
  {
    "content": "# API requests\nimport requests\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::API requests",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "API requests"
    ],
    "metadata": {
      "level": 1,
      "heading": "API requests"
    },
    "tags": []
  },
  {
    "content": "# Date/time handling\nfrom datetime import datetime, timedelta\nimport pandas_market_calendars as mcal\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Date/time handling",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Date/time handling"
    ],
    "metadata": {
      "level": 1,
      "heading": "Date/time handling"
    },
    "tags": []
  },
  {
    "content": "# Type hints\nfrom typing import List, Dict, Optional, Any\n```\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Type hints",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Type hints"
    ],
    "metadata": {
      "level": 1,
      "heading": "Type hints"
    },
    "tags": []
  },
  {
    "content": "### Optional Libraries\n\n```python",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Type hints::Optional Libraries",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Type hints",
      "Optional Libraries"
    ],
    "metadata": {
      "level": 3,
      "heading": "Optional Libraries"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# Visualization (for testing)\nimport matplotlib.pyplot as plt\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Visualization (for testing)",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Visualization (for testing)"
    ],
    "metadata": {
      "level": 1,
      "heading": "Visualization (for testing)"
    },
    "tags": [
      "backtest"
    ]
  },
  {
    "content": "# Progress tracking\nfrom tqdm import tqdm\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Progress tracking",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Progress tracking"
    ],
    "metadata": {
      "level": 1,
      "heading": "Progress tracking"
    },
    "tags": []
  },
  {
    "content": "# Configuration management\nimport yaml\nimport json\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Configuration management",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Configuration management"
    ],
    "metadata": {
      "level": 1,
      "heading": "Configuration management"
    },
    "tags": []
  },
  {
    "content": "# Logging\nimport logging\n```\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Logging",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Logging"
    ],
    "metadata": {
      "level": 1,
      "heading": "Logging"
    },
    "tags": []
  },
  {
    "content": "## 11. Integration with EdgeDev System\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Logging::11. Integration with EdgeDev System",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Logging",
      "11. Integration with EdgeDev System"
    ],
    "metadata": {
      "level": 2,
      "heading": "11. Integration with EdgeDev System"
    },
    "tags": []
  },
  {
    "content": "### Project Structure\n\n```\nedge-dev-main/\n\u251c\u2500\u2500 backend/\n\u2502   \u251c\u2500\u2500 scanner.py              # Main scanner file\n\u2502   \u251c\u2500\u2500 backtest.py             # Backtesting engine\n\u2502   \u2514\u2500\u2500 main.py                 # API endpoints\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 app/\n\u2502   \u2502   \u2514\u2500\u2500 api/\n\u2502   \u2502       \u2514\u2500\u2500 systematic/\n\u2502   \u2502           \u2514\u2500\u2500 scan/\n\u2502   \u2502               \u2514\u2500\u2500 route.ts  # Frontend integration\n\u2502   \u2514\u2500\u2500 types/\n\u2502       \u2514\u2500\u2500 projectTypes.ts      # Type definitions\n\u2514\u2500\u2500 data/\n    \u2514\u2500\u2500 projects.json            # Project storage\n```\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Logging::11. Integration with EdgeDev System::Project Structure",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Logging",
      "11. Integration with EdgeDev System",
      "Project Structure"
    ],
    "metadata": {
      "level": 3,
      "heading": "Project Structure"
    },
    "tags": [
      "scanner",
      "backtest"
    ]
  },
  {
    "content": "### API Integration Pattern\n\n```python",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Logging::11. Integration with EdgeDev System::API Integration Pattern",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Logging",
      "11. Integration with EdgeDev System",
      "API Integration Pattern"
    ],
    "metadata": {
      "level": 3,
      "heading": "API Integration Pattern"
    },
    "tags": [
      "pattern",
      "code"
    ]
  },
  {
    "content": "# Frontend (TypeScript)\nconst response = await fetch('/api/systematic/scan', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n        scanner_type: 'backside_b',\n        date_range: {\n            start_date: '2024-01-01',\n            end_date: '2024-12-31'\n        },\n        parameters: scanner_params\n    })\n});\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Frontend (TypeScript)",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Frontend (TypeScript)"
    ],
    "metadata": {
      "level": 1,
      "heading": "Frontend (TypeScript)"
    },
    "tags": [
      "scanner"
    ]
  },
  {
    "content": "# Backend (Python/FastAPI)\n@app.post('/api/systematic/scan')\nasync def execute_scan(request: ScanRequest):\n    scanner = BacksideBScanner(\n        api_key=os.getenv('POLYGON_API_KEY'),\n        d0_start=request.date_range.start_date,\n        d0_end=request.date_range.end_date\n    )\n    results = scanner.run_scan()\n    return {'results': results}\n```\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Backend (Python/FastAPI)",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "code",
    "heading_path": [
      "Backend (Python/FastAPI)"
    ],
    "metadata": {
      "level": 1,
      "heading": "Backend (Python/FastAPI)"
    },
    "tags": [
      "scanner",
      "code"
    ]
  },
  {
    "content": "## 12. Uncertainties and Questions for User\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Backend (Python/FastAPI)::12. Uncertainties and Questions for User",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Backend (Python/FastAPI)",
      "12. Uncertainties and Questions for User"
    ],
    "metadata": {
      "level": 2,
      "heading": "12. Uncertainties and Questions for User"
    },
    "tags": []
  },
  {
    "content": "### Questions Requiring Clarification\n\n1. **Scanner Architecture Preference**:\n   - Should new scanners be V31 class-based or standalone scripts?\n   - Is there a performance requirement that dictates the choice?\n\n2. **Backtest Fidelity**:\n   - Should backtests use simple P&L simulation or enhanced intraday simulation?\n   - What level of accuracy is required for decision-making?\n\n3. **Parameter Management**:\n   - Should parameters be stored in code, database, or configuration files?\n   - How should parameter versioning be handled?\n\n4. **Error Handling**:\n   - Should scanners fail fast or gracefully handle errors?\n   - What level of logging is required in production?\n\n5. **Testing Requirements**:\n   - Should all scanners have automated tests?\n   - What test coverage percentage is required?\n\n6. **Performance Benchmarks**:\n   - What are the acceptable execution times for different scanner types?\n   - How many symbols can be scanned in a single execution?\n\n7. **Data Quality**:\n   - How should missing or corrupted data be handled?\n   - What data validation checks should be in place?\n\n8. **Integration Points**:\n   - Are there specific API endpoints that must be used?\n   - How should results be formatted for frontend consumption?\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Backend (Python/FastAPI)::12. Uncertainties and Questions for User::Questions Requiring Clarification",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Backend (Python/FastAPI)",
      "12. Uncertainties and Questions for User",
      "Questions Requiring Clarification"
    ],
    "metadata": {
      "level": 3,
      "heading": "Questions Requiring Clarification"
    },
    "tags": [
      "scanner",
      "backtest",
      "strategy",
      "v31",
      "code",
      "execution"
    ]
  },
  {
    "content": "## 13. Recommendations\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Backend (Python/FastAPI)::13. Recommendations",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Backend (Python/FastAPI)",
      "13. Recommendations"
    ],
    "metadata": {
      "level": 2,
      "heading": "13. Recommendations"
    },
    "tags": []
  },
  {
    "content": "### For New Scanner Development\n\n1. **Start with V31 class-based architecture** for production scanners\n2. **Use standalone scripts** for simple prototypes and testing\n3. **Implement all 5 stages** for optimal performance\n4. **Follow the validation checklists** before deployment\n5. **Test with small datasets first**, then scale up\n6. **Document parameters** and their effects\n7. **Use version control** for scanner iterations\n8. **Monitor performance** in production\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Backend (Python/FastAPI)::13. Recommendations::For New Scanner Development",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Backend (Python/FastAPI)",
      "13. Recommendations",
      "For New Scanner Development"
    ],
    "metadata": {
      "level": 3,
      "heading": "For New Scanner Development"
    },
    "tags": [
      "scanner",
      "backtest",
      "v31",
      "pyramiding"
    ]
  },
  {
    "content": "### For Backtest Development\n\n1. **Start with simple P&L simulation** for validation\n2. **Add intraday simulation** for accuracy when needed\n3. **Calculate all required metrics** consistently\n4. **Handle edge cases** (no trades, extreme values)\n5. **Document assumptions** (slippage, commissions, etc.)\n6. **Validate against real trades** when possible\n7. **Track performance over time**\n8. **Compare strategies** using consistent metrics\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Backend (Python/FastAPI)::13. Recommendations::For Backtest Development",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Backend (Python/FastAPI)",
      "13. Recommendations",
      "For Backtest Development"
    ],
    "metadata": {
      "level": 3,
      "heading": "For Backtest Development"
    },
    "tags": [
      "backtest",
      "indicator"
    ]
  },
  {
    "content": "### For Code Quality\n\n1. **Follow PEP 8** style guidelines\n2. **Add type hints** for all functions\n3. **Write docstrings** for all classes and functions\n4. **Handle exceptions** gracefully\n5. **Log progress** and errors\n6. **Use constants** instead of magic numbers\n7. **Validate inputs** (parameters, data)\n8. **Write tests** for critical logic\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Backend (Python/FastAPI)::13. Recommendations::For Code Quality",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Backend (Python/FastAPI)",
      "13. Recommendations",
      "For Code Quality"
    ],
    "metadata": {
      "level": 3,
      "heading": "For Code Quality"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "## Conclusion\n\nThis research document provides a comprehensive overview of the EdgeDev codebase patterns and standards. The \"presumed gold standard\" is based on analysis of production code, working scanners, and established patterns.\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Backend (Python/FastAPI)::Conclusion",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Backend (Python/FastAPI)",
      "Conclusion"
    ],
    "metadata": {
      "level": 2,
      "heading": "Conclusion"
    },
    "tags": [
      "scanner",
      "pattern",
      "code"
    ]
  },
  {
    "content": "### Key Takeaways\n\n1. **V31 architecture is the modern standard** - 360x faster, scalable, maintainable\n2. **Backside B pattern is most battle-tested** - 75+ variants, proven results\n3. **Two-pass computation is critical** - Simple features \u2192 Filter \u2192 Full features\n4. **Per-ticker operations are mandatory** - Correctness depends on it\n5. **Historical data preservation is essential** - ABS window needs 1000+ days\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Backend (Python/FastAPI)::Conclusion::Key Takeaways",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Backend (Python/FastAPI)",
      "Conclusion",
      "Key Takeaways"
    ],
    "metadata": {
      "level": 3,
      "heading": "Key Takeaways"
    },
    "tags": [
      "pattern",
      "v31"
    ]
  },
  {
    "content": "### Next Steps\n\n1. Review this document with stakeholders\n2. Clarify uncertainties and questions\n3. Validate assumptions with team\n4. Create implementation guides based on this research\n5. Establish code review standards\n6. Develop automated validation tools\n\n---\n\n**Document Status**: RESEARCH COMPLETE\n**Last Updated**: 2026-01-29\n**Version**: 1.0\n**Author**: Claude (Research Agent)\n**Reviewed By**: [PENDING]\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Backend (Python/FastAPI)::Conclusion::Next Steps",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Backend (Python/FastAPI)",
      "Conclusion",
      "Next Steps"
    ],
    "metadata": {
      "level": 3,
      "heading": "Next Steps"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "## Appendix A: File References\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Backend (Python/FastAPI)::Appendix A: File References",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Backend (Python/FastAPI)",
      "Appendix A: File References"
    ],
    "metadata": {
      "level": 2,
      "heading": "Appendix A: File References"
    },
    "tags": []
  },
  {
    "content": "### Key Specification Documents\n- `/projects/edge-dev-main/V31_GOLD_STANDARD_SPECIFICATION.md` - Complete V31 specification\n- `/projects/edge-dev-main/V31_QUICK_REFERENCE.md` - Quick reference card\n- `/projects/edge-dev-main/MASTER_UNIFIED_SCANNER_TEMPLATE.py` - Template code\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Backend (Python/FastAPI)::Appendix A: File References::Key Specification Documents",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Backend (Python/FastAPI)",
      "Appendix A: File References",
      "Key Specification Documents"
    ],
    "metadata": {
      "level": 3,
      "heading": "Key Specification Documents"
    },
    "tags": [
      "scanner",
      "v31",
      "code"
    ]
  },
  {
    "content": "### Working Scanner Examples\n- `/projects/edge-dev-main/backend/SIMPLE_TEST_SCANNER.py` - Simple test scanner\n- `/projects/edge-dev-main/backend/optimized_backside_b_scanner.py` - Optimized Backside B\n- `/projects/edge-dev-main/backend/proven_backside_scanner.py` - Proven working scanner\n- `/projects/edge-dev-main/backend/fixed_backside_b_scanner.py` - Fixed version\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Backend (Python/FastAPI)::Appendix A: File References::Working Scanner Examples",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "example",
    "heading_path": [
      "Backend (Python/FastAPI)",
      "Appendix A: File References",
      "Working Scanner Examples"
    ],
    "metadata": {
      "level": 3,
      "heading": "Working Scanner Examples"
    },
    "tags": [
      "scanner",
      "optimization"
    ]
  },
  {
    "content": "### Backtest Engines\n- `/projects/edge-dev-main/src/utils/backtest_script.py` - Simple backtest\n- `/projects/edge-dev-main/src/utils/enhanced_backtest_engine.py` - Enhanced backtest\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Backend (Python/FastAPI)::Appendix A: File References::Backtest Engines",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Backend (Python/FastAPI)",
      "Appendix A: File References",
      "Backtest Engines"
    ],
    "metadata": {
      "level": 3,
      "heading": "Backtest Engines"
    },
    "tags": [
      "backtest"
    ]
  },
  {
    "content": "### Type Definitions\n- `/projects/edge-dev-main/src/types/projectTypes.ts` - TypeScript types\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Backend (Python/FastAPI)::Appendix A: File References::Type Definitions",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Backend (Python/FastAPI)",
      "Appendix A: File References",
      "Type Definitions"
    ],
    "metadata": {
      "level": 3,
      "heading": "Type Definitions"
    },
    "tags": []
  },
  {
    "content": "## Appendix B: Parameter Reference\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Backend (Python/FastAPI)::Appendix B: Parameter Reference",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Backend (Python/FastAPI)",
      "Appendix B: Parameter Reference"
    ],
    "metadata": {
      "level": 2,
      "heading": "Appendix B: Parameter Reference"
    },
    "tags": []
  },
  {
    "content": "### Common Parameter Categories\n\n**Market Filters**:\n- `price_min`: Minimum stock price (default: 8.0)\n- `adv20_min_usd`: Minimum 20-day average dollar volume (default: 30,000,000)\n- `volume_min`: Minimum daily volume (default: 1,000,000)\n\n**Technical Indicators**:\n- `atr_mult`: ATR multiplier (default: 0.9)\n- `vol_mult`: Volume multiplier (default: 0.9)\n- `ema_periods`: EMA periods to use (default: [9, 20, 50])\n\n**Pattern Specific**:\n- `abs_lookback_days`: Lookback for absolute position (default: 1000)\n- `gap_div_atr_min`: Minimum gap/ATR ratio (default: 0.75)\n- `open_over_ema9_min`: Minimum open/EMA9 ratio (default: 0.9)\n\n---\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Backend (Python/FastAPI)::Appendix B: Parameter Reference::Common Parameter Categories",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Backend (Python/FastAPI)",
      "Appendix B: Parameter Reference",
      "Common Parameter Categories"
    ],
    "metadata": {
      "level": 3,
      "heading": "Common Parameter Categories"
    },
    "tags": [
      "indicator",
      "pattern",
      "position"
    ]
  },
  {
    "content": "## Appendix C: Performance Benchmarks\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Backend (Python/FastAPI)::Appendix C: Performance Benchmarks",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Backend (Python/FastAPI)",
      "Appendix C: Performance Benchmarks"
    ],
    "metadata": {
      "level": 2,
      "heading": "Appendix C: Performance Benchmarks"
    },
    "tags": []
  },
  {
    "content": "### Scanner Execution Times\n\n| Scanner Type | Symbols | Date Range | Execution Time |\n|--------------|---------|------------|----------------|\n| V31 Class-Based | 100 | 1 year | 10-30 seconds |\n| V31 Class-Based | 1000 | 1 year | 30-60 seconds |\n| Standalone Script | 100 | 1 year | 2-5 minutes |\n| Standalone Script | 1000 | 1 year | 10-20 minutes |\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Backend (Python/FastAPI)::Appendix C: Performance Benchmarks::Scanner Execution Times",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Backend (Python/FastAPI)",
      "Appendix C: Performance Benchmarks",
      "Scanner Execution Times"
    ],
    "metadata": {
      "level": 3,
      "heading": "Scanner Execution Times"
    },
    "tags": [
      "scanner",
      "strategy",
      "v31",
      "execution"
    ]
  },
  {
    "content": "### Backtest Execution Times\n\n| Backtest Type | Trades | Intraday Data | Execution Time |\n|---------------|--------|---------------|----------------|\n| Simple P&L | 100 | No | <1 second |\n| Simple P&L | 1000 | No | 1-2 seconds |\n| Enhanced | 100 | Yes | 30-60 seconds |\n| Enhanced | 1000 | Yes | 5-10 minutes |\n\n---\n\n**END OF RESEARCH DOCUMENT**\n",
    "chunk_id": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md::Backend (Python/FastAPI)::Appendix C: Performance Benchmarks::Backtest Execution Times",
    "source_file": "EDGEDEV_PRESUMED_GOLD_STANDARD_SPECIFICATION.md",
    "chunk_type": "section",
    "heading_path": [
      "Backend (Python/FastAPI)",
      "Appendix C: Performance Benchmarks",
      "Backtest Execution Times"
    ],
    "metadata": {
      "level": 3,
      "heading": "Backtest Execution Times"
    },
    "tags": [
      "backtest",
      "strategy",
      "execution"
    ]
  },
  {
    "content": "# EdgeDev Pattern Type Catalog\n**Comprehensive Guide to Different Trading Pattern Approaches**\n\n**Purpose**: Document ALL pattern types used in EdgeDev, not just Backside B variants.\n\n**Research Date**: 2026-01-29\n**Status**: COMPLETE - Pattern Diversity Analysis\n\n---\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::EdgeDev Pattern Type Catalog",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Pattern Type Catalog"
    ],
    "metadata": {
      "level": 1,
      "heading": "EdgeDev Pattern Type Catalog"
    },
    "tags": [
      "strategy",
      "pattern"
    ]
  },
  {
    "content": "## Table of Contents\n\n1. [Pattern Type Matrix](#pattern-type-matrix)\n2. [Multi-Day Momentum (DMR)](#1-multi-day-momentum-dmr)\n3. [Fade Breakout (FBO)](#2-fade-breakout-fbo)\n4. [Extension Gaps](#3-extension-gaps)\n5. [Parabolic Extensions (Daily Para)](#4-parabolic-extensions-daily-para)\n6. [Frontside Extensions (FRD)](#5-frontside-extensions-frd)\n7. [3-Day Trigger (LC 3 Day)](#6-3-day-trigger-lc-3-day)\n8. [Code Structure Comparison](#code-structure-comparison)\n9. [Parameter System Patterns](#parameter-system-patterns)\n10. [When to Use Which Pattern](#when-to-use-which-pattern)\n\n---\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::EdgeDev Pattern Type Catalog::Table of Contents",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Pattern Type Catalog",
      "Table of Contents"
    ],
    "metadata": {
      "level": 2,
      "heading": "Table of Contents"
    },
    "tags": [
      "pattern",
      "code"
    ]
  },
  {
    "content": "## Pattern Type Matrix\n\n| Pattern Type | Direction | Time Horizon | Core Logic | Complexity |\n|--------------|----------|--------------|-------------|------------|\n| **DMR** | Long | Multi-day (D2-D4) | Trigger high \u2192 continuation | High |\n| **FBO** | Short | 1-2 days | Gap into resistance \u2192 fade | High |\n| **Extension Gap** | Long | Daily | Extended move \u2192 gap continuation | Medium |\n| **Daily Para** | Long | Daily | Parabolic extension \u2192 continuation | Medium |\n| **FRD EXT Gap** | Long | Daily | Frontside extension + gap | Medium |\n| **LC 3d Gap** | Long | Daily | 3-day gap setup | Low |\n| **Backside B** | Short | Daily | Gap up \u2192 hold high \u2192 fade | Medium |\n\n**Key Insight**: Each pattern type targets a DIFFERENT market condition and behavior.\n\n---\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::EdgeDev Pattern Type Catalog::Pattern Type Matrix",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Pattern Type Catalog",
      "Pattern Type Matrix"
    ],
    "metadata": {
      "level": 2,
      "heading": "Pattern Type Matrix"
    },
    "tags": [
      "pattern"
    ]
  },
  {
    "content": "## 1. Multi-Day Momentum (DMR)\n\n**File**: `SC DMR SCAN.py`\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::EdgeDev Pattern Type Catalog::1. Multi-Day Momentum (DMR)",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Pattern Type Catalog",
      "1. Multi-Day Momentum (DMR)"
    ],
    "metadata": {
      "level": 2,
      "heading": "1. Multi-Day Momentum (DMR)"
    },
    "tags": [
      "scanner"
    ]
  },
  {
    "content": "### What It Is\nMulti-day setup where a strong trigger high is followed by continuation patterns over 2-4 days.\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::EdgeDev Pattern Type Catalog::1. Multi-Day Momentum (DMR)::What It Is",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Pattern Type Catalog",
      "1. Multi-Day Momentum (DMR)",
      "What It Is"
    ],
    "metadata": {
      "level": 3,
      "heading": "What It Is"
    },
    "tags": [
      "pattern"
    ]
  },
  {
    "content": "### Core Logic\n```\nD-10 to D-2: Strong uptrend, forming a \"trigger high\"\nD-1: Consolidation or pause\nD0: Gap open + continuation trigger\n```\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::EdgeDev Pattern Type Catalog::1. Multi-Day Momentum (DMR)::Core Logic",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Pattern Type Catalog",
      "1. Multi-Day Momentum (DMR)",
      "Core Logic"
    ],
    "metadata": {
      "level": 3,
      "heading": "Core Logic"
    },
    "tags": []
  },
  {
    "content": "### Key Parameters\n```python",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::EdgeDev Pattern Type Catalog::1. Multi-Day Momentum (DMR)::Key Parameters",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Pattern Type Catalog",
      "1. Multi-Day Momentum (DMR)",
      "Key Parameters"
    ],
    "metadata": {
      "level": 3,
      "heading": "Key Parameters"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# Trigger high validation\nvalid_trig_high = (\n    prev_high >= prev_high_2 and\n    prev_high >= prev_high_3 and\n    ...\n    prev_high >= prev_high_10  # Highest in last 10 periods\n)\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Trigger high validation",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Trigger high validation"
    ],
    "metadata": {
      "level": 1,
      "heading": "Trigger high validation"
    },
    "tags": []
  },
  {
    "content": "# Pre-market gap\ndol_pmh_gap >= prev_range * 0.5\npct_pmh_gap >= 0.5  # 0.5% gap in pre-market\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Pre-market gap",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Pre-market gap"
    ],
    "metadata": {
      "level": 1,
      "heading": "Pre-market gap"
    },
    "tags": []
  },
  {
    "content": "# D0 continuation\ngap >= 0.2  # At least 0.2% gap\ndol_gap >= prev_range * 0.3\n```\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::D0 continuation",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "D0 continuation"
    ],
    "metadata": {
      "level": 1,
      "heading": "D0 continuation"
    },
    "tags": []
  },
  {
    "content": "### Setup Variants\n1. **D2 PM Setup**: Parabolic move + pre-market gap\n2. **D2 PMH Break**: Gap + trade through pre-market high\n3. **D2 No PMH Break**: Gap + don't trade PMH\n4. **D2 Extreme Gap**: Massive gap (>1x range)\n5. **D3**: Two days of strong moves\n6. **D4**: Three days of strong moves\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::D0 continuation::Setup Variants",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "D0 continuation",
      "Setup Variants"
    ],
    "metadata": {
      "level": 3,
      "heading": "Setup Variants"
    },
    "tags": [
      "pattern"
    ]
  },
  {
    "content": "### When to Use\n- **Market Condition**: Strong momentum markets\n- **Stock Type**: High beta, high volatility\n- **Volatility**: Expansion periods\n- **Timeframe**: Bull markets, strong uptrends\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::D0 continuation::Setup Variants::When to Use",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "D0 continuation",
      "Setup Variants",
      "When to Use"
    ],
    "metadata": {
      "level": 3,
      "heading": "When to Use"
    },
    "tags": []
  },
  {
    "content": "### What Makes It Unique\n- **Multi-day persistence**: Not just a 1-day setup\n- **Trigger high validation**: Must be THE high in a window\n- **Pre-market analysis**: Uses PM data for confirmation\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::D0 continuation::Setup Variants::What Makes It Unique",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "D0 continuation",
      "Setup Variants",
      "What Makes It Unique"
    ],
    "metadata": {
      "level": 3,
      "heading": "What Makes It Unique"
    },
    "tags": [
      "pattern"
    ]
  },
  {
    "content": "### Code Structure\n```python",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::D0 continuation::Setup Variants::Code Structure",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "D0 continuation",
      "Setup Variants",
      "Code Structure"
    ],
    "metadata": {
      "level": 3,
      "heading": "Code Structure"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# Step 1: Calculate valid trigger high\ndf['valid_trig_high'] = (\n    df['prev_high'] >= df['prev_high_2'] &  # Highest of last 10\n    df['prev_high'] >= df['prev_high_3'] &\n    ...\n    df['prev_high'] >= df['prev_high_10']\n)\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Step 1: Calculate valid trigger high",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Step 1: Calculate valid trigger high"
    ],
    "metadata": {
      "level": 1,
      "heading": "Step 1: Calculate valid trigger high"
    },
    "tags": []
  },
  {
    "content": "# Step 2: Calculate pre-market gap\ndf['dol_pmh_gap'] = df['pm_high'] - df['prev_close']\ndf['pct_pmh_gap'] = df['pm_high'] / df['prev_close'] - 1\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Step 2: Calculate pre-market gap",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Step 2: Calculate pre-market gap"
    ],
    "metadata": {
      "level": 1,
      "heading": "Step 2: Calculate pre-market gap"
    },
    "tags": []
  },
  {
    "content": "# Step 3: Pattern-specific conditions\ndf['d2_pm_setup'] = (\n    df['valid_trig_high'] &\n    (df['prev_high'] / df['prev_close_1'] - 1) >= 1 &  # Doubled\n    df['dol_pmh_gap'] >= df['prev_range'] * 0.5 &\n    df['prev_close_range'] >= 0.5 &  # Strong D-1\n    df['prev_close'] >= df['prev_open']  # Green D-1\n)\n```\n\n---\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Step 3: Pattern-specific conditions",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Step 3: Pattern-specific conditions"
    ],
    "metadata": {
      "level": 1,
      "heading": "Step 3: Pattern-specific conditions"
    },
    "tags": [
      "pattern"
    ]
  },
  {
    "content": "## 2. Fade Breakout (FBO)\n\n**File**: `daily fbo/mold 1 scan.py`\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Step 3: Pattern-specific conditions::2. Fade Breakout (FBO)",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Step 3: Pattern-specific conditions",
      "2. Fade Breakout (FBO)"
    ],
    "metadata": {
      "level": 2,
      "heading": "2. Fade Breakout (FBO)"
    },
    "tags": [
      "scanner"
    ]
  },
  {
    "content": "### What It Is\nFades a gap-up INTO resistance. The logic is: stock gaps up toward a significant high, then fades.\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Step 3: Pattern-specific conditions::2. Fade Breakout (FBO)::What It Is",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Step 3: Pattern-specific conditions",
      "2. Fade Breakout (FBO)",
      "What It Is"
    ],
    "metadata": {
      "level": 3,
      "heading": "What It Is"
    },
    "tags": []
  },
  {
    "content": "### Core Logic\n```\nHistorical (1000 days): Find significant high\nBetween (level date \u2192 D0): Pullback required\nD0: Gap UP toward level \u2192 Touch/fade \u2192 Short signal\n```\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Step 3: Pattern-specific conditions::2. Fade Breakout (FBO)::Core Logic",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Step 3: Pattern-specific conditions",
      "2. Fade Breakout (FBO)",
      "Core Logic"
    ],
    "metadata": {
      "level": 3,
      "heading": "Core Logic"
    },
    "tags": [
      "indicator"
    ]
  },
  {
    "content": "### Key Parameters\n```python",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Step 3: Pattern-specific conditions::2. Fade Breakout (FBO)::Key Parameters",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Step 3: Pattern-specific conditions",
      "2. Fade Breakout (FBO)",
      "Key Parameters"
    ],
    "metadata": {
      "level": 3,
      "heading": "Key Parameters"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# Level selection\nlookback_days_for_level = 1000  # Look back 1000 days\nsig_require_pivot = True  # Level must be pivot high\nsig_level_pos_abs_min = 0.85  # In top 15% of range\nsig_prom_atr_min = 1.5  # Prominence vs valleys\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Level selection",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Level selection"
    ],
    "metadata": {
      "level": 1,
      "heading": "Level selection"
    },
    "tags": []
  },
  {
    "content": "# D0 gap conditions\ngap_min_pct = 2.0  # Must gap at least 2%\ntouch_tol_pct = 1.0  # Within 1% of level counts\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::D0 gap conditions",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "D0 gap conditions"
    ],
    "metadata": {
      "level": 1,
      "heading": "D0 gap conditions"
    },
    "tags": []
  },
  {
    "content": "# Pullback between\nmin_low_pullback_min_pct = 10.0  # Must pull back 10% from level\n```\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Pullback between",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Pullback between"
    ],
    "metadata": {
      "level": 1,
      "heading": "Pullback between"
    },
    "tags": []
  },
  {
    "content": "### Significance Metrics\n```python",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Pullback between::Significance Metrics",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Pullback between",
      "Significance Metrics"
    ],
    "metadata": {
      "level": 3,
      "heading": "Significance Metrics"
    },
    "tags": [
      "indicator",
      "code"
    ]
  },
  {
    "content": "# Where is level in absolute range?\nLevelPosAbs = (level - abs_low) / (abs_top - abs_low)\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Where is level in absolute range?",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Where is level in absolute range?"
    ],
    "metadata": {
      "level": 1,
      "heading": "Where is level in absolute range?"
    },
    "tags": []
  },
  {
    "content": "# What % of absolute high?\nLevelPctOfTop = level / abs_top\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::What % of absolute high?",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "What % of absolute high?"
    ],
    "metadata": {
      "level": 1,
      "heading": "What % of absolute high?"
    },
    "tags": []
  },
  {
    "content": "# Is this a real pivot high?\nIsPivotHigh = level is higher than surrounding highs\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Is this a real pivot high?",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Is this a real pivot high?"
    ],
    "metadata": {
      "level": 1,
      "heading": "Is this a real pivot high?"
    },
    "tags": []
  },
  {
    "content": "# How prominent vs local valleys?\nLevelPivotProm_ATR = (level - local_valley) / ATR\n```\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::How prominent vs local valleys?",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "How prominent vs local valleys?"
    ],
    "metadata": {
      "level": 1,
      "heading": "How prominent vs local valleys?"
    },
    "tags": []
  },
  {
    "content": "### When to Use\n- **Market Condition**: Choppy, range-bound markets\n- **Stock Type: Names hitting resistance\n- **Volatility**: Low to medium\n- **Timeframe**: Any, but best in ranging markets\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::How prominent vs local valleys?::When to Use",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "How prominent vs local valleys?",
      "When to Use"
    ],
    "metadata": {
      "level": 3,
      "heading": "When to Use"
    },
    "tags": []
  },
  {
    "content": "### What Makes It Unique\n- **Historical level validation**: Uses 1000-day lookback\n- **Pivot detection**: Level must be technically significant\n- **Pullback requirement**: Must pull away from level first\n- **Direction**: SHORT (unlike most others)\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::How prominent vs local valleys?::When to Use::What Makes It Unique",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "How prominent vs local valleys?",
      "When to Use",
      "What Makes It Unique"
    ],
    "metadata": {
      "level": 3,
      "heading": "What Makes It Unique"
    },
    "tags": []
  },
  {
    "content": "### Code Structure\n```python",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::How prominent vs local valleys?::When to Use::Code Structure",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "How prominent vs local valleys?",
      "When to Use",
      "Code Structure"
    ],
    "metadata": {
      "level": 3,
      "heading": "Code Structure"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# Step 1: Find significant high\ndef pick_level_date(m, d0, p):\n    # Look back 1000 days\n    prior = m[(m.index >= d0 - timedelta(days=1000)) & (m.index < d0)]\n\n    # Find pivot highs\n    pivots = _pivot_high_dates(prior, left=3, right=3)\n\n    # Prefer pivot, fallback to max\n    if pivots:\n        return last_occurrence_of_max(prior.loc[pivots][\"High\"])\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Step 1: Find significant high",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Step 1: Find significant high"
    ],
    "metadata": {
      "level": 1,
      "heading": "Step 1: Find significant high"
    },
    "tags": []
  },
  {
    "content": "# Step 2: Validate significance\nsig = significance_metrics(m, level_date, d0, p)",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Step 2: Validate significance",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Step 2: Validate significance"
    ],
    "metadata": {
      "level": 1,
      "heading": "Step 2: Validate significance"
    },
    "tags": [
      "indicator"
    ]
  },
  {
    "content": "# Returns: LevelPosAbs, IsPivotHigh, LevelPivotProm_ATR, etc.\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Returns: LevelPosAbs, IsPivotHigh, LevelPivotProm_ATR, etc.",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Returns: LevelPosAbs, IsPivotHigh, LevelPivotProm_ATR, etc."
    ],
    "metadata": {
      "level": 1,
      "heading": "Returns: LevelPosAbs, IsPivotHigh, LevelPivotProm_ATR, etc."
    },
    "tags": []
  },
  {
    "content": "# Step 3: Check D0 gap toward level\ngap_pct = (open - prev_close) / prev_close * 100\ntouch_pct = (open - level) / level * 100  # How close to level?\n```\n\n---\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Step 3: Check D0 gap toward level",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Step 3: Check D0 gap toward level"
    ],
    "metadata": {
      "level": 1,
      "heading": "Step 3: Check D0 gap toward level"
    },
    "tags": []
  },
  {
    "content": "## 3. Extension Gaps\n\n**File**: `LC 3d Gap/scan.py`\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Step 3: Check D0 gap toward level::3. Extension Gaps",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Step 3: Check D0 gap toward level",
      "3. Extension Gaps"
    ],
    "metadata": {
      "level": 2,
      "heading": "3. Extension Gaps"
    },
    "tags": [
      "scanner"
    ]
  },
  {
    "content": "### What It Is\nGaps that occur AFTER an extended move (not reversal gaps, continuation gaps).\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Step 3: Check D0 gap toward level::3. Extension Gaps::What It Is",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Step 3: Check D0 gap toward level",
      "3. Extension Gaps",
      "What It Is"
    ],
    "metadata": {
      "level": 3,
      "heading": "What It Is"
    },
    "tags": []
  },
  {
    "content": "### Core Logic\n```\nD-65 to D-5: Extended uptrend (measured by EMA distance)\nD-2: Strong push higher\nD-1: New high (swing high)\nD0: Gap open \u2192 continuation\n```\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Step 3: Check D0 gap toward level::3. Extension Gaps::Core Logic",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Step 3: Check D0 gap toward level",
      "3. Extension Gaps",
      "Core Logic"
    ],
    "metadata": {
      "level": 3,
      "heading": "Core Logic"
    },
    "tags": []
  },
  {
    "content": "### Key Parameters\n```python",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Step 3: Check D0 gap toward level::3. Extension Gaps::Key Parameters",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Step 3: Check D0 gap toward level",
      "3. Extension Gaps",
      "Key Parameters"
    ],
    "metadata": {
      "level": 3,
      "heading": "Key Parameters"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# EMA distance (as multiple of ATR)\nday_14_avg_ema_10 >= 0.25  # Extended over 14 days\nday_7_avg_ema_10 >= 0.25   # Extended over 7 days\nday_3_avg_ema_10 >= 0.5    # Recently extended\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::EMA distance (as multiple of ATR)",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "EMA distance (as multiple of ATR)"
    ],
    "metadata": {
      "level": 1,
      "heading": "EMA distance (as multiple of ATR)"
    },
    "tags": []
  },
  {
    "content": "# D-1 strength\nday_1_ema_distance_10 >= 1.5  # High is 1.5x ATR above EMA\nday_1_ema_distance_30 >= 3.0  # High is 3x ATR above EMA\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::D-1 strength",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "D-1 strength"
    ],
    "metadata": {
      "level": 1,
      "heading": "D-1 strength"
    },
    "tags": []
  },
  {
    "content": "# Gap requirements\nday_0_gap >= 0.5 * ATR  # Gap at least half ATR\n```\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Gap requirements",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Gap requirements"
    ],
    "metadata": {
      "level": 1,
      "heading": "Gap requirements"
    },
    "tags": []
  },
  {
    "content": "### Swing High Detection\n```python\ndef calculate_swing_high(data, start_offset, end_offset):\n    \"\"\"\n    Find highest high that is surrounded by lower highs.\n\n    A swing high is a local maximum.\n    \"\"\"\n    swing_highs = []\n\n    for i in range(1, len(range_data) - 1):\n        if (curr_high > prev_high and\n            curr_high > next_high):\n            swing_highs.append(curr_high)\n\n    return max(swing_highs)\n```\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Gap requirements::Swing High Detection",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Gap requirements",
      "Swing High Detection"
    ],
    "metadata": {
      "level": 3,
      "heading": "Swing High Detection"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "### When to Use\n- **Market Condition**: Trending markets with extended moves\n- **Stock Type**: Momentum names\n- **Volatility**: Medium to high\n- **Timeframe**: Bull markets\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Gap requirements::Swing High Detection::When to Use",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Gap requirements",
      "Swing High Detection",
      "When to Use"
    ],
    "metadata": {
      "level": 3,
      "heading": "When to Use"
    },
    "tags": []
  },
  {
    "content": "### What Makes It Unique\n- **Extension detection**: Measures how extended stock already is\n- **Multi-timeframe EMA**: Uses both 10 and 30 period EMAs\n- **Swing high validation**: Recent high must be \"real\"\n- **Gap continuation**: Gap is AFTER extension, not the start\n\n---\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Gap requirements::Swing High Detection::What Makes It Unique",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Gap requirements",
      "Swing High Detection",
      "What Makes It Unique"
    ],
    "metadata": {
      "level": 3,
      "heading": "What Makes It Unique"
    },
    "tags": []
  },
  {
    "content": "## 4. Parabolic Extensions (Daily Para)\n\n**File**: `Daily Para/other half a+ scan.py`\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Gap requirements::4. Parabolic Extensions (Daily Para)",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Gap requirements",
      "4. Parabolic Extensions (Daily Para)"
    ],
    "metadata": {
      "level": 2,
      "heading": "4. Parabolic Extensions (Daily Para)"
    },
    "tags": [
      "scanner"
    ]
  },
  {
    "content": "### What It Is\nParabolic move detection - stocks that are accelerating upward.\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Gap requirements::4. Parabolic Extensions (Daily Para)::What It Is",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Gap requirements",
      "4. Parabolic Extensions (Daily Para)",
      "What It Is"
    ],
    "metadata": {
      "level": 3,
      "heading": "What It Is"
    },
    "tags": []
  },
  {
    "content": "### Core Logic\n```\nD-50 to D-1: Accelerating uptrend\nD-1: Strong green candle\nD0: Gap open + continuation\n```\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Gap requirements::4. Parabolic Extensions (Daily Para)::Core Logic",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Gap requirements",
      "4. Parabolic Extensions (Daily Para)",
      "Core Logic"
    ],
    "metadata": {
      "level": 3,
      "heading": "Core Logic"
    },
    "tags": []
  },
  {
    "content": "### Key Parameters\n```python",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Gap requirements::4. Parabolic Extensions (Daily Para)::Key Parameters",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Gap requirements",
      "4. Parabolic Extensions (Daily Para)",
      "Key Parameters"
    ],
    "metadata": {
      "level": 3,
      "heading": "Key Parameters"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# Slope requirements (measured in %)\nslope3d_min = 10    # 3-day slope >= 10%\nslope5d_min = 20    # 5-day slope >= 20%\nslope15d_min = 40   # 15-day slope >= 40%\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Slope requirements (measured in %)",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Slope requirements (measured in %)"
    ],
    "metadata": {
      "level": 1,
      "heading": "Slope requirements (measured in %)"
    },
    "tags": []
  },
  {
    "content": "# Custom 50-day slope\nslope50d = (ema9[-4] - ema9[-50]) / ema9[-50] * 100\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Custom 50-day slope",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Custom 50-day slope"
    ],
    "metadata": {
      "level": 1,
      "heading": "Custom 50-day slope"
    },
    "tags": []
  },
  {
    "content": "# Gap requirements\ngap_div_atr_min = 0.5  # Gap >= 0.5x ATR\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Gap requirements",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Gap requirements"
    ],
    "metadata": {
      "level": 1,
      "heading": "Gap requirements"
    },
    "tags": []
  },
  {
    "content": "# Position within range\nupper_70_range >= 65  # Close in upper 70% of D-1 range\n```\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Position within range",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Position within range"
    ],
    "metadata": {
      "level": 1,
      "heading": "Position within range"
    },
    "tags": [
      "position"
    ]
  },
  {
    "content": "### Metrics\n```python",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Position within range::Metrics",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Position within range",
      "Metrics"
    ],
    "metadata": {
      "level": 3,
      "heading": "Metrics"
    },
    "tags": [
      "indicator",
      "code"
    ]
  },
  {
    "content": "# Slope = EMA change over time\nSlope_9_3d = (ema9 - ema9.shift(3)) / ema9.shift(3) * 100\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Slope = EMA change over time",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Slope = EMA change over time"
    ],
    "metadata": {
      "level": 1,
      "heading": "Slope = EMA change over time"
    },
    "tags": []
  },
  {
    "content": "# 50-day slope (custom window)\nSlope_9_4to50d = (ema9.shift(4) - ema9.shift(50)) / ema9.shift(50) * 100\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::50-day slope (custom window)",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "50-day slope (custom window)"
    ],
    "metadata": {
      "level": 1,
      "heading": "50-day slope (custom window)"
    },
    "tags": []
  },
  {
    "content": "# Gap vs ATR\ngap_div_atr = gap / (0.5 * atr)\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Gap vs ATR",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Gap vs ATR"
    ],
    "metadata": {
      "level": 1,
      "heading": "Gap vs ATR"
    },
    "tags": []
  },
  {
    "content": "# Close position in range\nupper_70_range = (close - low) / (high - low) * 100\n```\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Close position in range",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Close position in range"
    ],
    "metadata": {
      "level": 1,
      "heading": "Close position in range"
    },
    "tags": [
      "position"
    ]
  },
  {
    "content": "### When to Use\n- **Market Condition**: Meme stocks, speculative frenzies\n- **Stock Type**: High beta, small caps\n- **Volatility**: High\n- **Timeframe**: Speculative periods\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Close position in range::When to Use",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Close position in range",
      "When to Use"
    ],
    "metadata": {
      "level": 3,
      "heading": "When to Use"
    },
    "tags": []
  },
  {
    "content": "### What Makes It Unique\n- **Acceleration focus**: Measures rate of change, not just level\n- **Multiple slope windows**: 3d, 5d, 15d, 50d\n- **Upper range requirement**: Stock must close strong\n- **Parabolic detection**: Finds accelerating moves\n\n---\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Close position in range::When to Use::What Makes It Unique",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Close position in range",
      "When to Use",
      "What Makes It Unique"
    ],
    "metadata": {
      "level": 3,
      "heading": "What Makes It Unique"
    },
    "tags": []
  },
  {
    "content": "## 5. Frontside Extensions (FRD)\n\n**File**: `FRD EXT Gap/scan.py`\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Close position in range::5. Frontside Extensions (FRD)",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Close position in range",
      "5. Frontside Extensions (FRD)"
    ],
    "metadata": {
      "level": 2,
      "heading": "5. Frontside Extensions (FRD)"
    },
    "tags": [
      "scanner"
    ]
  },
  {
    "content": "### What It Is\n\"Frontside\" means the FIRST extended move before a consolidation or reversal.\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Close position in range::5. Frontside Extensions (FRD)::What It Is",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Close position in range",
      "5. Frontside Extensions (FRD)",
      "What It Is"
    ],
    "metadata": {
      "level": 3,
      "heading": "What It Is"
    },
    "tags": []
  },
  {
    "content": "### Core Logic\n```\nHistorical: Stock in downtrend or consolidation\nRecent: Frontside breakout begins\nD0: Gap confirms frontside extension\n```\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Close position in range::5. Frontside Extensions (FRD)::Core Logic",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Close position in range",
      "5. Frontside Extensions (FRD)",
      "Core Logic"
    ],
    "metadata": {
      "level": 3,
      "heading": "Core Logic"
    },
    "tags": []
  },
  {
    "content": "### Key Concept\n- **Frontside** = First leg up after downtrend/consolidation\n- **Backside** = Parabolic extension after already extended\n- **FRD** = Frontside detection\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Close position in range::5. Frontside Extensions (FRD)::Key Concept",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Close position in range",
      "5. Frontside Extensions (FRD)",
      "Key Concept"
    ],
    "metadata": {
      "level": 3,
      "heading": "Key Concept"
    },
    "tags": []
  },
  {
    "content": "### Key Parameters\n```python",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Close position in range::5. Frontside Extensions (FRD)::Key Parameters",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Close position in range",
      "5. Frontside Extensions (FRD)",
      "Key Parameters"
    ],
    "metadata": {
      "level": 3,
      "heading": "Key Parameters"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# EMA distance thresholds\nhigh_to_ema9_div_atr >= 1.75   # Breaking out\nhigh_to_ema30_div_atr >= 4.0    # Clear of long-term MA\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::EMA distance thresholds",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "EMA distance thresholds"
    ],
    "metadata": {
      "level": 1,
      "heading": "EMA distance thresholds"
    },
    "tags": []
  },
  {
    "content": "# % change vs ATR\npct_change_7d_div_atr >= 2     # 7-day move >= 2x ATR\npct_change_14d_div_atr >= 3.5  # 14-day move >= 3.5x ATR\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::% change vs ATR",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "% change vs ATR"
    ],
    "metadata": {
      "level": 1,
      "heading": "% change vs ATR"
    },
    "tags": []
  },
  {
    "content": "# Gap requirements\ngap_div_atr >= 2  # Gap >= 2x ATR (very large gap)\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Gap requirements",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Gap requirements"
    ],
    "metadata": {
      "level": 1,
      "heading": "Gap requirements"
    },
    "tags": []
  },
  {
    "content": "# Close position\nupper_70_range >= 65  # Strong close\n```\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Close position",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Close position"
    ],
    "metadata": {
      "level": 1,
      "heading": "Close position"
    },
    "tags": [
      "position"
    ]
  },
  {
    "content": "### When to Use\n- **Market Condition**: Reversal from downtrend\n- **Stock Type**: Value names breaking out\n- **Volatility**: Low to medium (then increases)\n- **Timeframe**: Bottoming process\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Close position::When to Use",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Close position",
      "When to Use"
    ],
    "metadata": {
      "level": 3,
      "heading": "When to Use"
    },
    "tags": []
  },
  {
    "content": "### What Makes It Unique\n- **Reversal detection**: Finds first leg up, not continuation\n- **Large gap requirement**: Gap must be >= 2x ATR\n- **Multiple timeframes**: 7d, 14d momentum validation\n- **EMA break**: Clear of long-term moving averages\n\n---\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Close position::When to Use::What Makes It Unique",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Close position",
      "When to Use",
      "What Makes It Unique"
    ],
    "metadata": {
      "level": 3,
      "heading": "What Makes It Unique"
    },
    "tags": []
  },
  {
    "content": "## 6. 3-Day Trigger (LC 3 Day)\n\n**File**: `LC 3 Day Trig/scan.py` (referenced)\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Close position::6. 3-Day Trigger (LC 3 Day)",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Close position",
      "6. 3-Day Trigger (LC 3 Day)"
    ],
    "metadata": {
      "level": 2,
      "heading": "6. 3-Day Trigger (LC 3 Day)"
    },
    "tags": [
      "scanner"
    ]
  },
  {
    "content": "### What It Is\nSimple 3-day pattern setup with gap trigger.\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Close position::6. 3-Day Trigger (LC 3 Day)::What It Is",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Close position",
      "6. 3-Day Trigger (LC 3 Day)",
      "What It Is"
    ],
    "metadata": {
      "level": 3,
      "heading": "What It Is"
    },
    "tags": [
      "pattern"
    ]
  },
  {
    "content": "### Core Logic\n```\nD-3: Setup begins\nD-2: Continued setup\nD-1: Preparation\nD0: Gap triggers entry\n```\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Close position::6. 3-Day Trigger (LC 3 Day)::Core Logic",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Close position",
      "6. 3-Day Trigger (LC 3 Day)",
      "Core Logic"
    ],
    "metadata": {
      "level": 3,
      "heading": "Core Logic"
    },
    "tags": [
      "pattern"
    ]
  },
  {
    "content": "### When to Use\n- **Market Condition**: Any\n- **Complexity**: Simple pattern for quick testing\n- **Learning**: Good for understanding basics\n\n---\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Close position::6. 3-Day Trigger (LC 3 Day)::When to Use",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Close position",
      "6. 3-Day Trigger (LC 3 Day)",
      "When to Use"
    ],
    "metadata": {
      "level": 3,
      "heading": "When to Use"
    },
    "tags": [
      "backtest",
      "pattern"
    ]
  },
  {
    "content": "## Code Structure Comparison\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Close position::Code Structure Comparison",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Close position",
      "Code Structure Comparison"
    ],
    "metadata": {
      "level": 2,
      "heading": "Code Structure Comparison"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "### Pattern A: Multi-Pattern Scanner (DMR-style)\n\n```python",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Close position::Code Structure Comparison::Pattern A: Multi-Pattern Scanner (DMR-style)",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Close position",
      "Code Structure Comparison",
      "Pattern A: Multi-Pattern Scanner (DMR-style)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Pattern A: Multi-Pattern Scanner (DMR-style)"
    },
    "tags": [
      "scanner",
      "pattern",
      "code"
    ]
  },
  {
    "content": "# Structure: Single pass, multiple pattern flags\nfor i, row in df.iterrows():\n    df['d2_pm_setup'] = condition_set_1\n    df['d2_pmh_break'] = condition_set_2\n    df['d3'] = condition_set_3\n    df['d4'] = condition_set_4\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Structure: Single pass, multiple pattern flags",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Structure: Single pass, multiple pattern flags"
    ],
    "metadata": {
      "level": 1,
      "heading": "Structure: Single pass, multiple pattern flags"
    },
    "tags": [
      "pattern"
    ]
  },
  {
    "content": "# Output: One row per ticker per day, multiple True/False flags\n```\n\n**Pros**: Efficient single pass\n**Cons**: Complex logic, harder to debug\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Output: One row per ticker per day, multiple True/False flags",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Output: One row per ticker per day, multiple True/False flags"
    ],
    "metadata": {
      "level": 1,
      "heading": "Output: One row per ticker per day, multiple True/False flags"
    },
    "tags": []
  },
  {
    "content": "### Pattern B: Single Pattern Per File\n\n```python",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Output: One row per ticker per day, multiple True/False flags::Pattern B: Single Pattern Per File",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Output: One row per ticker per day, multiple True/False flags",
      "Pattern B: Single Pattern Per File"
    ],
    "metadata": {
      "level": 3,
      "heading": "Pattern B: Single Pattern Per File"
    },
    "tags": [
      "pattern",
      "code"
    ]
  },
  {
    "content": "# Structure: One pattern, simple logic\nfor symbol in symbols:\n    if condition_met:\n        results.append({\n            'ticker': symbol,\n            'date': date,\n            'setup_type': 'FBO'\n        })\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Structure: One pattern, simple logic",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Structure: One pattern, simple logic"
    ],
    "metadata": {
      "level": 1,
      "heading": "Structure: One pattern, simple logic"
    },
    "tags": [
      "pattern"
    ]
  },
  {
    "content": "# Output: List of setups found\n```\n\n**Pros**: Simple, easy to debug\n**Cons**: Inefficient for multiple patterns\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Output: List of setups found",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Output: List of setups found"
    ],
    "metadata": {
      "level": 1,
      "heading": "Output: List of setups found"
    },
    "tags": [
      "pattern"
    ]
  },
  {
    "content": "### Pattern C: Class-Based (V31)\n\n```python\nclass TradingScanner:\n    def run_scan(self):\n        stage1 = self.fetch_data()\n        stage2a = self.compute_simple_features(stage1)\n        stage2b = self.apply_filters(stage2a)\n        stage3a = self.compute_full_features(stage2b)\n        results = self.detect_patterns(stage3a)\n        return results\n```\n\n**Pros**: Modular, testable, fast\n**Cons**: More boilerplate\n\n---\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Output: List of setups found::Pattern C: Class-Based (V31)",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Output: List of setups found",
      "Pattern C: Class-Based (V31)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Pattern C: Class-Based (V31)"
    },
    "tags": [
      "scanner",
      "strategy",
      "pattern",
      "v31",
      "code"
    ]
  },
  {
    "content": "## Parameter System Patterns\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Output: List of setups found::Parameter System Patterns",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Output: List of setups found",
      "Parameter System Patterns"
    ],
    "metadata": {
      "level": 2,
      "heading": "Parameter System Patterns"
    },
    "tags": [
      "pattern"
    ]
  },
  {
    "content": "### Pattern 1: Threshold-Based (Most Common)\n\n```python\nparams = {\n    'gap_min': 0.5,           # Gap >= 0.5%\n    'volume_min': 10_000_000,  # Volume >= 10M\n    'atr_mult': 2.0           # Distance >= 2x ATR\n}\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Output: List of setups found::Parameter System Patterns::Pattern 1: Threshold-Based (Most Common)",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Output: List of setups found",
      "Parameter System Patterns",
      "Pattern 1: Threshold-Based (Most Common)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Pattern 1: Threshold-Based (Most Common)"
    },
    "tags": [
      "pattern",
      "code"
    ]
  },
  {
    "content": "# Usage: if gap >= params['gap_min']\n```\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Usage: if gap >= params['gap_min']",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Usage: if gap >= params['gap_min']"
    ],
    "metadata": {
      "level": 1,
      "heading": "Usage: if gap >= params['gap_min']"
    },
    "tags": []
  },
  {
    "content": "### Pattern 2: Range-Based\n\n```python\nparams = {\n    'level_pos_abs_min': 0.85,     # In top 15%\n    'level_pos_abs_max': 0.95,     # But not top 5%\n    'pivot_percentile_min': 0.85    # Top 15% of pivots\n}\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Usage: if gap >= params['gap_min']::Pattern 2: Range-Based",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Usage: if gap >= params['gap_min']",
      "Pattern 2: Range-Based"
    ],
    "metadata": {
      "level": 3,
      "heading": "Pattern 2: Range-Based"
    },
    "tags": [
      "pattern",
      "code"
    ]
  },
  {
    "content": "# Usage: if params['min'] <= value <= params['max']\n```\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Usage: if params['min'] <= value <= params['max']",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Usage: if params['min'] <= value <= params['max']"
    ],
    "metadata": {
      "level": 1,
      "heading": "Usage: if params['min'] <= value <= params['max']"
    },
    "tags": []
  },
  {
    "content": "### Pattern 3: Multi-Condition\n\n```python\nparams = {\n    'require_prev_green': True,\n    'require_pm_h_high': True,\n    'require_volume_confirm': False\n}\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Usage: if params['min'] <= value <= params['max']::Pattern 3: Multi-Condition",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Usage: if params['min'] <= value <= params['max']",
      "Pattern 3: Multi-Condition"
    ],
    "metadata": {
      "level": 3,
      "heading": "Pattern 3: Multi-Condition"
    },
    "tags": [
      "pattern",
      "code"
    ]
  },
  {
    "content": "# Usage: All required conditions must be True\n```\n\n---\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Usage: All required conditions must be True",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "code",
    "heading_path": [
      "Usage: All required conditions must be True"
    ],
    "metadata": {
      "level": 1,
      "heading": "Usage: All required conditions must be True"
    },
    "tags": []
  },
  {
    "content": "## When to Use Which Pattern\n\n| Market Condition | Use Pattern | Rationale |\n|------------------|-------------|------------|\n| Strong momentum, breaking out | DMR | Ride the trend |\n| Resistance holds, choppy | FBO | Fade failed breakouts |\n| Extended move continues | Extension Gap | Parabolic continuation |\n| Acceleration phase | Daily Para | Catch the rocket |\n| Bottoming, reversal | FRD EXT Gap | First leg up |\n| Simple setup test | LC 3d | Quick validation |\n\n---\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Usage: All required conditions must be True::When to Use Which Pattern",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Usage: All required conditions must be True",
      "When to Use Which Pattern"
    ],
    "metadata": {
      "level": 2,
      "heading": "When to Use Which Pattern"
    },
    "tags": [
      "pattern"
    ]
  },
  {
    "content": "## Key Takeaways for AI Agent Development\n\n1. **NOT ONE PATTERN TYPE**: Backside B is just one of MANY\n2. **DIFFERENT LOGIC**: Each pattern type has fundamentally different detection logic\n3. **DIFFERENT PARAMETERS**: Each uses different metrics and thresholds\n4. **DIFFERENT MARKET CONDITIONS**: Each targets different market behavior\n5. **CODE STRUCTURE VARIETY**: Simple scripts, class-based, multi-pattern\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Usage: All required conditions must be True::Key Takeaways for AI Agent Development",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "section",
    "heading_path": [
      "Usage: All required conditions must be True",
      "Key Takeaways for AI Agent Development"
    ],
    "metadata": {
      "level": 2,
      "heading": "Key Takeaways for AI Agent Development"
    },
    "tags": [
      "indicator",
      "pattern",
      "code"
    ]
  },
  {
    "content": "### AI Agent Must Be Able To:\n\n1. **Identify pattern type** from user description\n2. **Choose appropriate code structure** for that pattern\n3. **Generate correct parameters** for that pattern type\n4. **Validate against A+ examples** of THAT pattern type\n5. **Debug using pattern-specific logic**\n\n---\n\n**Document Status**: COMPLETE\n**Version**: 1.0\n**Last Updated**: 2026-01-29\n",
    "chunk_id": "EDGEDEV_PATTERN_TYPE_CATALOG.md::Usage: All required conditions must be True::Key Takeaways for AI Agent Development::AI Agent Must Be Able To:",
    "source_file": "EDGEDEV_PATTERN_TYPE_CATALOG.md",
    "chunk_type": "example",
    "heading_path": [
      "Usage: All required conditions must be True",
      "Key Takeaways for AI Agent Development",
      "AI Agent Must Be Able To:"
    ],
    "metadata": {
      "level": 3,
      "heading": "AI Agent Must Be Able To:"
    },
    "tags": [
      "pattern",
      "code"
    ]
  },
  {
    "content": "# EdgeDev Code Structure Guide\n**How to Write Scanner Code - Methodology & Patterns**\n\n**Purpose**: Teach the PATTERNS of writing good scanner code, regardless of specific pattern type.\n\n**Research Date**: 2026-01-29\n**Status**: COMPLETE - Code Structure Methodology\n\n---\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::EdgeDev Code Structure Guide",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Code Structure Guide"
    ],
    "metadata": {
      "level": 1,
      "heading": "EdgeDev Code Structure Guide"
    },
    "tags": [
      "scanner",
      "pattern",
      "code"
    ]
  },
  {
    "content": "## Table of Contents\n\n1. [The Scanner Development Framework](#the-scanner-development-framework)\n2. [Expressing a Mold in Code](#expressing-a-mold-in-code)\n3. [Code Structure Patterns](#code-structure-patterns)\n4. [Parameter System Design](#parameter-system-design)\n5. [Data Flow Architecture](#data-flow-architecture)\n6. [Validation Patterns](#validation-patterns)\n7. [Anti-Patterns to Avoid](#anti-patterns-to-avoid)\n8. [Code Templates](#code-templates)\n\n---\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::EdgeDev Code Structure Guide::Table of Contents",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Code Structure Guide",
      "Table of Contents"
    ],
    "metadata": {
      "level": 2,
      "heading": "Table of Contents"
    },
    "tags": [
      "scanner",
      "pattern",
      "code"
    ]
  },
  {
    "content": "## The Scanner Development Framework\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::EdgeDev Code Structure Guide::The Scanner Development Framework",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Code Structure Guide",
      "The Scanner Development Framework"
    ],
    "metadata": {
      "level": 2,
      "heading": "The Scanner Development Framework"
    },
    "tags": [
      "scanner"
    ]
  },
  {
    "content": "### The Process (From Idea to Working Scanner)",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::EdgeDev Code Structure Guide::The Scanner Development Framework::The Process (From Idea to Working Scanner)::chunk0",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Code Structure Guide",
      "The Scanner Development Framework",
      "The Process (From Idea to Working Scanner)"
    ],
    "metadata": {
      "level": 3,
      "heading": "The Process (From Idea to Working Scanner)"
    },
    "tags": [
      "scanner",
      "pattern",
      "v31",
      "code"
    ]
  },
  {
    "content": "### The Process (From Idea to Working Scanner)\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        SCANNER DEVELOPMENT LIFECYCLE                    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                         \u2502\n\u2502  1. DESCRIBE THE MOLD (Plain English)                                 \u2502\n\u2502     \"Stock runs up for 5-10 days, gaps up 3%+, holds high, fades\"     \u2502\n\u2502                          \u2502                                              \u2502\n\u2502                          \u25bc                                              \u2502\n\u2502  2. IDENTIFY A+ EXAMPLES (Real Trades)                                \u2502\n\u2502     \u2022 NVDA Jan 8, 2025: 4.2% gap, held 0.3% range, closed down      \u2502\n\u2502     \u2022 TSLA Dec 3, 2024: 3.8% gap, held tight, faded 2.1%            \u2502\n\u2502     \u2022 AAPL Nov 15, 2024: 5.1% gap, perfect fade                     \u2502\n\u2502                          \u2502                                              \u2502\n\u2502                          \u25bc                                              \u2502\n\u2502  3. EXTRACT PARAMETERS FROM A+ (Quantify the Mold)                  \u2502\n\u2502     From NVDA Jan 8:                                                 \u2502\n\u2502     \u2022 gap_percent = 4.2%     \u2192 min_gap = 3.5%                        \u2502\n\u2502     \u2022 hold_range = 0.3%     \u2192 max_hold = 0.5%                        \u2502\n\u2502     \u2022 fade_amount = -1.8%   \u2192 min_fade = -1.0%                       \u2502\n\u2502     \u2022 volume_ratio = 2.1x    \u2192 min_vol_ratio = 2.0                     \u2502\n\u2502                          \u2502                                              \u2502\n\u2502                          \u25bc                                              \u2502\n\u2502  4. CHOOSE CODE STRUCTURE (Based on complexity)                     \u2502\n\u2502     Simple?  \u2192 Standalone script                                     \u2502\n\u2502     Medium?  \u2192 Function-based                                         \u2502\n\u2502     Complex? \u2192 Class-based (V31)                                       \u2502\n\u2502                          \u2502                                              \u2502\n\u2502                          \u25bc                                              \u2502\n\u2502  5. IMPLEMENT THE MOLD (Write code)                                  \u2502\n\u2502     \u2022 Data fetching                                                   \u2502\n\u2502     \u2022 Feature calculation                                            \u2502\n\u2502     \u2022 Pattern detection                                             \u2502\n\u2502     \u2022 Result filtering                                               \u2502\n\u2502                          \u2502                                              \u2502\n\u2502                          \u25bc                                              \u2502\n\u2502  6. VALIDATE WITH A+ (Ground truth test)                            \u2502\n\u2502     \u2022 Run scanner on dates around A+ examples                       \u2502\n\u2502     \u2022 NVDA Jan 8 MUST appear in results                             \u2502\n\u2502     \u2022 Visual spot-check on random results                           \u2502\n\u2502                          \u2502                                              \u2502\n\u2502                          \u25bc                                              \u2502\n\u2502  7. DEBUG WITH PARAMETER CHECKING (See what failed)                \u2502\n\u2502     \u2022 Why didn't AAPL trigger?                                     \u2502\n\u2502     \u2022 Check each parameter value on that date                       \u2502\n\u2502     \u2022 Adjust thresholds if needed                                   \u2502\n\u2502                          \u2502                                              \u2502\n\u2502                          \u25bc                                              \u2502\n\u2502  8. EXPAND TO HISTORICAL (Full date range)                          \u2502\n\u2502     \u2022 Run on 1-2 years of data                                       \u2502\n\u2502     \u2022 Verify edge potential                                         \u2502\n\u2502     \u2022 Save working scanner                                          \u2502\n\u2502                                                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::EdgeDev Code Structure Guide::The Scanner Development Framework::The Process (From Idea to Working Scanner)::chunk1",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Code Structure Guide",
      "The Scanner Development Framework",
      "The Process (From Idea to Working Scanner)"
    ],
    "metadata": {
      "level": 3,
      "heading": "The Process (From Idea to Working Scanner)"
    },
    "tags": [
      "scanner",
      "pattern",
      "v31",
      "code"
    ]
  },
  {
    "content": "\u2502\n\u2502                                                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n\n\n[...previous chunk overlap...]\n\n---",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::EdgeDev Code Structure Guide::The Scanner Development Framework::The Process (From Idea to Working Scanner)::chunk2",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Code Structure Guide",
      "The Scanner Development Framework",
      "The Process (From Idea to Working Scanner)"
    ],
    "metadata": {
      "level": 3,
      "heading": "The Process (From Idea to Working Scanner)"
    },
    "tags": [
      "scanner",
      "pattern",
      "v31",
      "code"
    ]
  },
  {
    "content": "## Expressing a Mold in Code\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::EdgeDev Code Structure Guide::Expressing a Mold in Code",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Code Structure Guide",
      "Expressing a Mold in Code"
    ],
    "metadata": {
      "level": 2,
      "heading": "Expressing a Mold in Code"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "### What is a \"Mold\"?\n\nA **mold** is the pattern shape you're looking for. It's the visual/technical criteria that define \"this is a setup.\"\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::EdgeDev Code Structure Guide::Expressing a Mold in Code::What is a \"Mold\"?",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Code Structure Guide",
      "Expressing a Mold in Code",
      "What is a \"Mold\"?"
    ],
    "metadata": {
      "level": 3,
      "heading": "What is a \"Mold\"?"
    },
    "tags": [
      "pattern"
    ]
  },
  {
    "content": "### Example: Gap-and-Fade Mold\n\n**Plain English Description:**\n```\nI want stocks that:\n1. Have been running up for 5-10 days (uptrend)\n2. Gap up at least 3% on D0\n3. Open near the high and hold it (within 0.5% range)\n4. Close weak (below open)\n5. Had high volume on the gap\n```\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::EdgeDev Code Structure Guide::Expressing a Mold in Code::Example: Gap-and-Fade Mold",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Code Structure Guide",
      "Expressing a Mold in Code",
      "Example: Gap-and-Fade Mold"
    ],
    "metadata": {
      "level": 3,
      "heading": "Example: Gap-and-Fade Mold"
    },
    "tags": []
  },
  {
    "content": "### Step 1: Break Down the Mold into Testable Conditions\n\n```python",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::EdgeDev Code Structure Guide::Expressing a Mold in Code::Step 1: Break Down the Mold into Testable Conditions",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Code Structure Guide",
      "Expressing a Mold in Code",
      "Step 1: Break Down the Mold into Testable Conditions"
    ],
    "metadata": {
      "level": 3,
      "heading": "Step 1: Break Down the Mold into Testable Conditions"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# Condition 1: Uptrend (5-10 days)",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Condition 1: Uptrend (5-10 days)",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "Condition 1: Uptrend (5-10 days)"
    ],
    "metadata": {
      "level": 1,
      "heading": "Condition 1: Uptrend (5-10 days)"
    },
    "tags": []
  },
  {
    "content": "# How to test: Check if recent closes are higher than older closes\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::How to test: Check if recent closes are higher than older closes",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "How to test: Check if recent closes are higher than older closes"
    ],
    "metadata": {
      "level": 1,
      "heading": "How to test: Check if recent closes are higher than older closes"
    },
    "tags": []
  },
  {
    "content": "# Condition 2: Gap up >= 3%",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Condition 2: Gap up >= 3%",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "Condition 2: Gap up >= 3%"
    ],
    "metadata": {
      "level": 1,
      "heading": "Condition 2: Gap up >= 3%"
    },
    "tags": []
  },
  {
    "content": "# How to test: (open - prev_close) / prev_close >= 0.03\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::How to test: (open - prev_close) / prev_close >= 0.03",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "How to test: (open - prev_close) / prev_close >= 0.03"
    ],
    "metadata": {
      "level": 1,
      "heading": "How to test: (open - prev_close) / prev_close >= 0.03"
    },
    "tags": []
  },
  {
    "content": "# Condition 3: Hold the high (within 0.5%)",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Condition 3: Hold the high (within 0.5%)",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "Condition 3: Hold the high (within 0.5%)"
    ],
    "metadata": {
      "level": 1,
      "heading": "Condition 3: Hold the high (within 0.5%)"
    },
    "tags": []
  },
  {
    "content": "# How to test: (high - open) / open <= 0.005\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::How to test: (high - open) / open <= 0.005",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "How to test: (high - open) / open <= 0.005"
    ],
    "metadata": {
      "level": 1,
      "heading": "How to test: (high - open) / open <= 0.005"
    },
    "tags": []
  },
  {
    "content": "# Condition 4: Close weak",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Condition 4: Close weak",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "Condition 4: Close weak"
    ],
    "metadata": {
      "level": 1,
      "heading": "Condition 4: Close weak"
    },
    "tags": []
  },
  {
    "content": "# How to test: close < open\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::How to test: close < open",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "How to test: close < open"
    ],
    "metadata": {
      "level": 1,
      "heading": "How to test: close < open"
    },
    "tags": []
  },
  {
    "content": "# Condition 5: High volume",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Condition 5: High volume",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "Condition 5: High volume"
    ],
    "metadata": {
      "level": 1,
      "heading": "Condition 5: High volume"
    },
    "tags": []
  },
  {
    "content": "# How to test: volume >= avg_volume * 2\n```\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::How to test: volume >= avg_volume * 2",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "How to test: volume >= avg_volume * 2"
    ],
    "metadata": {
      "level": 1,
      "heading": "How to test: volume >= avg_volume * 2"
    },
    "tags": []
  },
  {
    "content": "### Step 2: Calculate Parameters from A+ Example\n\n```python",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::How to test: volume >= avg_volume * 2::Step 2: Calculate Parameters from A+ Example",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "How to test: volume >= avg_volume * 2",
      "Step 2: Calculate Parameters from A+ Example"
    ],
    "metadata": {
      "level": 3,
      "heading": "Step 2: Calculate Parameters from A+ Example"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# A+ Example: NVDA on Jan 8, 2025\nexample = {\n    'date': '2025-01-08',\n    'gap_pct': 4.2,      # 4.2% gap\n    'hold_range': 0.3,  # Held within 0.3% of high\n    'close_change': -1.8,  # Closed down 1.8%\n    'volume_ratio': 2.1  # 2.1x average volume\n}\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::A+ Example: NVDA on Jan 8, 2025",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "example",
    "heading_path": [
      "A+ Example: NVDA on Jan 8, 2025"
    ],
    "metadata": {
      "level": 1,
      "heading": "A+ Example: NVDA on Jan 8, 2025"
    },
    "tags": []
  },
  {
    "content": "# Convert to scanner parameters with tolerance\nparams = {\n    'min_gap': 3.5,          # 4.2 * 0.9 (10% tolerance)\n    'max_hold_range': 0.5,  # 0.3 * 1.1 (10% tolerance)\n    'require_close_down': True,\n    'min_volume_ratio': 2.0  # 2.1 * 0.95\n}\n```\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Convert to scanner parameters with tolerance",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "Convert to scanner parameters with tolerance"
    ],
    "metadata": {
      "level": 1,
      "heading": "Convert to scanner parameters with tolerance"
    },
    "tags": [
      "scanner"
    ]
  },
  {
    "content": "### Step 3: Implement the Mold in Code\n\n```python\ndef detect_gap_and_fade(df, params):\n    \"\"\"\n    Detect gap-and-fade mold.\n\n    Returns: DataFrame with boolean 'is_setup' column\n    \"\"\"\n    # Calculate required features\n    df['gap_pct'] = (df['open'] - df['close'].shift(1)) / df['close'].shift(1)\n    df['hold_range'] = (df['high'] - df['open']) / df['open']\n    df['close_down'] = df['close'] < df['open']\n    df['avg_volume'] = df['volume'].rolling(20).mean()\n    df['volume_ratio'] = df['volume'] / df['avg_volume']\n\n    # Uptrend condition (5-10 day lookback)\n    df['is_uptrend'] = (\n        df['close'] > df['close'].shift(5) &  # Higher than 5 days ago\n        df['close'] > df['close'].shift(10)  # Higher than 10 days ago\n    )\n\n    # Apply the mold\n    df['is_setup'] = (\n        (df['gap_pct'] >= params['min_gap']) &\n        (df['hold_range'] <= params['max_hold_range']) &\n        (df['close_down'] == True) &\n        (df['volume_ratio'] >= params['min_volume_ratio']) &\n        (df['is_uptrend'] == True)\n    )\n\n    return df\n```\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Convert to scanner parameters with tolerance::Step 3: Implement the Mold in Code",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "Convert to scanner parameters with tolerance",
      "Step 3: Implement the Mold in Code"
    ],
    "metadata": {
      "level": 3,
      "heading": "Step 3: Implement the Mold in Code"
    },
    "tags": [
      "pattern",
      "code"
    ]
  },
  {
    "content": "### Key Principle: Each Condition is Independent\n\n```python",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Convert to scanner parameters with tolerance::Step 3: Implement the Mold in Code::Key Principle: Each Condition is Independent",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "Convert to scanner parameters with tolerance",
      "Step 3: Implement the Mold in Code",
      "Key Principle: Each Condition is Independent"
    ],
    "metadata": {
      "level": 3,
      "heading": "Key Principle: Each Condition is Independent"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# \u2705 CORRECT: Each condition tested separately\ncondition1 = df['gap_pct'] >= params['min_gap']\ncondition2 = df['hold_range'] <= params['max_hold_range']\ncondition3 = df['close'] < df['open']\ncondition4 = df['volume_ratio'] >= params['min_volume_ratio']\ncondition5 = df['is_uptrend']\n\nall_conditions = condition1 & condition2 & condition3 & condition4 & condition5\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::\u2705 CORRECT: Each condition tested separately",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "\u2705 CORRECT: Each condition tested separately"
    ],
    "metadata": {
      "level": 1,
      "heading": "\u2705 CORRECT: Each condition tested separately"
    },
    "tags": []
  },
  {
    "content": "# \u274c WRONG: Nested conditions make debugging impossible\nif df['gap_pct'] >= params['min_gap']:\n    if df['hold_range'] <= params['max_hold_range']:\n        if df['close'] < df['open']:\n            # Can't debug which condition failed\n            pass\n```\n\n**Why This Matters**: When debugging, you want to see:\n- Condition 1: \u2713 PASSED\n- Condition 2: \u2717 FAILED (hold_range was 0.6%, max is 0.5%)\n- Condition 3: \u2713 PASSED\n- ...\n\n---\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::\u274c WRONG: Nested conditions make debugging impossible",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "\u274c WRONG: Nested conditions make debugging impossible"
    ],
    "metadata": {
      "level": 1,
      "heading": "\u274c WRONG: Nested conditions make debugging impossible"
    },
    "tags": []
  },
  {
    "content": "## Code Structure Patterns\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::\u274c WRONG: Nested conditions make debugging impossible::Code Structure Patterns",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "\u274c WRONG: Nested conditions make debugging impossible",
      "Code Structure Patterns"
    ],
    "metadata": {
      "level": 2,
      "heading": "Code Structure Patterns"
    },
    "tags": [
      "pattern",
      "code"
    ]
  },
  {
    "content": "### Pattern 1: Standalone Script (Simple Patterns)\n\n**When to Use**: Testing ideas, simple patterns, quick validation\n\n```python\nimport pandas as pd\nimport requests\n\nAPI_KEY = \"your_key\"\nBASE_URL = \"https://api.polygon.io\"\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::\u274c WRONG: Nested conditions make debugging impossible::Code Structure Patterns::Pattern 1: Standalone Script (Simple Patterns)",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "\u274c WRONG: Nested conditions make debugging impossible",
      "Code Structure Patterns",
      "Pattern 1: Standalone Script (Simple Patterns)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Pattern 1: Standalone Script (Simple Patterns)"
    },
    "tags": [
      "backtest",
      "pattern",
      "code"
    ]
  },
  {
    "content": "# Configuration\nSYMBOLS = ['AAPL', 'MSFT', 'GOOGL', 'TSLA', 'NVDA']\nSTART_DATE = \"2024-01-01\"\nEND_DATE = \"2024-12-31\"\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Configuration",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "Configuration"
    ],
    "metadata": {
      "level": 1,
      "heading": "Configuration"
    },
    "tags": []
  },
  {
    "content": "# Parameters\nPARAMS = {\n    'min_gap': 0.03,\n    'min_volume': 10_000_000\n}\n\ndef fetch_data(symbol, start, end):\n    \"\"\"Fetch OHLC data for a symbol.\"\"\"\n    url = f\"{BASE_URL}/v2/aggs/ticker/{symbol}/range/1/day/{start}/{end}\"\n    resp = requests.get(url, params={'apiKey': API_KEY})\n    data = resp.json().get('results', [])\n    return pd.DataFrame(data)\n\ndef scan_symbol(symbol, start, end, params):\n    \"\"\"Scan one symbol for the pattern.\"\"\"\n    df = fetch_data(symbol, start, end)\n\n    # Calculate features\n    df['gap'] = (df['o'] - df['c'].shift(1)) / df['c'].shift(1)\n\n    # Apply conditions\n    setups = df[df['gap'] >= params['min_gap']]\n\n    # Format results\n    results = []\n    for idx, row in setups.iterrows():\n        results.append({\n            'symbol': symbol,\n            'date': row['t'],\n            'gap': row['gap']\n        })\n\n    return results\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Parameters",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "Parameters"
    ],
    "metadata": {
      "level": 1,
      "heading": "Parameters"
    },
    "tags": [
      "scanner",
      "pattern"
    ]
  },
  {
    "content": "# Main execution\nif __name__ == '__main__':\n    all_results = []\n    for symbol in SYMBOLS:\n        results = scan_symbol(symbol, START_DATE, END_DATE, PARAMS)\n        all_results.extend(results)\n\n    print(f\"Found {len(all_results)} setups\")\n```\n\n**Pros**: Simple, fast to write\n**Cons**: Not scalable, hard to maintain\n\n---\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Main execution",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "Main execution"
    ],
    "metadata": {
      "level": 1,
      "heading": "Main execution"
    },
    "tags": [
      "scanner",
      "strategy",
      "pattern",
      "execution"
    ]
  },
  {
    "content": "### Pattern 2: Function-Based (Medium Complexity)\n\n**When to Use**: Multiple patterns, reusable code\n\n```python\nimport pandas as pd\nimport requests\nfrom typing import List, Dict\n\nclass ScannerConfig:\n    \"\"\"Configuration for scanner parameters.\"\"\"\n    min_gap: float = 0.03\n    min_volume: int = 10_000_000\n    min_price: float = 10.0\n\ndef fetch_data(symbols: List[str], start: str, end: str) -> pd.DataFrame:\n    \"\"\"Fetch data for multiple symbols.\"\"\"\n    all_data = []\n    for symbol in symbols:\n        # Fetch logic here\n        pass\n    return pd.concat(all_data)\n\ndef calculate_features(df: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"Calculate all required features.\"\"\"\n    df['gap'] = (df['open'] - df['close'].shift(1)) / df['close'].shift(1)\n    df['volume_avg'] = df['volume'].rolling(20).mean()\n    df['volume_ratio'] = df['volume'] / df['volume_avg']\n    return df\n\ndef detect_pattern(df: pd.DataFrame, config: ScannerConfig) -> pd.DataFrame:\n    \"\"\"Detect the pattern.\"\"\"\n    setups = df[\n        (df['gap'] >= config.min_gap) &\n        (df['volume'] >= config.min_volume) &\n        (df['close'] >= config.min_price)\n    ]\n    return setups\n\ndef run_scan(symbols: List[str], start: str, end: str, config: ScannerConfig) -> List[Dict]:\n    \"\"\"Main scan execution.\"\"\"\n    df = fetch_data(symbols, start, end)\n    df = calculate_features(df)\n    setups = detect_pattern(df, config)\n    return setups.to_dict('records')\n```\n\n**Pros**: Modular, testable, reusable\n**Cons**: More boilerplate\n\n---\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Main execution::Pattern 2: Function-Based (Medium Complexity)",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "Main execution",
      "Pattern 2: Function-Based (Medium Complexity)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Pattern 2: Function-Based (Medium Complexity)"
    },
    "tags": [
      "scanner",
      "strategy",
      "pattern",
      "code",
      "execution"
    ]
  },
  {
    "content": "### Pattern 3: Class-Based V31 (Production)\n\n**When to Use**: Complex patterns, high performance requirements",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Main execution::Pattern 2: Function-Based (Medium Complexity)::Pattern 3: Class-Based V31 (Production)::chunk0",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "Main execution",
      "Pattern 2: Function-Based (Medium Complexity)",
      "Pattern 3: Class-Based V31 (Production)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Pattern 3: Class-Based V31 (Production)"
    },
    "tags": [
      "scanner",
      "strategy",
      "pattern",
      "v31",
      "code"
    ]
  },
  {
    "content": "### Pattern 3: Class-Based V31 (Production)\n\n**When to Use**: Complex patterns, high performance requirements\n\n```python\nimport pandas as pd\nimport requests\nfrom concurrent.futures import ThreadPoolExecutor\nimport pandas_market_calendars as mcal\n\nclass TradingScanner:\n    \"\"\"\n    Production scanner using V31 architecture.\n\n    5-Stage Pipeline:\n    1. Fetch grouped data\n    2a. Compute simple features\n    2b. Apply smart filters\n    3a. Compute full features\n    3b. Detect patterns\n    \"\"\"\n\n    def __init__(self, api_key: str, d0_start: str, d0_end: str):\n        \"\"\"Initialize scanner.\"\"\"\n        # Configuration\n        self.api_key = api_key\n        self.base_url = \"https://api.polygon.io\"\n        self.session = requests.Session()\n\n        # Date range\n        self.d0_start_user = d0_start\n        self.d0_end_user = d0_end\n\n        # Calculate historical buffer\n        lookback = self.params.get('abs_lookback_days', 1000) + 50\n        scan_start = pd.to_datetime(d0_start) - pd.Timedelta(days=lookback)\n        self.scan_start = scan_start.strftime('%Y-%m-%d')\n\n        # Parameters\n        self.params = {\n            'price_min': 8.0,\n            'adv20_min_usd': 30_000_000,\n            # ... pattern-specific params\n        }\n\n        # Workers\n        self.stage1_workers = 5\n        self.stage3_workers = 10\n\n    def run_scan(self) -> List[Dict]:\n        \"\"\"Execute the 5-stage pipeline.\"\"\"\n        # Stage 1: Fetch\n        stage1_data = self.fetch_grouped_data()\n\n        # Stage 2a: Simple features\n        stage2a_data = self.compute_simple_features(stage1_data)\n\n        # Stage 2b: Smart filters\n        stage2b_data = self.apply_smart_filters(stage2a_data)\n\n        # Stage 3a: Full features\n        stage3a_data = self.compute_full_features(stage2b_data)\n\n        # Stage 3b: Detect\n        results = self.detect_patterns(stage3a_data)\n\n        return results\n\n    def fetch_grouped_data(self) -> pd.DataFrame:\n        \"\"\"Stage 1: Fetch all tickers for all dates.\"\"\"\n        # Implementation here\n        pass\n\n    def compute_simple_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Stage 2a: Compute cheap features.\"\"\"\n        df['prev_close'] = df.groupby('ticker')['close'].shift(1)\n        df['adv20'] = (df['close'] * df['volume']).groupby(df['ticker']).transform(\n            lambda x: x.rolling(20, min_periods=20).mean()\n        )\n        return df\n\n    def apply_smart_filters(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Stage 2b: Filter D0, preserve historical.\"\"\"\n        # Separate historical from D0\n        df_historical = df[~df['date'].between(self.d0_start_user, self.d0_end_user)]\n        df_output = df[df['date'].between(self.d0_start_user, self.d0_end_user)]\n\n        # Filter only D0\n        df_filtered = df_output[\n            (df_output['prev_close'] >= self.params['price_min']) &\n            (df_output['adv20'] >= self.params['adv20_min_usd'])\n        ]\n\n        # Recombine\n        return pd.concat([df_historical, df_filtered])\n\n    def compute_full_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Stage 3a: Compute expensive features.\"\"\"\n        # EMA, ATR, slopes, etc.\n        pass\n\n    def detect_patterns(self, df: pd.DataFrame) -> List[Dict]:\n        \"\"\"Stage 3b: Pattern detection logic.\"\"\"\n        # Pattern-specific detection\n        pass\n```",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Main execution::Pattern 2: Function-Based (Medium Complexity)::Pattern 3: Class-Based V31 (Production)::chunk1",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "Main execution",
      "Pattern 2: Function-Based (Medium Complexity)",
      "Pattern 3: Class-Based V31 (Production)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Pattern 3: Class-Based V31 (Production)"
    },
    "tags": [
      "scanner",
      "strategy",
      "pattern",
      "v31",
      "code"
    ]
  },
  {
    "content": "ATR, slopes, etc.\n        pass\n\n    def detect_patterns(self, df: pd.DataFrame) -> List[Dict]:\n        \"\"\"Stage 3b: Pattern detection logic.\"\"\"\n        # Pattern-specific detection\n        pass\n```\n\n\n\n[...previous chunk overlap...]\n\n**Pros**: Fast, scalable, maintainable\n**Cons**: More complex, higher learning curve\n\n---",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Main execution::Pattern 2: Function-Based (Medium Complexity)::Pattern 3: Class-Based V31 (Production)::chunk2",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "Main execution",
      "Pattern 2: Function-Based (Medium Complexity)",
      "Pattern 3: Class-Based V31 (Production)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Pattern 3: Class-Based V31 (Production)"
    },
    "tags": [
      "scanner",
      "strategy",
      "pattern",
      "v31",
      "code"
    ]
  },
  {
    "content": "## Parameter System Design\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Main execution::Parameter System Design",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "Main execution",
      "Parameter System Design"
    ],
    "metadata": {
      "level": 2,
      "heading": "Parameter System Design"
    },
    "tags": []
  },
  {
    "content": "### Pattern 1: Flat Dictionary (Simple)\n\n```python\nparams = {\n    'min_gap': 0.03,\n    'max_hold_range': 0.005,\n    'min_volume': 10_000_000,\n    'min_price': 10.0\n}\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Main execution::Parameter System Design::Pattern 1: Flat Dictionary (Simple)",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "Main execution",
      "Parameter System Design",
      "Pattern 1: Flat Dictionary (Simple)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Pattern 1: Flat Dictionary (Simple)"
    },
    "tags": [
      "pattern",
      "code"
    ]
  },
  {
    "content": "# Usage: df['gap'] >= params['min_gap']\n```\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Usage: df['gap'] >= params['min_gap']",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "Usage: df['gap'] >= params['min_gap']"
    ],
    "metadata": {
      "level": 1,
      "heading": "Usage: df['gap'] >= params['min_gap']"
    },
    "tags": []
  },
  {
    "content": "### Pattern 2: Grouped by Category (Better)\n\n```python\nparams = {\n    # Price filters\n    'price_min': 10.0,\n    'gap_min': 0.03,\n    'hold_range_max': 0.005,\n\n    # Volume filters\n    'volume_min': 10_000_000,\n    'volume_ratio_min': 2.0,\n    'adv20_min_usd': 30_000_000,\n\n    # Trend filters\n    'require_uptrend': True,\n    'require_d1_green': True,\n\n    # Significance filters\n    'level_pos_abs_min': 0.85,\n    'is_pivot_high': True\n}\n```\n\n**Benefits**:\n- Easy to find related parameters\n- Simple to document\n- Clear what each group controls\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Usage: df['gap'] >= params['min_gap']::Pattern 2: Grouped by Category (Better)",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "Usage: df['gap'] >= params['min_gap']",
      "Pattern 2: Grouped by Category (Better)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Pattern 2: Grouped by Category (Better)"
    },
    "tags": [
      "pattern",
      "code"
    ]
  },
  {
    "content": "### Pattern 3: Parameter Objects (Advanced)\n\n```python\nfrom dataclasses import dataclass\nfrom typing import Optional\n\n@dataclass\nclass ScannerParams:\n    \"\"\"Type-safe parameter configuration.\"\"\"\n\n    # Price parameters\n    price_min: float = 10.0\n    gap_min: float = 0.03\n    hold_range_max: float = 0.005\n\n    # Volume parameters\n    volume_min: int = 10_000_000\n    volume_ratio_min: float = 2.0\n\n    # Toggle parameters\n    require_uptrend: bool = True\n    require_d1_green: bool = True\n\n    def validate(self) -> List[str]:\n        \"\"\"Validate parameters for consistency.\"\"\"\n        errors = []\n        if self.gap_min < 0:\n            errors.append(\"gap_min must be positive\")\n        if self.price_min < 1:\n            errors.append(\"price_min too low\")\n        return errors\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Usage: df['gap'] >= params['min_gap']::Pattern 2: Grouped by Category (Better)::Pattern 3: Parameter Objects (Advanced)",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "Usage: df['gap'] >= params['min_gap']",
      "Pattern 2: Grouped by Category (Better)",
      "Pattern 3: Parameter Objects (Advanced)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Pattern 3: Parameter Objects (Advanced)"
    },
    "tags": [
      "scanner",
      "pattern",
      "code"
    ]
  },
  {
    "content": "# Usage\nparams = ScannerParams(\n    price_min=10.0,\n    gap_min=0.03\n)\n\nif errors := params.validate():\n    print(f\"Invalid parameters: {errors}\")\n```\n\n**Benefits**:\n- Type safety\n- Validation built-in\n- IDE autocomplete\n- Self-documenting\n\n---\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Usage",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "Usage"
    ],
    "metadata": {
      "level": 1,
      "heading": "Usage"
    },
    "tags": [
      "scanner"
    ]
  },
  {
    "content": "## Data Flow Architecture\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Usage::Data Flow Architecture",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "Usage",
      "Data Flow Architecture"
    ],
    "metadata": {
      "level": 2,
      "heading": "Data Flow Architecture"
    },
    "tags": []
  },
  {
    "content": "### The Golden Rule: Separate Historical from D0\n\n```python",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Usage::Data Flow Architecture::The Golden Rule: Separate Historical from D0",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "Usage",
      "Data Flow Architecture",
      "The Golden Rule: Separate Historical from D0"
    ],
    "metadata": {
      "level": 3,
      "heading": "The Golden Rule: Separate Historical from D0"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# \u274c WRONG: Loses historical data\ndf_filtered = df[df['date'] >= d0_start]\ndf_filtered['atr'] = df_filtered['atr'].rolling(14).mean()  # WRONG! Lost history\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::\u274c WRONG: Loses historical data",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "\u274c WRONG: Loses historical data"
    ],
    "metadata": {
      "level": 1,
      "heading": "\u274c WRONG: Loses historical data"
    },
    "tags": []
  },
  {
    "content": "# \u2705 CORRECT: Preserve historical data\ndf_historical = df[df['date'] < d0_start]  # Keep for context\ndf_d0 = df[df['date'] >= d0_start]\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::\u2705 CORRECT: Preserve historical data",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "\u2705 CORRECT: Preserve historical data"
    ],
    "metadata": {
      "level": 1,
      "heading": "\u2705 CORRECT: Preserve historical data"
    },
    "tags": []
  },
  {
    "content": "# Calculate on full dataset, then filter\ndf['atr'] = df['atr'].rolling(14).mean()\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Calculate on full dataset, then filter",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "Calculate on full dataset, then filter"
    ],
    "metadata": {
      "level": 1,
      "heading": "Calculate on full dataset, then filter"
    },
    "tags": []
  },
  {
    "content": "# Filter D0 for output, keep historical for computation\ndf_output = df_d0[\n    (df_d0['gap'] >= params['min_gap']) &\n    (df_d0['volume'] >= params['volume_min'])\n]\n```\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Filter D0 for output, keep historical for computation",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "Filter D0 for output, keep historical for computation"
    ],
    "metadata": {
      "level": 1,
      "heading": "Filter D0 for output, keep historical for computation"
    },
    "tags": []
  },
  {
    "content": "### Why This Matters\n\nMany indicators need historical data:\n- **ATR**: Needs 14+ periods\n- **EMA**: Needs period length\n- **Slope**: Needs window length\n- **Position in range**: Needs 1000-day window\n\nIf you filter before calculating, you get WRONG results.\n\n---\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Filter D0 for output, keep historical for computation::Why This Matters",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "Filter D0 for output, keep historical for computation",
      "Why This Matters"
    ],
    "metadata": {
      "level": 3,
      "heading": "Why This Matters"
    },
    "tags": [
      "indicator",
      "position"
    ]
  },
  {
    "content": "## Validation Patterns\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Filter D0 for output, keep historical for computation::Validation Patterns",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "Filter D0 for output, keep historical for computation",
      "Validation Patterns"
    ],
    "metadata": {
      "level": 2,
      "heading": "Validation Patterns"
    },
    "tags": [
      "pattern"
    ]
  },
  {
    "content": "### Pattern 1: A+ Example Validation\n\n```python\ndef validate_with_a_plus_examples(scanner, a_plus_examples, params):\n    \"\"\"\n    Validate that scanner finds A+ examples.\n\n    Args:\n        scanner: Scanner function\n        a_plus_examples: List of {'symbol': 'NVDA', 'date': '2025-01-08'}\n        params: Scanner parameters\n\n    Returns:\n        Validation results\n    \"\"\"\n    results = []\n\n    for example in a_plus_examples:\n        # Run scanner around that date\n        start = (pd.to_datetime(example['date']) - timedelta(days=5)).strftime('%Y-%m-%d')\n        end = (pd.to_datetime(example['date']) + timedelta(days=5)).strftime('%Y-%m-%d')\n\n        setups = scanner(example['symbol'], start, end, params)\n\n        # Check if A+ example is found\n        found = any(\n            s['date'] == example['date'] and\n            s['symbol'] == example['symbol']\n            for s in setups\n        )\n\n        results.append({\n            'example': example,\n            'found': found\n        })\n\n    return results\n```\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Filter D0 for output, keep historical for computation::Validation Patterns::Pattern 1: A+ Example Validation",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "Filter D0 for output, keep historical for computation",
      "Validation Patterns",
      "Pattern 1: A+ Example Validation"
    ],
    "metadata": {
      "level": 3,
      "heading": "Pattern 1: A+ Example Validation"
    },
    "tags": [
      "scanner",
      "pattern",
      "code"
    ]
  },
  {
    "content": "### Pattern 2: Parameter Debugging\n\n```python\ndef debug_parameters_on_date(symbol, date, params):\n    \"\"\"\n    Show what each parameter value is on a specific date.\n\n    Useful for understanding why a setup didn't trigger.\n    \"\"\"\n    df = fetch_data(symbol, date, date)\n\n    # Calculate all parameters\n    gap_pct = (df['open'] / df['close'].shift(1) - 1).iloc[0]\n    hold_range = (df['high'] - df['open']) / df['open'].iloc[0]\n    close_down = df['close'].iloc[0] < df['open'].iloc[0]\n    volume_ratio = df['volume'].iloc[0] / df['volume'].rolling(20).mean().iloc[0]\n\n    # Check each condition\n    print(f\"{symbol} on {date}:\")\n    print(f\"  gap_pct: {gap_pct:.4f} >= {params['min_gap']:.4f} ? {gap_pct >= params['min_gap']}\")\n    print(f\"  hold_range: {hold_range:.4f} <= {params['max_hold_range']:.4f} ? {hold_range <= params['max_hold_range']}\")\n    print(f\"  close_down: {close_down} (required: True)\")\n    print(f\"  volume_ratio: {volume_ratio:.2f} >= {params['min_volume_ratio']:.2f} ? {volume_ratio >= params['min_volume_ratio']}\")\n```\n\n**Output**:\n```\nNVDA on 2025-01-08:\n  gap_pct: 0.0420 >= 0.0300 ? True\n  hold_range: 0.0030 <= 0.0050 ? True\n  close_down: True (required: True)\n  volume_ratio: 2.10 >= 2.00 ? True\n\n\u2713 ALL CONDITIONS PASSED\n```\n\n---\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Filter D0 for output, keep historical for computation::Validation Patterns::Pattern 2: Parameter Debugging",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "Filter D0 for output, keep historical for computation",
      "Validation Patterns",
      "Pattern 2: Parameter Debugging"
    ],
    "metadata": {
      "level": 3,
      "heading": "Pattern 2: Parameter Debugging"
    },
    "tags": [
      "pattern",
      "code"
    ]
  },
  {
    "content": "## Anti-Patterns to Avoid\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Filter D0 for output, keep historical for computation::Anti-Patterns to Avoid",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "Filter D0 for output, keep historical for computation",
      "Anti-Patterns to Avoid"
    ],
    "metadata": {
      "level": 2,
      "heading": "Anti-Patterns to Avoid"
    },
    "tags": [
      "pattern"
    ]
  },
  {
    "content": "### Anti-Pattern 1: Nested Conditions\n\n```python",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Filter D0 for output, keep historical for computation::Anti-Patterns to Avoid::Anti-Pattern 1: Nested Conditions",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "Filter D0 for output, keep historical for computation",
      "Anti-Patterns to Avoid",
      "Anti-Pattern 1: Nested Conditions"
    ],
    "metadata": {
      "level": 3,
      "heading": "Anti-Pattern 1: Nested Conditions"
    },
    "tags": [
      "pattern",
      "code"
    ]
  },
  {
    "content": "# \u274c WRONG: Hard to debug\nif gap >= params['min_gap']:\n    if volume >= params['min_volume']:\n        if close < open:\n            if is_uptrend:\n                return True\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::\u274c WRONG: Hard to debug",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "\u274c WRONG: Hard to debug"
    ],
    "metadata": {
      "level": 1,
      "heading": "\u274c WRONG: Hard to debug"
    },
    "tags": []
  },
  {
    "content": "# \u2705 CORRECT: Flat conditions\nall_passed = (\n    (gap >= params['min_gap']) and\n    (volume >= params['min_volume']) and\n    (close < open) and\n    is_uptrend\n)\nreturn all_passed\n```\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::\u2705 CORRECT: Flat conditions",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "\u2705 CORRECT: Flat conditions"
    ],
    "metadata": {
      "level": 1,
      "heading": "\u2705 CORRECT: Flat conditions"
    },
    "tags": []
  },
  {
    "content": "### Anti-Pattern 2: Magic Numbers\n\n```python",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::\u2705 CORRECT: Flat conditions::Anti-Pattern 2: Magic Numbers",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "\u2705 CORRECT: Flat conditions",
      "Anti-Pattern 2: Magic Numbers"
    ],
    "metadata": {
      "level": 3,
      "heading": "Anti-Pattern 2: Magic Numbers"
    },
    "tags": [
      "pattern",
      "code"
    ]
  },
  {
    "content": "# \u274c WRONG: What is 0.03? What is 10000000?\nif gap >= 0.03 and volume >= 10000000:\n    pass\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::\u274c WRONG: What is 0.03? What is 10000000?",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "\u274c WRONG: What is 0.03? What is 10000000?"
    ],
    "metadata": {
      "level": 1,
      "heading": "\u274c WRONG: What is 0.03? What is 10000000?"
    },
    "tags": []
  },
  {
    "content": "# \u2705 CORRECT: Named parameters\nGAP_MIN = 0.03\nVOLUME_MIN = 10_000_000\n\nif gap >= GAP_MIN and volume >= VOLUME_MIN:\n    pass\n```\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::\u2705 CORRECT: Named parameters",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "\u2705 CORRECT: Named parameters"
    ],
    "metadata": {
      "level": 1,
      "heading": "\u2705 CORRECT: Named parameters"
    },
    "tags": []
  },
  {
    "content": "### Anti-Pattern 3: Forward-Looking Bias\n\n```python",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::\u2705 CORRECT: Named parameters::Anti-Pattern 3: Forward-Looking Bias",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "\u2705 CORRECT: Named parameters",
      "Anti-Pattern 3: Forward-Looking Bias"
    ],
    "metadata": {
      "level": 3,
      "heading": "Anti-Pattern 3: Forward-Looking Bias"
    },
    "tags": [
      "pattern",
      "code"
    ]
  },
  {
    "content": "# \u274c WRONG: Uses future data in calculation\ndf['future_return'] = df['close'].shift(-2)  # Peeks into future\ndf['signal'] = df['future_return'] > 0  # Impossible to know in real-time\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::\u274c WRONG: Uses future data in calculation",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "\u274c WRONG: Uses future data in calculation"
    ],
    "metadata": {
      "level": 1,
      "heading": "\u274c WRONG: Uses future data in calculation"
    },
    "tags": [
      "indicator"
    ]
  },
  {
    "content": "# \u2705 CORRECT: Only use current and past data\ndf['signal'] = (\n    df['gap'] >= params['min_gap']  # Known at open\n)  # All data from current or past\n```\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::\u2705 CORRECT: Only use current and past data",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "\u2705 CORRECT: Only use current and past data"
    ],
    "metadata": {
      "level": 1,
      "heading": "\u2705 CORRECT: Only use current and past data"
    },
    "tags": [
      "indicator"
    ]
  },
  {
    "content": "### Anti-Pattern 4: Not Grouping by Ticker\n\n```python",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::\u2705 CORRECT: Only use current and past data::Anti-Pattern 4: Not Grouping by Ticker",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "\u2705 CORRECT: Only use current and past data",
      "Anti-Pattern 4: Not Grouping by Ticker"
    ],
    "metadata": {
      "level": 3,
      "heading": "Anti-Pattern 4: Not Grouping by Ticker"
    },
    "tags": [
      "pattern",
      "code"
    ]
  },
  {
    "content": "# \u274c WRONG: Calculates across all tickers together\ndf['adv20'] = (df['close'] * df['volume']).rolling(20).mean()",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::\u274c WRONG: Calculates across all tickers together",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "\u274c WRONG: Calculates across all tickers together"
    ],
    "metadata": {
      "level": 1,
      "heading": "\u274c WRONG: Calculates across all tickers together"
    },
    "tags": []
  },
  {
    "content": "# Problem: AAPL's volume affects MSFT's average\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Problem: AAPL's volume affects MSFT's average",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "Problem: AAPL's volume affects MSFT's average"
    ],
    "metadata": {
      "level": 1,
      "heading": "Problem: AAPL's volume affects MSFT's average"
    },
    "tags": []
  },
  {
    "content": "# \u2705 CORRECT: Per-ticker calculation\ndf['adv20'] = (df['close'] * df['volume']).groupby(df['ticker']).transform(\n    lambda x: x.rolling(20, min_periods=20).mean()\n)\n```\n\n---\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::\u2705 CORRECT: Per-ticker calculation",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "\u2705 CORRECT: Per-ticker calculation"
    ],
    "metadata": {
      "level": 1,
      "heading": "\u2705 CORRECT: Per-ticker calculation"
    },
    "tags": []
  },
  {
    "content": "## Code Templates\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::\u2705 CORRECT: Per-ticker calculation::Code Templates",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "\u2705 CORRECT: Per-ticker calculation",
      "Code Templates"
    ],
    "metadata": {
      "level": 2,
      "heading": "Code Templates"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "### Template 1: Simple Mean Reversion Scanner",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::\u2705 CORRECT: Per-ticker calculation::Code Templates::Template 1: Simple Mean Reversion Scanner::chunk0",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "\u2705 CORRECT: Per-ticker calculation",
      "Code Templates",
      "Template 1: Simple Mean Reversion Scanner"
    ],
    "metadata": {
      "level": 3,
      "heading": "Template 1: Simple Mean Reversion Scanner"
    },
    "tags": [
      "scanner",
      "pattern",
      "code"
    ]
  },
  {
    "content": "### Template 1: Simple Mean Reversion Scanner\n\n```python\nimport pandas as pd\nimport requests\nfrom typing import List, Dict\n\nAPI_KEY = \"your_key\"\nBASE_URL = \"https://api.polygon.io\"\n\nclass MeanReversionScanner:\n    \"\"\"Base template for mean reversion scanners.\"\"\"\n\n    def __init__(self, params: Dict):\n        self.params = params\n        self.session = requests.Session()\n\n    def fetch_data(self, symbols: List[str], start: str, end: str) -> pd.DataFrame:\n        \"\"\"Fetch data for symbols.\"\"\"\n        all_data = []\n        for symbol in symbols:\n            url = f\"{BASE_URL}/v2/aggs/ticker/{symbol}/range/1/day/{start}/{end}\"\n            resp = self.session.get(url, params={'apiKey': API_KEY})\n            data = resp.json().get('results', [])\n            if data:\n                df = pd.DataFrame(data)\n                df['symbol'] = symbol\n                all_data.append(df)\n        return pd.concat(all_data, ignore_index=True)\n\n    def calculate_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Calculate features. Override in subclass.\"\"\"\n        df['gap'] = (df['o'] - df['c'].shift(1)) / df['c'].shift(1)\n        df['volume_avg'] = df.groupby('symbol')['v'].transform(\n            lambda x: x.rolling(20).mean()\n        )\n        return df\n\n    def detect_setup(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Detect setup. Override in subclass.\"\"\"\n        raise NotImplementedError(\"Subclass must implement detect_setup\")\n\n    def scan(self, symbols: List[str], start: str, end: str) -> List[Dict]:\n        \"\"\"Run the scan.\"\"\"\n        df = self.fetch_data(symbols, start, end)\n        df = self.calculate_features(df)\n        setups = self.detect_setup(df)\n        return setups.to_dict('records')\n\n\nclass GapAndFadeScanner(MeanReversionScanner):\n    \"\"\"Concrete implementation: Gap and fade setup.\"\"\"\n\n    def detect_setup(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Detect gap-and-fade pattern.\"\"\"\n        return df[\n            (df['gap'] >= self.params.get('min_gap', 0.03)) &\n            (df['volume'] >= self.params.get('min_volume', 10_000_000)) &\n            (df['c'] < df['o'])  # Close down (weak close)\n        ]",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::\u2705 CORRECT: Per-ticker calculation::Code Templates::Template 1: Simple Mean Reversion Scanner::chunk1",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "\u2705 CORRECT: Per-ticker calculation",
      "Code Templates",
      "Template 1: Simple Mean Reversion Scanner"
    ],
    "metadata": {
      "level": 3,
      "heading": "Template 1: Simple Mean Reversion Scanner"
    },
    "tags": [
      "scanner",
      "pattern",
      "code"
    ]
  },
  {
    "content": "# Usage\nscanner = GapAndFadeScanner(params={\n    'min_gap': 0.03,\n    'min_volume': 10_000_000\n})\n\nresults = scanner.scan(\n    symbols=['AAPL', 'MSFT', 'TSLA'],\n    start='2024-01-01',\n    end='2024-12-31'\n)\n```\n\n---\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Usage",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "code",
    "heading_path": [
      "Usage"
    ],
    "metadata": {
      "level": 1,
      "heading": "Usage"
    },
    "tags": [
      "scanner"
    ]
  },
  {
    "content": "## Summary: The Methodology\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Usage::Summary: The Methodology",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "section",
    "heading_path": [
      "Usage",
      "Summary: The Methodology"
    ],
    "metadata": {
      "level": 2,
      "heading": "Summary: The Methodology"
    },
    "tags": []
  },
  {
    "content": "### When Building ANY Scanner:\n\n1. **Start with the Mold**: What does the setup look like?\n2. **Find A+ Examples**: Real trades that represent the mold\n3. **Extract Parameters**: Quantify what makes those trades work\n4. **Choose Structure**: Simple, Function, or Class-based\n5. **Implement**: Write the code\n6. **Validate**: Check against A+ examples\n7. **Debug**: Use parameter checking to fix issues\n8. **Expand**: Run on historical data\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Usage::Summary: The Methodology::When Building ANY Scanner:",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "example",
    "heading_path": [
      "Usage",
      "Summary: The Methodology",
      "When Building ANY Scanner:"
    ],
    "metadata": {
      "level": 3,
      "heading": "When Building ANY Scanner:"
    },
    "tags": [
      "scanner",
      "pattern",
      "code"
    ]
  },
  {
    "content": "### Key Principles:\n\n1. **Flat Conditions**: Never nest if-statements\n2. **Named Parameters**: No magic numbers\n3. **Per-Ticker Operations**: Always group by ticker\n4. **Preserve Historical**: Keep historical data for calculations\n5. **Validate Continuously**: Always check against A+ examples\n6. **Debug Visually**: Look at charts to verify\n\n---\n\n**Document Status**: COMPLETE\n**Version**: 1.0\n**Last Updated**: 2026-01-29\n",
    "chunk_id": "EDGEDEV_CODE_STRUCTURE_GUIDE.md::Usage::Summary: The Methodology::Key Principles:",
    "source_file": "EDGEDEV_CODE_STRUCTURE_GUIDE.md",
    "chunk_type": "example",
    "heading_path": [
      "Usage",
      "Summary: The Methodology",
      "Key Principles:"
    ],
    "metadata": {
      "level": 3,
      "heading": "Key Principles:"
    },
    "tags": []
  },
  {
    "content": "# EdgeDev Backtesting & Optimization Gold Standard\n**Complete Framework for Strategy Validation**\n\n**Version**: 1.0\n**Date**: 2026-01-29\n**Status**: COMPLETE - Ready for Implementation\n\n---\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard"
    ],
    "metadata": {
      "level": 1,
      "heading": "EdgeDev Backtesting & Optimization Gold Standard"
    },
    "tags": [
      "backtest",
      "strategy",
      "optimization"
    ]
  },
  {
    "content": "## Table of Contents\n\n1. [Overview](#overview)\n2. [Backtest Types](#backtest-types)\n3. [Parameter Optimization](#parameter-optimization)\n4. [Walk-Forward Testing](#walk-forward-testing)\n5. [Forward Testing & Paper Trading](#forward-testing--paper-trading)\n6. [Overfitting Prevention](#overfitting-prevention)\n7. [Out-of-Sample Testing](#out-of-sample-testing)\n8. [Regime Analysis](#regime-analysis)\n9. [Monte Carlo Simulation](#monte-carlo-simulation)\n10. [Performance Metrics](#performance-metrics)\n11. [Validation Workflow](#validation-workflow)\n\n---\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Table of Contents",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "example",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Table of Contents"
    ],
    "metadata": {
      "level": 2,
      "heading": "Table of Contents"
    },
    "tags": [
      "backtest",
      "strategy",
      "indicator",
      "optimization"
    ]
  },
  {
    "content": "## Overview\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Overview",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Overview"
    ],
    "metadata": {
      "level": 2,
      "heading": "Overview"
    },
    "tags": []
  },
  {
    "content": "### The Validation Pyramid\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    VALIDATION PYRAMID                                   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                         \u2502\n\u2502                    \u25b2\u25b2\u25b2                                                   \u2502\n\u2502                   \u25b2 PRODUCTION                                         \u2502\n\u2502                  \u25b2 Forward Testing (Paper Trading)                     \u2502\n\u2502                 \u25b2                                                      \u2502\n\u2502                \u25b2 Walk-Forward Testing                                   \u2502\n\u2502               \u25bc                                                        \u2502\n\u2502              \u25bc Out-of-Sample Testing                                    \u2502\n\u2502             \u25bc                                                           \u2502\n\u2502            \u25bc In-Sample Backtesting                                     \u2502\n\u2502           \u25bc                                                             \u2502\n\u2502          \u25bc\u25bc\u25bc                                                           \u2502\n\u2502                                                                         \u2502\n\u2502  Each level validates the strategy is robust before moving up.         \u2502\n\u2502                                                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Overview::The Validation Pyramid",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Overview",
      "The Validation Pyramid"
    ],
    "metadata": {
      "level": 3,
      "heading": "The Validation Pyramid"
    },
    "tags": [
      "backtest",
      "strategy",
      "pyramiding"
    ]
  },
  {
    "content": "### Core Principles\n\n1. **No Single Metric**: Never rely on one metric (e.g., just win rate or total return)\n2. **Out-of-Sample Validation**: Always test on unseen data\n3. **Regime Awareness**: Understand performance in different market conditions\n4. **Overfitting Detection**: Watch for too many parameters, curve fitting\n5. **Realistic Assumptions**: Slippage, commissions, partial fills\n\n---\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Overview::Core Principles",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "example",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Overview",
      "Core Principles"
    ],
    "metadata": {
      "level": 3,
      "heading": "Core Principles"
    },
    "tags": [
      "indicator",
      "execution"
    ]
  },
  {
    "content": "## Backtest Types\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Backtest Types",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Backtest Types"
    ],
    "metadata": {
      "level": 2,
      "heading": "Backtest Types"
    },
    "tags": [
      "backtest"
    ]
  },
  {
    "content": "### Type 1: Simple P&L Simulation (Quick Validation)\n\n**Purpose**: Fast validation of setup quality\n**Execution Time**: 1-5 seconds\n**Data Required**: Daily OHLCV only\n\n**When to Use**:\n- Initial pattern validation\n- Quick parameter checks\n- A+ example verification",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Backtest Types::Type 1: Simple P&L Simulation (Quick Validation)::chunk0",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "example",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Backtest Types",
      "Type 1: Simple P&L Simulation (Quick Validation)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Type 1: Simple P&L Simulation (Quick Validation)"
    },
    "tags": [
      "scanner",
      "backtest",
      "strategy",
      "indicator",
      "pattern",
      "code",
      "risk",
      "execution"
    ]
  },
  {
    "content": "Fast validation of setup quality\n**Execution Time**: 1-5 seconds\n**Data Required**: Daily OHLCV only\n\n**When to Use**:\n- Initial pattern validation\n- Quick parameter checks\n- A+ example verification\n\n\n\n[...previous chunk overlap...]\n\n**Code Structure**:\n```python\nclass SimpleBacktest:\n    \"\"\"Fast daily-bar backtest for initial validation\"\"\"\n\n    def __init__(self, config):\n        self.risk_per_trade_r = 1.0  # 1R risk\n        self.commission_per_share = 0.005\n        self.start_capital = 100000\n\n    def run_backtest(self, scan_results):\n        \"\"\"\n        Simple P&L calculation using daily bars only.\n\n        Entry: Close on signal day (D0)\n        Exit: Next day open (D+1)\n        \"\"\"\n        trades = []\n\n        for signal in scan_results:\n            entry_price = signal['close']  # Enter at D0 close\n            exit_price = signal['next_open']  # Exit at D+1 open\n\n            # Calculate P&L\n            if signal['direction'] == 'SHORT':\n                pnl = (entry_price - exit_price) / entry_price\n            else:\n                pnl = (exit_price - entry_price) / entry_price\n\n            r_multiple = pnl / self.risk_per_trade_r\n\n            trades.append({\n                'ticker': signal['ticker'],\n                'date': signal['date'],\n                'entry': entry_price,\n                'exit': exit_price,\n                'pnl_pct': pnl * 100,\n                'r_multiple': r_multiple\n            })\n\n        return self._calculate_metrics(trades)\n\n    def _calculate_metrics(self, trades):\n        \"\"\"Calculate standard backtest metrics\"\"\"\n        df = pd.DataFrame(trades)\n\n        winners = df[df['r_multiple'] > 0]\n        losers = df[df['r_multiple'] <= 0]\n\n        return {\n            'total_trades': len(df),\n            'win_rate': len(winners) / len(df) if df else 0,\n            'avg_win': winners['r_multiple'].mean() if len(winners) > 0 else 0,\n            'avg_loss': losers['r_multiple'].mean() if len(losers) > 0 else 0,\n            'total_r': df['r_multiple'].sum(),\n            'expectancy': df['r_multiple'].mean(),\n            'max_drawdown_r': self._calculate_max_dd(df['r_multiple']),\n        }\n```",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Backtest Types::Type 1: Simple P&L Simulation (Quick Validation)::chunk1",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Backtest Types",
      "Type 1: Simple P&L Simulation (Quick Validation)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Type 1: Simple P&L Simulation (Quick Validation)"
    },
    "tags": [
      "scanner",
      "backtest",
      "strategy",
      "indicator",
      "pattern",
      "code",
      "risk",
      "execution"
    ]
  },
  {
    "content": "s) > 0 else 0,\n            'total_r': df['r_multiple'].sum(),\n            'expectancy': df['r_multiple'].mean(),\n            'max_drawdown_r': self._calculate_max_dd(df['r_multiple']),\n        }\n```\n\n\n\n[...previous chunk overlap...]\n\n**Limitations**:\n- No intraday exit logic\n- No stops/targets\n- Unrealistic execution (close/open)\n- **NOT for production decisions**\n\n---",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Backtest Types::Type 1: Simple P&L Simulation (Quick Validation)::chunk2",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Backtest Types",
      "Type 1: Simple P&L Simulation (Quick Validation)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Type 1: Simple P&L Simulation (Quick Validation)"
    },
    "tags": [
      "scanner",
      "backtest",
      "strategy",
      "indicator",
      "pattern",
      "code",
      "risk",
      "execution"
    ]
  },
  {
    "content": "### Type 2: Enhanced Intraday Backtest (Production Quality)\n\n**Purpose**: Realistic simulation with intraday exits\n**Execution Time**: 30-120 seconds (depends on API calls)\n**Data Required**: Daily OHLCV + Intraday minute bars\n\n**When to Use**:\n- Production validation\n- Parameter optimization\n- Strategy comparison",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Backtest Types::Type 2: Enhanced Intraday Backtest (Production Quality)::chunk0",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Backtest Types",
      "Type 2: Enhanced Intraday Backtest (Production Quality)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Type 2: Enhanced Intraday Backtest (Production Quality)"
    },
    "tags": [
      "scanner",
      "backtest",
      "strategy",
      "indicator",
      "code",
      "optimization",
      "risk",
      "position",
      "execution"
    ]
  },
  {
    "content": "Execution Time**: 30-120 seconds (depends on API calls)\n**Data Required**: Daily OHLCV + Intraday minute bars\n\n**When to Use**:\n- Production validation\n- Parameter optimization\n- Strategy comparison\n\n\n\n[...previous chunk overlap...]\n\n**Code Structure**:\n```python\nclass EnhancedBacktest:\n    \"\"\"Production backtest with realistic intraday execution\"\"\"\n\n    def __init__(self, config):\n        self.api_key = config['polygon_api_key']\n        self.risk_per_trade_dollars = 1000\n        self.commission_per_share = 0.005\n\n        # Exit strategy parameters\n        self.profit_target_atr = 2.0\n        self.stop_loss_atr = 0.8\n        self.trailing_stop_atr = 0.5\n        self.time_exit_minutes = 240\n        self.volume_exit_threshold = 0.3\n\n    def run_backtest(self, scan_results):\n        \"\"\"\n        Realistic backtest using intraday data.\n\n        For each signal:\n        1. Fetch intraday minute bars\n        2. Calculate entry price (first 30 min logic)\n        3. Simulate exits (stop, target, trailing, time, volume)\n        4. Calculate realistic P&L with commissions\n        \"\"\"\n        all_trades = []\n\n        for signal in scan_results:\n            # Fetch intraday data\n            intraday_data = self._fetch_intraday(\n                signal['ticker'],\n                signal['date']\n            )\n\n            if not intraday_data:\n                continue\n\n            # Simulate trade\n            trade_result = self._simulate_trade(\n                signal=signal,\n                intraday_data=intraday_data\n            )\n\n            if trade_result:\n                all_trades.append(trade_result)\n\n        return self._calculate_comprehensive_metrics(all_trades)\n\n    def _simulate_trade(self, signal, intraday_data):\n        \"\"\"Simulate single trade with realistic exits\"\"\"\n        # Entry logic (first 30 minutes)\n        entry = self._calculate_entry(signal, intraday_data)\n\n        # Position sizing\n        atr = signal['atr']\n        risk_amount = atr * self.stop_loss_atr\n        shares = int(self.risk_per_trade_dollars / risk_amount)\n\n        # Calculate exit levels\n        profit_target = entry['price'] + (atr * self.profit_target_atr)\n        stop_loss = entry['price'] - (atr * self.stop_loss_atr)\n        trailing_stop = entry['price'] - (atr * self.trailing_stop_atr)\n\n        # Simulate through the day\n        highest_price = entry['price']\n\n        for bar in intraday_data[entry['bar_index']+1:]:\n            # Update trailing stop\n            if bar['high'] > highest_price:\n                highest_price = bar['high']\n                trailing_stop = highest_price - (atr * self.trailing_stop_atr)\n\n            # Check exits (in priority order)\n            if bar['low'] <= stop_loss:\n                exit_price = stop_loss\n                exit_reason = 'Stop Loss'\n                break\n            elif bar['high'] >= profit_target:\n                exit_price = profit_target\n                exit_reason = 'Profit Target'\n                break\n            elif bar['low'] <= trailing_stop:\n                exit_price = trailing_stop\n                exit_reason = 'Trailing Stop'\n                break\n            elif self._time_exit_triggered(entry, bar):\n                exit_price = bar['close']\n                exit_reason = 'Time Exit'\n                break\n            elif self._volume_exit_triggered(entry, bar):\n                exit_price = bar['close']\n                exit_reason = 'Volume Exit'\n                break\n        else:\n            # EOD exit\n            exit_price = intraday_data[-1]['close']\n            exit_reason = 'End of Day'\n\n        # Calculate P&L\n        gross_pnl = (exit_price - entry['price']) * shares\n        commission = shares * self.commission_per_share * 2  # Round trip\n        net_pnl = gross_pnl - commission\n\n        r_multiple = net_pnl / self.risk_per_trade_dollars\n\n        return {\n            'ticker': signal['ticker'],\n            'date': signal['date'],\n            'entry_price': entry['price'],\n            'entry_time': entry['time'],\n            'exit_price': exit_price,\n            'exit_time': bar['datetime'],\n            'exit_reason': exit_reason,\n            'shares': shares,\n            'gross_pnl': gross_pnl,\n            'commission': commission,\n            'net_pnl': net_pnl,\n            'r_multiple': r_multiple,\n            'holding_minutes': (bar['datetime'] - entry['time']).total_seconds() / 60,\n            'highest_price': highest_price,\n            'atr': atr\n        }\n```",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Backtest Types::Type 2: Enhanced Intraday Backtest (Production Quality)::chunk1",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Backtest Types",
      "Type 2: Enhanced Intraday Backtest (Production Quality)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Type 2: Enhanced Intraday Backtest (Production Quality)"
    },
    "tags": [
      "scanner",
      "backtest",
      "strategy",
      "indicator",
      "code",
      "optimization",
      "risk",
      "position",
      "execution"
    ]
  },
  {
    "content": "'r_multiple': r_multiple,\n            'holding_minutes': (bar['datetime'] - entry['time']).total_seconds() / 60,\n            'highest_price': highest_price,\n            'atr': atr\n        }\n```\n\n\n\n[...previous chunk overlap...]\n\n**Key Features**:\n- Realistic entry logic (first 30 min)\n- Multiple exit strategies\n- Position sizing based on volatility\n- Commission calculations\n- Partial fills (optional)\n- Slippage modeling (optional)\n\n---",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Backtest Types::Type 2: Enhanced Intraday Backtest (Production Quality)::chunk2",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Backtest Types",
      "Type 2: Enhanced Intraday Backtest (Production Quality)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Type 2: Enhanced Intraday Backtest (Production Quality)"
    },
    "tags": [
      "scanner",
      "backtest",
      "strategy",
      "indicator",
      "code",
      "optimization",
      "risk",
      "position",
      "execution"
    ]
  },
  {
    "content": "## Parameter Optimization\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Parameter Optimization",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Parameter Optimization"
    ],
    "metadata": {
      "level": 2,
      "heading": "Parameter Optimization"
    },
    "tags": [
      "optimization"
    ]
  },
  {
    "content": "### Goal\n\nFind parameters that maximize edge while minimizing overfitting.\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Parameter Optimization::Goal",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Parameter Optimization",
      "Goal"
    ],
    "metadata": {
      "level": 3,
      "heading": "Goal"
    },
    "tags": []
  },
  {
    "content": "### Optimization Methods\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Parameter Optimization::Optimization Methods",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Parameter Optimization",
      "Optimization Methods"
    ],
    "metadata": {
      "level": 3,
      "heading": "Optimization Methods"
    },
    "tags": [
      "optimization"
    ]
  },
  {
    "content": "#### Method 1: Grid Search (Exhaustive)\n\n**Best for**: Small parameter spaces (2-4 parameters)",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Parameter Optimization::Optimization Methods::Method 1: Grid Search (Exhaustive)::chunk0",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Parameter Optimization",
      "Optimization Methods",
      "Method 1: Grid Search (Exhaustive)"
    ],
    "metadata": {
      "level": 4,
      "heading": "Method 1: Grid Search (Exhaustive)"
    },
    "tags": [
      "scanner",
      "backtest",
      "indicator",
      "code",
      "optimization"
    ]
  },
  {
    "content": "#### Method 1: Grid Search (Exhaustive)\n\n**Best for**: Small parameter spaces (2-4 parameters)\n\n```python\nclass GridSearchOptimizer:\n    \"\"\"Exhaustive grid search over parameter space\"\"\"\n\n    def __init__(self, scanner, backtest):\n        self.scanner = scanner\n        self.backtest = backtest\n\n    def optimize(self, param_grid, train_start, train_end, validation_start, validation_end):\n        \"\"\"\n        Grid search over all parameter combinations.\n\n        param_grid example:\n        {\n            'min_gap': [0.02, 0.025, 0.03, 0.035, 0.04],\n            'max_hold_range': [0.0025, 0.003, 0.0035, 0.004],\n            'min_volume_ratio': [1.5, 2.0, 2.5]\n        }\n        \"\"\"\n        # Generate all combinations\n        import itertools\n        param_names = list(param_grid.keys())\n        param_values = list(param_grid.values())\n        all_combinations = list(itertools.product(*param_values))\n\n        results = []\n\n        for i, combination in enumerate(all_combinations):\n            # Create param dict\n            params = dict(zip(param_names, combination))\n\n            print(f\"Testing {i+1}/{len(all_combinations)}: {params}\")\n\n            # Update scanner params\n            self.scanner.params.update(params)\n\n            # Run scan on training data\n            train_signals = self.scanner.run_scan(train_start, train_end)\n\n            if len(train_signals) < 10:\n                # Too few signals, skip\n                continue\n\n            # Run backtest\n            train_results = self.backtest.run_backtest(train_signals)\n\n            # Run validation\n            val_signals = self.scanner.run_scan(validation_start, validation_end)\n            val_results = self.backtest.run_backtest(val_signals)\n\n            results.append({\n                'params': params,\n                'train_metrics': train_results,\n                'val_metrics': val_results,\n                'overfit_score': self._calculate_overfit_score(train_results, val_results)\n            })\n\n        # Sort by validation performance\n        results.sort(key=lambda x: x['val_metrics']['expectancy'], reverse=True)\n\n        return results\n```",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Parameter Optimization::Optimization Methods::Method 1: Grid Search (Exhaustive)::chunk1",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Parameter Optimization",
      "Optimization Methods",
      "Method 1: Grid Search (Exhaustive)"
    ],
    "metadata": {
      "level": 4,
      "heading": "Method 1: Grid Search (Exhaustive)"
    },
    "tags": [
      "scanner",
      "backtest",
      "indicator",
      "code",
      "optimization"
    ]
  },
  {
    "content": "#### Method 2: Random Search (Efficient)\n\n**Best for**: Larger parameter spaces (5+ parameters)\n\n```python\nclass RandomSearchOptimizer:\n    \"\"\"Random search over parameter space\"\"\"\n\n    def optimize(self, param_bounds, n_iterations=50, train_start, train_end):\n        \"\"\"\n        Randomly sample parameter space.\n\n        param_bounds example:\n        {\n            'min_gap': (0.02, 0.05),  # (min, max)\n            'max_hold_range': (0.002, 0.005),\n            'min_volume_ratio': (1.0, 3.0)\n        }\n        \"\"\"\n        results = []\n\n        for i in range(n_iterations):\n            # Random sample\n            params = {\n                k: np.random.uniform(v[0], v[1])\n                for k, v in param_bounds.items()\n            }\n\n            # Test parameters\n            # ... (same as grid search)\n\n            results.append({\n                'params': params,\n                'metrics': metrics\n            })\n\n        return sorted(results, key=lambda x: x['metrics']['expectancy'], reverse=True)\n```\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Parameter Optimization::Optimization Methods::Method 2: Random Search (Efficient)",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Parameter Optimization",
      "Optimization Methods",
      "Method 2: Random Search (Efficient)"
    ],
    "metadata": {
      "level": 4,
      "heading": "Method 2: Random Search (Efficient)"
    },
    "tags": [
      "indicator",
      "code",
      "optimization"
    ]
  },
  {
    "content": "#### Method 3: Bayesian Optimization (Smart)\n\n**Best for**: Expensive-to-evaluate functions\n\n```python\nclass BayesianOptimizer:\n    \"\"\"Bayesian optimization using Gaussian Process\"\"\"\n\n    def optimize(self, param_bounds, n_iterations=30):\n        \"\"\"\n        Use previous results to guide next parameter choice.\n        More efficient than random/grid search.\n        \"\"\"\n        # Requires scikit-optimize or similar library\n        from skopt import gp_minimize\n\n        # Define objective function\n        def objective(params_list):\n            params = dict(zip(param_bounds.keys(), params_list))\n\n            # Run backtest\n            metrics = self._test_params(params)\n\n            # Minimize negative expectancy\n            return -metrics['expectancy']\n\n        # Run optimization\n        result = gp_minimize(\n            objective,\n            dimensions=[list(v) for v in param_bounds.values()],\n            n_calls=n_iterations,\n            random_state=42\n        )\n\n        return {\n            'best_params': dict(zip(param_bounds.keys(), result.x)),\n            'best_expectancy': -result.fun\n        }\n```\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Parameter Optimization::Optimization Methods::Method 3: Bayesian Optimization (Smart)",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Parameter Optimization",
      "Optimization Methods",
      "Method 3: Bayesian Optimization (Smart)"
    ],
    "metadata": {
      "level": 4,
      "heading": "Method 3: Bayesian Optimization (Smart)"
    },
    "tags": [
      "backtest",
      "indicator",
      "code",
      "optimization"
    ]
  },
  {
    "content": "### Optimization Best Practices\n\n1. **Train/Validation Split**:\n   - Train: 70% of data (for optimization)\n   - Validation: 30% of data (for selection)\n\n2. **Parameter Ranges**:\n   - Use realistic ranges based on A+ examples\n   - Don't search too wide (waste of time)\n   - Don't search too narrow (miss optimal)\n\n3. **Minimum Signals**:\n   - Require at least 30-50 signals in training\n   - Too few = unreliable statistics\n\n4. **Multiple Metrics**:\n   - Optimize for expectancy (primary)\n   - Consider win rate, max DD, Sharpe (secondary)\n\n5. **Overfitting Detection**:\n   - Compare train vs validation performance\n   - Large gap = overfitting\n\n---\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Parameter Optimization::Optimization Best Practices",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "example",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Parameter Optimization",
      "Optimization Best Practices"
    ],
    "metadata": {
      "level": 3,
      "heading": "Optimization Best Practices"
    },
    "tags": [
      "indicator",
      "optimization"
    ]
  },
  {
    "content": "## Walk-Forward Testing\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Walk-Forward Testing",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Walk-Forward Testing"
    ],
    "metadata": {
      "level": 2,
      "heading": "Walk-Forward Testing"
    },
    "tags": [
      "backtest"
    ]
  },
  {
    "content": "### What Is Walk-Forward?\n\nRolling window validation that simulates real-time trading:\n- Train on period 1\n- Test on period 2\n- Roll forward and repeat\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Walk-Forward Testing::What Is Walk-Forward?",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Walk-Forward Testing",
      "What Is Walk-Forward?"
    ],
    "metadata": {
      "level": 3,
      "heading": "What Is Walk-Forward?"
    },
    "tags": [
      "strategy"
    ]
  },
  {
    "content": "### Why Walk-Forward?\n\n- **Realistic**: Simulates actual trading process\n- **Adaptive**: Parameters adapt over time\n- **Robust**: Tests stability across periods\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Walk-Forward Testing::Why Walk-Forward?",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Walk-Forward Testing",
      "Why Walk-Forward?"
    ],
    "metadata": {
      "level": 3,
      "heading": "Why Walk-Forward?"
    },
    "tags": [
      "strategy"
    ]
  },
  {
    "content": "### Walk-Forward Implementation",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Walk-Forward Testing::Walk-Forward Implementation::chunk0",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Walk-Forward Testing",
      "Walk-Forward Implementation"
    ],
    "metadata": {
      "level": 3,
      "heading": "Walk-Forward Implementation"
    },
    "tags": [
      "scanner",
      "backtest",
      "strategy",
      "indicator",
      "code",
      "optimization"
    ]
  },
  {
    "content": "### Walk-Forward Implementation\n\n```python\nclass WalkForwardValidator:\n    \"\"\"Rolling window validation for strategy robustness\"\"\"\n\n    def __init__(self, scanner, backtest, optimizer):\n        self.scanner = scanner\n        self.backtest = backtest\n        self.optimizer = optimizer\n\n    def run_walk_forward(\n        self,\n        full_start,\n        full_end,\n        train_period_months=12,\n        test_period_months=3,\n        step_months=3\n    ):\n        \"\"\"\n        Walk-forward validation.\n\n        Example:\n        - Train: Jan 2022 - Dec 2022 (12 months)\n        - Test: Jan 2023 - Mar 2023 (3 months)\n        - Step forward 3 months\n        - Repeat\n\n        This simulates:\n        1. Optimize on past 12 months\n        2. Trade next 3 months with those params\n        3. Re-optimize on most recent 12 months\n        4. Trade next 3 months\n        \"\"\"\n        results = []\n\n        current_date = pd.to_datetime(full_start)\n\n        while True:\n            # Define train period\n            train_start = current_date\n            train_end = current_date + pd.DateOffset(months=train_period_months)\n\n            # Define test period\n            test_start = train_end\n            test_end = test_start + pd.DateOffset(months=test_period_months)\n\n            # Check if we've gone past full_end\n            if test_end > pd.to_datetime(full_end):\n                break\n\n            print(f\"\\n{'='*60}\")\n            print(f\"Train: {train_start.date()} to {train_end.date()}\")\n            print(f\"Test:  {test_start.date()} to {test_end.date()}\")\n            print(f\"{'='*60}\\n\")\n\n            # Optimize on training period\n            print(\"Optimizing parameters...\")\n            best_params = self.optimizer.optimize(\n                train_start=train_start.strftime('%Y-%m-%d'),\n                train_end=train_end.strftime('%Y-%m-%d'),\n                validation_start=test_start.strftime('%Y-%m-%d'),\n                validation_end=test_end.strftime('%Y-%m-%d')\n            )[0]['params']\n\n            print(f\"Best params: {best_params}\")\n\n            # Apply to test period\n            self.scanner.params.update(best_params)\n            test_signals = self.scanner.run_scan(\n                test_start.strftime('%Y-%m-%d'),\n                test_end.strftime('%Y-%m-%d')\n            )\n\n            # Backtest test period\n            test_results = self.backtest.run_backtest(test_signals)\n\n            results.append({\n                'train_start': train_start,\n                'train_end': train_end,\n                'test_start': test_start,\n                'test_end': test_end,\n                'params': best_params,\n                'test_signals': len(test_signals),\n                'test_metrics': test_results\n            })\n\n            # Step forward\n            current_date = current_date + pd.DateOffset(months=step_months)\n\n        # Analyze walk-forward results\n        return self._analyze_walk_forward(results)\n\n    def _analyze_walk_forward(self, results):\n        \"\"\"Analyze walk-forward performance\"\"\"\n\n        # Aggregate metrics\n        total_trades = sum(r['test_signals'] for r in results)\n        avg_expectancy = np.mean([r['test_metrics']['expectancy'] for r in results])\n        expectancy_std = np.std([r['test_metrics']['expectancy'] for r in results])\n\n        # Consistency check\n        profitable_periods = sum(\n            1 for r in results\n            if r['test_metrics']['expectancy'] > 0\n        )\n        consistency_pct = profitable_periods / len(results) * 100\n\n        # Parameter stability\n        param_stability = self._check_param_stability(results)\n\n        return {\n            'total_periods': len(results),\n            'total_trades': total_trades,\n            'avg_trades_per_period': total_trades / len(results),\n            'avg_expectancy': avg_expectancy,\n            'expectancy_std': expectancy_std,\n            'expectancy_std_pct': (expectancy_std / abs(avg_expectancy) * 100) if avg_expectancy != 0 else float('inf'),\n            'profitable_periods': profitable_periods,\n            'consistency_pct': consistency_pct,\n            'param_stability': param_stability,\n            'period_results': results\n        }\n```",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Walk-Forward Testing::Walk-Forward Implementation::chunk1",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Walk-Forward Testing",
      "Walk-Forward Implementation"
    ],
    "metadata": {
      "level": 3,
      "heading": "Walk-Forward Implementation"
    },
    "tags": [
      "scanner",
      "backtest",
      "strategy",
      "indicator",
      "code",
      "optimization"
    ]
  },
  {
    "content": "### Walk-Forward Success Criteria\n\n| Metric | Good | Warning | Bad |\n|--------|------|---------|-----|\n| **Consistency** | >70% periods profitable | 50-70% | <50% |\n| **Expectancy Std** | <50% of mean | 50-100% | >100% |\n| **Parameter Stability** | Stable across periods | Some drift | Highly variable |\n| **Signals/Period** | 20-100 | 10-20 or 100-200 | <10 or >200 |\n\n---\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Walk-Forward Testing::Walk-Forward Success Criteria",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Walk-Forward Testing",
      "Walk-Forward Success Criteria"
    ],
    "metadata": {
      "level": 3,
      "heading": "Walk-Forward Success Criteria"
    },
    "tags": [
      "indicator"
    ]
  },
  {
    "content": "## Forward Testing & Paper Trading\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Forward Testing & Paper Trading",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Forward Testing & Paper Trading"
    ],
    "metadata": {
      "level": 2,
      "heading": "Forward Testing & Paper Trading"
    },
    "tags": [
      "backtest",
      "strategy"
    ]
  },
  {
    "content": "### What Is Forward Testing?\n\nTesting the final strategy on NEW data (after all optimization is done).\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Forward Testing & Paper Trading::What Is Forward Testing?",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Forward Testing & Paper Trading",
      "What Is Forward Testing?"
    ],
    "metadata": {
      "level": 3,
      "heading": "What Is Forward Testing?"
    },
    "tags": [
      "backtest",
      "strategy",
      "optimization"
    ]
  },
  {
    "content": "### Forward Testing Workflow",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Forward Testing & Paper Trading::Forward Testing Workflow::chunk0",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Forward Testing & Paper Trading",
      "Forward Testing Workflow"
    ],
    "metadata": {
      "level": 3,
      "heading": "Forward Testing Workflow"
    },
    "tags": [
      "scanner",
      "backtest",
      "strategy",
      "indicator",
      "code",
      "optimization"
    ]
  },
  {
    "content": "### Forward Testing Workflow\n\n```python\nclass ForwardTester:\n    \"\"\"Paper trading on new, unseen data\"\"\"\n\n    def __init__(self, scanner, backtest, final_params):\n        self.scanner = scanner\n        self.backtest = backtest\n        self.final_params = final_params\n\n    def run_forward_test(self, start_date, min_trades=30):\n        \"\"\"\n        Run on new data starting from start_date.\n\n        CRITICAL: This data must NOT have been used in:\n        - Scanner development\n        - Parameter optimization\n        - Walk-forward testing\n\n        It must be truly new, forward data.\n        \"\"\"\n        # Apply final parameters\n        self.scanner.params.update(self.final_params)\n\n        # Run scan on forward period\n        signals = self.scanner.run_scan(start_date, datetime.now().strftime('%Y-%m-%d'))\n\n        if len(signals) < min_trades:\n            print(f\"\u26a0\ufe0f  Warning: Only {len(signals)} signals in forward test\")\n            print(f\"Recommend waiting for at least {min_trades} signals\")\n\n        # Run backtest\n        results = self.backtest.run_backtest(signals)\n\n        # Compare to in-sample expectations\n        comparison = self._compare_to_in_sample(results)\n\n        return {\n            'forward_results': results,\n            'comparison_to_expected': comparison,\n            'passed': comparison['is_acceptable'],\n            'recommendation': self._generate_recommendation(comparison)\n        }\n\n    def _compare_to_in_sample(self, forward_results):\n        \"\"\"Compare forward results to in-sample expectations\"\"\"\n\n        # These would be stored from optimization/walk-forward\n        expected_expectancy = 0.15  # Example\n        expected_win_rate = 0.60    # Example\n\n        # Calculate acceptable ranges (\u00b120%)\n        expectancy_range = (expected_expectancy * 0.8, expected_expectancy * 1.2)\n        win_rate_range = (expected_win_rate * 0.8, expected_win_rate * 1.2)\n\n        forward_expectancy = forward_results['expectancy']\n        forward_win_rate = forward_results['win_rate']\n\n        # Check if within range\n        expectancy_ok = expectancy_range[0] <= forward_expectancy <= expectancy_range[1]\n        win_rate_ok = win_rate_range[0] <= forward_win_rate <= win_rate_range[1]\n\n        return {\n            'expected_expectancy': expected_expectancy,\n            'forward_expectancy': forward_expectancy,\n            'expectancy_diff_pct': ((forward_expectancy - expected_expectancy) / expected_expectancy * 100),\n            'expectancy_ok': expectancy_ok,\n            'expected_win_rate': expected_win_rate,\n            'forward_win_rate': forward_win_rate,\n            'win_rate_diff_pct': ((forward_win_rate - expected_win_rate) / expected_win_rate * 100),\n            'win_rate_ok': win_rate_ok,\n            'is_acceptable': expectancy_ok and win_rate_ok\n        }\n```",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Forward Testing & Paper Trading::Forward Testing Workflow::chunk1",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Forward Testing & Paper Trading",
      "Forward Testing Workflow"
    ],
    "metadata": {
      "level": 3,
      "heading": "Forward Testing Workflow"
    },
    "tags": [
      "scanner",
      "backtest",
      "strategy",
      "indicator",
      "code",
      "optimization"
    ]
  },
  {
    "content": "### Forward Testing Success Criteria\n\n1. **Performance within 20% of expected** (expectancy, win rate)\n2. **At least 30 trades** (statistical significance)\n3. **No regime change detected** (market structure similar)\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Forward Testing & Paper Trading::Forward Testing Success Criteria",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Forward Testing & Paper Trading",
      "Forward Testing Success Criteria"
    ],
    "metadata": {
      "level": 3,
      "heading": "Forward Testing Success Criteria"
    },
    "tags": [
      "backtest"
    ]
  },
  {
    "content": "### Paper Trading (Live Simulation)\n\nBefore real money, do paper trading:\n\n```python\nclass PaperTrader:\n    \"\"\"Simulated live trading without real money\"\"\"\n\n    def __init__(self, scanner, final_params, execution_platform):\n        self.scanner = scanner\n        self.final_params = final_params\n        self.execution = execution_platform  # Simulated execution\n        self.positions = {}\n\n    def run_paper_trading(self, duration_days=30):\n        \"\"\"\n        Run paper trading for specified duration.\n\n        This is the final test before real money.\n        Simulates:\n        - Daily signal generation\n        - Order placement (simulated)\n        - Position management\n        - P&L tracking\n        \"\"\"\n        start_date = datetime.now()\n        end_date = start_date + timedelta(days=duration_days)\n\n        while datetime.now() < end_date:\n            # Run daily scan\n            signals = self.scanner.run_scan(\n                datetime.now().strftime('%Y-%m-%d'),\n                datetime.now().strftime('%Y-%m-%d')\n            )\n\n            # Execute signals (simulated)\n            for signal in signals:\n                self._execute_signal(signal)\n\n            # Manage existing positions\n            self._manage_positions()\n\n            # Wait until next trading day\n            self._wait_until_next_trading_day()\n\n        # Calculate paper trading results\n        return self._calculate_paper_results()\n```\n\n---\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Forward Testing & Paper Trading::Paper Trading (Live Simulation)",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Forward Testing & Paper Trading",
      "Paper Trading (Live Simulation)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Paper Trading (Live Simulation)"
    },
    "tags": [
      "scanner",
      "strategy",
      "indicator",
      "code",
      "position",
      "execution"
    ]
  },
  {
    "content": "## Overfitting Prevention\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Overfitting Prevention",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Overfitting Prevention"
    ],
    "metadata": {
      "level": 2,
      "heading": "Overfitting Prevention"
    },
    "tags": []
  },
  {
    "content": "### What Is Overfitting?\n\nWhen a strategy performs well on historical data but fails in live trading because it's too closely fitted to past data patterns.\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Overfitting Prevention::What Is Overfitting?",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Overfitting Prevention",
      "What Is Overfitting?"
    ],
    "metadata": {
      "level": 3,
      "heading": "What Is Overfitting?"
    },
    "tags": [
      "strategy",
      "pattern"
    ]
  },
  {
    "content": "### Overfitting Detection Methods\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Overfitting Prevention::Overfitting Detection Methods",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Overfitting Prevention",
      "Overfitting Detection Methods"
    ],
    "metadata": {
      "level": 3,
      "heading": "Overfitting Detection Methods"
    },
    "tags": []
  },
  {
    "content": "#### Method 1: Train/Validation Gap\n\n```python\ndef detect_overfitting_gap(train_metrics, val_metrics):\n    \"\"\"Check if validation performance is much worse than training\"\"\"\n\n    train_expectancy = train_metrics['expectancy']\n    val_expectancy = val_metrics['expectancy']\n\n    # Calculate gap\n    gap_pct = ((train_expectancy - val_expectancy) / train_expectancy) * 100\n\n    if gap_pct > 50:\n        return {\n            'overfit_detected': True,\n            'severity': 'HIGH',\n            'gap_pct': gap_pct,\n            'message': f'Validation expectancy {gap_pct:.1f}% worse than training'\n        }\n    elif gap_pct > 25:\n        return {\n            'overfit_detected': True,\n            'severity': 'MEDIUM',\n            'gap_pct': gap_pct,\n            'message': f'Validation expectancy {gap_pct:.1f}% worse than training'\n        }\n    else:\n        return {\n            'overfit_detected': False,\n            'severity': 'NONE',\n            'gap_pct': gap_pct\n        }\n```\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Overfitting Prevention::Overfitting Detection Methods::Method 1: Train/Validation Gap",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Overfitting Prevention",
      "Overfitting Detection Methods",
      "Method 1: Train/Validation Gap"
    ],
    "metadata": {
      "level": 4,
      "heading": "Method 1: Train/Validation Gap"
    },
    "tags": [
      "indicator",
      "code"
    ]
  },
  {
    "content": "#### Method 2: Parameter Count vs Signal Count\n\n```python\ndef detect_overfitting_params(n_params, n_signals):\n    \"\"\"Check if too many parameters for too few signals\"\"\"\n\n    # Rule of thumb: At least 10 signals per parameter\n    min_signals = n_params * 10\n\n    if n_signals < min_signals:\n        return {\n            'overfit_detected': True,\n            'reason': f'Too few signals ({n_signals}) for {n_params} parameters',\n            'recommendation': f'Need at least {min_signals} signals'\n        }\n    else:\n        return {\n            'overfit_detected': False\n        }\n```\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Overfitting Prevention::Overfitting Detection Methods::Method 2: Parameter Count vs Signal Count",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Overfitting Prevention",
      "Overfitting Detection Methods",
      "Method 2: Parameter Count vs Signal Count"
    ],
    "metadata": {
      "level": 4,
      "heading": "Method 2: Parameter Count vs Signal Count"
    },
    "tags": [
      "indicator",
      "code"
    ]
  },
  {
    "content": "#### Method 3: Holdout Test\n\n```python\ndef detect_overfitting_holdout(scanner, backtest, params):\n    \"\"\"Test on completely unseen holdout period\"\"\"\n\n    # Train on 2019-2022\n    train_results = backtest.run_backtest(\n        scanner.run_scan('2019-01-01', '2022-12-31', params)\n    )\n\n    # Holdout: 2023-2024 (completely unseen)\n    holdout_results = backtest.run_backtest(\n        scanner.run_scan('2023-01-01', '2024-12-31', params)\n    )\n\n    # Compare\n    train_expectancy = train_results['expectancy']\n    holdout_expectancy = holdout_results['expectancy']\n    degradation = ((train_expectancy - holdout_expectancy) / train_expectancy) * 100\n\n    if degradation > 40:\n        return {\n            'overfit_detected': True,\n            'degradation_pct': degradation,\n            'message': f'Expectancy degraded by {degradation:.1f}% on holdout'\n        }\n    else:\n        return {\n            'overfit_detected': False\n        }\n```\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Overfitting Prevention::Overfitting Detection Methods::Method 3: Holdout Test",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Overfitting Prevention",
      "Overfitting Detection Methods",
      "Method 3: Holdout Test"
    ],
    "metadata": {
      "level": 4,
      "heading": "Method 3: Holdout Test"
    },
    "tags": [
      "scanner",
      "backtest",
      "code"
    ]
  },
  {
    "content": "### Overfitting Prevention Rules\n\n1. **Limit Parameters**: Start with 3-5 parameters maximum\n2. **Minimum Signals**: 50+ signals in training, 30+ in validation\n3. **Train/Validation Split**: Always use separate datasets\n4. **Walk-Forward**: Test across multiple time periods\n5. **Simpler is Better**: Prefer simple models over complex ones\n\n---\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Overfitting Prevention::Overfitting Prevention Rules",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Overfitting Prevention",
      "Overfitting Prevention Rules"
    ],
    "metadata": {
      "level": 3,
      "heading": "Overfitting Prevention Rules"
    },
    "tags": [
      "indicator"
    ]
  },
  {
    "content": "## Out-of-Sample Testing\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Out-of-Sample Testing",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "example",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Out-of-Sample Testing"
    ],
    "metadata": {
      "level": 2,
      "heading": "Out-of-Sample Testing"
    },
    "tags": [
      "backtest"
    ]
  },
  {
    "content": "### Data Split Strategy\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    DATA SPLIT STRATEGY                                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                         \u2502\n\u2502  Total Data: 2019-2024 (6 years)                                        \u2502\n\u2502                                                                         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u2502\n\u2502  \u2502   TRAINING     \u2502   VALIDATION   \u2502   FORWARD TEST  \u2502                 \u2502\n\u2502  \u2502   (In-Sample)  \u2502   (Out-Sample) \u2502   (Out-Sample)  \u2502                 \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                 \u2502\n\u2502  \u2502 2019-2021 (3y) \u2502 2022 (1 year)  \u2502 2023-2024 (2y)  \u2502                 \u2502\n\u2502  \u2502   60%          \u2502     20%        \u2502      20%        \u2502                 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2502\n\u2502                                                                         \u2502\n\u2502  Training:   Optimize parameters                                        \u2502\n\u2502  Validation: Select best parameters (unseen during training)            \u2502\n\u2502  Forward:    Final test (unseen during training AND validation)        \u2502\n\u2502                                                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Out-of-Sample Testing::Data Split Strategy",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Out-of-Sample Testing",
      "Data Split Strategy"
    ],
    "metadata": {
      "level": 3,
      "heading": "Data Split Strategy"
    },
    "tags": [
      "strategy",
      "optimization"
    ]
  },
  {
    "content": "### Out-of-Sample Implementation",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Out-of-Sample Testing::Out-of-Sample Implementation::chunk0",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "example",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Out-of-Sample Testing",
      "Out-of-Sample Implementation"
    ],
    "metadata": {
      "level": 3,
      "heading": "Out-of-Sample Implementation"
    },
    "tags": [
      "scanner",
      "backtest",
      "indicator",
      "code",
      "optimization"
    ]
  },
  {
    "content": "### Out-of-Sample Implementation\n\n```python\nclass OutOfSampleValidator:\n    \"\"\"Proper train/validation/forward split\"\"\"\n\n    def __init__(self, scanner, backtest, full_start, full_end):\n        self.scanner = scanner\n        self.backtest = backtest\n\n        # Calculate splits\n        total_days = (pd.to_datetime(full_end) - pd.to_datetime(full_start)).days\n        train_days = int(total_days * 0.6)\n        val_days = int(total_days * 0.2)\n\n        self.train_start = full_start\n        self.train_end = (pd.to_datetime(full_start) + timedelta(days=train_days)).strftime('%Y-%m-%d')\n        self.val_start = self.train_end\n        self.val_end = (pd.to_datetime(self.val_start) + timedelta(days=val_days)).strftime('%Y-%m-%d')\n        self.forward_start = self.val_end\n        self.forward_end = full_end\n\n    def run_validation(self, param_grid):\n        \"\"\"Full out-of-sample validation\"\"\"\n\n        print(f\"Training period:   {self.train_start} to {self.train_end}\")\n        print(f\"Validation period: {self.val_start} to {self.val_end}\")\n        print(f\"Forward period:   {self.forward_start} to {self.forward_end}\")\n\n        # Phase 1: Optimize on training data\n        print(\"\\n=== PHASE 1: OPTIMIZATION (Training) ===\")\n        optimizer = GridSearchOptimizer(self.scanner, self.backtest)\n        optimization_results = optimizer.optimize(\n            param_grid,\n            self.train_start, self.train_end,\n            self.val_start, self.val_end\n        )\n\n        # Phase 2: Select best params on validation\n        print(\"\\n=== PHASE 2: SELECTION (Validation) ===\")\n        best_params = optimization_results[0]['params']\n        val_metrics = optimization_results[0]['val_metrics']\n\n        print(f\"Best params: {best_params}\")\n        print(f\"Validation expectancy: {val_metrics['expectancy']:.3f}\")\n\n        # Phase 3: Forward test\n        print(\"\\n=== PHASE 3: FORWARD TEST (Out-of-Sample) ===\")\n        self.scanner.params.update(best_params)\n        forward_signals = self.scanner.run_scan(self.forward_start, self.forward_end)\n        forward_results = self.backtest.run_backtest(forward_signals)\n\n        print(f\"Forward expectancy: {forward_results['expectancy']:.3f}\")\n\n        # Compare\n        train_expectancy = optimization_results[0]['train_metrics']['expectancy']\n        val_expectancy = val_metrics['expectancy']\n        forward_expectancy = forward_results['expectancy']\n\n        # Check degradation\n        train_to_val = ((train_expectancy - val_expectancy) / train_expectancy) * 100\n        val_to_forward = ((val_expectancy - forward_expectancy) / val_expectancy) * 100\n\n        return {\n            'best_params': best_params,\n            'train_expectancy': train_expectancy,\n            'val_expectancy': val_expectancy,\n            'forward_expectancy': forward_expectancy,\n            'train_to_val_degradation': train_to_val,\n            'val_to_forward_degradation': val_to_forward,\n            'passed': abs(val_to_forward) < 30,  # Less than 30% degradation\n            'recommendation': self._generate_recommendation(val_to_forward)\n        }\n```",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Out-of-Sample Testing::Out-of-Sample Implementation::chunk1",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Out-of-Sample Testing",
      "Out-of-Sample Implementation"
    ],
    "metadata": {
      "level": 3,
      "heading": "Out-of-Sample Implementation"
    },
    "tags": [
      "scanner",
      "backtest",
      "indicator",
      "code",
      "optimization"
    ]
  },
  {
    "content": "d_degradation': val_to_forward,\n            'passed': abs(val_to_forward) < 30,  # Less than 30% degradation\n            'recommendation': self._generate_recommendation(val_to_forward)\n        }\n```\n\n\n\n[...previous chunk overlap...]\n\n---",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Out-of-Sample Testing::Out-of-Sample Implementation::chunk2",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Out-of-Sample Testing",
      "Out-of-Sample Implementation"
    ],
    "metadata": {
      "level": 3,
      "heading": "Out-of-Sample Implementation"
    },
    "tags": [
      "scanner",
      "backtest",
      "indicator",
      "code",
      "optimization"
    ]
  },
  {
    "content": "## Regime Analysis\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Regime Analysis",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Regime Analysis"
    ],
    "metadata": {
      "level": 2,
      "heading": "Regime Analysis"
    },
    "tags": []
  },
  {
    "content": "### What Are Market Regimes?\n\nDistinct market conditions that affect strategy performance:\n- **Bull**: Rising markets (SPY +10%+ over 3 months)\n- **Bear**: Falling markets (SPY -10%+ over 3 months)\n- **Choppy**: Range-bound (SPY \u00b15% over 3 months)\n- **High Volatility**: VIX > 25\n- **Low Volatility**: VIX < 15\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Regime Analysis::What Are Market Regimes?",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Regime Analysis",
      "What Are Market Regimes?"
    ],
    "metadata": {
      "level": 3,
      "heading": "What Are Market Regimes?"
    },
    "tags": [
      "strategy"
    ]
  },
  {
    "content": "### Regime Detection\n\n```python\nclass RegimeDetector:\n    \"\"\"Detect market regime for given date\"\"\"\n\n    def __init__(self, market_data):\n        \"\"\"\n        market_data: DataFrame with SPY and VIX data\n        \"\"\"\n        self.market_data = market_data\n\n    def get_regime(self, date):\n        \"\"\"Determine market regime on given date\"\"\"\n\n        # Get SPY performance over last 3 months\n        spy_3mo_change = self._get_spy_change(date, months=3)\n\n        # Get VIX level\n        vix = self._get_vix(date)\n\n        # Classify regime\n        if spy_3mo_change > 0.10:\n            trend = 'BULL'\n        elif spy_3mo_change < -0.10:\n            trend = 'BEAR'\n        else:\n            trend = 'CHOPPY'\n\n        if vix > 25:\n            volatility = 'HIGH_VOL'\n        elif vix < 15:\n            volatility = 'LOW_VOL'\n        else:\n            volatility = 'NORMAL_VOL'\n\n        return f\"{trend}_{volatility}\"\n\n    def analyze_strategy_by_regime(self, trades):\n        \"\"\"Analyze strategy performance across regimes\"\"\"\n\n        trades_df = pd.DataFrame(trades)\n\n        # Add regime to each trade\n        trades_df['regime'] = trades_df['date'].apply(self.get_regime)\n\n        # Group by regime\n        regime_stats = trades_df.groupby('regime').agg({\n            'r_multiple': ['count', 'mean', 'sum'],\n            'ticker': 'count'\n        }).round(3)\n\n        return regime_stats\n```\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Regime Analysis::Regime Detection",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Regime Analysis",
      "Regime Detection"
    ],
    "metadata": {
      "level": 3,
      "heading": "Regime Detection"
    },
    "tags": [
      "strategy",
      "code"
    ]
  },
  {
    "content": "### Regime-Based Strategy Adjustment\n\n```python\nclass RegimeAwareStrategy:\n    \"\"\"Adjust strategy based on market regime\"\"\"\n\n    def __init__(self, base_params):\n        self.base_params = base_params\n\n        # Regime-specific adjustments\n        self.regime_adjustments = {\n            'BULL_NORMAL_VOL': {\n                'position_sizing_multiplier': 0.8,  # Reduce size in bull markets\n                'expectancy_reduction': 0.2         # Expect lower expectancy\n            },\n            'BEAR_NORMAL_VOL': {\n                'position_sizing_multiplier': 1.2,  # Increase size in bear markets\n                'expectancy_reduction': 0           # Normal expectancy\n            },\n            'BEAR_HIGH_VOL': {\n                'position_sizing_multiplier': 1.5,  # Max size in bear+high vol\n                'expectancy_reduction': -0.1        # Expect higher expectancy\n            },\n            'CHOPPY_NORMAL_VOL': {\n                'position_sizing_multiplier': 0.5,  # Reduce size in choppy\n                'expectancy_reduction': 0.3         # Expect much lower expectancy\n            }\n        }\n\n    def get_params_for_regime(self, current_regime):\n        \"\"\"Get parameters adjusted for current regime\"\"\"\n\n        if current_regime in self.regime_adjustments:\n            adjustment = self.regime_adjustments[current_regime]\n            return {\n                **self.base_params,\n                'position_sizing': self.base_params['position_sizing'] * adjustment['position_sizing_multiplier']\n            }\n        else:\n            return self.base_params\n```\n\n---\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Regime Analysis::Regime-Based Strategy Adjustment",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Regime Analysis",
      "Regime-Based Strategy Adjustment"
    ],
    "metadata": {
      "level": 3,
      "heading": "Regime-Based Strategy Adjustment"
    },
    "tags": [
      "strategy",
      "code",
      "position"
    ]
  },
  {
    "content": "## Monte Carlo Simulation\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Monte Carlo Simulation",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Monte Carlo Simulation"
    ],
    "metadata": {
      "level": 2,
      "heading": "Monte Carlo Simulation"
    },
    "tags": []
  },
  {
    "content": "### What Is Monte Carlo?\n\nRandomly resampling trades to test strategy robustness and estimate confidence intervals.\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Monte Carlo Simulation::What Is Monte Carlo?",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Monte Carlo Simulation",
      "What Is Monte Carlo?"
    ],
    "metadata": {
      "level": 3,
      "heading": "What Is Monte Carlo?"
    },
    "tags": [
      "strategy"
    ]
  },
  {
    "content": "### Monte Carlo Implementation\n\n```python\nclass MonteCarloSimulator:\n    \"\"\"Monte Carlo simulation for strategy validation\"\"\"\n\n    def __init__(self, backtest_results, n_simulations=1000):\n        self.results = backtest_results\n        self.n_simulations = n_simulations\n        self.trades = backtest_results['trades']\n\n    def run_simulation(self):\n        \"\"\"Run Monte Carlo simulation\"\"\"\n\n        simulation_results = []\n\n        for i in range(self.n_simulations):\n            # Resample trades with replacement\n            resampled = self.trades.sample(n=len(self.trades), replace=True)\n\n            # Calculate cumulative equity curve\n            equity = resampled['r_multiple'].cumsum()\n\n            simulation_results.append({\n                'final_equity_r': equity.iloc[-1],\n                'max_drawdown_r': self._calculate_max_dd(equity),\n                'sharpe_ratio': self._calculate_sharpe(equity)\n            })\n\n        # Analyze simulation results\n        df_sim = pd.DataFrame(simulation_results)\n\n        return {\n            'mean_final_equity': df_sim['final_equity_r'].mean(),\n            'std_final_equity': df_sim['final_equity_r'].std(),\n            'percentile_5': df_sim['final_equity_r'].quantile(0.05),\n            'percentile_95': df_sim['final_equity_r'].quantile(0.95),\n            'mean_max_dd': df_sim['max_drawdown_r'].mean(),\n            'worst_case_dd': df_sim['max_drawdown_r'].min(),\n            'probability_profit': (df_sim['final_equity_r'] > 0).sum() / self.n_simulations\n        }\n\n    def _calculate_max_dd(self, equity_curve):\n        \"\"\"Calculate max drawdown from equity curve\"\"\"\n        cummax = equity_curve.cummax()\n        drawdown = equity_curve - cummax\n        return drawdown.min()\n```\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Monte Carlo Simulation::Monte Carlo Implementation",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Monte Carlo Simulation",
      "Monte Carlo Implementation"
    ],
    "metadata": {
      "level": 3,
      "heading": "Monte Carlo Implementation"
    },
    "tags": [
      "backtest",
      "strategy",
      "code"
    ]
  },
  {
    "content": "### Monte Carlo Interpretation\n\n| Metric | Good | Acceptable | Bad |\n|--------|------|------------|-----|\n| **Probability of Profit** | >95% | 90-95% | <90% |\n| **5th Percentile** | >0 | -5R to 0 | <-5R |\n| **Worst Case DD** | <20R | 20-30R | >30R |\n\n---\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Monte Carlo Simulation::Monte Carlo Interpretation",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Monte Carlo Simulation",
      "Monte Carlo Interpretation"
    ],
    "metadata": {
      "level": 3,
      "heading": "Monte Carlo Interpretation"
    },
    "tags": [
      "indicator"
    ]
  },
  {
    "content": "## Performance Metrics\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Performance Metrics",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Performance Metrics"
    ],
    "metadata": {
      "level": 2,
      "heading": "Performance Metrics"
    },
    "tags": [
      "indicator"
    ]
  },
  {
    "content": "### Required Metrics (Minimum)\n\n```python\nREQUIRED_METRICS = {\n    # Trade count\n    'total_trades': 'Total number of trades',\n    'avg_trades_per_month': 'Frequency of signals',\n\n    # Win/Loss stats\n    'win_rate': 'Percentage of winning trades',\n    'avg_win_r': 'Average win in R-multiples',\n    'avg_loss_r': 'Average loss in R-multiples',\n    'win_loss_ratio': 'Avg win / Avg loss (absolute)',\n\n    # Profitability\n    'total_return_r': 'Total profit in R-multiples',\n    'expectancy': 'Average R per trade',\n    'profit_factor': 'Sum wins / Sum losses (absolute)',\n\n    # Risk\n    'max_drawdown_r': 'Maximum peak-to-trough decline',\n    'max_consecutive_losses': 'Worst losing streak',\n\n    # Efficiency\n    'avg_holding_time': 'Average trade duration',\n    'sharpe_ratio': 'Return / Volatility ratio',\n}\n```\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Performance Metrics::Required Metrics (Minimum)",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Performance Metrics",
      "Required Metrics (Minimum)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Required Metrics (Minimum)"
    },
    "tags": [
      "indicator",
      "code",
      "risk"
    ]
  },
  {
    "content": "### Advanced Metrics (Optional)\n\n```python\nADVANCED_METRICS = {\n    # Statistics\n    'kelly_criterion': 'Optimal position sizing %',\n    'sortino_ratio': 'Return / Downside volatility',\n    'calmar_ratio': 'Return / Max drawdown',\n\n    # Stability\n    'monthly_win_rate': 'Win rate consistency by month',\n    'expectancy_std': 'Std dev of expectancy',\n    'regime_performance': 'Performance by market regime',\n\n    # Reliability\n    'monte_carlo_p5': '5th percentile equity (worst case)',\n    'monte_carlo_p95': '95th percentile equity (best case)',\n    'probability_of_profit': '% simulations profitable',\n}\n```\n\n---\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Performance Metrics::Advanced Metrics (Optional)",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Performance Metrics",
      "Advanced Metrics (Optional)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Advanced Metrics (Optional)"
    },
    "tags": [
      "indicator",
      "code",
      "position"
    ]
  },
  {
    "content": "## Validation Workflow\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Validation Workflow",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Validation Workflow"
    ],
    "metadata": {
      "level": 2,
      "heading": "Validation Workflow"
    },
    "tags": []
  },
  {
    "content": "### Complete Workflow (End-to-End)",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Validation Workflow::Complete Workflow (End-to-End)::chunk0",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Validation Workflow",
      "Complete Workflow (End-to-End)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Complete Workflow (End-to-End)"
    },
    "tags": [
      "backtest",
      "strategy",
      "indicator",
      "pattern",
      "optimization",
      "risk",
      "execution"
    ]
  },
  {
    "content": "### Complete Workflow (End-to-End)\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    VALIDATION WORKFLOW                                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                         \u2502\n\u2502  PHASE 1: INITIAL VALIDATION (Quick Check)                             \u2502\n\u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                             \u2502\n\u2502  \u2022 Run simple backtest on recent 6 months                              \u2502\n\u2502  \u2022 Check: 20+ signals, expectancy > 0                                  \u2502\n\u2502  \u2022 If fail: Pattern doesn't work, stop                                 \u2502\n\u2502  \u2022 If pass: Continue to Phase 2                                        \u2502\n\u2502                                                                         \u2502\n\u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2502\n\u2502                                                                         \u2502\n\u2502  PHASE 2: PARAMETER OPTIMIZATION (Train/Val Split)                    \u2502\n\u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                     \u2502\n\u2502  \u2022 Split data: 60% train, 20% validation, 20% forward                 \u2502\n\u2502  \u2022 Grid search on training data                                        \u2502\n\u2502  \u2022 Select best params on validation data                               \u2502\n\u2502  \u2022 Check: Train/val gap < 25%                                          \u2502\n\u2502  \u2022 If fail: Overfitting detected, simplify params                     \u2502\n\u2502  \u2022 If pass: Continue to Phase 3                                        \u2502\n\u2502                                                                         \u2502\n\u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2502\n\u2502                                                                         \u2502\n\u2502  PHASE 3: WALK-FORWARD TESTING (Stability Check)                       \u2502\n\u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                     \u2502\n\u2502  \u2022 12-month train, 3-month test, roll forward                          \u2502\n\u2502  \u2022 Check: >70% periods profitable, expectancy std < 50%                \u2502\n\u2502  \u2022 If fail: Strategy not stable, revise pattern                        \u2502\n\u2502  \u2022 If pass: Continue to Phase 4                                        \u2502\n\u2502                                                                         \u2502\n\u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2502\n\u2502                                                                         \u2502\n\u2502  PHASE 4: FORWARD TESTING (Final Check)                                \u2502\n\u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                             \u2502\n\u2502  \u2022 Test on completely new data (forward period)                        \u2502\n\u2502  \u2022 Check: Performance within 20% of expected                           \u2502\n\u2502  \u2022 If fail: Regime change or overfitting                              \u2502\n\u2502  \u2022 If pass: Ready for paper trading                                    \u2502\n\u2502                                                                         \u2502\n\u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2502\n\u2502                                                                         \u2502\n\u2502  PHASE 5: PAPER TRADING (Live Simulation)                              \u2502\n\u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                         \u2502\n\u2502  \u2022 Run for 30 days with real-time signals                              \u2502\n\u2502  \u2022 Check: Performance matches expectations                              \u2502\n\u2502  \u2022 If fail: Execution issue or regime change                           \u2502\n\u2502  \u2022 If pass: Ready for live trading (optional)                          \u2502\n\u2502                                                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Validation Workflow::Complete Workflow (End-to-End)::chunk1",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Validation Workflow",
      "Complete Workflow (End-to-End)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Complete Workflow (End-to-End)"
    },
    "tags": [
      "backtest",
      "strategy",
      "indicator",
      "pattern",
      "optimization",
      "risk",
      "execution"
    ]
  },
  {
    "content": "### Decision Tree\n\n```\n                    Simple Backtest\n                           \u2502\n                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                  \u2502 Expectancy > 0? \u2502\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    NO            YES\n                    \u2502             \u2502\n              STOP              Optimize\n                                 \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502 Train/Val Gap < 25%?    \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      NO            YES\n                      \u2502             \u2502\n                 Simplify      Walk-Forward\n                                 \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502 >70% Periods Profitable?\u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      NO            YES\n                      \u2502             \u2502\n                 Revise      Forward Test\n                                 \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502 Within 20% Expected?    \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      NO            YES\n                      \u2502             \u2502\n                  Investigate   Paper Trading\n                                   \u2502\n                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                          \u2502 30 Days Pass?   \u2502\n                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            NO        YES\n                            \u2502         \u2502\n                        Debug    Live Trading\n```\n\n---\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Validation Workflow::Decision Tree",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Validation Workflow",
      "Decision Tree"
    ],
    "metadata": {
      "level": 3,
      "heading": "Decision Tree"
    },
    "tags": [
      "backtest",
      "strategy",
      "optimization",
      "risk"
    ]
  },
  {
    "content": "## Summary: Gold Standard Checklist\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Summary: Gold Standard Checklist",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Summary: Gold Standard Checklist"
    ],
    "metadata": {
      "level": 2,
      "heading": "Summary: Gold Standard Checklist"
    },
    "tags": []
  },
  {
    "content": "### Scanner Development\n- [ ] Uses V31 architecture (5-stage pipeline)\n- [ ] Market calendar integration\n- [ ] Per-ticker operations\n- [ ] Historical/D0 separation\n- [ ] Smart filtering\n- [ ] Parallel processing\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Summary: Gold Standard Checklist::Scanner Development",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Summary: Gold Standard Checklist",
      "Scanner Development"
    ],
    "metadata": {
      "level": 3,
      "heading": "Scanner Development"
    },
    "tags": [
      "scanner",
      "v31"
    ]
  },
  {
    "content": "### Backtesting\n- [ ] Simple backtest for quick validation\n- [ ] Enhanced backtest with intraday data\n- [ ] Realistic execution assumptions\n- [ ] Position sizing based on volatility\n- [ ] Commission calculations\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Summary: Gold Standard Checklist::Backtesting",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Summary: Gold Standard Checklist",
      "Backtesting"
    ],
    "metadata": {
      "level": 3,
      "heading": "Backtesting"
    },
    "tags": [
      "backtest",
      "strategy",
      "position",
      "execution"
    ]
  },
  {
    "content": "### Optimization\n- [ ] Train/validation/forward split\n- [ ] Grid/random search for parameters\n- [ ] Overfitting detection\n- [ ] Minimum 50 signals in training\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Summary: Gold Standard Checklist::Optimization",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Summary: Gold Standard Checklist",
      "Optimization"
    ],
    "metadata": {
      "level": 3,
      "heading": "Optimization"
    },
    "tags": [
      "indicator",
      "optimization"
    ]
  },
  {
    "content": "### Validation\n- [ ] Walk-forward testing (>70% periods profitable)\n- [ ] Forward test (within 20% of expected)\n- [ ] Monte Carlo simulation (>95% prob of profit)\n- [ ] Regime analysis (performance by market type)\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Summary: Gold Standard Checklist::Validation",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Summary: Gold Standard Checklist",
      "Validation"
    ],
    "metadata": {
      "level": 3,
      "heading": "Validation"
    },
    "tags": [
      "backtest"
    ]
  },
  {
    "content": "### Metrics (Minimum)\n- [ ] Total trades, win rate, expectancy\n- [ ] Max drawdown, profit factor\n- [ ] Avg win/loss, win/loss ratio\n- [ ] Sharpe ratio\n\n---\n\n**Document Status**: COMPLETE\n**Version**: 1.0\n**Last Updated**: 2026-01-29\n",
    "chunk_id": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md::EdgeDev Backtesting & Optimization Gold Standard::Summary: Gold Standard Checklist::Metrics (Minimum)",
    "source_file": "EDGEDEV_BACKTEST_OPTIMIZATION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Backtesting & Optimization Gold Standard",
      "Summary: Gold Standard Checklist",
      "Metrics (Minimum)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Metrics (Minimum)"
    },
    "tags": [
      "indicator",
      "risk"
    ]
  },
  {
    "content": "# EdgeDev Indicators & Execution Gold Standard\n**Complete Framework for Indicators, Position Sizing, and Execution Strategies**\n\n**Version**: 1.0\n**Date**: 2026-01-29\n**Status**: COMPLETE - Ready for Implementation\n\n---\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::EdgeDev Indicators & Execution Gold Standard",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Indicators & Execution Gold Standard"
    ],
    "metadata": {
      "level": 1,
      "heading": "EdgeDev Indicators & Execution Gold Standard"
    },
    "tags": [
      "strategy",
      "indicator",
      "position",
      "execution"
    ]
  },
  {
    "content": "## Table of Contents\n\n1. [Package Requirements](#package-requirements)\n2. [Indicator Library](#indicator-library)\n3. [Building Custom Indicators](#building-custom-indicators)\n4. [Position Sizing Methods](#position-sizing-methods)\n5. [Pyramiding Strategies](#pyramiding-strategies)\n6. [Capital Recycling](#capital-recycling)\n7. [Execution Strategies](#execution-strategies)\n8. [Stop Management](#stop-management)\n9. [Target Management](#target-management)\n10. [Complete Execution Framework](#complete-execution-framework)\n\n---\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::EdgeDev Indicators & Execution Gold Standard::Table of Contents",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Indicators & Execution Gold Standard",
      "Table of Contents"
    ],
    "metadata": {
      "level": 2,
      "heading": "Table of Contents"
    },
    "tags": [
      "strategy",
      "indicator",
      "risk",
      "position",
      "pyramiding",
      "execution"
    ]
  },
  {
    "content": "## Package Requirements\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::EdgeDev Indicators & Execution Gold Standard::Package Requirements",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Indicators & Execution Gold Standard",
      "Package Requirements"
    ],
    "metadata": {
      "level": 2,
      "heading": "Package Requirements"
    },
    "tags": []
  },
  {
    "content": "### Core Data Packages\n\n```python",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::EdgeDev Indicators & Execution Gold Standard::Package Requirements::Core Data Packages",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Indicators & Execution Gold Standard",
      "Package Requirements",
      "Core Data Packages"
    ],
    "metadata": {
      "level": 3,
      "heading": "Core Data Packages"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# requirements.txt for EdgeDev Gold Standard\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::requirements.txt for EdgeDev Gold Standard",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "requirements.txt for EdgeDev Gold Standard"
    ],
    "metadata": {
      "level": 1,
      "heading": "requirements.txt for EdgeDev Gold Standard"
    },
    "tags": []
  },
  {
    "content": "# === CORE DATA ===\npandas>=2.0.0              # Data manipulation\nnumpy>=1.24.0              # Numerical computing\nrequests>=2.31.0           # HTTP requests (Polygon API)\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::=== CORE DATA ===",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "=== CORE DATA ==="
    ],
    "metadata": {
      "level": 1,
      "heading": "=== CORE DATA ==="
    },
    "tags": []
  },
  {
    "content": "# === MARKET CALENDAR ===\npandas-market-calendars>=4.3.0  # Trading days, holidays\npytz>=2023.3               # Timezone handling\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::=== MARKET CALENDAR ===",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "=== MARKET CALENDAR ==="
    ],
    "metadata": {
      "level": 1,
      "heading": "=== MARKET CALENDAR ==="
    },
    "tags": [
      "strategy"
    ]
  },
  {
    "content": "# === TECHNICAL ANALYSIS ===",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::=== TECHNICAL ANALYSIS ===",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "=== TECHNICAL ANALYSIS ==="
    ],
    "metadata": {
      "level": 1,
      "heading": "=== TECHNICAL ANALYSIS ==="
    },
    "tags": []
  },
  {
    "content": "# NOTE: We implement indicators ourselves (see below)",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::NOTE: We implement indicators ourselves (see below)",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "NOTE: We implement indicators ourselves (see below)"
    ],
    "metadata": {
      "level": 1,
      "heading": "NOTE: We implement indicators ourselves (see below)"
    },
    "tags": [
      "indicator"
    ]
  },
  {
    "content": "# No external TA libraries required - gives full control\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::No external TA libraries required - gives full control",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "No external TA libraries required - gives full control"
    ],
    "metadata": {
      "level": 1,
      "heading": "No external TA libraries required - gives full control"
    },
    "tags": []
  },
  {
    "content": "# === PARALLEL PROCESSING ===\nconcurrent.futures         # Built-in (no install needed)\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::=== PARALLEL PROCESSING ===",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "=== PARALLEL PROCESSING ==="
    ],
    "metadata": {
      "level": 1,
      "heading": "=== PARALLEL PROCESSING ==="
    },
    "tags": []
  },
  {
    "content": "# === BACKTESTING ===",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::=== BACKTESTING ===",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "=== BACKTESTING ==="
    ],
    "metadata": {
      "level": 1,
      "heading": "=== BACKTESTING ==="
    },
    "tags": [
      "backtest"
    ]
  },
  {
    "content": "# We use custom backtest engines (see backtest_gold_standard.md)\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::We use custom backtest engines (see backtest_gold_standard.md)",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "We use custom backtest engines (see backtest_gold_standard.md)"
    ],
    "metadata": {
      "level": 1,
      "heading": "We use custom backtest engines (see backtest_gold_standard.md)"
    },
    "tags": [
      "backtest"
    ]
  },
  {
    "content": "# === VISUALIZATION (Optional) ===\nmatplotlib>=3.7.0          # Plotting (optional)\nplotly>=5.18.0             # Interactive charts (optional)\n```\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::=== VISUALIZATION (Optional) ===",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "=== VISUALIZATION (Optional) ==="
    ],
    "metadata": {
      "level": 1,
      "heading": "=== VISUALIZATION (Optional) ==="
    },
    "tags": []
  },
  {
    "content": "### Why No TA-Lib?\n\n```python",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::=== VISUALIZATION (Optional) ===::Why No TA-Lib?",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "=== VISUALIZATION (Optional) ===",
      "Why No TA-Lib?"
    ],
    "metadata": {
      "level": 3,
      "heading": "Why No TA-Lib?"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# WE IMPLEMENT OUR OWN INDICATORS\n#",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::WE IMPLEMENT OUR OWN INDICATORS",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "WE IMPLEMENT OUR OWN INDICATORS"
    ],
    "metadata": {
      "level": 1,
      "heading": "WE IMPLEMENT OUR OWN INDICATORS"
    },
    "tags": [
      "indicator"
    ]
  },
  {
    "content": "# Why:",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Why:",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Why:"
    ],
    "metadata": {
      "level": 1,
      "heading": "Why:"
    },
    "tags": []
  },
  {
    "content": "# 1. Full control over calculations",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::1. Full control over calculations",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "1. Full control over calculations"
    ],
    "metadata": {
      "level": 1,
      "heading": "1. Full control over calculations"
    },
    "tags": []
  },
  {
    "content": "# 2. No external dependencies",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::2. No external dependencies",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "2. No external dependencies"
    ],
    "metadata": {
      "level": 1,
      "heading": "2. No external dependencies"
    },
    "tags": []
  },
  {
    "content": "# 3. Can optimize for our specific needs",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::3. Can optimize for our specific needs",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "3. Can optimize for our specific needs"
    ],
    "metadata": {
      "level": 1,
      "heading": "3. Can optimize for our specific needs"
    },
    "tags": [
      "optimization"
    ]
  },
  {
    "content": "# 4. Transparent logic (no black boxes)",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::4. Transparent logic (no black boxes)",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "4. Transparent logic (no black boxes)"
    ],
    "metadata": {
      "level": 1,
      "heading": "4. Transparent logic (no black boxes)"
    },
    "tags": []
  },
  {
    "content": "# 5. Easy to modify/extend\n#",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::5. Easy to modify/extend",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "5. Easy to modify/extend"
    ],
    "metadata": {
      "level": 1,
      "heading": "5. Easy to modify/extend"
    },
    "tags": []
  },
  {
    "content": "# TA-Lib disadvantages:",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::TA-Lib disadvantages:",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "TA-Lib disadvantages:"
    ],
    "metadata": {
      "level": 1,
      "heading": "TA-Lib disadvantages:"
    },
    "tags": []
  },
  {
    "content": "# - Binary installation issues (especially on Mac M1/M2)",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::- Binary installation issues (especially on Mac M1/M2)",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "- Binary installation issues (especially on Mac M1/M2)"
    ],
    "metadata": {
      "level": 1,
      "heading": "- Binary installation issues (especially on Mac M1/M2)"
    },
    "tags": []
  },
  {
    "content": "# - Limited customization",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::- Limited customization",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "- Limited customization"
    ],
    "metadata": {
      "level": 1,
      "heading": "- Limited customization"
    },
    "tags": []
  },
  {
    "content": "# - Black box calculations",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::- Black box calculations",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "- Black box calculations"
    ],
    "metadata": {
      "level": 1,
      "heading": "- Black box calculations"
    },
    "tags": []
  },
  {
    "content": "# - Outdated maintenance\n#",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::- Outdated maintenance",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "- Outdated maintenance"
    ],
    "metadata": {
      "level": 1,
      "heading": "- Outdated maintenance"
    },
    "tags": []
  },
  {
    "content": "# All indicators below are pure pandas/numpy implementations\n```\n\n---\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::All indicators below are pure pandas/numpy implementations",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "All indicators below are pure pandas/numpy implementations"
    ],
    "metadata": {
      "level": 1,
      "heading": "All indicators below are pure pandas/numpy implementations"
    },
    "tags": [
      "indicator"
    ]
  },
  {
    "content": "## Indicator Library\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::All indicators below are pure pandas/numpy implementations::Indicator Library",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "All indicators below are pure pandas/numpy implementations",
      "Indicator Library"
    ],
    "metadata": {
      "level": 2,
      "heading": "Indicator Library"
    },
    "tags": [
      "indicator"
    ]
  },
  {
    "content": "### Core Indicators (Must Have)\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::All indicators below are pure pandas/numpy implementations::Indicator Library::Core Indicators (Must Have)",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "All indicators below are pure pandas/numpy implementations",
      "Indicator Library",
      "Core Indicators (Must Have)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Core Indicators (Must Have)"
    },
    "tags": [
      "indicator"
    ]
  },
  {
    "content": "#### 1. Moving Averages\n\n```python\ndef sma(series: pd.Series, period: int) -> pd.Series:\n    \"\"\"Simple Moving Average\"\"\"\n    return series.rolling(window=period, min_periods=period).mean()\n\ndef ema(series: pd.Series, period: int) -> pd.Series:\n    \"\"\"Exponential Moving Average (Wilder's smoothing)\"\"\"\n    return series.ewm(span=period, adjust=False).mean()\n\ndef vwap(df: pd.DataFrame) -> pd.Series:\n    \"\"\"Volume-Weighted Average Price\"\"\"\n    typical_price = (df['high'] + df['low'] + df['close']) / 3\n    vwap_value = (typical_price * df['volume']).cumsum() / df['volume'].cumsum()\n    return vwap_value\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::All indicators below are pure pandas/numpy implementations::Indicator Library::Core Indicators (Must Have)::1. Moving Averages",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "All indicators below are pure pandas/numpy implementations",
      "Indicator Library",
      "Core Indicators (Must Have)",
      "1. Moving Averages"
    ],
    "metadata": {
      "level": 4,
      "heading": "1. Moving Averages"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# Usage example:\ndf['ema_9'] = ema(df['close'], 9)\ndf['ema_30'] = ema(df['close'], 30)\ndf['sma_50'] = sma(df['close'], 50)\ndf['vwap'] = vwap(df)\n```\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Usage example:",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Usage example:"
    ],
    "metadata": {
      "level": 1,
      "heading": "Usage example:"
    },
    "tags": []
  },
  {
    "content": "#### 2. Volatility Indicators\n\n```python\ndef atr(df: pd.DataFrame, period: int = 14) -> pd.Series:\n    \"\"\"\n    Average True Range (Wilder's smoothing)\n\n    Measures market volatility. Used for:\n    - Position sizing\n    - Stop loss placement\n    - Target calculation\n    \"\"\"\n    high = df['high']\n    low = df['low']\n    close = df['close']\n\n    # True Range calculation\n    tr1 = high - low\n    tr2 = abs(high - close.shift(1))\n    tr3 = abs(low - close.shift(1))\n\n    tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)\n\n    # Wilder's smoothing (EMA-style)\n    atr_series = tr.ewm(alpha=1/period, adjust=False).mean()\n\n    return atr_series\n\ndef bollinger_bands(series: pd.Series, period: int = 20, std_dev: float = 2.0) -> pd.DataFrame:\n    \"\"\"Bollinger Bands\"\"\"\n    middle = sma(series, period)\n    std = series.rolling(window=period).std()\n\n    upper = middle + (std * std_dev)\n    lower = middle - (std * std_dev)\n\n    bandwidth = (upper - lower) / middle\n    percent_b = (series - lower) / (upper - lower)\n\n    return pd.DataFrame({\n        'bb_middle': middle,\n        'bb_upper': upper,\n        'bb_lower': lower,\n        'bb_bandwidth': bandwidth,\n        'bb_percent_b': percent_b\n    })\n\ndef keltner_channels(df: pd.DataFrame, ema_period: int = 20,\n                     atr_period: int = 10, atr_mult: float = 2.0) -> pd.DataFrame:\n    \"\"\"Keltner Channels\"\"\"\n    middle = ema(df['close'], ema_period)\n    atr_value = atr(df, atr_period)\n\n    upper = middle + (atr_value * atr_mult)\n    lower = middle - (atr_value * atr_mult)\n\n    return pd.DataFrame({\n        'kc_middle': middle,\n        'kc_upper': upper,\n        'kc_lower': lower,\n        'kc_atr': atr_value\n    })\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Usage example:::2. Volatility Indicators",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Usage example:",
      "2. Volatility Indicators"
    ],
    "metadata": {
      "level": 4,
      "heading": "2. Volatility Indicators"
    },
    "tags": [
      "indicator",
      "code",
      "risk",
      "position"
    ]
  },
  {
    "content": "# Usage example:\ndf['atr'] = atr(df, 14)\ndf['atr_30'] = atr(df, 30)\nbb = bollinger_bands(df['close'], 20, 2.0)\ndf = pd.concat([df, bb], axis=1)\nkc = keltner_channels(df, 20, 10, 2.0)\ndf = pd.concat([df, kc], axis=1)\n```\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Usage example:",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Usage example:"
    ],
    "metadata": {
      "level": 1,
      "heading": "Usage example:"
    },
    "tags": []
  },
  {
    "content": "#### 3. Momentum Indicators\n\n```python\ndef rsi(series: pd.Series, period: int = 14) -> pd.Series:\n    \"\"\"\n    Relative Strength Index\n\n    0-100 scale:\n    - >70 = Overbought\n    - <30 = Oversold\n    \"\"\"\n    delta = series.diff()\n    gain = delta.where(delta > 0, 0)\n    loss = -delta.where(delta < 0, 0)\n\n    avg_gain = gain.rolling(window=period).mean()\n    avg_loss = loss.rolling(window=period).mean()\n\n    rs = avg_gain / avg_loss\n    rsi_value = 100 - (100 / (1 + rs))\n\n    return rsi_value\n\ndef macd(series: pd.Series, fast: int = 12, slow: int = 26,\n         signal: int = 9) -> pd.DataFrame:\n    \"\"\"MACD (Moving Average Convergence Divergence)\"\"\"\n    ema_fast = ema(series, fast)\n    ema_slow = ema(series, slow)\n\n    macd_line = ema_fast - ema_slow\n    signal_line = ema(macd_line, signal)\n    histogram = macd_line - signal_line\n\n    return pd.DataFrame({\n        'macd': macd_line,\n        'macd_signal': signal_line,\n        'macd_histogram': histogram\n    })\n\ndef stoch_oscillator(df: pd.DataFrame, k_period: int = 14,\n                     d_period: int = 3) -> pd.DataFrame:\n    \"\"\"Stochastic Oscillator\"\"\"\n    low_min = df['low'].rolling(window=k_period).min()\n    high_max = df['high'].rolling(window=k_period).max()\n\n    k_percent = 100 * ((df['close'] - low_min) / (high_max - low_min))\n    d_percent = k_percent.rolling(window=d_period).mean()\n\n    return pd.DataFrame({\n        'stoch_k': k_percent,\n        'stoch_d': d_percent\n    })\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Usage example:::3. Momentum Indicators",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Usage example:",
      "3. Momentum Indicators"
    ],
    "metadata": {
      "level": 4,
      "heading": "3. Momentum Indicators"
    },
    "tags": [
      "indicator",
      "code",
      "risk",
      "pyramiding"
    ]
  },
  {
    "content": "# Usage example:\ndf['rsi'] = rsi(df['close'], 14)\nmacd_df = macd(df['close'], 12, 26, 9)\ndf = pd.concat([df, macd_df], axis=1)\nstoch_df = stoch_oscillator(df, 14, 3)\ndf = pd.concat([df, stoch_df], axis=1)\n```\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Usage example:",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Usage example:"
    ],
    "metadata": {
      "level": 1,
      "heading": "Usage example:"
    },
    "tags": []
  },
  {
    "content": "#### 4. Volume Indicators\n\n```python\ndef adv(df: pd.DataFrame, period: int = 20) -> pd.Series:\n    \"\"\"Average Daily Volume (dollar volume)\"\"\"\n    dollar_volume = df['close'] * df['volume']\n    return dollar_volume.rolling(window=period, min_periods=1).mean()\n\ndef volume_profile_tier(df: pd.DataFrame, n_tiers: int = 3) -> pd.Series:\n    \"\"\"\n    Volume Profile Tier\n\n    Classifies each bar's volume into tiers:\n    - Tier 1: Highest volume (top 33%)\n    - Tier 2: Medium volume (middle 33%)\n    - Tier 3: Low volume (bottom 33%)\n    \"\"\"\n    volume_percentiles = df['volume'].rank(pct=True)\n\n    tiers = pd.cut(\n        volume_percentiles,\n        bins=[0, 1/n_tiers, 2/n_tiers, 1.0],\n        labels=[f'Tier {i+1}' for i in range(n_tiers)],\n        include_lowest=True\n    )\n\n    return tiers\n\ndef obv(df: pd.DataFrame) -> pd.Series:\n    \"\"\"On-Balance Volume\"\"\"\n    obv_value = (np.sign(df['close'].diff()) * df['volume']).fillna(0).cumsum()\n    return obv_value\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Usage example:::4. Volume Indicators",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Usage example:",
      "4. Volume Indicators"
    ],
    "metadata": {
      "level": 4,
      "heading": "4. Volume Indicators"
    },
    "tags": [
      "indicator",
      "code",
      "execution"
    ]
  },
  {
    "content": "# Usage example:\ndf['adv20'] = adv(df, 20)\ndf['volume_tier'] = volume_profile_tier(df, 3)\ndf['obv'] = obv(df)\n```\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Usage example:",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Usage example:"
    ],
    "metadata": {
      "level": 1,
      "heading": "Usage example:"
    },
    "tags": []
  },
  {
    "content": "#### 5. Price Derivatives\n\n```python\ndef rate_of_change(series: pd.Series, period: int = 10) -> pd.Series:\n    \"\"\"Rate of Change (ROC) - % change over period\"\"\"\n    return ((series - series.shift(period)) / series.shift(period)) * 100\n\ndef momentum(series: pd.Series, period: int = 10) -> pd.Series:\n    \"\"\"Momentum - absolute price change over period\"\"\"\n    return series - series.shift(period)\n\ndef williams_r(df: pd.DataFrame, period: int = 14) -> pd.Series:\n    \"\"\"Williams %R\"\"\"\n    high_max = df['high'].rolling(window=period).max()\n    low_min = df['low'].rolling(window=period).min()\n\n    wr = -100 * ((high_max - df['close']) / (high_max - low_min))\n\n    return wr\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Usage example:::5. Price Derivatives",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Usage example:",
      "5. Price Derivatives"
    ],
    "metadata": {
      "level": 4,
      "heading": "5. Price Derivatives"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# Usage example:\ndf['roc_10'] = rate_of_change(df['close'], 10)\ndf['momentum_5'] = momentum(df['close'], 5)\ndf['williams_r'] = williams_r(df, 14)\n```\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Usage example:",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Usage example:"
    ],
    "metadata": {
      "level": 1,
      "heading": "Usage example:"
    },
    "tags": []
  },
  {
    "content": "### Extension Indicators (For Mean Reversion)\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Usage example:::Extension Indicators (For Mean Reversion)",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Usage example:",
      "Extension Indicators (For Mean Reversion)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Extension Indicators (For Mean Reversion)"
    },
    "tags": [
      "indicator"
    ]
  },
  {
    "content": "#### Extension Metrics\n\n```python\ndef ema_distance(df: pd.DataFrame, ema_period: int = 9) -> pd.Series:\n    \"\"\"\n    Distance from EMA as multiple of ATR\n\n    Used to measure how extended price is from mean.\n    Positive = above EMA, Negative = below EMA\n    \"\"\"\n    ema_value = ema(df['close'], ema_period)\n    atr_value = atr(df, 14)\n\n    distance = (df['close'] - ema_value) / atr_value\n\n    return distance\n\ndef extension_score(df: pd.DataFrame, short_ema: int = 9,\n                    long_ema: int = 30, lookback: int = 14) -> pd.Series:\n    \"\"\"\n    Extension Score (0-100)\n\n    Combines multiple extension metrics:\n    - EMA distance (short and long)\n    - Slope (rate of change)\n    - Position in recent range\n    \"\"\"\n    # EMA distances\n    dist_short = ema_distance(df, short_ema)\n    dist_long = ema_distance(df, long_ema)\n\n    # Normalize to 0-100 based on lookback\n    dist_short_norm = (dist_short - dist_short.rolling(lookback).min()) / \\\n                      (dist_short.rolling(lookback).max() - dist_short.rolling(lookback).min()) * 100\n\n    # Slope (ROC over recent period)\n    slope = rate_of_change(df['close'], lookback)\n\n    # Position in range\n    range_high = df['high'].rolling(lookback).max()\n    range_low = df['low'].rolling(lookback).min()\n    position_pct = ((df['close'] - range_low) / (range_high - range_low)) * 100\n\n    # Combine (weighted average)\n    score = (dist_short_norm * 0.4 + position_pct * 0.4 + slope * 0.2)\n\n    return score\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Usage example:::Extension Indicators (For Mean Reversion)::Extension Metrics",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Usage example:",
      "Extension Indicators (For Mean Reversion)",
      "Extension Metrics"
    ],
    "metadata": {
      "level": 4,
      "heading": "Extension Metrics"
    },
    "tags": [
      "indicator",
      "code",
      "position"
    ]
  },
  {
    "content": "# Usage example:\ndf['ema9_distance'] = ema_distance(df, 9)\ndf['ema30_distance'] = ema_distance(df, 30)\ndf['extension_score'] = extension_score(df, 9, 30, 14)\n```\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Usage example:",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Usage example:"
    ],
    "metadata": {
      "level": 1,
      "heading": "Usage example:"
    },
    "tags": []
  },
  {
    "content": "#### Parabolic Detection\n\n```python\ndef parabolic_score(df: pd.DataFrame, ema_period: int = 9,\n                    slope_periods: list = [3, 7, 14]) -> pd.Series:\n    \"\"\"\n    Parabolic Score (0-100)\n\n    Detects accelerating upward moves:\n    - High EMA distance\n    - Increasing slope (acceleration)\n    - Multiple expanding gaps\n    \"\"\"\n    # EMA distance\n    dist = ema_distance(df, ema_period)\n\n    # Slopes at multiple timeframes\n    slopes = [rate_of_change(df['close'], p) for p in slope_periods]\n\n    # Slope acceleration (short slope > long slope)\n    acceleration = slopes[0] - slopes[-1]  # 3-period - 14-period\n\n    # Count recent gaps\n    gap_pct = (df['open'] / df['close'].shift(1) - 1) * 100\n    recent_gaps = (gap_pct.rolling(5).sum() > 0).astype(int)\n\n    # Combine signals\n    dist_norm = ((dist - dist.rolling(50).min()) /\n                 (dist.rolling(50).max() - dist.rolling(50).min())) * 100\n\n    score = (dist_norm * 0.4 +\n             (acceleration * 10) * 0.3 +\n             recent_gaps * 20 * 0.3)\n\n    return score.clip(0, 100)\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Usage example:::Parabolic Detection",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Usage example:",
      "Parabolic Detection"
    ],
    "metadata": {
      "level": 4,
      "heading": "Parabolic Detection"
    },
    "tags": [
      "indicator",
      "code"
    ]
  },
  {
    "content": "# Usage example:\ndf['parabolic_score'] = parabolic_score(df, 9, [3, 7, 14])",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Usage example:",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "example",
    "heading_path": [
      "Usage example:"
    ],
    "metadata": {
      "level": 1,
      "heading": "Usage example:"
    },
    "tags": []
  },
  {
    "content": "# Parabolic condition: score > 70\n```\n\n---\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Parabolic condition: score > 70"
    ],
    "metadata": {
      "level": 1,
      "heading": "Parabolic condition: score > 70"
    },
    "tags": []
  },
  {
    "content": "## Building Custom Indicators\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Building Custom Indicators",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Building Custom Indicators"
    ],
    "metadata": {
      "level": 2,
      "heading": "Building Custom Indicators"
    },
    "tags": [
      "indicator"
    ]
  },
  {
    "content": "### Template for Custom Indicators\n\n```python\ndef custom_indicator(df: pd.DataFrame, **params) -> pd.Series:\n    \"\"\"\n    Template for custom indicator\n\n    Steps:\n    1. Validate inputs\n    2. Calculate intermediate values\n    3. Apply indicator logic\n    4. Return result\n    \"\"\"\n\n    # 1. Validate inputs\n    required_columns = ['open', 'high', 'low', 'close', 'volume']\n    if not all(col in df.columns for col in required_columns):\n        raise ValueError(f\"DataFrame must have: {required_columns}\")\n\n    # 2. Extract parameters with defaults\n    period = params.get('period', 14)\n    multiplier = params.get('multiplier', 2.0)\n\n    # 3. Calculate indicator\n    # ... your logic here ...\n\n    # 4. Return result\n    return df['result_column']\n```\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Building Custom Indicators::Template for Custom Indicators",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Building Custom Indicators",
      "Template for Custom Indicators"
    ],
    "metadata": {
      "level": 3,
      "heading": "Template for Custom Indicators"
    },
    "tags": [
      "indicator",
      "code"
    ]
  },
  {
    "content": "### Example: Gap Fade Indicator\n\n```python\ndef gap_fade_strength(df: pd.DataFrame, lookback: int = 20) -> pd.DataFrame:\n    \"\"\"\n    Measures strength of gap fade signal\n\n    Combines:\n    - Gap size\n    - Volume confirmation\n    - Pre-market hold\n    - Intraday fade progress\n    \"\"\"\n    # Gap metrics\n    df['gap_pct'] = (df['open'] / df['close'].shift(1) - 1) * 100\n    df['gap_vs_range'] = (df['open'] - df['close'].shift(1)) / df['high'].shift(1) - df['low'].shift(1)\n\n    # Volume confirmation\n    df['volume_ratio'] = df['volume'] / df['volume'].rolling(30).mean()\n\n    # Hold strength (how well gap held)\n    df['hold_range'] = (df['high'] - df['open']) / df['open'] * 100\n\n    # Fade progress\n    df['fade_progress'] = (df['open'] - df['close']) / (df['high'] - df['low']) * 100\n\n    # Combine into strength score\n    df['gap_fade_score'] = (\n        (df['gap_pct'] > 2.0).astype(int) * 25 +\n        (df['volume_ratio'] > 1.5).astype(int) * 25 +\n        (df['hold_range'] < 0.5).astype(int) * 25 +\n        (df['fade_progress'] > 50).astype(int) * 25\n    )\n\n    return df[['gap_pct', 'gap_vs_range', 'volume_ratio',\n               'hold_range', 'fade_progress', 'gap_fade_score']]\n```\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Building Custom Indicators::Example: Gap Fade Indicator",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Building Custom Indicators",
      "Example: Gap Fade Indicator"
    ],
    "metadata": {
      "level": 3,
      "heading": "Example: Gap Fade Indicator"
    },
    "tags": [
      "indicator",
      "code",
      "position"
    ]
  },
  {
    "content": "### Example: Multi-Timeframe Confirmation\n\n```python\ndef mtf_confirmation(df_daily: pd.DataFrame, df_hourly: pd.DataFrame,\n                    indicator: str = 'ema') -> pd.Series:\n    \"\"\"\n    Multi-Timeframe Confirmation\n\n    Checks if signal is confirmed across timeframes\n    \"\"\"\n    # Resample hourly to daily\n    hourly_daily = df_hourly.resample('D').agg({\n        'open': 'first',\n        'high': 'max',\n        'low': 'min',\n        'close': 'last',\n        'volume': 'sum'\n    })\n\n    # Calculate indicator on both timeframes\n    if indicator == 'ema':\n        daily_signal = df_daily['close'] > ema(df_daily['close'], 9)\n        hourly_signal = hourly_daily['close'] > ema(hourly_daily['close'], 9)\n\n    # Confirm if both agree\n    confirmation = daily_signal & hourly_signal\n\n    return confirmation\n```\n\n---\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Building Custom Indicators::Example: Multi-Timeframe Confirmation",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Building Custom Indicators",
      "Example: Multi-Timeframe Confirmation"
    ],
    "metadata": {
      "level": 3,
      "heading": "Example: Multi-Timeframe Confirmation"
    },
    "tags": [
      "indicator",
      "code"
    ]
  },
  {
    "content": "## Position Sizing Methods\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Position Sizing Methods",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Position Sizing Methods"
    ],
    "metadata": {
      "level": 2,
      "heading": "Position Sizing Methods"
    },
    "tags": [
      "position"
    ]
  },
  {
    "content": "### Method 1: Fixed Dollar Risk\n\n**Simple**: Risk same dollar amount per trade\n\n```python\ndef fixed_dollar_risk_sizing(entry_price: float, stop_price: float,\n                             risk_dollars: float = 1000) -> dict:\n    \"\"\"\n    Fixed dollar risk per trade\n\n    Example: Risk $1000 per trade regardless of account size\n    \"\"\"\n    risk_per_share = abs(entry_price - stop_price)\n    shares = int(risk_dollars / risk_per_share)\n\n    position_size = shares * entry_price\n\n    return {\n        'shares': shares,\n        'position_size': position_size,\n        'risk_dollars': risk_dollars,\n        'risk_r': risk_dollars / risk_dollars  # Always 1R\n    }\n```\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Position Sizing Methods::Method 1: Fixed Dollar Risk",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Position Sizing Methods",
      "Method 1: Fixed Dollar Risk"
    ],
    "metadata": {
      "level": 3,
      "heading": "Method 1: Fixed Dollar Risk"
    },
    "tags": [
      "code",
      "risk",
      "position"
    ]
  },
  {
    "content": "### Method 2: Fixed Percentage Risk\n\n**Proportional**: Risk same % of account per trade\n\n```python\ndef fixed_pct_risk_sizing(entry_price: float, stop_price: float,\n                          account_value: float, risk_pct: float = 0.01) -> dict:\n    \"\"\"\n    Fixed percentage risk per trade\n\n    Example: Risk 1% of account per trade\n    \"\"\"\n    risk_dollars = account_value * risk_pct\n    risk_per_share = abs(entry_price - stop_price)\n    shares = int(risk_dollars / risk_per_share)\n\n    position_size = shares * entry_price\n\n    return {\n        'shares': shares,\n        'position_size': position_size,\n        'risk_dollars': risk_dollars,\n        'risk_r': 1.0,  # By definition\n        'risk_pct_of_account': risk_pct * 100\n    }\n```\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Position Sizing Methods::Method 2: Fixed Percentage Risk",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Position Sizing Methods",
      "Method 2: Fixed Percentage Risk"
    ],
    "metadata": {
      "level": 3,
      "heading": "Method 2: Fixed Percentage Risk"
    },
    "tags": [
      "code",
      "risk",
      "position"
    ]
  },
  {
    "content": "### Method 3: ATR-Based Sizing (Volatility Adjusted)\n\n**Adaptive**: Size positions based on market volatility\n\n```python\ndef atr_based_sizing(entry_price: float, atr: float,\n                     account_value: float, risk_pct: float = 0.01,\n                     atr_multiplier: float = 0.8) -> dict:\n    \"\"\"\n    ATR-based position sizing\n\n    Stop = atr_multiplier * ATR away from entry\n    Position sized to risk risk_pct of account\n    \"\"\"\n    # Calculate stop distance\n    stop_distance = atr * atr_multiplier\n\n    # Calculate risk amount\n    risk_dollars = account_value * risk_pct\n\n    # Calculate shares\n    shares = int(risk_dollars / stop_distance)\n\n    position_size = shares * entry_price\n    stop_price = entry_price - stop_distance  # For long\n\n    return {\n        'shares': shares,\n        'position_size': position_size,\n        'stop_price': stop_price,\n        'risk_dollars': risk_dollars,\n        'atr': atr,\n        'risk_r': 1.0\n    }\n```\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Position Sizing Methods::Method 3: ATR-Based Sizing (Volatility Adjusted)",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Position Sizing Methods",
      "Method 3: ATR-Based Sizing (Volatility Adjusted)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Method 3: ATR-Based Sizing (Volatility Adjusted)"
    },
    "tags": [
      "code",
      "risk",
      "position"
    ]
  },
  {
    "content": "### Method 4: Kelly Criterion (Optimal Growth)\n\n**Mathematical**: Calculate optimal position size for growth\n\n```python\ndef kelly_sizing(entry_price: float, stop_price: float, target_price: float,\n                win_rate: float, account_value: float,\n                kelly_fraction: float = 0.25) -> dict:\n    \"\"\"\n    Kelly Criterion position sizing\n\n    WARNING: Use fraction of Kelly (quarter-Kelly is common)\n    Full Kelly is too aggressive for most traders\n    \"\"\"\n    # Calculate win/loss amounts\n    win_amount = abs(target_price - entry_price)\n    loss_amount = abs(entry_price - stop_price)\n\n    # Win/loss ratio\n    win_loss_ratio = win_amount / loss_amount\n\n    # Kelly %\n    kelly_pct = win_rate - ((1 - win_rate) / win_loss_ratio)\n\n    # Use fraction of Kelly\n    adjusted_kelly_pct = kelly_pct * kelly_fraction\n\n    # Calculate position\n    risk_dollars = account_value * adjusted_kelly_pct\n    shares = int(risk_dollars / loss_amount)\n\n    position_size = shares * entry_price\n\n    return {\n        'shares': shares,\n        'position_size': position_size,\n        'kelly_pct': kelly_pct * 100,\n        'adjusted_kelly_pct': adjusted_kelly_pct * 100,\n        'risk_dollars': risk_dollars,\n        'kelly_fraction': kelly_fraction\n    }\n```\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Position Sizing Methods::Method 4: Kelly Criterion (Optimal Growth)",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Position Sizing Methods",
      "Method 4: Kelly Criterion (Optimal Growth)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Method 4: Kelly Criterion (Optimal Growth)"
    },
    "tags": [
      "code",
      "risk",
      "position"
    ]
  },
  {
    "content": "### Position Sizing Comparison\n\n| Method | Pros | Cons | Best For |\n|--------|------|------|----------|\n| **Fixed Dollar** | Simple, predictable | Doesn't scale with account | Small accounts, beginners |\n| **Fixed %** | Scales with account | Risk varies with volatility | General trading |\n| **ATR-Based** | Adjusts for volatility | Requires ATR calculation | Most trading strategies |\n| **Kelly** | Optimal growth | Too aggressive, requires good data | Advanced traders (use fraction) |\n\n---\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Position Sizing Methods::Position Sizing Comparison",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Position Sizing Methods",
      "Position Sizing Comparison"
    ],
    "metadata": {
      "level": 3,
      "heading": "Position Sizing Comparison"
    },
    "tags": [
      "strategy",
      "risk",
      "position",
      "pyramiding"
    ]
  },
  {
    "content": "## Pyramiding Strategies\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Pyramiding Strategies",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Pyramiding Strategies"
    ],
    "metadata": {
      "level": 2,
      "heading": "Pyramiding Strategies"
    },
    "tags": [
      "pyramiding"
    ]
  },
  {
    "content": "### What Is Pyramiding?\n\nAdding to winning positions as they move in your favor.\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Pyramiding Strategies::What Is Pyramiding?",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Pyramiding Strategies",
      "What Is Pyramiding?"
    ],
    "metadata": {
      "level": 3,
      "heading": "What Is Pyramiding?"
    },
    "tags": [
      "position",
      "pyramiding"
    ]
  },
  {
    "content": "### Pyramiding Method 1: Fixed Add-Ons\n\n```python\ndef pyramid_fixed_addons(initial_entry: float, stop_price: float,\n                        target_price: float, initial_shares: int,\n                        num_addons: int = 2, addon_pct: float = 0.5) -> dict:\n    \"\"\"\n    Fixed add-on pyramiding\n\n    Add fixed % of initial position at predetermined levels\n    \"\"\"\n    add_levels = []\n    total_shares = initial_shares\n    total_cost = initial_entry * initial_shares\n\n    for i in range(1, num_addons + 1):\n        # Calculate add level (spread between entry and target)\n        level_progress = i / (num_addons + 1)\n        add_price = initial_entry + (target_price - initial_entry) * level_progress\n\n        # Calculate add-on shares\n        addon_shares = int(initial_shares * addon_pct)\n\n        add_levels.append({\n            'level': i,\n            'price': add_price,\n            'shares': addon_shares,\n            'cost': addon_shares * add_price\n        })\n\n        total_shares += addon_shares\n        total_cost += addon_shares * add_price\n\n    avg_price = total_cost / total_shares\n    total_potential_profit = (target_price - avg_price) * total_shares\n\n    return {\n        'initial_shares': initial_shares,\n        'add_levels': add_levels,\n        'total_shares': total_shares,\n        'avg_price': avg_price,\n        'total_cost': total_cost,\n        'total_potential_profit': total_potential_profit\n    }\n```\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Pyramiding Strategies::Pyramiding Method 1: Fixed Add-Ons",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Pyramiding Strategies",
      "Pyramiding Method 1: Fixed Add-Ons"
    ],
    "metadata": {
      "level": 3,
      "heading": "Pyramiding Method 1: Fixed Add-Ons"
    },
    "tags": [
      "code",
      "risk",
      "position",
      "pyramiding"
    ]
  },
  {
    "content": "### Pyramiding Method 2: Volatility-Adjusted\n\n```python\ndef pyramid_volatility_adjusted(initial_entry: float, atr: float,\n                                initial_shares: int, num_addons: int = 2,\n                                atr_spacing: float = 1.5) -> dict:\n    \"\"\"\n    Volatility-adjusted pyramiding\n\n    Add positions at ATR-based intervals\n    \"\"\"\n    add_levels = []\n    total_shares = initial_shares\n    total_cost = initial_entry * initial_shares\n\n    for i in range(1, num_addons + 1):\n        # Add level is ATR-spaced above previous level\n        if i == 1:\n            add_price = initial_entry + (atr * atr_spacing)\n        else:\n            add_price = add_levels[-1]['price'] + (atr * atr_spacing)\n\n        # Add-on shares (could reduce size as price increases)\n        addon_shares = int(initial_shares * 0.5)  # Half size\n\n        add_levels.append({\n            'level': i,\n            'price': add_price,\n            'shares': addon_shares,\n            'cost': addon_shares * add_price,\n            'atr_from_entry': (add_price - initial_entry) / atr\n        })\n\n        total_shares += addon_shares\n        total_cost += addon_shares * add_price\n\n    avg_price = total_cost / total_shares\n\n    return {\n        'initial_shares': initial_shares,\n        'add_levels': add_levels,\n        'total_shares': total_shares,\n        'avg_price': avg_price,\n        'total_cost': total_cost\n    }\n```\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Pyramiding Strategies::Pyramiding Method 2: Volatility-Adjusted",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Pyramiding Strategies",
      "Pyramiding Method 2: Volatility-Adjusted"
    ],
    "metadata": {
      "level": 3,
      "heading": "Pyramiding Method 2: Volatility-Adjusted"
    },
    "tags": [
      "code",
      "position",
      "pyramiding"
    ]
  },
  {
    "content": "### Pyramiding Risk Management\n\n```python\ndef pyramid_stop_management(initial_entry: float, initial_stop: float,\n                           add_levels: list, trailing_stop_atr: float = 1.0,\n                           atr: float = None) -> dict:\n    \"\"\"\n    Manage stops when pyramiding\n\n    Strategy: Move stop to breakeven after first add-on,\n              then trail by ATR\n    \"\"\"\n    stops = []\n\n    # Initial stop\n    stops.append({\n        'position': 'Initial',\n        'stop_price': initial_stop,\n        'action': 'Initial stop placement'\n    })\n\n    # After first add-on: Move to breakeven\n    if len(add_levels) > 0:\n        stops.append({\n            'position': 'After Add 1',\n            'stop_price': initial_entry,  # Breakeven\n            'action': 'Moved to breakeven'\n        })\n\n        # After subsequent add-ons: Trail by ATR\n        for i, level in enumerate(add_levels[1:], start=2):\n            if atr:\n                trail_stop = level['price'] - (atr * trailing_stop_atr)\n                stops.append({\n                    'position': f'After Add {i}',\n                    'stop_price': trail_stop,\n                    'action': f'Trailing stop ({trailing_stop_atr}x ATR)'\n                })\n\n    return stops\n```\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Pyramiding Strategies::Pyramiding Risk Management",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Pyramiding Strategies",
      "Pyramiding Risk Management"
    ],
    "metadata": {
      "level": 3,
      "heading": "Pyramiding Risk Management"
    },
    "tags": [
      "strategy",
      "code",
      "risk",
      "position",
      "pyramiding"
    ]
  },
  {
    "content": "### Pyramiding Rules\n\n1. **Only pyramid winners**: Never add to losing positions\n2. **Reduced size**: Each add-on should be smaller than initial\n3. **Predefined levels**: Know your add levels before entering\n4. **Stop management**: Move stop to breakeven after first add\n5. **Maximum pyramids**: Usually 2-3 add-ons max\n\n---\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Pyramiding Strategies::Pyramiding Rules",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Pyramiding Strategies",
      "Pyramiding Rules"
    ],
    "metadata": {
      "level": 3,
      "heading": "Pyramiding Rules"
    },
    "tags": [
      "risk",
      "position",
      "pyramiding"
    ]
  },
  {
    "content": "## Capital Recycling\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Capital Recycling",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Capital Recycling"
    ],
    "metadata": {
      "level": 2,
      "heading": "Capital Recycling"
    },
    "tags": []
  },
  {
    "content": "### What Is Capital Recycling?\n\nReusing capital + profits from closed trades for new trades.\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Capital Recycling::What Is Capital Recycling?",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Capital Recycling",
      "What Is Capital Recycling?"
    ],
    "metadata": {
      "level": 3,
      "heading": "What Is Capital Recycling?"
    },
    "tags": []
  },
  {
    "content": "### Simple Recycling (100% Reinvestment)\n\n```python\ndef simple_recycling(account_value: float, win_rate: float,\n                    avg_win_r: float, avg_loss_r: float,\n                    num_trades: int) -> dict:\n    \"\"\"\n    Simple 100% recycling simulation\n\n    Reinvest all capital + profits on each trade\n    \"\"\"\n    equity = account_value\n    equity_curve = [equity]\n\n    for i in range(num_trades):\n        # Determine win/loss based on win_rate\n        is_win = np.random.random() < win_rate\n\n        if is_win:\n            result_r = avg_win_r\n        else:\n            result_r = avg_loss_r\n\n        # Calculate P&L\n        risk_pct = 0.01  # 1% risk per trade\n        risk_dollars = equity * risk_pct\n        pnl_dollars = risk_dollars * result_r\n\n        # Update equity\n        equity += pnl_dollars\n        equity_curve.append(equity)\n\n    total_return = (equity - account_value) / account_value\n\n    return {\n        'initial_equity': account_value,\n        'final_equity': equity,\n        'total_return_pct': total_return * 100,\n        'equity_curve': equity_curve\n    }\n```\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Capital Recycling::Simple Recycling (100% Reinvestment)",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Capital Recycling",
      "Simple Recycling (100% Reinvestment)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Simple Recycling (100% Reinvestment)"
    },
    "tags": [
      "code",
      "risk"
    ]
  },
  {
    "content": "### Fractional Recycling (Conservative)\n\n```python\ndef fractional_recycling(account_value: float, win_rate: float,\n                        avg_win_r: float, avg_loss_r: float,\n                        num_trades: int, reinvest_pct: float = 0.5) -> dict:\n    \"\"\"\n    Fractional recycling\n\n    Only reinvest portion of profits, withdraw rest\n    \"\"\"\n    base_equity = account_value\n    equity = account_value\n    equity_curve = [equity]\n    withdrawn = []\n\n    for i in range(num_trades):\n        # Determine win/loss\n        is_win = np.random.random() < win_rate\n\n        if is_win:\n            result_r = avg_win_r\n        else:\n            result_r = avg_loss_r\n\n        # Calculate P&L\n        risk_pct = 0.01\n        risk_dollars = equity * risk_pct\n        pnl_dollars = risk_dollars * result_r\n\n        # Update equity\n        equity += pnl_dollars\n\n        # Withdraw portion of profits\n        if pnl_dollars > 0:\n            withdrawal = pnl_dollars * (1 - reinvest_pct)\n            equity -= withdrawal\n            withdrawn.append(withdrawal)\n        else:\n            withdrawn.append(0)\n\n        equity_curve.append(equity)\n\n    total_withdrawn = sum(withdrawn)\n    total_return = (equity - base_equity) / base_equity\n\n    return {\n        'initial_equity': account_value,\n        'final_equity': equity,\n        'total_withdrawn': total_withdrawn,\n        'total_return_pct': total_return * 100,\n        'equity_curve': equity_curve,\n        'withdrawals': withdrawn\n    }\n```\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Capital Recycling::Fractional Recycling (Conservative)",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Capital Recycling",
      "Fractional Recycling (Conservative)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Fractional Recycling (Conservative)"
    },
    "tags": [
      "code",
      "risk"
    ]
  },
  {
    "content": "### Kelly Recycling (Optimal Growth)\n\n```python\ndef kelly_recycling(account_value: float, win_rate: float,\n                   avg_win_r: float, avg_loss_r: float,\n                   num_trades: int, kelly_fraction: float = 0.25) -> dict:\n    \"\"\"\n    Kelly-based recycling\n\n    Position size adjusts based on Kelly criterion\n    \"\"\"\n    equity = account_value\n    equity_curve = [equity]\n    position_sizes = []\n\n    # Calculate Kelly %\n    win_loss_ratio = abs(avg_win_r / avg_loss_r)\n    kelly_pct = win_rate - ((1 - win_rate) / win_loss_ratio)\n    adjusted_kelly_pct = kelly_pct * kelly_fraction\n\n    for i in range(num_trades):\n        # Determine win/loss\n        is_win = np.random.random() < win_rate\n\n        if is_win:\n            result_r = avg_win_r\n        else:\n            result_r = avg_loss_r\n\n        # Calculate position size (based on Kelly)\n        risk_dollars = equity * adjusted_kelly_pct\n\n        # Calculate P&L\n        pnl_dollars = risk_dollars * result_r\n\n        # Track position size\n        position_sizes.append({\n            'trade': i + 1,\n            'equity_before': equity,\n            'position_size_pct': adjusted_kelly_pct * 100,\n            'position_size_dollars': risk_dollars\n        })\n\n        # Update equity\n        equity += pnl_dollars\n        equity_curve.append(equity)\n\n    total_return = (equity - account_value) / account_value\n\n    return {\n        'initial_equity': account_value,\n        'final_equity': equity,\n        'kelly_pct': kelly_pct * 100,\n        'adjusted_kelly_pct': adjusted_kelly_pct * 100,\n        'total_return_pct': total_return * 100,\n        'equity_curve': equity_curve,\n        'position_sizes': position_sizes\n    }\n```\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Capital Recycling::Kelly Recycling (Optimal Growth)",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Capital Recycling",
      "Kelly Recycling (Optimal Growth)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Kelly Recycling (Optimal Growth)"
    },
    "tags": [
      "code",
      "risk",
      "position"
    ]
  },
  {
    "content": "### Recycling Comparison\n\n| Method | Growth | Risk | Best For |\n|--------|--------|------|----------|\n| **Simple 100%** | Max | High | Aggressive growth, high win rate |\n| **Fractional** | Medium | Medium | Balanced growth + income |\n| **Kelly** | Optimal | Variable | Professional traders (use fraction) |\n\n---\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Capital Recycling::Recycling Comparison",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Capital Recycling",
      "Recycling Comparison"
    ],
    "metadata": {
      "level": 3,
      "heading": "Recycling Comparison"
    },
    "tags": [
      "risk"
    ]
  },
  {
    "content": "## Execution Strategies\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Execution Strategies",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Execution Strategies"
    ],
    "metadata": {
      "level": 2,
      "heading": "Execution Strategies"
    },
    "tags": [
      "strategy",
      "execution"
    ]
  },
  {
    "content": "### Strategy 1: Immediate Entry\n\n```python\ndef immediate_entry(signal: dict, current_price: float,\n                   position_sizing_fn, **sizing_params) -> dict:\n    \"\"\"\n    Enter immediately on signal\n\n    No waiting for confirmation\n    \"\"\"\n    # Calculate position size\n    sizing = position_sizing_fn(\n        entry_price=current_price,\n        stop_price=signal['stop_price'],\n        **sizing_params\n    )\n\n    return {\n        'entry_price': current_price,\n        'entry_time': datetime.now(),\n        'shares': sizing['shares'],\n        'position_size': sizing['position_size'],\n        'stop_price': sizing.get('stop_price', signal['stop_price']),\n        'target_price': signal.get('target_price'),\n        'entry_reason': 'Immediate entry on signal'\n    }\n```\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Execution Strategies::Strategy 1: Immediate Entry",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Execution Strategies",
      "Strategy 1: Immediate Entry"
    ],
    "metadata": {
      "level": 3,
      "heading": "Strategy 1: Immediate Entry"
    },
    "tags": [
      "strategy",
      "indicator",
      "code",
      "risk",
      "position"
    ]
  },
  {
    "content": "### Strategy 2: Confirmation Entry\n\n```python\ndef confirmation_entry(signal: dict, bars: list,\n                      position_sizing_fn, confirmation_bars: int = 1,\n                      **sizing_params) -> dict:\n    \"\"\"\n    Wait for confirmation before entering\n\n    Examples:\n    - For gap fade: Wait for first red bar after gap\n    - For breakout: Wait for close above breakout level\n    \"\"\"\n    # Check for confirmation\n    confirmed = False\n    entry_price = None\n    entry_bar_idx = None\n\n    for i in range(confirmation_bars, len(bars)):\n        bar = bars[i]\n\n        # Confirmation logic (example: weak close)\n        if bar['close'] < bar['open']:\n            confirmed = True\n            entry_price = bar['close']\n            entry_bar_idx = i\n            break\n\n    if not confirmed:\n        return {'error': 'Confirmation not triggered'}\n\n    # Calculate position size\n    sizing = position_sizing_fn(\n        entry_price=entry_price,\n        stop_price=signal['stop_price'],\n        **sizing_params\n    )\n\n    return {\n        'entry_price': entry_price,\n        'entry_time': bar['datetime'],\n        'shares': sizing['shares'],\n        'position_size': sizing['position_size'],\n        'stop_price': sizing.get('stop_price', signal['stop_price']),\n        'target_price': signal.get('target_price'),\n        'entry_bar_index': entry_bar_idx,\n        'entry_reason': f'Confirmation after {confirmation_bars} bars'\n    }\n```\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Execution Strategies::Strategy 2: Confirmation Entry",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Execution Strategies",
      "Strategy 2: Confirmation Entry"
    ],
    "metadata": {
      "level": 3,
      "heading": "Strategy 2: Confirmation Entry"
    },
    "tags": [
      "strategy",
      "indicator",
      "code",
      "risk",
      "position"
    ]
  },
  {
    "content": "### Strategy 3: Limit Order Entry\n\n```python\ndef limit_order_entry(signal: dict, current_price: float,\n                     limit_discount: float = 0.001,\n                     position_sizing_fn, **sizing_params) -> dict:\n    \"\"\"\n    Place limit order at discount to current price\n\n    Good for:\n    - Getting better fill\n    - Avoiding chasing\n    - Reducing slippage\n    \"\"\"\n    # Calculate limit price\n    if signal['direction'] == 'LONG':\n        limit_price = current_price * (1 - limit_discount)\n    else:  # SHORT\n        limit_price = current_price * (1 + limit_discount)\n\n    # Calculate position size\n    sizing = position_sizing_fn(\n        entry_price=limit_price,\n        stop_price=signal['stop_price'],\n        **sizing_params\n    )\n\n    return {\n        'entry_type': 'LIMIT',\n        'limit_price': limit_price,\n        'current_price': current_price,\n        'discount_pct': limit_discount * 100,\n        'shares': sizing['shares'],\n        'position_size': sizing['position_size'],\n        'stop_price': sizing.get('stop_price', signal['stop_price']),\n        'target_price': signal.get('target_price'),\n        'entry_reason': f'Limit order at {limit_discount*100:.1f}% discount'\n    }\n```\n\n---\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Execution Strategies::Strategy 3: Limit Order Entry",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Execution Strategies",
      "Strategy 3: Limit Order Entry"
    ],
    "metadata": {
      "level": 3,
      "heading": "Strategy 3: Limit Order Entry"
    },
    "tags": [
      "strategy",
      "indicator",
      "code",
      "risk",
      "position",
      "execution"
    ]
  },
  {
    "content": "## Stop Management\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Stop Management",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Stop Management"
    ],
    "metadata": {
      "level": 2,
      "heading": "Stop Management"
    },
    "tags": [
      "risk"
    ]
  },
  {
    "content": "### Stop Types\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Stop Management::Stop Types",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Stop Management",
      "Stop Types"
    ],
    "metadata": {
      "level": 3,
      "heading": "Stop Types"
    },
    "tags": [
      "risk"
    ]
  },
  {
    "content": "#### 1. Fixed Stop (Price-Based)\n\n```python\ndef fixed_stop(entry_price: float, direction: str,\n               stop_distance: float) -> float:\n    \"\"\"\n    Fixed dollar or percentage stop\n\n    Example: Stop $2 below entry, or 2% below entry\n    \"\"\"\n    if direction == 'LONG':\n        stop_price = entry_price - stop_distance\n    else:  # SHORT\n        stop_price = entry_price + stop_distance\n\n    return stop_price\n```\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Stop Management::Stop Types::1. Fixed Stop (Price-Based)",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Stop Management",
      "Stop Types",
      "1. Fixed Stop (Price-Based)"
    ],
    "metadata": {
      "level": 4,
      "heading": "1. Fixed Stop (Price-Based)"
    },
    "tags": [
      "code",
      "risk"
    ]
  },
  {
    "content": "#### 2. ATR Stop (Volatility-Based)\n\n```python\ndef atr_stop(entry_price: float, direction: str,\n             atr: float, atr_multiplier: float = 1.5) -> float:\n    \"\"\"\n    ATR-based stop\n\n    Stop distance = ATR * multiplier\n    Adjusts automatically to market volatility\n    \"\"\"\n    stop_distance = atr * atr_multiplier\n\n    if direction == 'LONG':\n        stop_price = entry_price - stop_distance\n    else:  # SHORT\n        stop_price = entry_price + stop_distance\n\n    return stop_price\n```\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Stop Management::Stop Types::2. ATR Stop (Volatility-Based)",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Stop Management",
      "Stop Types",
      "2. ATR Stop (Volatility-Based)"
    ],
    "metadata": {
      "level": 4,
      "heading": "2. ATR Stop (Volatility-Based)"
    },
    "tags": [
      "code",
      "risk"
    ]
  },
  {
    "content": "#### 3. Trailing Stop (Breakeven + Trail)",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Stop Management::Stop Types::3. Trailing Stop (Breakeven + Trail)::chunk0",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Stop Management",
      "Stop Types",
      "3. Trailing Stop (Breakeven + Trail)"
    ],
    "metadata": {
      "level": 4,
      "heading": "3. Trailing Stop (Breakeven + Trail)"
    },
    "tags": [
      "code",
      "risk"
    ]
  },
  {
    "content": "#### 3. Trailing Stop (Breakeven + Trail)\n\n```python\nclass TrailingStop:\n    \"\"\"Trailing stop management\"\"\"\n\n    def __init__(self, entry_price: float, direction: str,\n                 initial_stop: float, trail_atr: float,\n                 atr: float, breakeven_after_r: float = 1.0):\n        self.entry_price = entry_price\n        self.direction = direction\n        self.initial_stop = initial_stop\n        self.trail_atr = trail_atr\n        self.atr = atr\n        self.breakeven_after_r = breakeven_after_r\n\n        self.highest_price = entry_price  # For longs\n        self.lowest_price = entry_price   # For shorts\n        self.current_stop = initial_stop\n\n    def update(self, high: float, low: float) -> dict:\n        \"\"\"Update stop based on new price data\"\"\"\n        stop_action = None\n\n        if self.direction == 'LONG':\n            # Update highest price\n            if high > self.highest_price:\n                self.highest_price = high\n\n                # Check if breakeven should be triggered\n                unrealized_r = (self.highest_price - self.entry_price) / \\\n                               (self.entry_price - self.initial_stop)\n\n                if unrealized_r >= self.breakeven_after_r:\n                    # Move to breakeven\n                    new_stop = self.entry_price\n                    if new_stop > self.current_stop:\n                        self.current_stop = new_stop\n                        stop_action = 'Moved to breakeven'\n\n                # Trail stop\n                trail_stop = self.highest_price - (self.trail_atr * self.atr)\n                if trail_stop > self.current_stop:\n                    self.current_stop = trail_stop\n                    stop_action = 'Trailing stop raised'\n\n        else:  # SHORT\n            # Update lowest price\n            if low < self.lowest_price:\n                self.lowest_price = low\n\n                # Check if breakeven should be triggered\n                unrealized_r = (self.entry_price - self.lowest_price) / \\\n                               (self.initial_stop - self.entry_price)\n\n                if unrealized_r >= self.breakeven_after_r:\n                    # Move to breakeven\n                    new_stop = self.entry_price\n                    if new_stop < self.current_stop:\n                        self.current_stop = new_stop\n                        stop_action = 'Moved to breakeven'\n\n                # Trail stop\n                trail_stop = self.lowest_price + (self.trail_atr * self.atr)\n                if trail_stop < self.current_stop:\n                    self.current_stop = trail_stop\n                    stop_action = 'Trailing stop lowered'\n\n        return {\n            'current_stop': self.current_stop,\n            'highest_price': self.highest_price if self.direction == 'LONG' else None,\n            'lowest_price': self.lowest_price if self.direction == 'SHORT' else None,\n            'action': stop_action\n        }\n```",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Stop Management::Stop Types::3. Trailing Stop (Breakeven + Trail)::chunk1",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Stop Management",
      "Stop Types",
      "3. Trailing Stop (Breakeven + Trail)"
    ],
    "metadata": {
      "level": 4,
      "heading": "3. Trailing Stop (Breakeven + Trail)"
    },
    "tags": [
      "code",
      "risk"
    ]
  },
  {
    "content": "rice': self.highest_price if self.direction == 'LONG' else None,\n            'lowest_price': self.lowest_price if self.direction == 'SHORT' else None,\n            'action': stop_action\n        }\n```\n\n\n\n[...previous chunk overlap...]\n\n---",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Stop Management::Stop Types::3. Trailing Stop (Breakeven + Trail)::chunk2",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Stop Management",
      "Stop Types",
      "3. Trailing Stop (Breakeven + Trail)"
    ],
    "metadata": {
      "level": 4,
      "heading": "3. Trailing Stop (Breakeven + Trail)"
    },
    "tags": [
      "code",
      "risk"
    ]
  },
  {
    "content": "## Target Management\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Target Management",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Target Management"
    ],
    "metadata": {
      "level": 2,
      "heading": "Target Management"
    },
    "tags": []
  },
  {
    "content": "### Target Types\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Target Management::Target Types",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Target Management",
      "Target Types"
    ],
    "metadata": {
      "level": 3,
      "heading": "Target Types"
    },
    "tags": []
  },
  {
    "content": "#### 1. Fixed Target (R-Multiple)\n\n```python\ndef fixed_r_target(entry_price: float, direction: str,\n                   stop_distance: float, target_r: float = 2.0) -> float:\n    \"\"\"\n    Fixed R-multiple target\n\n    Example: Target at 2R (2x the risk)\n    \"\"\"\n    target_distance = stop_distance * target_r\n\n    if direction == 'LONG':\n        target_price = entry_price + target_distance\n    else:  # SHORT\n        target_price = entry_price - target_distance\n\n    return target_price\n```\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Target Management::Target Types::1. Fixed Target (R-Multiple)",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Target Management",
      "Target Types",
      "1. Fixed Target (R-Multiple)"
    ],
    "metadata": {
      "level": 4,
      "heading": "1. Fixed Target (R-Multiple)"
    },
    "tags": [
      "code",
      "risk"
    ]
  },
  {
    "content": "#### 2. ATR Target (Volatility-Based)\n\n```python\ndef atr_target(entry_price: float, direction: str,\n               atr: float, atr_multiplier: float = 2.0) -> float:\n    \"\"\"\n    ATR-based target\n\n    Target = ATR * multiplier away from entry\n    \"\"\"\n    target_distance = atr * atr_multiplier\n\n    if direction == 'LONG':\n        target_price = entry_price + target_distance\n    else:  # SHORT\n        target_price = entry_price - target_distance\n\n    return target_price\n```\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Target Management::Target Types::2. ATR Target (Volatility-Based)",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Target Management",
      "Target Types",
      "2. ATR Target (Volatility-Based)"
    ],
    "metadata": {
      "level": 4,
      "heading": "2. ATR Target (Volatility-Based)"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "#### 3. Partial Targets (Scale Out)\n\n```python\ndef partial_targets(entry_price: float, direction: str,\n                   stop_distance: float, target_levels: list) -> list:\n    \"\"\"\n    Partial targets at multiple levels\n\n    Example: Exit 50% at 1R, 30% at 2R, 20% at 3R\n    \"\"\"\n    targets = []\n\n    for level in target_levels:\n        r_multiple = level['r']\n        exit_pct = level['exit_pct']\n\n        target_distance = stop_distance * r_multiple\n\n        if direction == 'LONG':\n            target_price = entry_price + target_distance\n        else:  # SHORT\n            target_price = entry_price - target_distance\n\n        targets.append({\n            'level': len(targets) + 1,\n            'r_multiple': r_multiple,\n            'target_price': target_price,\n            'exit_pct': exit_pct\n        })\n\n    return targets\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Parabolic condition: score > 70::Target Management::Target Types::3. Partial Targets (Scale Out)",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Parabolic condition: score > 70",
      "Target Management",
      "Target Types",
      "3. Partial Targets (Scale Out)"
    ],
    "metadata": {
      "level": 4,
      "heading": "3. Partial Targets (Scale Out)"
    },
    "tags": [
      "code",
      "risk",
      "pyramiding"
    ]
  },
  {
    "content": "# Example usage:\ntarget_levels = [\n    {'r': 1.5, 'exit_pct': 0.5},   # Exit 50% at 1.5R\n    {'r': 2.5, 'exit_pct': 0.3},   # Exit 30% at 2.5R\n    {'r': 4.0, 'exit_pct': 0.2},   # Exit 20% at 4R\n]\n```\n\n---\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Example usage:",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Example usage:"
    ],
    "metadata": {
      "level": 1,
      "heading": "Example usage:"
    },
    "tags": []
  },
  {
    "content": "## Complete Execution Framework\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Example usage:::Complete Execution Framework",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Example usage:",
      "Complete Execution Framework"
    ],
    "metadata": {
      "level": 2,
      "heading": "Complete Execution Framework"
    },
    "tags": [
      "strategy",
      "execution"
    ]
  },
  {
    "content": "### Full Trade Simulator",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Example usage:::Complete Execution Framework::Full Trade Simulator::chunk0",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Example usage:",
      "Complete Execution Framework",
      "Full Trade Simulator"
    ],
    "metadata": {
      "level": 3,
      "heading": "Full Trade Simulator"
    },
    "tags": [
      "strategy",
      "indicator",
      "code",
      "risk",
      "position",
      "pyramiding",
      "execution"
    ]
  },
  {
    "content": "### Full Trade Simulator\n\n```python\nclass CompleteTradeSimulator:\n    \"\"\"\n    Complete execution simulation with:\n    - Entry logic\n    - Position sizing\n    - Stop management\n    - Target management\n    - Exit logic\n    - Pyramiding\n    \"\"\"\n\n    def __init__(self, account_value: float, config: dict = None):\n        self.account_value = account_value\n        self.config = config or {}\n\n        # Execution settings\n        self.entry_method = self.config.get('entry_method', 'confirmation')\n        self.position_sizing_method = self.config.get('sizing_method', 'atr_based')\n        self.stop_method = self.config.get('stop_method', 'trailing_atr')\n        self.target_method = self.config.get('target_method', 'partial_r')\n\n        # Parameters\n        self.risk_pct = self.config.get('risk_pct', 0.01)\n        self.atr_period = self.config.get('atr_period', 14)\n        self.stop_atr_mult = self.config.get('stop_atr_mult', 0.8)\n        self.target_atr_mult = self.config.get('target_atr_mult', 2.0)\n        self.trailing_atr_mult = self.config.get('trailing_atr_mult', 0.5)\n        self.breakeven_after_r = self.config.get('breakeven_after_r', 1.0)\n\n        # Pyramiding\n        self.pyramid_enabled = self.config.get('pyramid_enabled', False)\n        self.num_pyramids = self.config.get('num_pyramids', 2)\n\n    def simulate_trade(self, signal: dict, intraday_data: list) -> dict:\n        \"\"\"\n        Simulate complete trade from entry to exit\n        \"\"\"\n        # Step 1: Calculate entry\n        entry = self._calculate_entry(signal, intraday_data)\n\n        if 'error' in entry:\n            return entry\n\n        # Step 2: Calculate position size\n        sizing = self._calculate_position_size(entry, signal)\n\n        # Step 3: Initialize stop management\n        stop_manager = self._initialize_stop_manager(entry, signal)\n\n        # Step 4: Initialize targets\n        targets = self._calculate_targets(entry, signal)\n\n        # Step 5: Simulate through bars\n        trade_result = self._simulate_execution(\n            entry, sizing, stop_manager, targets, intraday_data\n        )\n\n        return trade_result\n\n    def _calculate_entry(self, signal: dict, bars: list) -> dict:\n        \"\"\"Calculate entry price and time\"\"\"\n        if self.entry_method == 'immediate':\n            return {\n                'entry_price': bars[0]['open'],\n                'entry_time': bars[0]['datetime'],\n                'entry_bar_index': 0\n            }\n        elif self.entry_method == 'confirmation':\n            # Wait for confirmation (example: weak close)\n            for i, bar in enumerate(bars):\n                if bar['close'] < bar['open']:\n                    return {\n                        'entry_price': bar['close'],\n                        'entry_time': bar['datetime'],\n                        'entry_bar_index': i,\n                        'entry_reason': 'Confirmation: weak close'\n                    }\n            return {'error': 'No confirmation triggered'}\n\n    def _calculate_position_size(self, entry: dict, signal: dict) -> dict:\n        \"\"\"Calculate position size\"\"\"\n        if self.position_sizing_method == 'fixed_pct':\n            return fixed_pct_risk_sizing(\n                entry_price=entry['entry_price'],\n                stop_price=signal['stop_price'],\n                account_value=self.account_value,\n                risk_pct=self.risk_pct\n            )\n        elif self.position_sizing_method == 'atr_based':\n            return atr_based_sizing(\n                entry_price=entry['entry_price'],\n                atr=signal['atr'],\n                account_value=self.account_value,\n                risk_pct=self.risk_pct,\n                atr_multiplier=self.stop_atr_mult\n            )\n        else:\n            raise ValueError(f\"Unknown sizing method: {self.position_sizing_method}\")\n\n    def _initialize_stop_manager(self, entry: dict, signal: dict) -> TrailingStop:\n        \"\"\"Initialize stop manager\"\"\"\n        direction = signal.get('direction', 'LONG')\n\n        if self.stop_method == 'trailing_atr':\n            return TrailingStop(\n                entry_price=entry['entry_price'],\n                direction=direction,\n                initial_stop=signal['stop_price'],\n                trail_atr=self.trailing_atr_mult,\n                atr=signal['atr'],\n                breakeven_after_r=self.breakeven_after_r\n            )\n        else:\n            raise ValueError(f\"Unknown stop method: {self.stop_method}\")\n\n    def _calculate_targets(self, entry: dict, signal: dict) -> list:\n        \"\"\"Calculate profit targets\"\"\"\n        if self.target_method == 'partial_r':\n            return partial_targets(\n                entry_price=entry['entry_price'],\n                direction=signal.get('direction', 'LONG'),\n                stop_distance=abs(entry['entry_price'] - signal['stop_price']),\n                target_levels=[\n                    {'r': 1.5, 'exit_pct': 0.5},\n                    {'r': 2.5, 'exit_pct': 0.3},\n                    {'r': 4.0, 'exit_pct': 0.2}\n                ]\n            )\n        else:\n            raise ValueError(f\"Unknown target method: {self.target_method}\")\n\n    def _simulate_execution(self, entry: dict, sizing: dict,\n                           stop_manager: TrailingStop, targets: list,\n                           bars: list) -> dict:\n        \"\"\"Simulate trade execution through bars\"\"\"\n        entry_bar = entry['entry_bar_index']\n        entry_price = entry['entry_price']\n        direction = 'LONG'  # or from signal\n\n        # Track position state\n        total_shares = sizing['shares']\n        remaining_shares = total_shares\n        realized_pnl = 0\n        trades = []\n\n        for i in range(entry_bar + 1, len(bars)):\n            bar = bars[i]\n\n            # Update trailing stop\n            stop_update = stop_manager.update(bar['high'], bar['low'])\n            current_stop = stop_update['current_stop']\n\n            # Check for partial target exits\n            for target in targets:\n                if target['remaining_shares'] > 0:\n                    if direction == 'LONG' and bar['high'] >= target['target_price']:\n                        # Exit portion at target\n                        exit_shares = int(remaining_shares * target['exit_pct'])\n                        exit_pnl = (target['target_price'] - entry_price) * exit_shares\n                        realized_pnl += exit_pnl\n                        remaining_shares -= exit_shares\n\n                        trades.append({\n                            'exit_type': 'target',\n                            'level': target['level'],\n                            'price': target['target_price'],\n                            'shares': exit_shares,\n                            'pnl': exit_pnl,\n                            'time': bar['datetime']\n                        })\n\n            # Check stop loss\n            if direction == 'LONG' and bar['low'] <= current_stop:\n                # Exit remaining at stop\n                exit_pnl = (current_stop - entry_price) * remaining_shares\n                realized_pnl += exit_pnl\n\n                trades.append({\n                    'exit_type': 'stop',\n                    'price': current_stop,\n                    'shares': remaining_shares,\n                    'pnl': exit_pnl,\n                    'time': bar['datetime'],\n                    'reason': stop_update['action']\n                })\n\n                remaining_shares = 0\n                break\n\n            # Check EOD exit\n            if i == len(bars) - 1 and remaining_shares > 0:\n                exit_pnl = (bar['close'] - entry_price) * remaining_shares\n                realized_pnl += exit_pnl\n\n                trades.append({\n                    'exit_type': 'eod',\n                    'price': bar['close'],\n                    'shares': remaining_shares,\n                    'pnl': exit_pnl,\n                    'time': bar['datetime']\n                })\n\n                remaining_shares = 0\n                break\n\n        # Calculate final metrics\n        r_multiple = realized_pnl / (sizing['risk_dollars'] or 1)\n\n        return {\n            'entry_price': entry_price,\n            'entry_time': entry['entry_time'],\n            'total_shares': total_shares,\n            'realized_pnl': realized_pnl,\n            'r_multiple': r_multiple,\n            'trades': trades,\n            'final_stop': stop_manager.current_stop\n        }\n```",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Example usage:::Complete Execution Framework::Full Trade Simulator::chunk1",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Example usage:",
      "Complete Execution Framework",
      "Full Trade Simulator"
    ],
    "metadata": {
      "level": 3,
      "heading": "Full Trade Simulator"
    },
    "tags": [
      "strategy",
      "indicator",
      "code",
      "risk",
      "position",
      "pyramiding",
      "execution"
    ]
  },
  {
    "content": "shares': total_shares,\n            'realized_pnl': realized_pnl,\n            'r_multiple': r_multiple,\n            'trades': trades,\n            'final_stop': stop_manager.current_stop\n        }\n```\n\n\n\n[...previous chunk overlap...]\n\n---",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Example usage:::Complete Execution Framework::Full Trade Simulator::chunk2",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Example usage:",
      "Complete Execution Framework",
      "Full Trade Simulator"
    ],
    "metadata": {
      "level": 3,
      "heading": "Full Trade Simulator"
    },
    "tags": [
      "strategy",
      "indicator",
      "code",
      "risk",
      "position",
      "pyramiding",
      "execution"
    ]
  },
  {
    "content": "## Summary: Gold Standard Checklist\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Example usage:::Summary: Gold Standard Checklist",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Example usage:",
      "Summary: Gold Standard Checklist"
    ],
    "metadata": {
      "level": 2,
      "heading": "Summary: Gold Standard Checklist"
    },
    "tags": []
  },
  {
    "content": "### Packages\n- [ ] pandas >= 2.0.0\n- [ ] numpy >= 1.24.0\n- [ ] requests >= 2.31.0\n- [ ] pandas-market-calendars >= 4.3.0\n- [ ] No TA-Lib (use custom implementations)\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Example usage:::Summary: Gold Standard Checklist::Packages",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Example usage:",
      "Summary: Gold Standard Checklist",
      "Packages"
    ],
    "metadata": {
      "level": 3,
      "heading": "Packages"
    },
    "tags": []
  },
  {
    "content": "### Indicators (Core)\n- [ ] SMA, EMA, VWAP\n- [ ] ATR, Bollinger Bands, Keltner Channels\n- [ ] RSI, MACD, Stochastic\n- [ ] ADV, Volume Profile, OBV\n- [ ] Rate of Change, Momentum, Williams %R\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Example usage:::Summary: Gold Standard Checklist::Indicators (Core)",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Example usage:",
      "Summary: Gold Standard Checklist",
      "Indicators (Core)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Indicators (Core)"
    },
    "tags": [
      "indicator"
    ]
  },
  {
    "content": "### Indicators (Extension)\n- [ ] EMA Distance, Extension Score\n- [ ] Parabolic Score\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Example usage:::Summary: Gold Standard Checklist::Indicators (Extension)",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Example usage:",
      "Summary: Gold Standard Checklist",
      "Indicators (Extension)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Indicators (Extension)"
    },
    "tags": [
      "indicator"
    ]
  },
  {
    "content": "### Position Sizing\n- [ ] Fixed dollar risk\n- [ ] Fixed percentage risk\n- [ ] ATR-based sizing (default)\n- [ ] Kelly criterion (optional)\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Example usage:::Summary: Gold Standard Checklist::Position Sizing",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Example usage:",
      "Summary: Gold Standard Checklist",
      "Position Sizing"
    ],
    "metadata": {
      "level": 3,
      "heading": "Position Sizing"
    },
    "tags": [
      "risk",
      "position"
    ]
  },
  {
    "content": "### Execution\n- [ ] Immediate entry\n- [ ] Confirmation entry (default)\n- [ ] Limit order entry\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Example usage:::Summary: Gold Standard Checklist::Execution",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Example usage:",
      "Summary: Gold Standard Checklist",
      "Execution"
    ],
    "metadata": {
      "level": 3,
      "heading": "Execution"
    },
    "tags": [
      "strategy",
      "execution"
    ]
  },
  {
    "content": "### Stop Management\n- [ ] Fixed stop\n- [ ] ATR stop (default)\n- [ ] Trailing stop with breakeven\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Example usage:::Summary: Gold Standard Checklist::Stop Management",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Example usage:",
      "Summary: Gold Standard Checklist",
      "Stop Management"
    ],
    "metadata": {
      "level": 3,
      "heading": "Stop Management"
    },
    "tags": [
      "risk"
    ]
  },
  {
    "content": "### Target Management\n- [ ] Fixed R target\n- [ ] ATR target\n- [ ] Partial targets (scale out)\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Example usage:::Summary: Gold Standard Checklist::Target Management",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Example usage:",
      "Summary: Gold Standard Checklist",
      "Target Management"
    ],
    "metadata": {
      "level": 3,
      "heading": "Target Management"
    },
    "tags": [
      "pyramiding"
    ]
  },
  {
    "content": "### Advanced\n- [ ] Pyramiding (add to winners)\n- [ ] Capital recycling\n- [ ] Kelly-based sizing\n\n---\n\n**Document Status**: COMPLETE\n**Version**: 1.0\n**Last Updated**: 2026-01-29\n",
    "chunk_id": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md::Example usage:::Summary: Gold Standard Checklist::Advanced",
    "source_file": "EDGEDEV_INDICATORS_EXECUTION_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Example usage:",
      "Summary: Gold Standard Checklist",
      "Advanced"
    ],
    "metadata": {
      "level": 3,
      "heading": "Advanced"
    },
    "tags": [
      "position",
      "pyramiding"
    ]
  },
  {
    "content": "# EdgeDev Execution System Gold Standard\n**Complete Strategy Definition, Execution & Backtesting Framework**\n\n**Version**: 2.0\n**Date**: 2026-01-29\n**Status**: COMPLETE - Archon-Enabled\n\n---\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::EdgeDev Execution System Gold Standard",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Execution System Gold Standard"
    ],
    "metadata": {
      "level": 1,
      "heading": "EdgeDev Execution System Gold Standard"
    },
    "tags": [
      "backtest",
      "strategy",
      "archon",
      "execution"
    ]
  },
  {
    "content": "## Table of Contents\n\n1. [System Overview](#system-overview)\n2. [Strategy Definition Framework](#strategy-definition-framework)\n3. [Entry Logic](#entry-logic)\n4. [Position Management](#position-management)\n5. [Exit Logic](#exit-logic)\n6. [Pyramiding & Scaling](#pyramiding--scaling)\n7. [Capital Management](#capital-management)\n8. [Risk Management](#risk-management)\n9. [Retry & Re-entry Rules](#retry--re-entry-rules)\n10. [Data Input Modes](#data-input-modes)\n11. [Execution Engine](#execution-engine)\n12. [Performance Metrics](#performance-metrics)\n13. [Validation Framework](#validation-framework)\n14. [Archon Integration](#archon-integration)\n\n---\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::EdgeDev Execution System Gold Standard::Table of Contents",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Execution System Gold Standard",
      "Table of Contents"
    ],
    "metadata": {
      "level": 2,
      "heading": "Table of Contents"
    },
    "tags": [
      "strategy",
      "indicator",
      "archon",
      "risk",
      "position",
      "pyramiding",
      "execution"
    ]
  },
  {
    "content": "## System Overview\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::EdgeDev Execution System Gold Standard::System Overview",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Execution System Gold Standard",
      "System Overview"
    ],
    "metadata": {
      "level": 2,
      "heading": "System Overview"
    },
    "tags": []
  },
  {
    "content": "### What This System Does\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    COMPLETE STRATEGY EXECUTION                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                         \u2502\n\u2502  INPUT: Any trading approach you can describe                          \u2502\n\u2502  \u251c\u2500\u2500 Scanner-based strategies                                          \u2502\n\u2502  \u251c\u2500\u2500 Custom signal strategies                                          \u2502\n\u2502  \u251c\u2500\u2500 Hybrid approaches                                                 \u2502\n\u2502  \u2514\u2500\u2500 Multi-stage execution                                            \u2502\n\u2502                                                                         \u2502\n\u2502  PROCESS: Define it \u2192 Agent generates code \u2192 Backtest validates       \u2502\n\u2502                                                                         \u2502\n\u2502  OUTPUT: Production-ready execution system                             \u2502\n\u2502  \u251c\u2500\u2500 Scanner code (if needed)                                          \u2502\n\u2502  \u251c\u2500\u2500 Execution logic                                                   \u2502\n\u2502  \u251c\u2500\u2500 Backtest results                                                  \u2502\n\u2502  \u251c\u2500\u2500 Performance metrics                                               \u2502\n\u2502  \u2514\u2500\u2500 Edge validation                                                   \u2502\n\u2502                                                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::EdgeDev Execution System Gold Standard::System Overview::What This System Does",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Execution System Gold Standard",
      "System Overview",
      "What This System Does"
    ],
    "metadata": {
      "level": 3,
      "heading": "What This System Does"
    },
    "tags": [
      "scanner",
      "backtest",
      "strategy",
      "indicator",
      "v31",
      "code",
      "execution"
    ]
  },
  {
    "content": "### Architecture",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::EdgeDev Execution System Gold Standard::System Overview::Architecture::chunk0",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Execution System Gold Standard",
      "System Overview",
      "Architecture"
    ],
    "metadata": {
      "level": 3,
      "heading": "Architecture"
    },
    "tags": [
      "scanner",
      "backtest",
      "strategy",
      "pattern",
      "v31",
      "archon",
      "code",
      "risk",
      "pyramiding",
      "execution"
    ]
  },
  {
    "content": "### Architecture\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    ARCHON-POWERED WORKFLOW                             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                         \u2502\n\u2502  1. USER DESCRIBES STRATEGY                                            \u2502\n\u2502     \"I want to fade gap ups with pyramiding and trailing stops\"        \u2502\n\u2502                                                                         \u2502\n\u2502  2. AGENT QUERIES ARCHON                                                \u2502\n\u2502     \u251c\u2500\u2500 Retrieve: Gap fade patterns                                     \u2502\n\u2502     \u251c\u2500\u2500 Retrieve: Pyramiding best practices                            \u2502\n\u2502     \u251c\u2500\u2500 Retrieve: Trailing stop methods                                \u2502\n\u2502     \u251c\u2500\u2500 Retrieve: Past similar projects                                \u2502\n\u2502     \u2514\u2500\u2500 Retrieve: What worked/what didn't                             \u2502\n\u2502                                                                         \u2502\n\u2502  3. AGENT GENERATES STRATEGY DEFINITION                                \u2502\n\u2502     \u251c\u2500\u2500 Entry logic (from Archon patterns)                             \u2502\n\u2502     \u251c\u2500\u2500 Execution rules (from Archon knowledge)                        \u2502\n\u2502     \u251c\u2500\u2500 Parameter suggestions (from past results)                      \u2502\n\u2502     \u2514\u2500\u2500 Code structure (from V31 Gold Standard)                        \u2502\n\u2502                                                                         \u2502\n\u2502  4. AGENT GENERATES CODE                                                \u2502\n\u2502     \u251c\u2500\u2500 Scanner (if needed)                                             \u2502\n\u2502     \u251c\u2500\u2500 Execution engine                                                \u2502\n\u2502     \u251c\u2500\u2500 Backtest simulator                                              \u2502\n\u2502     \u2514\u2500\u2500 Validation code                                                 \u2502\n\u2502                                                                         \u2502\n\u2502  5. SYSTEM VALIDATES                                                    \u2502\n\u2502     \u251c\u2500\u2500 Run backtest                                                   \u2502\n\u2502     \u251c\u2500\u2500 Check A+ examples                                              \u2502\n\u2502     \u251c\u2500\u2500 Validate edge                                                  \u2502\n\u2502     \u2514\u2500\u2500 Store results in Archon                                        \u2502\n\u2502                                                                         \u2502\n\u2502  6. USER REVIEWS & ITERATES                                            \u2502\n\u2502     \u2514\u2500\u2500 Cycle continues, agent learns more                             \u2502\n\u2502                                                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::EdgeDev Execution System Gold Standard::System Overview::Architecture::chunk1",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Execution System Gold Standard",
      "System Overview",
      "Architecture"
    ],
    "metadata": {
      "level": 3,
      "heading": "Architecture"
    },
    "tags": [
      "scanner",
      "backtest",
      "strategy",
      "pattern",
      "v31",
      "archon",
      "code",
      "risk",
      "pyramiding",
      "execution"
    ]
  },
  {
    "content": "learns more                             \u2502\n\u2502                                                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n\n\n[...previous chunk overlap...]\n\n---",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::EdgeDev Execution System Gold Standard::System Overview::Architecture::chunk2",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Execution System Gold Standard",
      "System Overview",
      "Architecture"
    ],
    "metadata": {
      "level": 3,
      "heading": "Architecture"
    },
    "tags": [
      "scanner",
      "backtest",
      "strategy",
      "pattern",
      "v31",
      "archon",
      "code",
      "risk",
      "pyramiding",
      "execution"
    ]
  },
  {
    "content": "## Strategy Definition Framework\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::EdgeDev Execution System Gold Standard::Strategy Definition Framework",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Execution System Gold Standard",
      "Strategy Definition Framework"
    ],
    "metadata": {
      "level": 2,
      "heading": "Strategy Definition Framework"
    },
    "tags": [
      "strategy"
    ]
  },
  {
    "content": "### Complete Strategy Specification\n\nEvery strategy can be fully defined with these components:",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::EdgeDev Execution System Gold Standard::Strategy Definition Framework::Complete Strategy Specification::chunk0",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Execution System Gold Standard",
      "Strategy Definition Framework",
      "Complete Strategy Specification"
    ],
    "metadata": {
      "level": 3,
      "heading": "Complete Strategy Specification"
    },
    "tags": [
      "scanner",
      "strategy",
      "indicator",
      "pattern",
      "code",
      "risk",
      "position",
      "pyramiding"
    ]
  },
  {
    "content": "### Complete Strategy Specification\n\nEvery strategy can be fully defined with these components:\n\n```python\nstrategy = {\n    # === IDENTITY ===\n    'name': 'Gap Fade with Pyramiding',\n    'description': 'Fade gap ups, add to winners, trail stops',\n    'author': 'User',\n    'created': '2025-01-29',\n\n    # === ENTRY LOGIC ===\n    'entry': {\n        'type': 'scanner_based',  # OR 'custom_signal' OR 'hybrid'\n        'scanner': 'GapFadeScanner',\n        'custom_condition': None,\n        'signal_filter': None,  # Additional filtering\n        'initial_position_pct': 0.5,  # Start with 50% of full position\n    },\n\n    # === POSITION MANAGEMENT ===\n    'position': {\n        'sizing_method': 'atr_based',  # OR 'fixed_pct' OR 'kelly'\n        'risk_per_trade_pct': 0.01,  # 1% of account\n        'max_positions': 5,\n        'correlation_limit': 0.7,  # Max correlation between positions\n    },\n\n    # === PYRAMIDING (Adding to Winners) ===\n    'pyramid': {\n        'enabled': True,\n        'num_adds': 2,  # Maximum 2 additions\n        'trigger': 'unrealized_r >= 1.0',  # Add when up 1R\n        'add_size_pct': 0.25,  # Add 25% of initial each time\n        'spacing': 'atr_based',  # OR 'fixed_r' OR 'fixed_price'\n        'atr_spacing': 1.5,\n    },\n\n    # === STOPS ===\n    'stops': {\n        'initial': {\n            'type': 'atr_based',  # OR 'fixed_price' OR 'fixed_pct'\n            'atr_multiplier': 0.8,\n        },\n        'breakeven': {\n            'enabled': True,\n            'trigger_r': 1.0,  # Move to breakeven after 1R\n        },\n        'trailing': {\n            'enabled': True,\n            'trigger_r': 2.0,  # Start trailing after 2R\n            'type': 'atr_based',  # OR 'fixed_r' OR 'percent'\n            'atr_multiplier': 0.5,\n        },\n        'time_stop': {\n            'enabled': False,\n            'max_holding_minutes': 240,\n        },\n    },\n\n    # === TARGETS ===\n    'targets': [\n        {'r': 1.5, 'exit_pct': 0.5, 'type': 'profit_target'},\n        {'r': 3.0, 'exit_pct': 0.3, 'type': 'profit_target'},\n        {'r': 5.0, 'exit_pct': 0.2, 'type': 'profit_target'},\n    ],\n    # Remaining exited by other conditions (stop, time, etc.)\n\n    # === RETRY RULES (Re-entry) ===\n    'retry': {\n        'enabled': True,\n        'condition': 'signal_reoccurs AND volume >= 2x_initial',\n        'cooldown_bars': 5,  # Wait 5 bars before re-entry\n        'max_retries_per_setup': 2,\n        'reset_after_stop': True,  # Reset retry count after stopped\n    },\n\n    # === CAPITAL MANAGEMENT ===\n    'capital': {\n        'recycling_pct': 0.5,  # Reinvest 50% of profits\n        'withdraw_pct': 0.5,  # Withdraw 50% of profits\n        'compounding': True,  # Compound profits\n        'base_rebalance': 'daily',  # How often to reset to base capital\n    },\n\n    # === RISK MANAGEMENT ===\n    'risk': {\n        'max_risk_per_trade': 0.02,  # 2% of account per trade\n        'max_portfolio_risk': 0.10,  # Stop trading if 10% drawdown\n        'max_correlation_exposure': 0.15,  # Max exposure to correlated positions\n        'daily_loss_limit': 0.03,  # Stop trading if 3% loss in day\n    },\n\n    # === DATA SOURCE ===\n    'data': {\n        'mode': 'scanner_results',  # OR 'single_ticker' OR 'multi_ticker' OR 'custom'\n        'tickers': None,  # For single/multi mode\n        'scanner_config': None,  # For scanner mode\n        'custom_data_source': None,  # For custom mode\n    },\n\n    # === VALIDATION ===\n    'validation': {\n        'min_trades': 30,\n        'min_win_rate': 0.55,\n        'min_expectancy': 0.10,  # 0.10R per trade\n        'max_drawdown': 0.15,\n        'regime_check': True,  # Must work in multiple regimes\n    },\n}\n```",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::EdgeDev Execution System Gold Standard::Strategy Definition Framework::Complete Strategy Specification::chunk1",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Execution System Gold Standard",
      "Strategy Definition Framework",
      "Complete Strategy Specification"
    ],
    "metadata": {
      "level": 3,
      "heading": "Complete Strategy Specification"
    },
    "tags": [
      "scanner",
      "strategy",
      "indicator",
      "pattern",
      "code",
      "risk",
      "position",
      "pyramiding"
    ]
  },
  {
    "content": "rades': 30,\n        'min_win_rate': 0.55,\n        'min_expectancy': 0.10,  # 0.10R per trade\n        'max_drawdown': 0.15,\n        'regime_check': True,  # Must work in multiple regimes\n    },\n}\n```\n\n\n\n[...previous chunk overlap...]\n\n---",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::EdgeDev Execution System Gold Standard::Strategy Definition Framework::Complete Strategy Specification::chunk2",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Execution System Gold Standard",
      "Strategy Definition Framework",
      "Complete Strategy Specification"
    ],
    "metadata": {
      "level": 3,
      "heading": "Complete Strategy Specification"
    },
    "tags": [
      "scanner",
      "strategy",
      "indicator",
      "pattern",
      "code",
      "risk",
      "position",
      "pyramiding"
    ]
  },
  {
    "content": "## Entry Logic\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::EdgeDev Execution System Gold Standard::Entry Logic",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Execution System Gold Standard",
      "Entry Logic"
    ],
    "metadata": {
      "level": 2,
      "heading": "Entry Logic"
    },
    "tags": []
  },
  {
    "content": "### Entry Types\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::EdgeDev Execution System Gold Standard::Entry Logic::Entry Types",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "EdgeDev Execution System Gold Standard",
      "Entry Logic",
      "Entry Types"
    ],
    "metadata": {
      "level": 3,
      "heading": "Entry Types"
    },
    "tags": []
  },
  {
    "content": "#### Type 1: Scanner-Based Entry\n\n```python",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::EdgeDev Execution System Gold Standard::Entry Logic::Entry Types::Type 1: Scanner-Based Entry",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "EdgeDev Execution System Gold Standard",
      "Entry Logic",
      "Entry Types",
      "Type 1: Scanner-Based Entry"
    ],
    "metadata": {
      "level": 4,
      "heading": "Type 1: Scanner-Based Entry"
    },
    "tags": [
      "scanner",
      "code"
    ]
  },
  {
    "content": "# Entry triggered by scanner signal\nentry = {\n    'type': 'scanner_based',\n    'scanner': 'GapFadeScanner',  # References scanner in Archon\n    'signal_filter': {\n        'min_gap': 0.03,  # Minimum 3% gap\n        'min_volume_ratio': 1.5,\n        'max_hold_range': 0.005,  # Hold tight\n    },\n    'initial_position_pct': 0.5,  # Start with 50% position\n}\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Entry triggered by scanner signal",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Entry triggered by scanner signal"
    ],
    "metadata": {
      "level": 1,
      "heading": "Entry triggered by scanner signal"
    },
    "tags": [
      "scanner",
      "indicator",
      "archon",
      "position"
    ]
  },
  {
    "content": "# Agent retrieves from Archon:",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Agent retrieves from Archon:",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Agent retrieves from Archon:"
    ],
    "metadata": {
      "level": 1,
      "heading": "Agent retrieves from Archon:"
    },
    "tags": [
      "archon"
    ]
  },
  {
    "content": "# - Scanner code (V31-compliant)",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::- Scanner code (V31-compliant)",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "- Scanner code (V31-compliant)"
    ],
    "metadata": {
      "level": 1,
      "heading": "- Scanner code (V31-compliant)"
    },
    "tags": [
      "scanner",
      "v31",
      "code"
    ]
  },
  {
    "content": "# - Best parameter values (from past optimizations)",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::- Best parameter values (from past optimizations)",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "- Best parameter values (from past optimizations)"
    ],
    "metadata": {
      "level": 1,
      "heading": "- Best parameter values (from past optimizations)"
    },
    "tags": [
      "optimization"
    ]
  },
  {
    "content": "# - Typical signal characteristics\n```\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::- Typical signal characteristics",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "- Typical signal characteristics"
    ],
    "metadata": {
      "level": 1,
      "heading": "- Typical signal characteristics"
    },
    "tags": [
      "indicator"
    ]
  },
  {
    "content": "#### Type 2: Custom Signal Entry\n\n```python",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::- Typical signal characteristics::Type 2: Custom Signal Entry",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "- Typical signal characteristics",
      "Type 2: Custom Signal Entry"
    ],
    "metadata": {
      "level": 4,
      "heading": "Type 2: Custom Signal Entry"
    },
    "tags": [
      "indicator",
      "code"
    ]
  },
  {
    "content": "# Entry based on custom logic (no scanner)\nentry = {\n    'type': 'custom_signal',\n    'condition': 'close < open AND volume > 2x_avg AND close < low_5_bars_ago',\n    'lookback_bars': 20,  # Need 20 bars history\n    'signal_strength': 'min_score_70',  # If signal has strength metric\n    'initial_position_pct': 1.0,  # Full position immediately\n}\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Entry based on custom logic (no scanner)",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Entry based on custom logic (no scanner)"
    ],
    "metadata": {
      "level": 1,
      "heading": "Entry based on custom logic (no scanner)"
    },
    "tags": [
      "scanner",
      "indicator",
      "position"
    ]
  },
  {
    "content": "# Agent generates from Archon knowledge:",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Agent generates from Archon knowledge:",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Agent generates from Archon knowledge:"
    ],
    "metadata": {
      "level": 1,
      "heading": "Agent generates from Archon knowledge:"
    },
    "tags": [
      "archon"
    ]
  },
  {
    "content": "# - Condition parsing",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::- Condition parsing",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "- Condition parsing"
    ],
    "metadata": {
      "level": 1,
      "heading": "- Condition parsing"
    },
    "tags": []
  },
  {
    "content": "# - Feature calculation (indicators)",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::- Feature calculation (indicators)",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "- Feature calculation (indicators)"
    ],
    "metadata": {
      "level": 1,
      "heading": "- Feature calculation (indicators)"
    },
    "tags": [
      "indicator"
    ]
  },
  {
    "content": "# - Signal strength scoring\n```\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::- Signal strength scoring",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "- Signal strength scoring"
    ],
    "metadata": {
      "level": 1,
      "heading": "- Signal strength scoring"
    },
    "tags": [
      "indicator"
    ]
  },
  {
    "content": "#### Type 3: Hybrid Entry\n\n```python",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::- Signal strength scoring::Type 3: Hybrid Entry",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "- Signal strength scoring",
      "Type 3: Hybrid Entry"
    ],
    "metadata": {
      "level": 4,
      "heading": "Type 3: Hybrid Entry"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# Entry combines scanner + custom confirmation\nentry = {\n    'type': 'hybrid',\n    'primary': 'scanner_signal',  # Scanner provides initial signal\n    'confirmation': 'custom_condition',  # Custom confirms entry\n    'scanner': 'GapFadeScanner',\n    'confirmation_logic': 'close < open AND volume_expanding',\n    'initial_position_pct': 0.75,  # Larger position when confirmed\n}\n```\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Entry combines scanner + custom confirmation",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Entry combines scanner + custom confirmation"
    ],
    "metadata": {
      "level": 1,
      "heading": "Entry combines scanner + custom confirmation"
    },
    "tags": [
      "scanner",
      "indicator",
      "position"
    ]
  },
  {
    "content": "### Entry Timing\n\n```python\nentry_timing = {\n    'type': 'immediate',  # OR 'confirmation' OR 'limit'\n\n    # Immediate: Enter at signal\n    'immediate': {\n        'price': 'close',  # OR 'open' OR 'next_open'\n    },\n\n    # Confirmation: Wait for confirmation pattern\n    'confirmation': {\n        'pattern': 'weak_close',  # OR 'volume_spike' OR 'breakout'\n        'max_wait_bars': 3,  # Don't wait forever\n        'entry_price': 'close_of_confirm_bar',\n    },\n\n    # Limit: Place limit order\n    'limit': {\n        'discount_from_signal': 0.001,  # 0.1% discount\n        'max_wait_bars': 5,\n        'if_not_filled': 'skip' OR 'market_order',\n    },\n}\n```\n\n---\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Entry combines scanner + custom confirmation::Entry Timing",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Entry combines scanner + custom confirmation",
      "Entry Timing"
    ],
    "metadata": {
      "level": 3,
      "heading": "Entry Timing"
    },
    "tags": [
      "indicator",
      "pattern",
      "code",
      "execution"
    ]
  },
  {
    "content": "## Position Management\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Entry combines scanner + custom confirmation::Position Management",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Entry combines scanner + custom confirmation",
      "Position Management"
    ],
    "metadata": {
      "level": 2,
      "heading": "Position Management"
    },
    "tags": [
      "position"
    ]
  },
  {
    "content": "### Position Sizing\n\n```python",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Entry combines scanner + custom confirmation::Position Management::Position Sizing",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Entry combines scanner + custom confirmation",
      "Position Management",
      "Position Sizing"
    ],
    "metadata": {
      "level": 3,
      "heading": "Position Sizing"
    },
    "tags": [
      "code",
      "position"
    ]
  },
  {
    "content": "# Sizing methods (stored in Archon, retrieved by agent)\nposition_sizing = {\n    'method': 'atr_based',  # Most common for trading\n\n    'atr_based': {\n        'risk_per_trade_pct': 0.01,  # 1% of account\n        'atr_multiplier': 0.8,  # Stop at 0.8x ATR\n        'shares': 'risk_amount / (atr * atr_multiplier)',\n    },\n\n    'fixed_pct': {\n        'risk_per_trade_pct': 0.01,\n        'shares': '(account * risk_pct) / (entry - stop)',\n    },\n\n    'kelly': {\n        'win_rate': 0.60,  # From backtest\n        'avg_win_r': 2.0,\n        'avg_loss_r': 1.0,\n        'kelly_fraction': 0.25,  # Use quarter-Kelly\n        'shares': '(account * kelly_pct) / loss_amount',\n    },\n\n    'volatility_adjusted': {\n        'base_risk_pct': 0.01,\n        'vol_adjustment': 'atr / 20d_avg_atr',\n        'final_risk_pct': 'base_risk * vol_adjustment',\n    },\n}\n```\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Sizing methods (stored in Archon, retrieved by agent)",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Sizing methods (stored in Archon, retrieved by agent)"
    ],
    "metadata": {
      "level": 1,
      "heading": "Sizing methods (stored in Archon, retrieved by agent)"
    },
    "tags": [
      "backtest",
      "strategy",
      "archon",
      "risk",
      "position"
    ]
  },
  {
    "content": "### Multi-Position Management\n\n```python",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Sizing methods (stored in Archon, retrieved by agent)::Multi-Position Management",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Sizing methods (stored in Archon, retrieved by agent)",
      "Multi-Position Management"
    ],
    "metadata": {
      "level": 3,
      "heading": "Multi-Position Management"
    },
    "tags": [
      "code",
      "position"
    ]
  },
  {
    "content": "# Managing multiple simultaneous positions\nposition_management = {\n    'max_positions': 5,  # Maximum concurrent positions\n\n    'position_limits': {\n        'max_per_sector': 2,  # Max 2 positions per sector\n        'max_correlated': 2,  # Max 2 correlated positions\n        'correlation_threshold': 0.7,\n    },\n\n    'sizing_with_multiple': {\n        'method': 'equal_risk',  # Equal risk per position\n        # OR 'equal_weight',  # Equal dollar amount\n        # OR 'volatility_paridad',  # More volatile = smaller position\n    },\n\n    'entry_priority': {\n        'rank_by': 'signal_strength',  # OR 'gap_size' OR 'volume'\n        'max_entries_per_day': 3,\n    },\n}\n```\n\n---\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Managing multiple simultaneous positions",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Managing multiple simultaneous positions"
    ],
    "metadata": {
      "level": 1,
      "heading": "Managing multiple simultaneous positions"
    },
    "tags": [
      "indicator",
      "risk",
      "position"
    ]
  },
  {
    "content": "## Exit Logic\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Managing multiple simultaneous positions::Exit Logic",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Managing multiple simultaneous positions",
      "Exit Logic"
    ],
    "metadata": {
      "level": 2,
      "heading": "Exit Logic"
    },
    "tags": []
  },
  {
    "content": "### Exit Types\n\n```python\nexit_logic = {\n    # 1. Profit Target (R-based)\n    'profit_target': {\n        'enabled': True,\n        'type': 'r_multiple',  # OR 'atr_based' OR 'price'\n        'targets': [\n            {'r': 1.5, 'exit_pct': 0.50},  # Exit 50% at 1.5R\n            {'r': 3.0, 'exit_pct': 0.30},  # Exit 30% at 3.0R\n            {'r': 5.0, 'exit_pct': 0.20},  # Exit 20% at 5.0R\n        ],\n        # Remaining 100% exited by other conditions\n    },\n\n    # 2. Stop Loss\n    'stop_loss': {\n        'initial': {\n            'type': 'atr_based',\n            'atr_multiplier': 0.8,\n            'buffer': 0.001,  # Small buffer to avoid noise\n        },\n        'breakeven': {\n            'enabled': True,\n            'trigger_r': 1.0,  # Move to breakeven after 1R\n        },\n        'trailing': {\n            'enabled': True,\n            'trigger_r': 2.0,  # Start trailing after 2R\n            'type': 'atr_based',\n            'atr_multiplier': 0.5,\n            # Trail stops as price moves in favor\n        },\n    },\n\n    # 3. Time-Based Exit\n    'time_exit': {\n        'enabled': True,\n        'max_holding_minutes': 240,  # 4 hours\n        'end_of_day': True,  # Exit at market close\n        'exit_time': '15:55:00',  # Exit at 3:55 PM ET\n    },\n\n    # 4. Condition-Based Exit\n    'condition_exit': {\n        'enabled': False,\n        'conditions': [\n            'volume_dries_up',  # Volume drops below threshold\n            'momentum_slows',  # Rate of change decreases\n            'pattern_invalidated',  # Setup fails\n        ],\n    },\n\n    # 5. Target Exit Priority\n    'exit_priority': [\n        'stop_loss',      # Check first (protect capital)\n        'profit_target',  # Check second (lock in gains)\n        'time_exit',      # Check third (don't overhold)\n        'condition_exit', # Check fourth\n    ],\n}\n```\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Managing multiple simultaneous positions::Exit Logic::Exit Types",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Managing multiple simultaneous positions",
      "Exit Logic",
      "Exit Types"
    ],
    "metadata": {
      "level": 3,
      "heading": "Exit Types"
    },
    "tags": [
      "pattern",
      "code",
      "risk"
    ]
  },
  {
    "content": "### Stop Management Implementation",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Managing multiple simultaneous positions::Exit Logic::Stop Management Implementation::chunk0",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Managing multiple simultaneous positions",
      "Exit Logic",
      "Stop Management Implementation"
    ],
    "metadata": {
      "level": 3,
      "heading": "Stop Management Implementation"
    },
    "tags": [
      "strategy",
      "pattern",
      "archon",
      "code",
      "risk",
      "position"
    ]
  },
  {
    "content": "### Stop Management Implementation\n\n```python\nclass StopManager:\n    \"\"\"\n    Manages all stop types for a position\n\n    Retrieved from Archon:\n    - Stop patterns that work\n    - ATR multiplier preferences\n    - Breakeven triggers\n    - Trailing configurations\n    \"\"\"\n\n    def __init__(self, position, strategy_config):\n        self.position = position\n        self.config = strategy_config['stops']\n\n        # Initialize stops\n        self.initial_stop = self._calculate_initial_stop()\n        self.current_stop = self.initial_stop\n        self.highest_price = position.entry_price  # For longs\n        self.lowest_price = position.entry_price   # For shorts\n\n    def update(self, bar):\n        \"\"\"Update stops based on new bar\"\"\"\n        unrealized_r = self._calculate_unrealized_r(bar)\n\n        # Check breakeven\n        if self.config['breakeven']['enabled']:\n            if unrealized_r >= self.config['breakeven']['trigger_r']:\n                self.current_stop = self.position.entry_price\n\n        # Check trailing\n        if self.config['trailing']['enabled']:\n            if unrealized_r >= self.config['trailing']['trigger_r']:\n                self._update_trailing_stop(bar)\n\n        # Check time stop\n        if self.config['time_stop']['enabled']:\n            if self._check_time_stop(bar):\n                return {'action': 'exit', 'reason': 'time_stop'}\n\n        # Check if stop hit\n        if self._check_stop_hit(bar):\n            return {'action': 'exit', 'reason': 'stop_loss',\n                    'price': self.current_stop}\n\n        return {'action': 'hold', 'current_stop': self.current_stop}\n\n    def _calculate_initial_stop(self):\n        \"\"\"Calculate initial stop based on config\"\"\"\n        if self.config['initial']['type'] == 'atr_based':\n            stop_distance = self.position.atr * self.config['initial']['atr_multiplier']\n\n            if self.position.direction == 'LONG':\n                return self.position.entry_price - stop_distance\n            else:\n                return self.position.entry_price + stop_distance\n\n    def _update_trailing_stop(self, bar):\n        \"\"\"Update trailing stop\"\"\"\n        if self.position.direction == 'LONG':\n            # Update highest price\n            if bar['high'] > self.highest_price:\n                self.highest_price = bar['high']\n\n            # Calculate new trailing stop\n            trail_distance = self.position.atr * self.config['trailing']['atr_multiplier']\n            new_stop = self.highest_price - trail_distance\n\n            # Only move stop up, never down\n            if new_stop > self.current_stop:\n                self.current_stop = new_stop\n```",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Managing multiple simultaneous positions::Exit Logic::Stop Management Implementation::chunk1",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Managing multiple simultaneous positions",
      "Exit Logic",
      "Stop Management Implementation"
    ],
    "metadata": {
      "level": 3,
      "heading": "Stop Management Implementation"
    },
    "tags": [
      "strategy",
      "pattern",
      "archon",
      "code",
      "risk",
      "position"
    ]
  },
  {
    "content": "new_stop = self.highest_price - trail_distance\n\n            # Only move stop up, never down\n            if new_stop > self.current_stop:\n                self.current_stop = new_stop\n```\n\n\n\n[...previous chunk overlap...]\n\n---",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Managing multiple simultaneous positions::Exit Logic::Stop Management Implementation::chunk2",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Managing multiple simultaneous positions",
      "Exit Logic",
      "Stop Management Implementation"
    ],
    "metadata": {
      "level": 3,
      "heading": "Stop Management Implementation"
    },
    "tags": [
      "strategy",
      "pattern",
      "archon",
      "code",
      "risk",
      "position"
    ]
  },
  {
    "content": "## Pyramiding & Scaling\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Managing multiple simultaneous positions::Pyramiding & Scaling",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Managing multiple simultaneous positions",
      "Pyramiding & Scaling"
    ],
    "metadata": {
      "level": 2,
      "heading": "Pyramiding & Scaling"
    },
    "tags": [
      "pyramiding"
    ]
  },
  {
    "content": "### Pyramiding (Adding to Winners)\n\n```python\npyramid_config = {\n    'enabled': True,\n\n    # When to add\n    'trigger': {\n        'type': 'r_based',  # OR 'price_based' OR 'time_based'\n        'r_threshold': 1.0,  # Add when up 1R\n        # OR\n        'price_threshold': 'entry + (2 * atr)',\n        # OR\n        'time_threshold': '30_minutes_after_entry',\n    },\n\n    # How much to add\n    'add_size': {\n        'type': 'pct_of_initial',  # OR 'fixed_risk' OR 'volatility_adjusted'\n        'pct_of_initial': 0.25,  # Add 25% of initial position each time\n        # OR\n        'fixed_risk': 500,  # Add $500 risk worth\n        # OR\n        'volatility_adjusted': 'initial * (entry_atr / current_atr)',\n    },\n\n    # How many times\n    'max_adds': 2,  # Maximum 2 additions\n\n    # Where to add\n    'add_levels': {\n        'type': 'automatic',  # Add at trigger\n        # OR 'predefined': Add at specific price levels\n        'levels': [\n            {'price': 'entry + (1.5 * atr)', 'size_pct': 0.25},\n            {'price': 'entry + (3.0 * atr)', 'size_pct': 0.25},\n        ],\n    },\n\n    # Stop management with pyramiding\n    'stops': {\n        'move_to_breakeven': 'after_first_add',  # After first add-on\n        'trail_all_adds': True,  # Trail all positions together\n    },\n}\n```\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Managing multiple simultaneous positions::Pyramiding & Scaling::Pyramiding (Adding to Winners)",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Managing multiple simultaneous positions",
      "Pyramiding & Scaling",
      "Pyramiding (Adding to Winners)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Pyramiding (Adding to Winners)"
    },
    "tags": [
      "code",
      "risk",
      "position",
      "pyramiding"
    ]
  },
  {
    "content": "### Scaling (Position Sizing Over Time)\n\n```python\nscaling_config = {\n    'enabled': False,\n\n    # Scale in (build position over time)\n    'scale_in': {\n        'initial_entry': 0.33,  # Start with 33%\n        'second_entry': 0.33,   # Add 33% at confirmation\n        'third_entry': 0.34,    # Add 34% on continuation\n        'conditions': [\n            'initial_entry': 'immediate',\n            'second_entry': 'close_below_open',\n            'third_entry': 'continues_lower',\n        ],\n    },\n\n    # Scale out (exit in pieces)\n    'scale_out': {\n        'first_exit': {'r': 1.5, 'pct': 0.50},\n        'second_exit': {'r': 3.0, 'pct': 0.30},\n        'final_exit': {'r': 5.0, 'pct': 0.20},\n    },\n}\n```\n\n---\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Managing multiple simultaneous positions::Pyramiding & Scaling::Scaling (Position Sizing Over Time)",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Managing multiple simultaneous positions",
      "Pyramiding & Scaling",
      "Scaling (Position Sizing Over Time)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Scaling (Position Sizing Over Time)"
    },
    "tags": [
      "code",
      "position",
      "pyramiding"
    ]
  },
  {
    "content": "## Capital Management\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Managing multiple simultaneous positions::Capital Management",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Managing multiple simultaneous positions",
      "Capital Management"
    ],
    "metadata": {
      "level": 2,
      "heading": "Capital Management"
    },
    "tags": []
  },
  {
    "content": "### Recycling Strategies\n\n```python\ncapital_management = {\n    # Base capital configuration\n    'base_capital': 100000,\n    'rebalance_frequency': 'daily',  # Reset to base daily\n\n    # Profit recycling\n    'recycling': {\n        'enabled': True,\n        'recycle_pct': 0.50,  # Reinvest 50% of profits\n        'withdraw_pct': 0.50,  # Withdraw 50% of profits\n        'recycle_delay': 'immediate',  # OR 'after_confirmation'\n    },\n\n    # Compounding\n    'compounding': {\n        'enabled': True,\n        'method': 'full',  # OR 'partial' OR 'kelly_based'\n        'max_growth': 2.0,  # Stop compounding at 2x capital\n    },\n\n    # Drawdown management\n    'drawdown_control': {\n        'max_drawdown_pct': 0.10,  # Stop trading at 10% DD\n        'reduce_size_at': 0.05,  # Reduce position size at 5% DD\n        'reduction_factor': 0.5,  # Reduce by 50%\n        'reset_after_drawdown': True,\n    },\n}\n```\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Managing multiple simultaneous positions::Capital Management::Recycling Strategies",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Managing multiple simultaneous positions",
      "Capital Management",
      "Recycling Strategies"
    ],
    "metadata": {
      "level": 3,
      "heading": "Recycling Strategies"
    },
    "tags": [
      "strategy",
      "code",
      "risk",
      "position"
    ]
  },
  {
    "content": "### Implementation\n\n```python\nclass CapitalManager:\n    \"\"\"\n    Manages account capital and position sizing\n\n    Retrieved from Archon:\n    - Recycling strategies that worked\n    - Risk management rules\n    - Account growth patterns\n    \"\"\"\n\n    def __init__(self, initial_capital, config):\n        self.base_capital = initial_capital\n        self.current_capital = initial_capital\n        self.config = config\n\n    def update_after_trade(self, trade_result):\n        \"\"\"Update capital after trade closes\"\"\"\n        pnl = trade_result['pnl']\n\n        # Apply recycling rules\n        if self.config['recycling']['enabled']:\n            if pnl > 0:  # Profit\n                recycle_amount = pnl * self.config['recycling']['recycle_pct']\n                self.current_capital += recycle_amount\n                # Remaining withdrawn\n            else:  # Loss\n                self.current_capital += pnl  # Full loss applied\n\n        # Check for rebalance\n        if self._should_rebalance():\n            self._rebalance_to_base()\n\n    def get_position_size(self, risk_per_trade, stop_distance):\n        \"\"\"Calculate position size based on current capital and risk\"\"\"\n        risk_amount = self.current_capital * risk_per_trade\n        shares = int(risk_amount / stop_distance)\n        return shares\n\n    def _should_rebalance(self):\n        \"\"\"Check if should reset to base capital\"\"\"\n        # Rebalance daily (or per config)\n        return True  # Simplified\n```\n\n---\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Managing multiple simultaneous positions::Capital Management::Implementation",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Managing multiple simultaneous positions",
      "Capital Management",
      "Implementation"
    ],
    "metadata": {
      "level": 3,
      "heading": "Implementation"
    },
    "tags": [
      "pattern",
      "archon",
      "code",
      "risk",
      "position"
    ]
  },
  {
    "content": "## Risk Management\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Managing multiple simultaneous positions::Risk Management",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Managing multiple simultaneous positions",
      "Risk Management"
    ],
    "metadata": {
      "level": 2,
      "heading": "Risk Management"
    },
    "tags": [
      "risk"
    ]
  },
  {
    "content": "### Portfolio-Level Risk\n\n```python\nrisk_management = {\n    # Per-trade risk\n    'per_trade': {\n        'max_risk_pct': 0.01,  # 1% of account per trade\n        'max_position_pct': 0.20,  # Max 20% of account in one position\n    },\n\n    # Portfolio risk\n    'portfolio': {\n        'max_open_risk': 0.05,  # Max 5% total risk at once\n        'max_drawdown_limit': 0.10,  # Stop trading at 10% DD\n        'max_daily_loss': 0.03,  # Stop trading for day at 3% loss\n    },\n\n    # Correlation risk\n    'correlation': {\n        'max_correlated_positions': 2,\n        'correlation_threshold': 0.7,\n        'sector_concentration_limit': 0.30,  # Max 30% in one sector\n    },\n\n    # Volatility risk\n    'volatility': {\n        'reduce_size_when_vix_high': True,\n        'vix_threshold': 25,\n        'size_reduction_factor': 0.5,\n    },\n}\n```\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Managing multiple simultaneous positions::Risk Management::Portfolio-Level Risk",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Managing multiple simultaneous positions",
      "Risk Management",
      "Portfolio-Level Risk"
    ],
    "metadata": {
      "level": 3,
      "heading": "Portfolio-Level Risk"
    },
    "tags": [
      "strategy",
      "code",
      "risk",
      "position"
    ]
  },
  {
    "content": "### Implementation\n\n```python\nclass RiskManager:\n    \"\"\"\n    Manages portfolio-level risk\n\n    Retrieved from Archon:\n    - Risk rules that protect capital\n    - Drawdown patterns to avoid\n    - Correlation management\n    \"\"\"\n\n    def __init__(self, account_value, config):\n        self.account_value = account_value\n        self.config = config\n        self.current_risk = 0\n        self.positions = {}\n\n    def can_enter_position(self, proposed_position):\n        \"\"\"Check if new position within risk limits\"\"\"\n        # Check per-trade risk\n        position_risk = proposed_position['risk_amount']\n        if position_risk > self.account_value * self.config['per_trade']['max_risk_pct']:\n            return False, \"Position risk exceeds limit\"\n\n        # Check portfolio risk\n        total_risk = self.current_risk + position_risk\n        if total_risk > self.account_value * self.config['portfolio']['max_open_risk']:\n            return False, \"Portfolio risk exceeds limit\"\n\n        # Check correlation\n        if not self._check_correlation(proposed_position):\n            return False, \"Too correlated to existing positions\"\n\n        return True, \"Position approved\"\n\n    def update_daily_limits(self, daily_pnl):\n        \"\"\"Update daily loss limits\"\"\"\n        if daily_pnl < 0:\n            daily_loss_pct = abs(daily_pnl) / self.account_value\n\n            if daily_loss_pct >= self.config['portfolio']['max_daily_loss']:\n                return 'STOP_TRADING_FOR_DAY'\n\n        return 'CONTINUE'\n```\n\n---\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Managing multiple simultaneous positions::Risk Management::Implementation",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Managing multiple simultaneous positions",
      "Risk Management",
      "Implementation"
    ],
    "metadata": {
      "level": 3,
      "heading": "Implementation"
    },
    "tags": [
      "strategy",
      "pattern",
      "archon",
      "code",
      "risk",
      "position"
    ]
  },
  {
    "content": "## Retry & Re-entry Rules\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Managing multiple simultaneous positions::Retry & Re-entry Rules",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Managing multiple simultaneous positions",
      "Retry & Re-entry Rules"
    ],
    "metadata": {
      "level": 2,
      "heading": "Retry & Re-entry Rules"
    },
    "tags": []
  },
  {
    "content": "### Re-entry After Stop\n\n```python\nretry_config = {\n    'enabled': True,\n\n    # When to retry\n    'conditions': [\n        'signal_reoccurs',  # Same setup appears again\n        'volume_confirms',  # Higher volume on re-signal\n        'trend_continues',  # Original trend still intact\n    ],\n\n    # When NOT to retry\n    'exclusions': [\n        'stop_was_far',  # If stopped far from entry (setup failed)\n        'market_regime_changed',  # Market conditions changed\n        'max_retries_reached',  # Already retried max times\n    ],\n\n    # Retry parameters\n    'max_retries': 2,\n    'cooldown_bars': 5,  # Wait 5 bars before retry\n    'cooldown_minutes': 30,  # OR wait 30 minutes\n    'reset_after_new_signal': True,  # Reset retry count on new signal\n\n    # Position sizing on retry\n    'retry_sizing': {\n        'same_size': False,  # Use same size\n        'reduce_size': True,  # Reduce size on retries\n        'reduction_factor': 0.5,  # 50% size on first retry\n        'min_size': 0.25,  # Min 25% of original\n    },\n}\n```\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Managing multiple simultaneous positions::Retry & Re-entry Rules::Re-entry After Stop",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Managing multiple simultaneous positions",
      "Retry & Re-entry Rules",
      "Re-entry After Stop"
    ],
    "metadata": {
      "level": 3,
      "heading": "Re-entry After Stop"
    },
    "tags": [
      "indicator",
      "pattern",
      "code",
      "risk",
      "position"
    ]
  },
  {
    "content": "### Implementation\n\n```python\nclass RetryManager:\n    \"\"\"\n    Manages re-entry after stops\n\n    Retrieved from Archon:\n    - Retry patterns that work\n    - When to retry vs when to skip\n    - Sizing adjustments for retries\n    \"\"\"\n\n    def __init__(self, config):\n        self.config = config\n        self.retry_history = {}  # Track retries per setup\n\n    def can_retry(self, original_signal, current_signal, stop_result):\n        \"\"\"Check if retry is allowed\"\"\"\n        setup_id = self._get_setup_id(original_signal)\n\n        # Check exclusions\n        if self._should_exclude(original_signal, stop_result):\n            return False, \"Retry excluded\"\n\n        # Check max retries\n        if setup_id in self.retry_history:\n            if self.retry_history[setup_id]['count'] >= self.config['max_retries']:\n                return False, \"Max retries reached\"\n\n        # Check conditions\n        if not self._check_conditions(original_signal, current_signal):\n            return False, \"Retry conditions not met\"\n\n        return True, \"Retry allowed\"\n\n    def calculate_retry_size(self, original_size, retry_number):\n        \"\"\"Calculate position size for retry\"\"\"\n        if self.config['retry_sizing']['reduce_size']:\n            reduction = self.config['retry_sizing']['reduction_factor']\n            adjusted_size = original_size * (reduction ** retry_number)\n\n            min_size = original_size * self.config['retry_sizing']['min_size']\n            return max(adjusted_size, min_size)\n\n        return original_size\n```\n\n---\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Managing multiple simultaneous positions::Retry & Re-entry Rules::Implementation",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Managing multiple simultaneous positions",
      "Retry & Re-entry Rules",
      "Implementation"
    ],
    "metadata": {
      "level": 3,
      "heading": "Implementation"
    },
    "tags": [
      "indicator",
      "pattern",
      "archon",
      "code",
      "risk",
      "position"
    ]
  },
  {
    "content": "## Data Input Modes\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Managing multiple simultaneous positions::Data Input Modes",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Managing multiple simultaneous positions",
      "Data Input Modes"
    ],
    "metadata": {
      "level": 2,
      "heading": "Data Input Modes"
    },
    "tags": []
  },
  {
    "content": "### Mode 1: Single Ticker\n\n```python",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Managing multiple simultaneous positions::Data Input Modes::Mode 1: Single Ticker",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Managing multiple simultaneous positions",
      "Data Input Modes",
      "Mode 1: Single Ticker"
    ],
    "metadata": {
      "level": 3,
      "heading": "Mode 1: Single Ticker"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# Test strategy on one ticker\ndata_config = {\n    'mode': 'single_ticker',\n    'ticker': 'SPY',\n    'start_date': '2020-01-01',\n    'end_date': '2024-12-31',\n    'data_source': 'polygon',  # OR 'alphavantage' OR 'local'\n    'bar_size': 'minute',  # OR 'daily' OR '5minute'\n}\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Test strategy on one ticker",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Test strategy on one ticker"
    ],
    "metadata": {
      "level": 1,
      "heading": "Test strategy on one ticker"
    },
    "tags": [
      "strategy",
      "position"
    ]
  },
  {
    "content": "# Use case: Test execution logic without scanner complexity",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Use case: Test execution logic without scanner complexity",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Use case: Test execution logic without scanner complexity"
    ],
    "metadata": {
      "level": 1,
      "heading": "Use case: Test execution logic without scanner complexity"
    },
    "tags": [
      "scanner",
      "strategy",
      "execution"
    ]
  },
  {
    "content": "# Example: \"Test if my pyramiding rules work on SPY\"\n```\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Example: \"Test if my pyramiding rules work on SPY\"",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Example: \"Test if my pyramiding rules work on SPY\""
    ],
    "metadata": {
      "level": 1,
      "heading": "Example: \"Test if my pyramiding rules work on SPY\""
    },
    "tags": [
      "pyramiding"
    ]
  },
  {
    "content": "### Mode 2: Multi-Ticker\n\n```python",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Example: \"Test if my pyramiding rules work on SPY\"::Mode 2: Multi-Ticker",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Example: \"Test if my pyramiding rules work on SPY\"",
      "Mode 2: Multi-Ticker"
    ],
    "metadata": {
      "level": 3,
      "heading": "Mode 2: Multi-Ticker"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# Test strategy on specific group of tickers\ndata_config = {\n    'mode': 'multi_ticker',\n    'tickers': ['SPY', 'QQQ', 'IWM', 'DIA'],\n    'start_date': '2020-01-01',\n    'end_date': '2024-12-31',\n    'data_source': 'polygon',\n    'bar_size': 'daily',\n}\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Test strategy on specific group of tickers",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Test strategy on specific group of tickers"
    ],
    "metadata": {
      "level": 1,
      "heading": "Test strategy on specific group of tickers"
    },
    "tags": [
      "strategy",
      "position"
    ]
  },
  {
    "content": "# Use case: Test on liquid ETFs",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Use case: Test on liquid ETFs",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Use case: Test on liquid ETFs"
    ],
    "metadata": {
      "level": 1,
      "heading": "Use case: Test on liquid ETFs"
    },
    "tags": []
  },
  {
    "content": "# Example: \"Test gap fade on major indices\"\n```\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Example: \"Test gap fade on major indices\"",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Example: \"Test gap fade on major indices\""
    ],
    "metadata": {
      "level": 1,
      "heading": "Example: \"Test gap fade on major indices\""
    },
    "tags": []
  },
  {
    "content": "### Mode 3: Scanner Results\n\n```python",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Example: \"Test gap fade on major indices\"::Mode 3: Scanner Results",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Example: \"Test gap fade on major indices\"",
      "Mode 3: Scanner Results"
    ],
    "metadata": {
      "level": 3,
      "heading": "Mode 3: Scanner Results"
    },
    "tags": [
      "scanner",
      "code"
    ]
  },
  {
    "content": "# Use scanner to find signals, then backtest\ndata_config = {\n    'mode': 'scanner_results',\n    'scanner': 'GapFadeScanner',\n    'scanner_params': {...},  # Scanner parameters\n    'scanner_date_range': {\n        'start': '2020-01-01',\n        'end': '2024-12-31',\n    },\n    'backtest_data': {\n        'bar_size': 'minute',  # Need minute bars for execution\n        'lookback_days': 5,  # Get 5 days around each signal\n    },\n}\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Use scanner to find signals, then backtest",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Use scanner to find signals, then backtest"
    ],
    "metadata": {
      "level": 1,
      "heading": "Use scanner to find signals, then backtest"
    },
    "tags": [
      "scanner",
      "backtest",
      "strategy",
      "indicator",
      "position",
      "execution"
    ]
  },
  {
    "content": "# Use case: Full workflow (scan \u2192 backtest)",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Use case: Full workflow (scan \u2192 backtest)",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Use case: Full workflow (scan \u2192 backtest)"
    ],
    "metadata": {
      "level": 1,
      "heading": "Use case: Full workflow (scan \u2192 backtest)"
    },
    "tags": [
      "scanner",
      "backtest"
    ]
  },
  {
    "content": "# Example: \"Find all gap fades \u2192 Test execution rules\"\n```\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Example: \"Find all gap fades \u2192 Test execution rules\"",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Example: \"Find all gap fades \u2192 Test execution rules\""
    ],
    "metadata": {
      "level": 1,
      "heading": "Example: \"Find all gap fades \u2192 Test execution rules\""
    },
    "tags": [
      "strategy",
      "execution"
    ]
  },
  {
    "content": "### Mode 4: Custom Signal\n\n```python",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Example: \"Find all gap fades \u2192 Test execution rules\"::Mode 4: Custom Signal",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Example: \"Find all gap fades \u2192 Test execution rules\"",
      "Mode 4: Custom Signal"
    ],
    "metadata": {
      "level": 3,
      "heading": "Mode 4: Custom Signal"
    },
    "tags": [
      "indicator",
      "code"
    ]
  },
  {
    "content": "# Generate signals from custom logic, then backtest\ndata_config = {\n    'mode': 'custom_signal',\n    'tickers': ['SPY'],  # OR multi-ticker\n    'signal_generator': {\n        'type': 'python_function',  # OR 'indicator_based' OR 'pattern_based'\n        'logic': 'close < open AND volume > 2x_avg',\n        'lookback': 20,\n    },\n    'backtest_data': {\n        'bar_size': 'minute',\n        'date_range': {...},\n    },\n}\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Generate signals from custom logic, then backtest",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Generate signals from custom logic, then backtest"
    ],
    "metadata": {
      "level": 1,
      "heading": "Generate signals from custom logic, then backtest"
    },
    "tags": [
      "backtest",
      "indicator",
      "pattern",
      "code",
      "position"
    ]
  },
  {
    "content": "# Use case: Test custom idea without building scanner",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Use case: Test custom idea without building scanner",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Use case: Test custom idea without building scanner"
    ],
    "metadata": {
      "level": 1,
      "heading": "Use case: Test custom idea without building scanner"
    },
    "tags": [
      "scanner"
    ]
  },
  {
    "content": "# Example: \"Test if weak close + high volume works\"\n```\n\n---\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Example: \"Test if weak close + high volume works\"",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Example: \"Test if weak close + high volume works\""
    ],
    "metadata": {
      "level": 1,
      "heading": "Example: \"Test if weak close + high volume works\""
    },
    "tags": []
  },
  {
    "content": "## Execution Engine\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Example: \"Test if weak close + high volume works\"::Execution Engine",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Example: \"Test if weak close + high volume works\"",
      "Execution Engine"
    ],
    "metadata": {
      "level": 2,
      "heading": "Execution Engine"
    },
    "tags": [
      "strategy",
      "execution"
    ]
  },
  {
    "content": "### Complete Backtest Simulator",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Example: \"Test if weak close + high volume works\"::Execution Engine::Complete Backtest Simulator::chunk0",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Example: \"Test if weak close + high volume works\"",
      "Execution Engine",
      "Complete Backtest Simulator"
    ],
    "metadata": {
      "level": 3,
      "heading": "Complete Backtest Simulator"
    },
    "tags": [
      "backtest",
      "strategy",
      "indicator",
      "pattern",
      "archon",
      "code",
      "risk",
      "position",
      "pyramiding",
      "execution"
    ]
  },
  {
    "content": "### Complete Backtest Simulator\n\n```python\nclass CompleteExecutionEngine:\n    \"\"\"\n    Simulates complete strategy execution\n\n    Retrieved from Archon:\n    - Execution patterns (what works)\n    - Performance baselines\n    - Common pitfalls to avoid\n    \"\"\"\n\n    def __init__(self, strategy_def, data_config):\n        self.strategy = strategy_def\n        self.data_config = data_config\n\n        # Initialize components\n        self.data_loader = self._initialize_data_loader()\n        self.signal_generator = self._initialize_signal_generator()\n        self.position_manager = PositionManager(strategy_def)\n        self.stop_manager = StopManager(strategy_def)\n        self.capital_manager = CapitalManager(strategy_def)\n        self.risk_manager = RiskManager(strategy_def)\n        self.retry_manager = RetryManager(strategy_def)\n\n    def run_backtest(self):\n        \"\"\"Run complete backtest\"\"\"\n        # Load data based on mode\n        data = self.data_loader.load(self.data_config)\n\n        # Generate signals\n        signals = self.signal_generator.generate(data, self.strategy)\n\n        # Process each signal\n        trades = []\n        equity_curve = []\n        account_value = self.strategy['capital']['base_capital']\n\n        for date, bars in data:\n            # Check existing positions\n            for position in list(self.position_manager.positions):\n                # Update stops\n                stop_action = self.stop_manager.update(position, bars)\n\n                # Check pyramiding\n                if self.strategy['pyramid']['enabled']:\n                    if self._check_pyramid_trigger(position):\n                        self._add_to_position(position)\n\n                # Check exits\n                if stop_action['action'] == 'exit':\n                    closed_trade = self.position_manager.close_position(\n                        position,\n                        exit_price=stop_action['price'],\n                        exit_reason=stop_action['reason']\n                    )\n\n                    trades.append(closed_trade)\n                    account_value += closed_trade['pnl']\n\n                    # Check retry\n                    if self.strategy['retry']['enabled']:\n                        if self.retry_manager.can_retry(closed_trade):\n                            # Re-enter logic\n                            pass\n\n            # Check new signals\n            new_signals = [s for s in signals if s['date'] == date]\n\n            for signal in new_signals:\n                # Check risk limits\n                can_enter, reason = self.risk_manager.can_enter_position(signal)\n\n                if can_enter:\n                    # Enter position\n                    position = self.position_manager.open_position(\n                        signal,\n                        account_value,\n                        self.strategy\n                    )\n\n            # Update equity curve\n            equity_curve.append({\n                'date': date,\n                'account_value': account_value,\n                'positions': len(self.position_manager.positions),\n            })\n\n            # Update capital\n            self.capital_manager.update_after_day(equity_curve[-1])\n\n        # Calculate metrics\n        results = self._calculate_metrics(trades, equity_curve)\n\n        # Validate\n        validation = self._validate_strategy(results, self.strategy)\n\n        return {\n            'trades': trades,\n            'equity_curve': equity_curve,\n            'metrics': results,\n            'validation': validation,\n        }\n```",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Example: \"Test if weak close + high volume works\"::Execution Engine::Complete Backtest Simulator::chunk1",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Example: \"Test if weak close + high volume works\"",
      "Execution Engine",
      "Complete Backtest Simulator"
    ],
    "metadata": {
      "level": 3,
      "heading": "Complete Backtest Simulator"
    },
    "tags": [
      "backtest",
      "strategy",
      "indicator",
      "pattern",
      "archon",
      "code",
      "risk",
      "position",
      "pyramiding",
      "execution"
    ]
  },
  {
    "content": "(results, self.strategy)\n\n        return {\n            'trades': trades,\n            'equity_curve': equity_curve,\n            'metrics': results,\n            'validation': validation,\n        }\n```\n\n\n\n[...previous chunk overlap...]\n\n---",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Example: \"Test if weak close + high volume works\"::Execution Engine::Complete Backtest Simulator::chunk2",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Example: \"Test if weak close + high volume works\"",
      "Execution Engine",
      "Complete Backtest Simulator"
    ],
    "metadata": {
      "level": 3,
      "heading": "Complete Backtest Simulator"
    },
    "tags": [
      "backtest",
      "strategy",
      "indicator",
      "pattern",
      "archon",
      "code",
      "risk",
      "position",
      "pyramiding",
      "execution"
    ]
  },
  {
    "content": "## Performance Metrics\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Example: \"Test if weak close + high volume works\"::Performance Metrics",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Example: \"Test if weak close + high volume works\"",
      "Performance Metrics"
    ],
    "metadata": {
      "level": 2,
      "heading": "Performance Metrics"
    },
    "tags": [
      "indicator"
    ]
  },
  {
    "content": "### Trade-Level Metrics\n\n```python\ntrade_metrics = {\n    # Basic stats\n    'total_trades': 'Total number of trades',\n    'avg_trades_per_month': 'Trading frequency',\n\n    # Win/Loss stats\n    'win_rate': 'Percentage of winning trades',\n    'avg_win_r': 'Average win in R-multiples',\n    'avg_loss_r': 'Average loss in R-multiples',\n    'win_loss_ratio': 'Avg win / Avg loss (absolute)',\n    'largest_win_r': 'Best trade',\n    'largest_loss_r': 'Worst trade',\n\n    # Profitability\n    'total_return_r': 'Total profit in R-multiples',\n    'total_return_pct': 'Total percent return on account',\n    'expectancy': 'Average R per trade',\n    'profit_factor': 'Sum wins / Sum losses (absolute)',\n    'sharpe_ratio': 'Return / Volatility ratio',\n    'sortino_ratio': 'Return / Downside volatility',\n\n    # Risk\n    'max_drawdown_r': 'Maximum peak-to-trough decline in R',\n    'max_drawdown_pct': 'Maximum peak-to-trough decline in %',\n    'max_consecutive_losses': 'Worst losing streak',\n    'avg_drawdown': 'Average drawdown',\n\n    # Efficiency\n    'avg_holding_time': 'Average trade duration',\n    'time_in_market_pct': '% time invested',\n}\n```\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Example: \"Test if weak close + high volume works\"::Performance Metrics::Trade-Level Metrics",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Example: \"Test if weak close + high volume works\"",
      "Performance Metrics",
      "Trade-Level Metrics"
    ],
    "metadata": {
      "level": 3,
      "heading": "Trade-Level Metrics"
    },
    "tags": [
      "strategy",
      "indicator",
      "code",
      "risk"
    ]
  },
  {
    "content": "### Component Analysis\n\n```python",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Example: \"Test if weak close + high volume works\"::Performance Metrics::Component Analysis",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Example: \"Test if weak close + high volume works\"",
      "Performance Metrics",
      "Component Analysis"
    ],
    "metadata": {
      "level": 3,
      "heading": "Component Analysis"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "# What's adding value?\ncomponent_analysis = {\n    # Entry effectiveness\n    'entry_analysis': {\n        'enter_at_signal': 'How well initial entry performs',\n        'confirmation_entry': 'Does confirmation help?',\n        'limit_entry': 'Does limit order improve?',\n        'skip_without_confirmation': 'Cost of skipping',\n    },\n\n    # Pyramiding effectiveness\n    'pyramid_analysis': {\n        'pyramid_contrib_r': 'R added from pyramiding',\n        'pyramid_win_rate': 'Win rate with pyramid vs without',\n        'optimal_num_adds': 'Best number of additions',\n        'when_pyramid_hurts': 'When adding hurts performance',\n    },\n\n    # Exit effectiveness\n    'exit_analysis': {\n        'stop_efficiency': 'Are stops saving capital?',\n        'target_hit_rate': 'How often targets hit',\n        'trailing_contrib': 'R added from trailing',\n        'time_exit_contrib': 'R added from time stops',\n    },\n\n    # Retry effectiveness\n    'retry_analysis': {\n        'retry_win_rate': 'Win rate on retries vs initial',\n        'retry_contrib_r': 'R added from retries',\n        'when_retry_hurts': 'When retries hurt performance',\n    },\n\n    # Capital impact\n    'capital_analysis': {\n        'recycling_contrib_r': 'R added from recycling',\n        'compounding_effect': 'Impact of compounding',\n        'optimal_recycle_pct': 'Best % to recycle',\n    },\n}\n```\n\n---\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::What's adding value?",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "What's adding value?"
    ],
    "metadata": {
      "level": 1,
      "heading": "What's adding value?"
    },
    "tags": [
      "indicator",
      "risk",
      "pyramiding",
      "execution"
    ]
  },
  {
    "content": "## Validation Framework\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::What's adding value?::Validation Framework",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "What's adding value?",
      "Validation Framework"
    ],
    "metadata": {
      "level": 2,
      "heading": "Validation Framework"
    },
    "tags": []
  },
  {
    "content": "### Validation Steps\n\n```python\nvalidation_steps = {\n    # Step 1: Basic validation\n    'basic': {\n        'min_trades': 30,\n        'min_win_rate': 0.55,\n        'min_expectancy': 0.10,\n    },\n\n    # Step 2: Statistical validation\n    'statistical': {\n        't_test_significance': 'p_value < 0.05',\n        'sharpe_threshold': '> 1.0',\n        'max_drawdown_limit': '< 0.15',\n    },\n\n    # Step 3: Regime validation\n    'regime': {\n        'bull_market_performance': 'Must be profitable',\n        'bear_market_performance': 'Must be profitable OR flat',\n        'choppy_performance': 'Must be profitable OR flat',\n        'consistency': '>70% of regimes profitable',\n    },\n\n    # Step 4: Walk-forward validation\n    'walk_forward': {\n        'enabled': True,\n        'train_period': '12 months',\n        'test_period': '3 months',\n        'min_consistency': '>70% periods profitable',\n    },\n\n    # Step 5: Forward validation\n    'forward': {\n        'enabled': True,\n        'forward_period': '6 months minimum',\n        'degradation_limit': '<30% from in-sample',\n    },\n}\n```\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::What's adding value?::Validation Framework::Validation Steps",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "What's adding value?",
      "Validation Framework",
      "Validation Steps"
    ],
    "metadata": {
      "level": 3,
      "heading": "Validation Steps"
    },
    "tags": [
      "code"
    ]
  },
  {
    "content": "### Edge Assessment\n\n```python\nedge_assessment = {\n    # Edge quality\n    'quality_metrics': {\n        'expectancy': '> 0.15R is excellent',\n        'sharpe': '> 2.0 is excellent',\n        'consistency': '<30% std dev is excellent',\n    },\n\n    # Edge durability\n    'durability_metrics': {\n        'walk_forward_pass': '>70% periods pass',\n        'forward_test_pass': '<30% degradation',\n        'regime_stability': 'Works in 2+ regimes',\n    },\n\n    # Edge uniqueness\n    'uniqueness_metrics': {\n        'not_market_return': 'Exceeds buy & hold',\n        'not_random': 'Better than random entries',\n        'pattern_specific': 'Edge from pattern, not beta',\n    },\n\n    # Overall assessment\n    'overall_edge': {\n        'strong_edge': 'Exceeds all thresholds',\n        'moderate_edge': 'Meets most thresholds',\n        'weak_edge': 'Barely passes',\n        'no_edge': 'Fails validation',\n    },\n}\n```\n\n---\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::What's adding value?::Validation Framework::Edge Assessment",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "What's adding value?",
      "Validation Framework",
      "Edge Assessment"
    ],
    "metadata": {
      "level": 3,
      "heading": "Edge Assessment"
    },
    "tags": [
      "indicator",
      "pattern",
      "code"
    ]
  },
  {
    "content": "## Archon Integration\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::What's adding value?::Archon Integration",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "What's adding value?",
      "Archon Integration"
    ],
    "metadata": {
      "level": 2,
      "heading": "Archon Integration"
    },
    "tags": [
      "archon"
    ]
  },
  {
    "content": "### Knowledge Structure in Archon\n\n```\nARCHON KNOWLEDGE BASE\n\u251c\u2500\u2500 SCANNER PATTERNS\n\u2502   \u251c\u2500\u2500 V31 Architecture (7 principles)\n\u2502   \u251c\u2500\u2500 Pattern Types (DMR, FBO, Extension, etc.)\n\u2502   \u251c\u2500\u2500 Code Structure Guide\n\u2502   \u2514\u2500\u2500 Scanner Examples\n\u2502\n\u251c\u2500\u2500 EXECUTION PATTERNS\n\u2502   \u251c\u2500\u2500 Entry Types (scanner, custom, hybrid)\n\u2502   \u251c\u2500\u2500 Position Sizing (4 methods)\n\u2502   \u251c\u2500\u2500 Stop Management (initial, breakeven, trailing)\n\u2502   \u251c\u2500\u2500 Target Management (R-based, partial)\n\u2502   \u251c\u2500\u2500 Pyramiding Rules\n\u2502   \u251c\u2500\u2500 Capital Recycling\n\u2502   \u2514\u2500\u2500 Retry Rules\n\u2502\n\u251c\u2500\u2500 BACKTESTING PATTERNS\n\u2502   \u251c\u2500\u2500 Data Input Modes (4 types)\n\u2502   \u251c\u2500\u2500 Execution Engine Patterns\n\u2502   \u251c\u2500\u2500 Performance Metrics\n\u2502   \u251c\u2500\u2500 Validation Framework\n\u2502   \u2514\u2500\u2500 Common Pitfalls\n\u2502\n\u251c\u2500\u2500 TRADING KNOWLEDGE\n\u2502   \u251c\u2500\u2500 Mean Reversion Principles\n\u2502   \u251c\u2500\u2500 Market Regimes\n\u2502   \u251c\u2500\u2500 Edge Assessment\n\u2502   \u251c\u2500\u2500 Risk Management\n\u2502   \u2514\u2500\u2500 Position Management\n\u2502\n\u251c\u2500\u2500 PAST PROJECTS\n\u2502   \u251c\u2500\u2500 Scanners Built (with results)\n\u2502   \u251c\u2500\u2500 Backtests Run (with metrics)\n\u2502   \u251c\u2500\u2500 What Worked (patterns, parameters)\n\u2502   \u2514\u2500\u2500 What Didn't (failures, lessons)\n\u2502\n\u2514\u2500\u2500 CONVERSATIONS\n    \u251c\u2500\u2500 Chat History\n    \u251c\u2500\u2500 User Preferences\n    \u251c\u2500\u2500 Strategy Iterations\n    \u2514\u2500\u2500 Decisions Made\n```\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::What's adding value?::Archon Integration::Knowledge Structure in Archon",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "What's adding value?",
      "Archon Integration",
      "Knowledge Structure in Archon"
    ],
    "metadata": {
      "level": 3,
      "heading": "Knowledge Structure in Archon"
    },
    "tags": [
      "scanner",
      "backtest",
      "strategy",
      "indicator",
      "pattern",
      "v31",
      "archon",
      "code",
      "risk",
      "position",
      "pyramiding",
      "execution"
    ]
  },
  {
    "content": "### Agent Workflow with Archon\n\n```python",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::What's adding value?::Archon Integration::Agent Workflow with Archon",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "What's adding value?",
      "Archon Integration",
      "Agent Workflow with Archon"
    ],
    "metadata": {
      "level": 3,
      "heading": "Agent Workflow with Archon"
    },
    "tags": [
      "archon",
      "code"
    ]
  },
  {
    "content": "# Agent retrieves relevant knowledge before generating code\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Agent retrieves relevant knowledge before generating code",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Agent retrieves relevant knowledge before generating code"
    ],
    "metadata": {
      "level": 1,
      "heading": "Agent retrieves relevant knowledge before generating code"
    },
    "tags": [
      "archon",
      "code"
    ]
  },
  {
    "content": "# Step 1: User describes strategy\nuser_input = \"I want to fade gap ups with pyramiding and trailing stops\"\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Step 1: User describes strategy",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Step 1: User describes strategy"
    ],
    "metadata": {
      "level": 1,
      "heading": "Step 1: User describes strategy"
    },
    "tags": [
      "strategy",
      "risk",
      "pyramiding"
    ]
  },
  {
    "content": "# Step 2: Agent queries Archon for relevant knowledge\narchon_query = {\n    'scanner_patterns': ['gap_fade', 'mean_reversion'],\n    'execution_patterns': ['pyramiding', 'trailing_stops'],\n    'past_projects': 'gap_fade strategies with results',\n    'trading_knowledge': ['mean_reversion', 'edge_validation'],\n}\n\nretrieved_knowledge = archon_client.search(archon_query)\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Step 2: Agent queries Archon for relevant knowledge",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Step 2: Agent queries Archon for relevant knowledge"
    ],
    "metadata": {
      "level": 1,
      "heading": "Step 2: Agent queries Archon for relevant knowledge"
    },
    "tags": [
      "scanner",
      "strategy",
      "pattern",
      "archon",
      "risk",
      "pyramiding",
      "execution"
    ]
  },
  {
    "content": "# Step 3: Agent generates strategy based on retrieved knowledge\nstrategy_def = agent.generate_strategy(user_input, retrieved_knowledge)\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Step 3: Agent generates strategy based on retrieved knowledge",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Step 3: Agent generates strategy based on retrieved knowledge"
    ],
    "metadata": {
      "level": 1,
      "heading": "Step 3: Agent generates strategy based on retrieved knowledge"
    },
    "tags": [
      "strategy",
      "archon"
    ]
  },
  {
    "content": "# Step 4: Agent generates code based on patterns in knowledge\ncode = agent.generate_code(strategy_def, retrieved_knowledge)\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Step 4: Agent generates code based on patterns in knowledge",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Step 4: Agent generates code based on patterns in knowledge"
    ],
    "metadata": {
      "level": 1,
      "heading": "Step 4: Agent generates code based on patterns in knowledge"
    },
    "tags": [
      "strategy",
      "pattern",
      "archon",
      "code"
    ]
  },
  {
    "content": "# Step 5: Results stored back in Archon\narchon_client.store_project({\n    'strategy': strategy_def,\n    'code': code,\n    'backtest_results': results,\n    'conversation_id': current_chat,\n})\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Step 5: Results stored back in Archon",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Step 5: Results stored back in Archon"
    ],
    "metadata": {
      "level": 1,
      "heading": "Step 5: Results stored back in Archon"
    },
    "tags": [
      "backtest",
      "strategy",
      "archon",
      "code"
    ]
  },
  {
    "content": "# Step 6: Agent learns from results\narchon_client.store_learning({\n    'what_worked': 'Pyramiding added 0.3R expectancy',\n    'what_didnt': 'Trailing stops reduced win rate',\n    'user_feedback': user_feedback,\n})\n```\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Step 6: Agent learns from results",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Step 6: Agent learns from results"
    ],
    "metadata": {
      "level": 1,
      "heading": "Step 6: Agent learns from results"
    },
    "tags": [
      "archon",
      "risk",
      "pyramiding"
    ]
  },
  {
    "content": "### Growing Knowledge Base\n\n```\nAGENT IMPROVES OVER TIME\n\nDay 1:\n\u251c\u2500\u2500 Limited knowledge\n\u251c\u2500\u2500 Generates decent code\n\u2514\u2500\u2500 Stores results in Archon\n\nDay 30:\n\u251c\u2500\u2500 30 projects stored\n\u251c\u2500\u2500 Knows what patterns work\n\u251c\u2500\u2500 Knows what parameters work\n\u2514\u2500\u2500 Generates better code\n\nDay 90:\n\u251c\u2500\u2500 90 projects stored\n\u251c\u2500\u2500 Knows user preferences\n\u251c\u2500\u2500 Knows market conditions\n\u251c\u2500\u2500 Has proven patterns\n\u2514\u2500\u2500 Generates excellent code\n\nThe agent doesn't just follow templates.\nIt learns from experience stored in Archon.\n```\n\n---\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Step 6: Agent learns from results::Growing Knowledge Base",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Step 6: Agent learns from results",
      "Growing Knowledge Base"
    ],
    "metadata": {
      "level": 3,
      "heading": "Growing Knowledge Base"
    },
    "tags": [
      "pattern",
      "archon",
      "code"
    ]
  },
  {
    "content": "## Summary: What Makes This Different\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Step 6: Agent learns from results::Summary: What Makes This Different",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Step 6: Agent learns from results",
      "Summary: What Makes This Different"
    ],
    "metadata": {
      "level": 2,
      "heading": "Summary: What Makes This Different"
    },
    "tags": []
  },
  {
    "content": "### Traditional Approach\n```\nUser \u2192 Templates \u2192 Code \u2192 Test\n\u2502      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2502\nPre-built patterns, rigid, no learning\n```\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Step 6: Agent learns from results::Summary: What Makes This Different::Traditional Approach",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Step 6: Agent learns from results",
      "Summary: What Makes This Different",
      "Traditional Approach"
    ],
    "metadata": {
      "level": 3,
      "heading": "Traditional Approach"
    },
    "tags": [
      "pattern",
      "code"
    ]
  },
  {
    "content": "### Our Approach (Archon-Powered)\n```\nUser \u2192 Archon Agent \u2192 Code \u2192 Test\n\u2502         \u2193                    \u2193\n\u2502    All Knowledge         Store\n\u2502    + Past Projects       Results\n\u2502    + Conversations       Back\n\u2502    + What Works          Into\n\u2502    + What Doesn't       Archon\n\u2502                         (Learning)\n```\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Step 6: Agent learns from results::Summary: What Makes This Different::Our Approach (Archon-Powered)",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "code",
    "heading_path": [
      "Step 6: Agent learns from results",
      "Summary: What Makes This Different",
      "Our Approach (Archon-Powered)"
    ],
    "metadata": {
      "level": 3,
      "heading": "Our Approach (Archon-Powered)"
    },
    "tags": [
      "archon",
      "code"
    ]
  },
  {
    "content": "### Key Difference\n\n**Traditional**: Agent follows rules\n**Ours**: Agent learns from experience\n\n---\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Step 6: Agent learns from results::Summary: What Makes This Different::Key Difference",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Step 6: Agent learns from results",
      "Summary: What Makes This Different",
      "Key Difference"
    ],
    "metadata": {
      "level": 3,
      "heading": "Key Difference"
    },
    "tags": []
  },
  {
    "content": "## Complete Checklist\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Step 6: Agent learns from results::Complete Checklist",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Step 6: Agent learns from results",
      "Complete Checklist"
    ],
    "metadata": {
      "level": 2,
      "heading": "Complete Checklist"
    },
    "tags": []
  },
  {
    "content": "### Strategy Definition\n- [ ] Entry logic (scanner, custom, or hybrid)\n- [ ] Position sizing (choose method)\n- [ ] Pyramiding rules (if enabled)\n- [ ] Stop management (all types)\n- [ ] Target management (all types)\n- [ ] Retry rules (if enabled)\n- [ ] Capital management (recycling)\n- [ ] Risk management (portfolio level)\n- [ ] Data input mode (4 options)\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Step 6: Agent learns from results::Complete Checklist::Strategy Definition",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Step 6: Agent learns from results",
      "Complete Checklist",
      "Strategy Definition"
    ],
    "metadata": {
      "level": 3,
      "heading": "Strategy Definition"
    },
    "tags": [
      "scanner",
      "strategy",
      "risk",
      "position",
      "pyramiding"
    ]
  },
  {
    "content": "### Execution Engine\n- [ ] Data loader (all 4 modes)\n- [ ] Signal generator\n- [ ] Position manager\n- [ ] Stop manager\n- [ ] Pyramid manager\n- [ ] Capital manager\n- [ ] Risk manager\n- [ ] Retry manager\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Step 6: Agent learns from results::Complete Checklist::Execution Engine",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Step 6: Agent learns from results",
      "Complete Checklist",
      "Execution Engine"
    ],
    "metadata": {
      "level": 3,
      "heading": "Execution Engine"
    },
    "tags": [
      "strategy",
      "indicator",
      "risk",
      "position",
      "pyramiding",
      "execution"
    ]
  },
  {
    "content": "### Performance Analysis\n- [ ] Trade-level metrics (all)\n- [ ] Component analysis (what adds value)\n- [ ] Regime analysis\n- [ ] Edge validation\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Step 6: Agent learns from results::Complete Checklist::Performance Analysis",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Step 6: Agent learns from results",
      "Complete Checklist",
      "Performance Analysis"
    ],
    "metadata": {
      "level": 3,
      "heading": "Performance Analysis"
    },
    "tags": [
      "indicator"
    ]
  },
  {
    "content": "### Archon Integration\n- [ ] Knowledge retrieval\n- [ ] Pattern matching\n- [ ] Past project reference\n- [ ] Result storage\n- [ ] Learning loop\n\n---\n\n**Document Status**: COMPLETE\n**Version**: 2.0\n**Last Updated**: 2026-01-29\n**Key Feature**: Archon-Powered with Learning & Memory\n",
    "chunk_id": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md::Step 6: Agent learns from results::Complete Checklist::Archon Integration",
    "source_file": "EDGEDEV_EXECUTION_SYSTEM_GOLD_STANDARD.md",
    "chunk_type": "section",
    "heading_path": [
      "Step 6: Agent learns from results",
      "Complete Checklist",
      "Archon Integration"
    ],
    "metadata": {
      "level": 3,
      "heading": "Archon Integration"
    },
    "tags": [
      "pattern",
      "archon"
    ]
  }
]