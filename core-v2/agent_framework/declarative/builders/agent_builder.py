"""
Agent Builder - Generate Python Agent Code from JSON

This module reads a declarative agent definition in JSON format and generates
ready-to-use Python agent code.

Usage:
    from core_v2.agent_framework.declarative.builders import AgentBuilder

    builder = AgentBuilder()
    builder.build("agent.json", output_dir="./my_agent")
"""

import json
import os
from typing import Dict, Any, List
from pathlib import Path
import logging

logger = logging.getLogger(__name__)


class AgentBuilder:
    """
    Builds Python agent code from JSON configuration.

    This class reads a JSON file defining an agent and generates
    complete, production-ready Python code.
    """

    def __init__(self):
        """Initialize agent builder"""
        self.template_dir = Path(__file__).parent.parent / "templates"

    def build(
        self,
        config_path: str,
        output_dir: str,
        include_tests: bool = True,
        include_docker: bool = False
    ) -> bool:
        """
        Build agent from JSON configuration.

        Args:
            config_path: Path to agent JSON file
            output_dir: Directory to write generated code
            include_tests: Whether to generate test files
            include_docker: Whether to generate Docker files

        Returns:
            True if build successful, False otherwise
        """
        try:
            # Load configuration
            config = self._load_config(config_path)
            agent_config = config.get("agent", {})

            if not agent_config:
                logger.error("Invalid config: missing 'agent' key")
                return False

            # Validate configuration
            if not self._validate_config(agent_config):
                return False

            # Create output directory
            output_path = Path(output_dir)
            output_path.mkdir(parents=True, exist_ok=True)

            # Generate files
            logger.info(f"Building agent: {agent_config.get('name', 'Unknown')}")

            # 1. Main agent file
            self._generate_agent_file(agent_config, output_path)

            # 2. Configuration file
            self._generate_config_file(agent_config, output_path)

            # 3. Requirements file
            self._generate_requirements_file(agent_config, output_path)

            # 4. README file
            self._generate_readme_file(agent_config, output_path)

            # 5. Tests (optional)
            if include_tests:
                self._generate_test_file(agent_config, output_path)

            # 6. Docker (optional)
            if include_docker:
                self._generate_docker_files(agent_config, output_path)

            logger.info(f"âœ… Agent built successfully in: {output_dir}")
            return True

        except Exception as e:
            logger.error(f"Error building agent: {e}")
            import traceback
            traceback.print_exc()
            return False

    def _load_config(self, config_path: str) -> Dict[str, Any]:
        """Load JSON configuration from file"""
        with open(config_path, 'r') as f:
            return json.load(f)

    def _validate_config(self, config: Dict[str, Any]) -> bool:
        """Validate agent configuration"""
        required_fields = ["name", "description", "max_tools", "system_prompt", "tools"]

        for field in required_fields:
            if field not in config:
                logger.error(f"Missing required field: {field}")
                return False

        # Validate tool count
        tool_count = len(config.get("tools", []))
        max_tools = config.get("max_tools", 10)

        if tool_count > max_tools:
            logger.warning(
                f"âš ï¸  Tool count ({tool_count}) exceeds maximum ({max_tools}). "
                f"This may degrade LLM performance."
            )

        return True

    def _generate_agent_file(self, config: Dict[str, Any], output_path: Path):
        """Generate main agent Python file"""
        agent_name = self._to_snake_case(config["name"])
        class_name = config["name"].replace(" ", "")

        # Generate Python code
        code = f'''"""
Auto-generated Agent: {config["name"]}
Generated by: CE Hub v2 Agent Builder
Date: {self._get_timestamp()}

Description: {config["description"]}
"""

from typing import Any, Dict, List, Optional
from core_v2.agent_framework.rag_enabled.rag_base import (
    RAGEnabledAgent,
    RAGConfig
)
import logging

logger = logging.getLogger(__name__)


class {class_name}Agent(RAGEnabledAgent):
    """
    {config["name"]}

    {config["description"]}
    """

    def __init__(self):
        """
        Initialize {config["name"]} agent.
        """
        # Initialize RAG configuration
        rag_config = RAGConfig(
            enabled={config.get("rag", {}).get("enabled", True)},
            vector_db_type="{config.get("rag", {}).get("vector_db", "neo4j")}",
            collection_name="{config.get("rag", {}).get("collection_name", f"{agent_name}_knowledge")}",
            top_k={config.get("rag", {}).get("top_k", 5)},
            chunk_size={config.get("rag", {}).get("chunk_size", 512)},
            chunk_overlap={config.get("rag", {}).get("chunk_overlap", 50)}
        )

        # Initialize parent class
        super().__init__(
            rag_config=rag_config,
            max_tools={config.get("max_tools", 10)},
            enable_rag={config.get("rag", {}).get("enabled", True)}
        )

        # Add tools
        self._initialize_tools()

        # Connect to vector database
        # Note: You may want to call this in your async context
        # await self.connect_vector_db()

    def _initialize_tools(self):
        """Initialize agent tools"""
        {self._generate_tools_init(config.get("tools", []), config["name"])}

    def get_system_prompt(self) -> str:
        """Get system prompt for this agent"""
        return """\"\"\"{self._generate_system_prompt(config.get("system_prompt", {}))}\"\"\"\"

    async def execute(
        self,
        task: str,
        context: Optional[Dict[str, Any]] = None,
        use_knowledge: bool = True
    ) -> Any:
        """
        Execute agent task.

        Args:
            task: Task description
            context: Additional context
            use_knowledge: Whether to use RAG knowledge retrieval

        Returns:
            Task execution result
        """
        # Retrieve relevant knowledge if RAG is enabled
        knowledge_context = ""
        if use_knowledge and self.rag_config.enabled:
            result = await self.retrieve_knowledge(task)
            if result.total_retrieved > 0:
                knowledge_context = "\\n\\nRelevant Knowledge:\\n"
                for doc in result.documents:
                    knowledge_context += f"- {{doc['content'][:200]}}...\\n"

        # Enhance task with knowledge
        enhanced_task = task + knowledge_context

        # Execute task with tools (implementation depends on your needs)
        logger.info(f"Executing task: {{task[:50]}}...")

        # TODO: Implement actual task execution logic here
        # This is where you would integrate with your LLM of choice
        # For example, using PydanticAI, OpenAI, Anthropic, etc.

        result = {{
            "task": task,
            "status": "completed",
            "agent": "{config["name"]}",
            "timestamp": self._get_timestamp()
        }}

        # Store execution in knowledge base for future retrieval
        if self.rag_config.enabled:
            await self.store_knowledge(
                content=f"Task: {{task}}\\nResult: {{result}}",
                metadata={{
                    "type": "execution",
                    "agent": "{config["name"]}",
                    "timestamp": self._get_timestamp()
                }}
            )

        return result


{self._generate_tool_classes(config.get("tools", []))}
'''

        # Write to file
        output_file = output_path / f"{agent_name}_agent.py"
        with open(output_file, 'w') as f:
            f.write(code)

        logger.info(f"Generated: {output_file}")

    def _generate_tools_init(self, tools: List[Dict], agent_name: str) -> str:
        """Generate tool initialization code"""
        if not tools:
            return "pass  # No tools defined"

        init_code = "        # Tools\n"
        for tool in tools:
            tool_name = tool["name"]
            tool_desc = tool.get("description", "No description")
            # Create a simple tool object using a named tuple-like approach
            init_code += f'        self.{tool_name}_tool = type("Tool", (), {{\n'
            init_code += f'            "name": "{tool_name}",\n'
            init_code += f'            "description": "{tool_desc}",\n'
            init_code += f'            "func": self.{tool_name}\n'
            init_code += f'        }})()\n'
            init_code += f'        self.add_tool(self.{tool_name}_tool)\n\n'

        return init_code

    def _generate_tool_classes(self, tools: List[Dict]) -> str:
        """Generate tool implementation classes"""
        if not tools:
            return "# No tools defined\n"

        tool_classes = "\n# Tool Implementations\n\n"

        for tool in tools:
            tool_name = tool["name"]
            tool_desc = tool.get("description", "")
            tool_type = tool.get("type", "analysis")
            params = tool.get("parameters", {})

            # Generate function signature
            param_list = []
            for param_name, param_info in params.items():
                param_type = param_info.get("type", "str")
                default_val = param_info.get("default", None)

                if param_info.get("required", False):
                    param_list.append(f"{param_name}: {param_type}")
                else:
                    if default_val is not None:
                        param_list.append(f"{param_name}: {param_type} = {repr(default_val)}")
                    else:
                        param_list.append(f"{param_name}: {param_type} = None")

            sig = ", ".join(param_list) if param_list else ""

            # Generate function docstring
            docstring = f'"""{tool_desc}"""'

            # Generate function body
            body = f'"""TODO: Implement {tool_name}"""'
            if tool_type == "analysis":
                body = f'"""# TODO: Implement {tool_name} analysis"""'
            elif tool_type == "calculation":
                body = f'"""# TODO: Implement {tool_name} calculation"""'

            tool_classes += f"    async def {tool_name}({sig}) -> Any:\n"
            tool_classes += f'        {docstring}\n'
            tool_classes += f'        {body}\n\n'

        return tool_classes

    def _generate_system_prompt(self, sys_prompt: Dict[str, str]) -> str:
        """Generate system prompt string"""
        prompt_parts = []

        if "role" in sys_prompt:
            prompt_parts.append(f"Role: {sys_prompt['role']}")

        if "responsibilities" in sys_prompt:
            resp = "\n".join(f"- {r}" for r in sys_prompt["responsibilities"])
            prompt_parts.append(f"\nResponsibilities:\n{resp}")

        if "guidelines" in sys_prompt:
            guide = "\n".join(f"- {g}" for g in sys_prompt["guidelines"])
            prompt_parts.append(f"\nGuidelines:\n{guide}")

        if "constraints" in sys_prompt:
            constraints = "\n".join(f"- {c}" for c in sys_prompt["constraints"])
            prompt_parts.append(f"\nConstraints:\n{constraints}")

        return "\n".join(prompt_parts)

    def _generate_config_file(self, config: Dict[str, Any], output_path: Path):
        """Generate configuration file"""
        agent_name = self._to_snake_case(config["name"])

        config_data = {
            "agent_name": config["name"],
            "agent_type": config.get("type", "simple"),
            "version": config.get("version", "1.0.0"),
            "model": config.get("model", "claude-3-5-sonnet-20241022"),
            "max_tools": config.get("max_tools", 10),
            "rag_enabled": config.get("rag", {}).get("enabled", True),
            "vector_db": config.get("rag", {}).get("vector_db", "neo4j")
        }

        config_file = output_path / f"{agent_name}_config.json"
        with open(config_file, 'w') as f:
            json.dump(config_data, f, indent=2)

        logger.info(f"Generated: {config_file}")

    def _generate_requirements_file(self, config: Dict[str, Any], output_path: Path):
        """Generate requirements.txt file"""
        requirements = [
            "# Core dependencies",
            "pydantic>=2.5.0",
            "python-dotenv>=1.0.0",
            "",
            "# RAG dependencies"
        ]

        vector_db = config.get("rag", {}).get("vector_db", "neo4j")

        if vector_db == "neo4j":
            requirements.extend([
                "neo4j>=5.0.0",
                "",  "# OpenAI for embeddings (or use sentence-transformers)",
                "# openai>=1.0.0"
            ])
        elif vector_db == "chroma":
            requirements.extend([
                "chromadb>=0.4.0",
                "sentence-transformers>=2.2.0"
            ])

        requirements.extend([
            "",
            "# Optional: LLM clients (choose what you use)",
            "# anthropic>=0.18.0",
            "# openai>=1.0.0",
            "",
            "# Testing",
            "pytest>=7.4.0",
            "pytest-asyncio>=0.21.0",
            "",
            "# Logging",
            "python-json-logger>=2.0.0"
        ])

        req_file = output_path / "requirements.txt"
        with open(req_file, 'w') as f:
            f.write("\n".join(requirements))

        logger.info(f"Generated: {req_file}")

    def _generate_readme_file(self, config: Dict[str, Any], output_path: Path):
        """Generate README.md file"""
        agent_name = config["name"]
        description = config["description"]
        agent_file = self._to_snake_case(agent_name) + "_agent.py"

        readme = f'''# {agent_name}

{description}

## Installation

```bash
pip install -r requirements.txt
```

## Configuration

Set up environment variables:

```bash
# For Neo4j (if using)
NEO4J_URI=bolt://localhost:7687
NEO4J_USERNAME=neo4j
NEO4J_PASSWORD=password

# For OpenAI embeddings (if using)
OPENAI_API_KEY=sk-...

# For LLM (if using)
ANTHROPIC_API_KEY=sk-...
# or
OPENAI_API_KEY=sk-...
```

## Usage

```python
from {agent_file[:-3]} import {agent_name.replace(" ", "")}Agent

async def main():
    # Create agent
    agent = {agent_name.replace(" ", "")}Agent()

    # Connect to vector database
    await agent.connect_vector_db()

    # Execute task
    result = await agent.execute(
        task="Your task here",
        use_knowledge=True  # Enable RAG
    )

    print(result)

    # Close connection
    await agent.close_vector_db()

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())
```

## Tools

This agent has {len(config.get("tools", []))} tools:

{chr(10).join(f"- {{tool['name']}}: {{tool.get('description', 'No description')}}" for tool in config.get("tools", []))}

## RAG Configuration

- **Enabled**: {config.get("rag", {}).get("enabled", True)}
- **Vector DB**: {config.get("rag", {}).get("vector_db", "neo4j")}
- **Collection**: {config.get("rag", {}).get("collection_name", "agent_knowledge")}
- **Top K**: {config.get("rag", {}).get("top_k", 5)}

## Development

This agent was auto-generated by CE Hub v2 Agent Builder.

**Generated**: {self._get_timestamp()}
'''

        readme_file = output_path / "README.md"
        with open(readme_file, 'w') as f:
            f.write(readme)

        logger.info(f"Generated: {readme_file}")

    def _generate_test_file(self, config: Dict[str, Any], output_path: Path):
        """Generate test file"""
        agent_name = self._to_snake_case(config["name"])
        class_name = config["name"].replace(" ", "")

        test_code = f'''"""
Tests for {config["name"]} Agent
"""

import pytest
from {agent_name}_agent import {class_name}Agent
from core_v2.agent_framework.rag_enabled.rag_base import RAGConfig


class Test{class_name}Agent:
    """Test suite for {config["name"]} agent"""

    @pytest.fixture
    async def agent(self):
        """Create agent instance"""
        agent = {class_name}Agent()
        # Disable RAG for testing
        agent.rag_config.enabled = False
        return agent

    @pytest.mark.asyncio
    async def test_agent_initialization(self, agent):
        """Test agent initializes correctly"""
        assert agent is not None
        assert agent.max_tools == {config.get("max_tools", 10)}
        assert len(agent.tools) == {len(config.get("tools", []))}

    @pytest.mark.asyncio
    async def test_system_prompt(self, agent):
        """Test system prompt is generated"""
        prompt = agent.get_system_prompt()
        assert prompt is not None
        assert len(prompt) > 0
        assert "Role:" in prompt or "role" in prompt.lower()

    @pytest.mark.asyncio
    async def test_execute_basic_task(self, agent):
        """Test basic task execution"""
        result = await agent.execute(
            task="Test task",
            use_knowledge=False
        )
        assert result is not None
        assert result["status"] == "completed"

    @pytest.mark.asyncio
    async def test_tool_limit_enforcement(self, agent):
        """Test tool limit is enforced"""
        initial_count = len(agent.tools)

        # Try to add tool beyond limit
        for i in range(agent.max_tools + 1):
            dummy_tool = type("Tool", (), {{"name": "dummy_" + str(i)}})()
            agent.add_tool(dummy_tool)

        # Should not exceed max_tools
        assert len(agent.tools) <= agent.max_tools

    @pytest.mark.asyncio
    async def test_metrics(self, agent):
        """Test agent metrics"""
        metrics = agent.get_metrics()
        assert metrics is not None
        assert "tool_count" in metrics
        assert "max_tools" in metrics
        assert metrics["tool_count"] == {len(config.get("tools", []))}
'''

        test_file = output_path / f"test_{agent_name}.py"
        with open(test_file, 'w') as f:
            f.write(test_code)

        logger.info(f"Generated: {test_file}")

    def _generate_docker_files(self, config: Dict[str, Any], output_path: Path):
        """Generate Docker files"""
        agent_name = self._to_snake_case(config["name"])

        # Dockerfile
        dockerfile = f'''FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \\
    gcc \\
    && rm -rf /var/lib/apt/lists/*

# Copy requirements first (better caching)
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY *.py .

# Create non-root user
RUN useradd -m -u 1000 agentuser && \\
    chown -R agentuser:agentuser /app
USER agentuser

# Health check
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \\
    CMD python -c "import sys; sys.exit(0)"

CMD ["python", "{agent_name}_agent.py"]
'''

        dockerfile_path = output_path / "Dockerfile"
        with open(dockerfile_path, 'w') as f:
            f.write(dockerfile)

        logger.info(f"Generated: {dockerfile_path}")

        # docker-compose.yml
        compose = f'''version: '3.8'

services:
  {agent_name}_agent:
    build: .
    container_name: {agent_name}_agent
    environment:
      - NEO4J_URI=bolt://neo4j:7687
      - NEO4J_USERNAME=neo4j
      - NEO4J_PASSWORD=password
      - LOG_LEVEL=INFO
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped
    depends_on:
      - neo4j

  neo4j:
    image: neo4j:5.0.0
    container_name: neo4j_knowledge
    environment:
      - NEO4J_AUTH=neo4j/password
      - NEO4J_dbms_memory_heap_max__size=512M
    ports:
      - "7474:7474"  # HTTP
      - "7687:7687"  # Bolt
    volumes:
      - neo4j_data:/data
    restart: unless-stopped

volumes:
  neo4j_data:
'''

        compose_file = output_path / "docker-compose.yml"
        with open(compose_file, 'w') as f:
            f.write(compose)

        logger.info(f"Generated: {compose_file}")

    def _to_snake_case(self, name: str) -> str:
        """Convert string to snake_case"""
        import re
        s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
        return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower().replace(" ", "_")

    def _get_timestamp(self) -> str:
        """Get current timestamp"""
        from datetime import datetime
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")


# CLI command function
def build_agent_cli():
    """CLI command for building agents"""
    import argparse

    parser = argparse.ArgumentParser(
        description="Build agent from JSON configuration"
    )
    parser.add_argument(
        "config",
        help="Path to agent JSON configuration file"
    )
    parser.add_argument(
        "-o", "--output",
        default="./output_agent",
        help="Output directory (default: ./output_agent)"
    )
    parser.add_argument(
        "--no-tests",
        action="store_false",
        dest="tests",
        help="Don't generate test files"
    )
    parser.add_argument(
        "--docker",
        action="store_true",
        help="Generate Docker files"
    )

    args = parser.parse_args()

    builder = AgentBuilder()
    success = builder.build(
        config_path=args.config,
        output_dir=args.output,
        include_tests=args.tests,
        include_docker=args.docker
    )

    if success:
        print(f"\nâœ… Agent built successfully!")
        print(f"ğŸ“ Location: {args.output}")
        print(f"\nğŸš€ Next steps:")
        print(f"   1. cd {args.output}")
        print(f"   2. pip install -r requirements.txt")
        print(f"   3. Set up environment variables")
        print(f"   4. python {args.output}/output_agent.py")
    else:
        print("\nâŒ Agent build failed")
        exit(1)


if __name__ == "__main__":
    build_agent_cli()
